transform eval (ROOT) :language('PIR') {
    .local pmc eval
    .local pmc iter
    $P0 = node['children']
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    $P1 = shift iter
    eval = tree.get('eval', $P1)
    goto iter_loop
  iter_end:
    .return (eval)
}

transform eval (PAST::Stmt) :language('PIR') {
    .local pmc eval
    $P0 = node['statement']
    eval = tree.get('eval', $P0)
    $I0 = isa $P0, 'PAST::Assign'
    if $I0 goto end
    if eval >= 0 goto print_eval
    print unicode:"\u207b"
    eval = neg eval
  print_eval:
    print eval
    print "\n"
  end:
    .return (eval)
}


transform eval (PAST::Op) :language('PIR') {
    .local pmc children_eval
    children_eval = new 'ResizablePMCArray'
  
    .local pmc iter 
    $P0 = node['children']
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    $P0 = shift iter
    $P1 = tree.get('eval', $P0)
    push children_eval, $P1
    goto iter_loop
  iter_end:

    .local pmc eval
    .local string op
    op = node['op']
    op = escape op
    $P0 = find_global 'APL::Functions', op
    eval = $P0(children_eval :flat)
    .return(eval)
}
 
transform eval (PAST::Val) :language('PIR') {
    $P0 = node['value']
    .return ($P0)
}


transform eval (PAST::Var) :language('PIR') {
    .local pmc var
    .local pmc eval
    var = find_global 'APL', '%var'
    $S0 = node['name']
    eval = var[$S0]
    $I0 = exists var[$S0]
    if $I0 goto end
    eval = new .Integer
    var[$S0] = eval
  end:
    .return (eval)
}


transform eval (PAST::Assign) :language('PIR') {
    .local pmc eval

    # obtain rhs value
    $P0 = node['expression']
    eval = tree.get('eval', $P0)

    # obtain lhs target
    .local pmc var
    var = find_global 'APL', '%var'
    $P0 = node['target']
    $S0 = $P0['name']
    var[$S0] = eval
    .return (eval)
}
    
    
