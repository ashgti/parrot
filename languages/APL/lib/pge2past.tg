ROOT: result(.) = {
    .local pmc result
    .local pmc children
    .local pmc iter

    result = new 'PAST::Stmts'
    result.'set_node'(node)

    children = new .ResizablePMCArray
    $P0 = node['statement']
    iter = new .Iterator, $P0
    iter = 0
  iter_loop:
    unless iter goto iter_end
    $P1 = shift iter
    $P2 = tree.get('result', $P1, 'APL::Grammar::statement')
    if null $P2 goto iter_loop
    push children, $P2
    goto iter_loop
  iter_end:
    result['children'] = children
    .return(result)
} 
    

APL::Grammar::statement: result(.) = {
    .local pmc result
    result = new 'PAST::Stmt'
    result.'set_node'(node)
    
    $P0 = node['expression']
    $P1 = tree.get('result', $P0, 'APL::Grammar::expression')
    result['statement'] = $P1
    .return (result)
}


APL::Grammar::expression: result(.) = {
    .local pmc result
    .local string op
    .local pmc children

    $I0 = exists node['target']
    if $I0 goto assignment
    $I0 = exists node['dyadic_identifier']
    if $I0 goto dyadic
    $I0 = exists node['monadic_identifier']
    if $I0 goto monadic

  subexpression:
    # A simple subexpression
    $P0 = node['subexpression']
    .return tree.get('result', $P0, 'APL::Grammar::subexpression')

  assignment:
    result = new 'PAST::Assign'
    result.set_node(node)
    $P0 = node['target']
    $P1 = tree.get('result', $P0, 'APL::Grammar::target')
    result['target'] = $P1
    $P0 = node['expression']
    $P1 = tree.get('result', $P0, 'APL::Grammar::expression')
    result['expression'] = $P1
    .return (result)

  dyadic:
    # create a new PAST::Op node
    result = new 'PAST::Op'
    result.set_node(node)

    # set the function name for this operator
    op = node['dyadic_identifier';0]
    op = concat 'dyadic:', op
    result['op'] = op

    # build a 'children' array of our (two) operands   
    children = new .ResizablePMCArray 
    $P0 = node['subexpression']
    $P1 = tree.get('result', $P0, 'APL::Grammar::subexpression')
    push children, $P1
    $P0 = node['expression']
    $P0 = $P0[0]
    $P1 = tree.get('result', $P0, 'APL::Grammar::expression')
    push children, $P1
    result['children'] = children
    .return (result)

  monadic:
    # create a new PAST::Op
    result = new 'PAST::Op'
    result.set_node(node)

    # set the function name for this operator
    op = node['monadic_identifier']
    op = op[0]
    op = concat 'monadic:', op
    result['op'] = op

    # build a "children" array of our (one) operand
    children = new .ResizablePMCArray
    $P0 = node['expression']
    $P1 = tree.get('result', $P0, 'APL::Grammar::expression')
    push children, $P1
    result['children'] = children
    .return (result)
}


APL::Grammar::subexpression: result(.) = {
    $P0 = node['simple_expression']
    .return tree.get('result', $P0, 'APL::Grammar::simple_expression')
}


APL::Grammar::simple_expression: result(.) = {
    $I0 = exists node['expression']
    if $I0 goto paren_expression
    $P0 = node['array_identifier']
    .return tree.'get'('result', $P0, 'APL::Grammar::array_identifier')
  paren_expression:
    $P0 = node['expression']
    .return tree.'get'('result', $P0, 'APL::Grammar::expression')
}


APL::Grammar::target: result(.) = {
    $P0 = node['variable_identifier']
    .return tree.get('result', $P0, 'APL::Grammar::variable_identifier')
}


APL::Grammar::array_identifier: result(.) = {
    $P0 = node['constant']
    unless $P0 goto variable_name
    .return tree.get('result', $P0, 'APL::Grammar::constant')

  variable_name:
    $P0 = node['variable_identifier']
    .return tree.get('result', $P0, 'APL::Grammar::variable_identifier')
}


APL::Grammar::constant: result(.) = {
    .local pmc result
    $P0 = node['character_constant']
    unless $P0 goto numeric_constant
    .return tree.get('result', $P0, 'APL::Grammar::character_constant')

  numeric_constant:
    $P0 = node['numeric_constant']
    .return tree.get('result', $P0, 'APL::Grammar::numeric_constant')
}


APL::Grammar::numeric_constant: result(.) = {

    $P0 = node['decimal_representation']
    $I0 = elements $P0
    if $I0 > 1 goto vector
    $P0 = $P0[0]
    .return tree.get('result', $P0, 'APL::Grammar::decimal_representation')

  vector:
    .local pmc result
    .local pmc children
    .local pmc iter
    result = new 'PAST::Vector'
    result.set_node(node)

    children = new .ResizablePMCArray
    iter = new .Iterator, $P0
    iter = 0
  iter_loop:
    unless iter goto iter_end
    $P0 = shift iter
    $P1 = tree.get('result', $P0, 'APL::Grammar::decimal_representation')
    if null $P1 goto iter_loop
    push children, $P1
    goto iter_loop
  iter_end:

    result['children'] = children
    .return (result)
}

    
APL::Grammar::decimal_representation: result(.) = {
    .local pmc result
    result = new 'PAST::Val'
    result.set_node(node)
    $S0 = node
    # replace any \u207b chars with "-"
  minus_loop:
    $I0 = index $S0, unicode:"\u207b"
    if $I0 < 0 goto set_value
    substr $S0, $I0, 1, "-"
    goto minus_loop
  set_value:
    $N0 = $S0
    result['value'] = $N0
    result['class'] = '.Float'
    .return (result)
}


APL::Grammar::character_constant: result(.) = {
    .local pmc result
    .local string delim, delim2, value
    result = new 'PAST::Val'
    result.set_node(node)
    delim = node[0]
    value = node[1]
    delim2 = concat delim, delim
    $I0 = 0
    # replace any '' with '
  remove_quotes:
    $I0 = index value, delim2, $I0
    if $I0 < 0 goto end
    substr value, $I0, 2, delim
    inc $I0
    goto remove_quotes
  end:
    result['value'] = value
    result['class'] = '.String'
    .return (result)
}


APL::Grammar::variable_identifier: result(.) = {
    .local pmc result
    result = new 'PAST::Var'
    result.set_node(node)
    $S0 = node
    result['name'] = $S0
    .return (result)
}

