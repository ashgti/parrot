/*
Copyright: 2005 The Perl Foundation.  All Rights Reserved.
$Id: luatable.pmc $

=head1 NAME

classes/luatable.pmc - Lua Table

=head1 DESCRIPTION

C<LuaTable> extends C<Hash> to provide a class with the behaviour of
the Lua C<Table> type.

TRIVIAL IMPLEMENTATION : C<Table> is just a Parrot C<Hash>, like in Lua 4.0.
Now, Lua 5.0 uses a hybrid data structure with a Hash part and an Array part.

=head2 Overloaded Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

static STRING *luatable_name;
static PMC *Lua_Nil;

pmclass LuaTable
    extends Hash 
    does hash 
    dynpmc 
    group lua_group 
    hll Lua {

/* Class initialization. Caches constant strings & PMC that will be used later.
*/
    void class_init() {
        if (pass) {
            luatable_name = const_string(INTERP, "table");
            Lua_Nil = pmc_new(INTERP, Parrot_PMC_typenum(INTERP, "LuaNil"));
        }
    }
     
/*

=item C<STRING* name()>

Return the string "table".

=cut

*/                                               
    STRING* name () {
        return luatable_name;
    }   


/*

=item C<STRING* get_string()>

=cut

*/
    STRING* get_string () {
        return Parrot_sprintf_c(INTERP, "table: %08X", SELF);
    }

/*

=item C<INTVAL get_bool()>

In Lua, both C<nil> and C<false> make a condition false; any other values 
makes it true.

So return always true. 

=cut

*/
    INTVAL get_bool () {
        return 1;
    }

/*

=item C<PMC* get_pmc_keyed (PMC* key)>

C<table> accessor.

=cut

*/

    /* case pmc key
    *
    * P0 = new .Key
    * P0 = "hiya"
    * P1 = P2[P0]
    */
    PMC* get_pmc_keyed (PMC* key) {
        PMC *retval = SUPER(key);

        if (enum_class_None == retval->vtable->base_type) {
            return Lua_Nil;
        }
        return retval;
    }

    /* case integer key
    *
    * P0 = P1[42]
    *
    */
    PMC* get_pmc_keyed_int (INTVAL key) {
        PMC *retval = SUPER(key);

        if (enum_class_None == retval->vtable->base_type) {
            return Lua_Nil;
        }
        return retval;
    }

    /* case string key
    *
    * P0 = P1["Hello"]
    *
    */
    PMC* get_pmc_keyed_str (STRING* key) {
        PMC *retval = SUPER(key);

        if (enum_class_None == retval->vtable->base_type) {
            return Lua_Nil;
        }
        return retval;
    }

/*

=item C<void set_pmc_keyed (PMC* key, PMC* value)>

C<table> mutator.

=cut

*/
    void set_pmc_keyed (PMC* key, PMC* value) {
        if (key == Lua_Nil) {
            real_exception(INTERP, NULL, 1, "table index is nil");
        }
        if (value == Lua_Nil) {
            Hash.SELF.delete_keyed(key);
        } else {
            SUPER(key, value);
        }
    }

    void set_pmc_keyed_int (INTVAL key, PMC* value) {
        SUPER(key, value);
        if (value == Lua_Nil) {
            default.SELF.delete_keyed_int(key);
        } else {
            SUPER(key, value);
        }
    }

    void set_pmc_keyed_str (STRING* key, PMC* value) {
        SUPER(key, value);
        if (value == Lua_Nil) {
            Hash.SELF.delete_keyed_str(key);
        } else {
            SUPER(key, value);
        }
    }


    /* Other metamethods */

    PMC* add (PMC* value, PMC* dest) {
        PMC *metatable = DYNSELF.getprop("__metatable");
        if (metatable) {
            printf("found metatable\n");
        } else {
            printf("Failed to find a metatable\n");
        }
        return (PMC*)0;
    }
  
    PMC* subtract (PMC* value, PMC* dest) {
        return (PMC*)0;
    }

    PMC* multiply (PMC* value, PMC* dest) {
        return (PMC*)0;
    }
  
    PMC* divide (PMC* value, PMC* dest) {
        return (PMC*)0;
    }
  
    PMC* modulus (PMC* value, PMC* dest) {
        return (PMC*)0;
    }
  
    PMC* pow (PMC* value, PMC* dest) {
        return (PMC*)0;
    }
  
    PMC* neg (PMC* dest) {
        return (PMC*)0;
    }
  
    PMC* concatenate (PMC* value, PMC* dest) {
        return (PMC*)0;
    }
  
    void* invoke (void* next) {
        return (void*)0;
    }
  
    INTVAL cmp (PMC* value) {
        return (INTVAL)0;
    }
    
}

/*

=back

=head1 AUTHORS

Original code by Klaas-Jan Stol.

=cut

*/

