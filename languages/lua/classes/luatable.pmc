/*
Copyright: 2005-2006 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/luatable.pmc - Lua Table

=head1 DESCRIPTION

C<LuaTable> extends C<Hash> to provide a class with the behaviour of
the Lua C<Table> type.

TRIVIAL IMPLEMENTATION : C<Table> is just a Parrot C<Hash>, like in Lua 4.0.
Now, Lua 5.0 uses a hybrid data structure with a Hash part and an Array part.

=head2 Overloaded Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

static STRING *luatable_name;
static INTVAL dynclass_LuaNil;

pmclass LuaTable
    extends Hash
    does hash
    dynpmc
    group lua_group
    hll Lua {

/* Class initialization. Caches constant strings & PMC that will be used later.
*/
    void class_init() {
        if (pass) {
            luatable_name = const_string(INTERP, "table");
            dynclass_LuaNil = pmc_type(INTERP,
              string_from_const_cstring(INTERP, "LuaNil", 0));
        }
    }

/*

=item C<STRING* name()>

Return the string "table".

=cut

*/
    STRING* name () {
        return luatable_name;
    }


/*

=item C<STRING* get_string()>

=cut

*/
    STRING* get_string () {
        return Parrot_sprintf_c(INTERP, "table: %08X", SELF);
    }

/*

=item C<PMC* clone()>

PMCs are always handled by-reference in Parrot. So, copying register contents only copies 
the reference to the PMC. For LuaString, LuaNumber, LuaBoolean, this is not correct,
as Lua has by-value semantics for these types. In order to be able to handle register
"move" instructions, this should be implemented using clone(). However, LuaTable and LuaFunction
do have by-reference semantics. As you don't know the type during compile-time of an object,
just always use clone() to copy register contents. LuaTable and LuaFunction should therefore
only clone the reference to themselves, not make a deep copy.

=cut

*/
     PMC* clone() {
         return SELF;
     }

/*

=item C<INTVAL get_bool()>

In Lua, both C<nil> and C<false> make a condition false; any other values
makes it true.

So return always true.

=cut

*/
    INTVAL get_bool () {
        return 1;
    }

/*

=item C<PMC* get_pmc_keyed (PMC* key)>

C<table> accessor.

A copy of the value is retrieved, otherwise, this could happen:

	temp = table[key]
	temp = <some other value>
	temp2 = table[key]
	# temp2 is now <some other value> due to the by-reference semantics of PMCs

=cut

*/
    PMC* get_pmc_keyed (PMC* key) {
        PMC *newcopy;
        PMC *retval = SUPER(key);

        if (enum_class_None == retval->vtable->base_type) {
            retval = pmc_new(INTERP, dynclass_LuaNil);
            return retval;
        }
        newcopy = retval->vtable->clone(INTERP, retval);
        return newcopy;
    }

/*

=item C<void set_pmc_keyed (PMC* key, PMC* value)>

C<table> mutator.

A copy of the value is stored, otherwise, this could happen:
 
	table[key] = value
	value = <some other value>
	temp = table[key]
	# temp is now <some other value> due to the by-reference semantics of PMCs

=cut

*/
    void set_pmc_keyed (PMC* key, PMC* value) {
        if (dynclass_LuaNil == key->vtable->base_type) {
            real_exception(INTERP, NULL, 1, "table index is nil");
        }
        if (dynclass_LuaNil == value->vtable->base_type) {
            Hash.SELF.delete_keyed(key);
        } 
        else {
            PMC *newcopy = value->vtable->clone(INTERP, value);
            SUPER(key, newcopy);
        }
    }

/*

=item C<PMC logical_not(PMC *dest)>

Return always false.

=cut

*/
    PMC* logical_not (PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, pmc_type(INTERP,
              string_from_const_cstring(INTERP, "LuaBoolean", 0)));
        VTABLE_set_integer_native(INTERP, dest, 0);
        return dest;
    }

/*

=item C<INTVAL is_equal (PMC* value)>

The C<==> operation. Compares reference (not in depth).

=cut

*/
    INTVAL is_equal (PMC* value) {
        if (SELF == value)
            return (INTVAL)1;
        else 
            return (INTVAL)0;
    }

    /* Other metamethods */

    PMC* add (PMC* value, PMC* dest) {
        PMC *metatable = DYNSELF.getprop("__metatable");
        if (metatable) {
            printf("found metatable\n");
        } else {
            printf("Failed to find a metatable\n");
        }
        return (PMC*)0;
    }

    /* TODO: Implement the Metamethod mechanism, see the Lua ref.man. */

    PMC* subtract (PMC* value, PMC* dest) {
        return (PMC*)0;
    }

    PMC* multiply (PMC* value, PMC* dest) {
        return (PMC*)0;
    }

    PMC* divide (PMC* value, PMC* dest) {
        return (PMC*)0;
    }

    PMC* modulus (PMC* value, PMC* dest) {
        return (PMC*)0;
    }

    PMC* pow (PMC* value, PMC* dest) {
        return (PMC*)0;
    }

    PMC* neg (PMC* dest) {
        return (PMC*)0;
    }

    PMC* concatenate (PMC* value, PMC* dest) {
        return (PMC*)0;
    }

    void* invoke (void* next) {
        return (void*)0;
    }

    INTVAL cmp (PMC* value) {
        return (INTVAL)0;
    }

}

/*

=back

=head1 AUTHORS

Francois Perrad

Klaas-Jan Stol

=cut

*/
