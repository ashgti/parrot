/*
Copyright: 2005-2006 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

pmc/luatable.pmc - Lua Table

=head1 DESCRIPTION

C<LuaTable> extends C<LuaBase> to provide a class with the behaviour of
the Lua C<Table> type.

TRIVIAL IMPLEMENTATION : C<Table> is just a Parrot C<Hash>, like in Lua 4.0.
Now, Lua 5.0 uses a hybrid data structure with a Hash part and an Array part.

=head2 Overloaded Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

static STRING *luatable_name;
static INTVAL dynpmc_LuaNil;
static INTVAL dynpmc_LuaString;

static STRING* make_hash_key(Interp* interpreter, PMC* key)
{
    if (key == NULL) {
        real_exception(interpreter, NULL, E_KeyError,
                "LuaTable: Cannot use NULL key");
        return NULL;
    }
    return string_concat(interpreter, 
            VTABLE_name(interpreter, key),
            VTABLE_get_string(interpreter, key), 0);
}


pmclass LuaTable
    extends LuaBase
    does hash
    dynpmc
    group lua_group
    hll Lua {

/* Class initialization. Caches constant strings & PMC that will be used later.
*/
    void class_init() {
        if (pass) {
            PMC *meth;

            Parrot_LuaBase_super_init(INTERP, NULL);
            luatable_name = const_string(INTERP, "table");
            dynpmc_LuaNil = pmc_type(INTERP,
              string_from_const_cstring(INTERP, "LuaNil", 0));
            dynpmc_LuaString = pmc_type(INTERP,
              string_from_const_cstring(INTERP, "LuaString", 0));

            /* namespace hack */
            meth = Parrot_find_global(INTERP,
                const_string(INTERP, "LuaTable"),
                const_string(INTERP, "tostring"));
            Parrot_store_global(INTERP,
                const_string(INTERP, "table"),
                const_string(INTERP, "tostring"),
                meth);
            meth = Parrot_find_global(INTERP,
                const_string(INTERP, "LuaTable"),
                const_string(INTERP, "tonumber"));
            Parrot_store_global(INTERP,
                const_string(INTERP, "table"),
                const_string(INTERP, "tonumber"),
                meth);
            meth = Parrot_find_global(INTERP,
                const_string(INTERP, "LuaTable"),
                const_string(INTERP, "rawget"));
            Parrot_store_global(INTERP,
                const_string(INTERP, "table"),
                const_string(INTERP, "rawget"),
                meth);
            meth = Parrot_find_global(INTERP,
                const_string(INTERP, "LuaTable"),
                const_string(INTERP, "rawset"));
            Parrot_store_global(INTERP,
                const_string(INTERP, "table"),
                const_string(INTERP, "rawset"),
                meth);
        }
    }

/*

=item C<void init()>

Initializes the instance.

=cut

*/
    void init () {
        PMC_struct_val(SELF) = NULL;
        PObj_custom_mark_destroy_SETALL(SELF);
        new_pmc_hash(INTERP, SELF);
    }

/*

=item C<void mark()>

Marks the hash as live.

=cut

*/
    void mark () {
        if (PMC_struct_val(SELF))
            mark_hash(INTERP, PMC_struct_val(SELF));
    }

/*

=item C<void destroy()>

Free hash structure.

=cut

*/
    void destroy () {
        if (PMC_struct_val(SELF)) {
            hash_destroy(INTERP, (Hash*) PMC_struct_val(SELF));
            PMC_struct_val(SELF) = NULL;
        }
    }

/*

=item C<STRING* name()>

Return the string "table".

=cut

*/
    STRING* name () {
        return luatable_name;
    }

/*

=item C<PMC* clone()>

PMCs are always handled by-reference in Parrot. So, copying register contents only copies 
the reference to the PMC. For LuaString, LuaNumber, LuaBoolean, this is not correct,
as Lua has by-value semantics for these types. In order to be able to handle register
"move" instructions, this should be implemented using clone(). However, LuaTable and LuaFunction
do have by-reference semantics. As you don't know the type during compile-time of an object,
just always use clone() to copy register contents. LuaTable and LuaFunction should therefore
only clone the reference to themselves, not make a deep copy.

=cut

*/
     PMC* clone() {
         return SELF;
     }

/*

=item C<STRING* get_string()>

=cut

*/
    STRING* get_string () {
        return Parrot_sprintf_c(INTERP, "table: %08X", SELF);
    }

/*

=item C<PMC* get_pmc_keyed (PMC* key)>

C<table> accessor.

A copy of the value is retrieved, otherwise, this could happen:

	temp = table[key]
	temp = <some other value>
	temp2 = table[key]
	# temp2 is now <some other value> due to the by-reference semantics of PMCs

=cut

*/
    PMC* get_pmc_keyed (PMC* key) {
        Hash *hash;
        STRING *keystr;
        PMC *retval;
        PMC *newcopy;

        hash = PMC_struct_val(SELF);
        keystr = make_hash_key(INTERP, key);
        retval = hash_get(INTERP, PMC_struct_val(SELF), keystr);
        if (retval == NULL) {
            retval = pmc_new(INTERP, dynpmc_LuaNil);
            return retval;
        }
        newcopy = VTABLE_clone(INTERP, retval);
        return newcopy;
    }

/*

=item C<void set_pmc_keyed (PMC* key, PMC* value)>

C<table> mutator.

A copy of the value is stored, otherwise, this could happen:
 
	table[key] = value
	value = <some other value>
	temp = table[key]
	# temp is now <some other value> due to the by-reference semantics of PMCs

=cut

*/
    void set_pmc_keyed (PMC* key, PMC* value) {
        Hash *hash;
        STRING *keystr;

        if (dynpmc_LuaNil == key->vtable->base_type) {
            real_exception(INTERP, NULL, 1, "table index is nil");
        }
        hash = PMC_struct_val(SELF);
        keystr = make_hash_key(INTERP, key);
        if (dynpmc_LuaNil == value->vtable->base_type) {
            hash_delete(INTERP, hash, keystr);
        } 
        else {
            PMC *newcopy = VTABLE_clone(INTERP, value);
            hash_put(INTERP, hash, keystr, newcopy);
        }
    }

/*

=item C<INTVAL elements()>

Returns the number of elements in the hash.

=cut

*/
    INTVAL elements () {
        return hash_size(INTERP, PMC_struct_val(SELF));
    }

/*

=back

=head2 non-Vtable Methods

=over 4

=item C<INTVAL is_equal (PMC* value)>

The C<==> operation. Compares reference (not in depth).

=cut

*/
    INTVAL is_equal (PMC* value) {
        if (SELF == value)
            return (INTVAL)1;
        else 
            return (INTVAL)0;
    }

/*

=item C<INTVAL cmp (PMC *value)>

=cut

*/
    INTVAL cmp (PMC* value) {
MMD_LuaTable: {
            real_exception(INTERP, NULL, ILL_INHERIT,
                    "attempt to compare two table values");
            return (INTVAL)0;
        }
MMD_DEFAULT: {
            real_exception(INTERP, NULL, ILL_INHERIT,
                    "attempt to compare table with %s",
                    string_to_cstring(INTERP, VTABLE_name(INTERP, value)));
            return (INTVAL)0;
        }
    }

/*

=back

=head2 Specific Methods

=over 4

=item C<PMC* rawget (PMC* key)>

=cut

*/
    METHOD PMC* rawget (PMC* key) {
        Hash *hash;
        STRING *keystr;
        PMC *retval;
        PMC *newcopy;

        hash = PMC_struct_val(SELF);
        keystr = make_hash_key(INTERP, key);
        retval = hash_get(INTERP, PMC_struct_val(SELF), keystr);
        if (retval == NULL) {
            retval = pmc_new(INTERP, dynpmc_LuaNil);
            return retval;
        }
        newcopy = VTABLE_clone(INTERP, retval);
        return newcopy;
    }

/*

=item C<void rawset (PMC* key, PMC* value)>

=cut

*/
    METHOD void rawset (PMC* key, PMC* value) {
        Hash *hash;
        STRING *keystr;

        if (dynpmc_LuaNil == key->vtable->base_type) {
            real_exception(INTERP, NULL, 1, "table index is nil");
        }
        hash = PMC_struct_val(SELF);
        keystr = make_hash_key(INTERP, key);
        if (dynpmc_LuaNil == value->vtable->base_type) {
            hash_delete(INTERP, hash, keystr);
        } 
        else {
            PMC *newcopy = VTABLE_clone(INTERP, value);
            hash_put(INTERP, hash, keystr, newcopy);
        }
    }

}
/*

=back

=head1 AUTHORS

Francois Perrad

Klaas-Jan Stol

=cut

*/
