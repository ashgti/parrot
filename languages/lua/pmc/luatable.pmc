/*
Copyright: 2005-2006 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

pmc/luatable.pmc - Lua Table

=head1 DESCRIPTION

C<LuaTable> extends C<LuaBase> to provide a class with the behaviour of
the Lua C<Table> type.

TRIVIAL IMPLEMENTATION : C<Table> is just a Parrot C<Hash>, like in Lua 4.0.
Now, Lua 5.0 uses a hybrid data structure with a Hash part and an Array part.

=head2 Overloaded Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

static STRING *luatable_name;
static INTVAL dynpmc_LuaBoolean;
static INTVAL dynpmc_LuaNil;
static INTVAL dynpmc_LuaNumber;
static INTVAL dynpmc_LuaString;
static INTVAL dynpmc_LuaTable;

static STRING* make_hash_key(Interp* interpreter, PMC* key)
{
    if (key == NULL) {
        real_exception(interpreter, NULL, E_KeyError,
                "LuaTable: Cannot use NULL key");
        return NULL;
    }

    return string_concat(interpreter, 
            VTABLE_name(interpreter, key),
            VTABLE_get_string(interpreter, key), 0);
}


pmclass LuaTable
    extends LuaBase
    does hash
    dynpmc
    group lua_group
    hll Lua {

/* Class initialization. Caches constant strings & PMC that will be used later.
*/
    void class_init() {
        if (pass) {
            PMC *meth;

            Parrot_LuaBase_super_init(INTERP, NULL);
            luatable_name = const_string(INTERP, "table");
            dynpmc_LuaBoolean = pmc_type(INTERP,
              string_from_const_cstring(INTERP, "LuaBoolean", 0));
            dynpmc_LuaNil = pmc_type(INTERP,
              string_from_const_cstring(INTERP, "LuaNil", 0));
            dynpmc_LuaNumber = pmc_type(INTERP,
              string_from_const_cstring(INTERP, "LuaNumber", 0));
            dynpmc_LuaString = pmc_type(INTERP,
              string_from_const_cstring(INTERP, "LuaString", 0));
            dynpmc_LuaTable = pmc_type(INTERP,
              string_from_const_cstring(INTERP, "LuaTable", 0));

            /* namespace hack */
            meth = Parrot_find_global(INTERP,
                const_string(INTERP, "LuaTable"),
                const_string(INTERP, "len"));
            Parrot_store_global(INTERP,
                const_string(INTERP, "table"),
                const_string(INTERP, "len"),
                meth);
            meth = Parrot_find_global(INTERP,
                const_string(INTERP, "LuaTable"),
                const_string(INTERP, "rawequal"));
            Parrot_store_global(INTERP,
                const_string(INTERP, "table"),
                const_string(INTERP, "rawequal"),
                meth);
            meth = Parrot_find_global(INTERP,
                const_string(INTERP, "LuaTable"),
                const_string(INTERP, "rawget"));
            Parrot_store_global(INTERP,
                const_string(INTERP, "table"),
                const_string(INTERP, "rawget"),
                meth);
            meth = Parrot_find_global(INTERP,
                const_string(INTERP, "LuaTable"),
                const_string(INTERP, "rawset"));
            Parrot_store_global(INTERP,
                const_string(INTERP, "table"),
                const_string(INTERP, "rawset"),
                meth);
            meth = Parrot_find_global(INTERP,
                const_string(INTERP, "LuaTable"),
                const_string(INTERP, "set_metatable"));
            Parrot_store_global(INTERP,
                const_string(INTERP, "table"),
                const_string(INTERP, "set_metatable"),
                meth);
        }
    }

/*

=item C<void init()>

Initializes the instance.

=cut

*/
    void init () {
        PMC_struct_val(SELF) = NULL;
        PObj_custom_mark_destroy_SETALL(SELF);
        new_pmc_hash(INTERP, SELF);
    }

/*

=item C<void mark()>

Marks the hash as live.

=cut

*/
    void mark () {
        if (PMC_struct_val(SELF))
            mark_hash(INTERP, PMC_struct_val(SELF));
    }

/*

=item C<void destroy()>

Free hash structure.

=cut

*/
    void destroy () {
        if (PMC_struct_val(SELF)) {
            hash_destroy(INTERP, PMC_struct_val(SELF));
            PMC_struct_val(SELF) = NULL;
        }
    }

/*

=item C<STRING* name()>

Return the string "table".

=cut

*/
    STRING* name () {
        return luatable_name;
    }

/*

=item C<PMC* clone()>

PMCs are always handled by-reference in Parrot. So, copying register contents only copies 
the reference to the PMC. For LuaString, LuaNumber, LuaBoolean, this is not correct,
as Lua has by-value semantics for these types. In order to be able to handle register
"move" instructions, this should be implemented using clone(). However, LuaTable and LuaFunction
do have by-reference semantics. As you don't know the type during compile-time of an object,
just always use clone() to copy register contents. LuaTable and LuaFunction should therefore
only clone the reference to themselves, not make a deep copy.

=cut

*/
    PMC* clone() {
        return SELF;
    }

/*

=item C<STRING* get_string()>

=cut

*/
    STRING* get_string () {
        return Parrot_sprintf_c(INTERP, "table: %08X", SELF);
    }

/*

=item C<PMC* get_pmc_keyed (PMC* key)>

C<table> accessor.

A copy of the value is retrieved, otherwise, this could happen:

	temp = table[key]
	temp = <some other value>
	temp2 = table[key]
	# temp2 is now <some other value> due to the by-reference semantics of PMCs

=cut

*/
    PMC* get_pmc_keyed (PMC* key) {
        Hash *hash;
        STRING *keystr;
        PMC *retval;
        PMC *newcopy;

        hash = PMC_struct_val(SELF);
        keystr = make_hash_key(INTERP, key);
        retval = hash_get(INTERP, PMC_struct_val(SELF), keystr);
        if (retval == NULL) {
            PMC *metamethod = Parrot_LuaBase_find_metamethod(INTERP, SELF,
                    string_from_const_cstring(INTERP, "__index", 0));
            if (metamethod != NULL) {
                if (dynpmc_LuaTable == metamethod->vtable->base_type) {
                    return VTABLE_get_pmc_keyed(INTERP, metamethod, key);
                } else {
                    retval = Parrot_runops_fromc_args(INTERP, metamethod, "PPP", SELF, key);
                }
            }
        }
        if (retval == NULL) {
            retval = pmc_new(INTERP, dynpmc_LuaNil);
            return retval;
        }
        newcopy = VTABLE_clone(INTERP, retval);
        return newcopy;
    }

/*

=item C<void set_pmc_keyed (PMC* key, PMC* value)>

C<table> mutator.

A copy of the value is stored, otherwise, this could happen:
 
	table[key] = value
	value = <some other value>
	temp = table[key]
	# temp is now <some other value> due to the by-reference semantics of PMCs

=cut

*/
    void set_pmc_keyed (PMC* key, PMC* value) {
        Hash *hash;
        STRING *keystr;

        if (dynpmc_LuaNil == key->vtable->base_type) {
            real_exception(INTERP, NULL, 1, "table index is nil");
        }
        hash = PMC_struct_val(SELF);
        keystr = make_hash_key(INTERP, key);
        if (NULL == hash_get(INTERP, hash, keystr)) {
            PMC *metamethod = Parrot_LuaBase_find_metamethod(INTERP, SELF,
                    string_from_const_cstring(INTERP, "__newindex", 0));
            if (metamethod != NULL) {
                if (dynpmc_LuaTable == metamethod->vtable->base_type) {
                    VTABLE_set_pmc_keyed(INTERP, metamethod, key, value);
                } else {
                    Parrot_runops_fromc_args(INTERP, metamethod, "vPPP", SELF, key, value);
                }
                return;
            }
        }
        if (dynpmc_LuaNil == value->vtable->base_type) {
            hash_delete(INTERP, hash, keystr);
        } 
        else {
            PMC *newcopy = VTABLE_clone(INTERP, value);
            hash_put(INTERP, hash, keystr, newcopy);
        }
    }

/*

=item C<INTVAL elements()>

Returns the number of elements in the hash.

=cut

*/
    INTVAL elements () {
        return hash_size(INTERP, PMC_struct_val(SELF));
    }

/*

=item C<void* invoke(void* next)>

=cut

*/
    void* invoke(void* next) {
        PMC *metamethod = Parrot_LuaBase_find_metamethod(INTERP, SELF,
                string_from_const_cstring(INTERP, "__call", 0));
        if (metamethod != NULL) {
            /* fix me */
            PMC *retval = Parrot_runops_fromc_args(INTERP, metamethod, "PP", SELF);
            if (NULL == retval) {
                retval = pmc_new(INTERP, dynpmc_LuaNil);
            }
            return retval;
        }
        return SUPER(next);
    }

/*

=back

=head2 non-Vtable Methods

=over 4

=item C<INTVAL is_equal (PMC* value)>

The C<==> operation. Compares reference (not in depth).

=cut

*/
    INTVAL is_equal (PMC* value) {
MMD_LuaTable: {
            PMC *metamethod = Parrot_LuaBase_find_metamethod(INTERP, SELF,
                    string_from_const_cstring(INTERP, "__eq", 0));
            if (metamethod != NULL) {
                PMC *retval = Parrot_runops_fromc_args(INTERP, metamethod, "PPP", SELF, value);
                if (NULL == retval) {
                    return (INTVAL)0;
                }
                return VTABLE_get_bool(INTERP, retval);
            }
            if (SELF == value)
                return (INTVAL)1;
            else 
                return (INTVAL)0;
        }
MMD_DEFAULT: {
            return (INTVAL)0;
        }
    }

/*

=item C<INTVAL cmp (PMC *value)>

=cut

*/
    INTVAL cmp (PMC* value) {
MMD_LuaTable: {
#if 0
            PMC *metamethod = Parrot_LuaBase_find_metamethod(INTERP, SELF,
                    string_from_const_cstring(INTERP, "__cmp", 0));
            if (metamethod != NULL) {
                PMC *retval = Parrot_runops_fromc_args(INTERP, metamethod, "PPP", SELF, value);
                if (retval != NULL) {
                    return (INTVAL)VTABLE_get_number(INTERP, retval);
                }
            }
#else
            PMC *_lt = Parrot_LuaBase_find_metamethod(INTERP, SELF,
                    string_from_const_cstring(INTERP, "__lt", 0));
            if (_lt != NULL) {
                PMC *retval = Parrot_runops_fromc_args(INTERP, _lt, "PPP", SELF, value);
                INTVAL r = (retval != NULL) ? VTABLE_get_bool(INTERP, retval) : (INTVAL)0;
                if (r) {
                    return (INTVAL)-1;
                } else {
                    PMC *_le = Parrot_LuaBase_find_metamethod(INTERP, SELF,
                             string_from_const_cstring(INTERP, "__le", 0));
                    if (_le != NULL) {
                        retval = Parrot_runops_fromc_args(INTERP, _le, "PPP", SELF, value);
                        r = (retval != NULL) ? VTABLE_get_bool(INTERP, retval) : (INTVAL)0;
                        if (r) {
                            return (INTVAL)0;
                        } else {
                            return (INTVAL)1;
                        }
                    } else {
                        retval = Parrot_runops_fromc_args(INTERP, _lt, "PPP", value, SELF);
                        r = (retval != NULL) ? VTABLE_get_bool(INTERP, retval) : (INTVAL)0;
                        if (r) {
                            return (INTVAL)1;
                        } else {
                            return (INTVAL)0;
                        }
                    }
                }
            }
#endif
            real_exception(INTERP, NULL, ILL_INHERIT,
                    "attempt to compare two table values");
            return (INTVAL)0;
        }
MMD_DEFAULT: {
            real_exception(INTERP, NULL, ILL_INHERIT,
                    "attempt to compare table with %s",
                    string_to_cstring(INTERP, VTABLE_name(INTERP, value)));
            return (INTVAL)0;
        }
    }

/*

=back

=head2 Specific Methods

=over 4

=item C<PMC* len()>

=cut

*/
    METHOD PMC* len () {
        PMC *retval;
        PMC *key;
        PMC *value;
        INTVAL idx;

        PMC *metamethod = Parrot_LuaBase_find_metamethod(INTERP, SELF,
                string_from_const_cstring(INTERP, "__len", 0));
        if (metamethod != NULL) {
            retval = Parrot_runops_fromc_args(INTERP, metamethod, "PP", SELF);
            if (NULL == retval) {
                retval = pmc_new(INTERP, dynpmc_LuaNil);
            }
            return retval;
        }
        key = pmc_new(INTERP, dynpmc_LuaNumber);
        idx = 1;
        PMC_num_val(key) = (FLOATVAL)idx;
        value = VTABLE_get_pmc_keyed(INTERP, SELF, key);
        while (dynpmc_LuaNil != value->vtable->base_type) {
            ++idx;
            PMC_num_val(key) = (FLOATVAL)idx;
            value = VTABLE_get_pmc_keyed(INTERP, SELF, key);
        }
        retval = pmc_new(INTERP, dynpmc_LuaNumber);
        PMC_num_val(retval) = (FLOATVAL)(idx - 1);
        return retval;
    }

/*

=item C<PMC* rawequal (PMC* value)>

=cut

*/
    METHOD PMC* rawequal (PMC* value) {
        PMC *retval;
       
        retval = pmc_new(INTERP, dynpmc_LuaBoolean);
        if (SELF->vtable->base_type == value->vtable->base_type
         && SELF == value)
            PMC_int_val(retval) = 1;
        else
            PMC_int_val(retval) = 0;
        return retval;
    }

/*

=item C<PMC* rawget (PMC* key)>

=cut

*/
    METHOD PMC* rawget (PMC* key) {
        Hash *hash;
        STRING *keystr;
        PMC *retval;
        PMC *newcopy;

        hash = PMC_struct_val(SELF);
        keystr = make_hash_key(INTERP, key);
        retval = hash_get(INTERP, PMC_struct_val(SELF), keystr);
        if (retval == NULL) {
            retval = pmc_new(INTERP, dynpmc_LuaNil);
            return retval;
        }
        newcopy = VTABLE_clone(INTERP, retval);
        return newcopy;
    }

/*

=item C<void rawset (PMC* key, PMC* value)>

=cut

*/
    METHOD void rawset (PMC* key, PMC* value) {
        Hash *hash;
        STRING *keystr;

        if (dynpmc_LuaNil == key->vtable->base_type) {
            real_exception(INTERP, NULL, 1, "table index is nil");
        }
        hash = PMC_struct_val(SELF);
        keystr = make_hash_key(INTERP, key);
        if (dynpmc_LuaNil == value->vtable->base_type) {
            hash_delete(INTERP, hash, keystr);
        } 
        else {
            PMC *newcopy = VTABLE_clone(INTERP, value);
            hash_put(INTERP, hash, keystr, newcopy);
        }
    }

/*

=item C<void set_metatable(PMC *meta)>

=cut

*/
    METHOD void set_metatable(PMC *meta) {
        if (dynpmc_LuaNil == meta->vtable->base_type) {
            VTABLE_delprop(INTERP, SELF,
                    string_from_const_cstring(INTERP, "__metatable", 0));
        } else {
            VTABLE_setprop(INTERP, SELF,
                    string_from_const_cstring(INTERP, "__metatable", 0),
                    meta);
        }
    }

}
/*

=back

=head1 AUTHORS

Francois Perrad

Klaas-Jan Stol

=cut

*/
