/*
Copyright (C) 2005-2006, The Perl Foundation.
$Id$

=head1 NAME

pmc/luathread.pmc - Lua Thread

=head1 DESCRIPTION

C<LuaThread> extends C<LuaAny> to provide a class with the behaviour
of the Lua C<Thread> type.
This implementation is based on C<Parrot::Coroutine>.

=head2 Overloaded Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

static STRING *luathread_name;
extern INTVAL dynpmc_LuaBoolean;


pmclass LuaThread
    extends LuaAny
    dynpmc
    group lua_group
    hll Lua {

/* Class initialization. Caches constant strings that will be used later.
*/
    void class_init() {
        if (pass) {
            luathread_name = const_string(INTERP, "thread");
        }
    }

/*

=item C<void init()>

Raises an exception. Use C<init_pmc()>.

=cut

*/
    void init () {
        real_exception(INTERP, NULL, E_Exception,
                       "LuaThread init without sub");
    }

/*

=item C<void init_pmc(PMC *sub)>

=cut

*/
    void init_pmc (PMC* sub) {
        INTVAL type = pmc_type(INTERP,
                          const_string(INTERP, "Parrot::Coroutine"));
        if (type)
            PMC_pmc_val(SELF) = pmc_new_init(INTERP, type, sub);
        else
            real_exception(INTERP, NULL, E_Exception,
                           "Parrot::Coroutine not found");
    }

/*

=item C<STRING* name()>

Return the string "thread".

=cut

*/
    STRING* name () {
        return luathread_name;
    }

/*

=item C<PMC* clone()>

=cut

*/
    PMC* clone() {
        return SELF;
    }

/*

=item C<PMC* get_attr_str(STRING* key)>

=cut

*/
    PMC* get_attr_str(STRING* key) {
        return PMC_pmc_val(SELF);
    }

/*

=item C<STRING* get_string()>

=cut

*/
    STRING* get_string () {
        return Parrot_sprintf_c(INTERP, "thread: %08X", SELF);
    }

/*

=item C<void set_pmc(PMC *value)>

=cut

*/
    void set_pmc(PMC *value) {
        PMC_pmc_val(SELF) = PMC_pmc_val(value);
    }

/*

=back

=head2 non-Vtable Methods

=over 4

=item C<INTVAL is_equal (PMC* value)>

=cut

*/
    INTVAL is_equal (PMC* value) {
MMD_LuaThread: {
            if (SELF == value)
                return (INTVAL)1;
            else
                return (INTVAL)0;
        }
MMD_DEFAULT: {
            return (INTVAL)0;
        }
    }

/*

=back

=head2 Specific Methods

=over 4

=item C<PMC* rawequal (PMC* value)>

=cut

*/
    METHOD PMC* rawequal (PMC* value) {
        PMC* retval = pmc_new(INTERP, dynpmc_LuaBoolean);
        if (SELF->vtable->base_type == value->vtable->base_type
         && SELF == value)
            PMC_int_val(retval) = 1;
        else
            PMC_int_val(retval) = 0;
        return retval;
    }

}

/*

=back

=head1 AUTHORS

Francois Perrad

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
