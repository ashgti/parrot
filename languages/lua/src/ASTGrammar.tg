# Copyright (C) 2006-2007, The Perl Foundation.
# $Id$

=head1 NAME

ASTGrammar.tg - A grammar for transforming the output of a PGE parse into
an abstract syntax tree.

=head1 DESCRIPTION


=cut

grammar Lua::PAST::Grammar is TGE::Grammar;


transform past (ROOT) :language('PIR') {
    .local pmc past
    past = new 'PAST::Block'
    past.'init'('node'=>node, 'name'=>'anon')
    .local pmc blocknode, blockpast
    blocknode = node['block']
    blockpast = tree.'get'('past', blocknode, 'Lua::Grammar::block')
    past.'push'(blockpast)
    .return (past)
}

transform past (Lua::Grammar::block) :language('PIR') {
    .local pmc past
    past = new 'PAST::Stmts'
    past.'init'('node'=>node)
    .local pmc iter
    $P0 = node['statement']
    if null $P0 goto iter_end
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'Lua::Grammar::statement')
    past.'push'(cpast)
    goto iter_loop
  iter_end:

    $P0 = node['last_statement']
    if null $P0 goto no_last_stat
    $P1 = tree.'get'('past', $P0, 'Lua::Grammar::last_statement')
    past.'push'($P1)
  no_last_stat:
    .return (past)
}

transform past (Lua::Grammar::statement) :language('PIR') {
    $S0 = node.'find_key'()
    $P0 = node[$S0]
    #printerr $S0
    $S0 = concat 'Lua::Grammar::', $S0
    .return tree.'get'('past', $P0, $S0)
}

transform past (Lua::Grammar::last_statement) :language('PIR') {
    .local pmc past, cnode

  returnstat:
    cnode = node['return']
    if null cnode goto breakstat

    .local pmc exprpast
    past = new 'PAST::Op'
    past.'init'('node'=>cnode, 'pasttype'=>'pirop', 'pirop'=>'return')

    cnode = node['expression_list']
    if null cnode goto no_return_values
    exprpast = tree.'get'('past', cnode, 'Lua::Grammar::expression_list')
    #past.'push'(exprpast)

  no_return_values:
    .return (past)

  breakstat:
    cnode = node['break']
    if null cnode goto no_stat
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'pirop', 'pirop'=>'goto')
    .return (past)

  no_stat:
    printerr "no last statement\n"
    exit 1
}

transform past (Lua::Grammar::if_stat) :language('PIR') {
    .local pmc past

    # create the PAST node for an if statement
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'if')

    .local pmc condnode, condpast
    # get the PAST node for the condition
    condnode = node['expression']
    condpast = tree.'get'('past', condnode, 'Lua::Grammar::expression')
    past.'push'(condpast)

    .local pmc ifnode, ifpast
    # get the PAST node for the if block
    ifnode = node['block']
    ifpast = tree.'get'('past', ifnode, 'Lua::Grammar::block')
    past.'push'(ifpast)

    .local pmc elseifnode, elseifpast
    # get the elseifblock nodes
    elseifnode = node['elseif_block']
    if null elseifnode goto skip_elseifs
    elseifpast = tree.'get'('past', elseifnode, 'Lua::Grammar::elseif_block')
    past.'push'(elseifpast)

  skip_elseifs:
    .local pmc elsenode, elsepast
    # get the elseblock nodes
    elsenode = node['else_block']
    if null elsenode goto skip_else
    elsepast = tree.'get'('past', elsenode, 'Lua::Grammar::block')
    past.'push'(elsepast)

  skip_else:
    .return (past)
}

transform past (Lua::Grammar::elseif_block) :language('PIR') {
    .local pmc past, iter

    $P0 = node['elseif_block']
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'Lua::Grammar::elseif_block')
    past.'push'(cpast)
    goto iter_loop
  iter_end:

    .return (past)
}

transform past (Lua::Grammar::elseif_block) :language('PIR') {
    .local pmc past

    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'if')

    .local pmc condnode, condpast
    condnode = node['expression']
    condpast = tree.'get'('past', condnode, 'Lua::Grammar::expression')
    past.'push'(condpast)

    .local pmc ifnode, ifpast
    ifnode = node['block']
    ifpast = tree.'get'('past', ifnode, 'Lua::Grammar::block')
    past.'push'(ifpast)

    .return (past)
}

transform past (Lua::Grammar::local_stat) :language('PIR') {
    .local pmc past
    past = new 'PAST::Var'
    past.'init'('node'=>node)
    .return (past)
}

transform past (Lua::Grammar::while_stat) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'while')

    .local pmc condnode, condpast
    condnode = node['expression']
    condpast = tree.'get'('past', condnode, 'Lua::Grammar::expression')
    past.'push'(condpast)

    .local pmc blocknode, blockpast
    blocknode = node['block']
    blockpast = tree.'get'('past', blocknode, 'Lua::Grammar::block')
    past.'push'(blockpast)

    .return (past)
}

transform past (Lua::Grammar::repeat_stat) {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node)

    .local pmc exprnode, exprpast
    exprnode = node['expression']
    exprpast = tree.'get'('past', exprnode, 'Lua::Grammar::expression')

    .local pmc blocknode, blockpast
    blocknode = node['block']
    blockpast = tree.'get'('past', blocknode, 'Lua::Grammar::block')
    past.'push'(blockpast)

    .return (past)
}

transform past (Lua::Grammar::for_stat) :language('PIR') {
    .local pmc past
  fornum:
    $P0 = node['fornum']
    if null $P0 goto forlist
    past = tree.'get'('past', $P0, 'Lua::Grammar::fornum')
  forlist:
    $P0 = node['forlist']
    past = tree.'get'('past', $P0, 'Lua::Grammar::forlist')
    .return (past)
}

transform past (Lua::Grammar::fornum) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node)
    .return (past)
}

transform past (Lua::Grammar::forlist) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    #past.'init'('node'=>node)
    .return (past)
}


transform past (Lua::Grammar::expression_stat) :language('PIR') {
    .local pmc past, primpast
    past = new 'PAST::Op'
    $P0 = node['primary_expression']
    primpast = tree.'get'('past', $P0, 'Lua::Grammar::primary_expression')
    past.'push'(primpast)

  assignment:
    .local pmc assignpast
    $P0 = node['assignment']
    if null $P0 goto function_call
    assignpast = tree.'get'('past', $P0, 'Lua::Grammar::assignment')
    past.'push'(assignpast)

  function_call:

    .local pmc callnode, callpast
    callnode = node['function_args']
    if null callnode goto no_funcargs
    callpast = tree.'get'('past', callnode, 'Lua::Grammar::function_args')
    if null callpast goto no_funcargs
    .return (past)

  no_funcargs:
    .return (past)
}

transform past (Lua::Grammar::assignment) :language('PIR') {
    $P0 = node['expression_list']

    if null $P0 goto more_expr
    .return tree.'get'('past', $P0, 'Lua::Grammar::expression_list')
  more_expr:
    printerr "Not implemented\n"
    exit 1

}

transform past (Lua::Grammar::function_args) :language('PIR') {
    #printerr "function_args\n"
    node = node[0]
    $S0 = node.'find_key'()
    $P0 = node[$S0]
    $S0 = concat 'Lua::Grammar::', $S0
    .return tree.'get'('past', $P0, $S0)
}

transform past (Lua::Grammar::function_stat) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'bind')

    .local pmc namenode, namepast
    namenode = node['functionname']
    namepast = tree.'get'('past', namenode, 'Lua::Grammar::functionname')
    past.'push'(namepast)

    .local pmc bodynode, bodypast
    bodynode = node['function_body']
    bodypast = tree.'get'('past', bodynode, 'Lua::Grammar::function_body')
    past.'push'(bodypast)
    .return (past)
}

transform past (Lua::Grammar::functionname) :language('PIR') {
    $P0 = node['name']
    $P0 = $P0[0] #hack!
    .return tree.'get'('past', $P0, 'Lua::Grammar::name')
}


# past (Lua::Grammar::body)
#
# Store each of the instructions in a body node in a PAST::Stmts node.
#
transform past (Lua::Grammar::function_body) :language('PIR') {
    .local pmc past
    past = new 'PAST::Block'
    past.'init'('node'=>node)
    #printerr "function body\n"
    # handle parameters

    # handle block
    .local pmc blocknode, blockpast
    blocknode = node['block']
    blockpast = tree.'get'('past', blocknode, 'Lua::Grammar::block')
    past.'push'(blockpast)

    .return (past)
}

transform past (Lua::Grammar::name) :language('PIR') {
    .local pmc past
    $S0 = node
    past = new 'PAST::Var'
    past.'init'('node'=>node, 'name'=>$S0, 'scope'=>'package')
    .return (past)
}

transform past (Lua::Grammar::constructor) :language('PIR') {
    .local pmc past
    past = new 'PAST::Var'
    past.'init'('node'=>node)
    .return (past)
}

transform past (Lua::Grammar::expression_list) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'name'=>'listmaker')
    .local pmc expriter

    #$S0 = node.'find_key'()
    #printerr $S0

    $P0 = node['expression_list']

    if null $P0 goto error
    #printerr $S0
    #printerr "\n"

    $P0 = $P0['expression']
    expriter = new .Iterator, $P0

  iter_loop:
    unless expriter goto iter_end
    .local pmc enode, epast
    enode = shift expriter
    epast = tree.'get'('past', enode, 'Lua::Grammar::expression')
    past.'push'(epast)
    goto iter_loop
  iter_end:
    .return (past)
  error:
    printerr "null access in expr list\n"
    exit 1
}
transform past (Lua::Grammar::expression) :language('PIR') {
    $P0 = node['expr']
    .return tree.'get'('past', $P0, 'Lua::Grammar::expr')
}


transform past (Lua::Grammar::expr) :language('PIR') {
    .local string type
    type = node['type']

    if type == 'term:' goto past_term

    .local pmc optable, optok
    .local string pasttype, pirop, returns
    .local int islvalue
    optable = get_hll_global [ 'Lua::Grammar' ], '$optable'
    optok = optable[type]
    pasttype = optok['past']
    pirop = optok['pirop']
    returns = optok['returns']
    islvalue = optok['lvalue']

    .local pmc past, iter
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'name'=>type, 'pasttype'=>pasttype, 'pirop'=>pirop, 'returns'=>returns)

    $P0 = node.'get_array'()
    if null $P0 goto iter_end
    iter = new .Iterator, $P0
    unless iter goto iter_end
    $P0[0;'islvalue'] = islvalue

  iter_loop:
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'Lua::Grammar::expr')
    if null cpast goto iter_loop
    past.'push'(cpast)
    if iter goto iter_loop
  iter_end:
    .return (past)

  past_term:
    $S0 = node.'find_key'()
    $P0 = node[$S0]
    $S0 = concat 'Lua::Grammar::', $S0
    .return tree.'get'('past', $P0, $S0)
}


transform past (Lua::Grammar::simple_expression) :language('PIR') {
    $S0 = node.'find_key'()
    $P0 = node[$S0]
    $S0 = concat 'Lua::Grammar::', $S0
    .return tree.'get'('past', $P0, $S0)
}

transform past (Lua::Grammar::number) :language('PIR') {
    .local pmc past
    past = new 'PAST::Val'
    past.'init'('node'=>node, 'vtype'=>'.LuaNumber', 'name'=>node, 'ctype'=>'i+')
    .return (past)
}

transform past (Lua::Grammar::nil) :language('PIR') {
    .local pmc past
    past = new 'PAST::Val'
    past.'init'('node'=>node, 'vtype'=>'.Undef', 'name'=>node)
    .return (past)
}

transform past (Lua::Grammar::primary_expression) :language('PIR') {
    $S0 = node.'find_key'()
    $P0 = node[$S0]
    $S0 = concat 'Lua::Grammar::', $S0
    .return tree.'get'('past', $P0, $S0)
}

transform past (Lua::Grammar::prefix_expression) :language('PIR') {
    $S0 = node.'find_key'()
    $P0 = node[$S0]
    $S0 = concat 'Lua::Grammar::', $S0
    .return tree.'get'('past', $P0, $S0)
}

transform past (Lua::Grammar::string) :language('PIR') {
    .local pmc result
    result = new 'PAST::Val'

  quoted_literal:
    $P0 = node['quoted_literal']
    if null $P0 goto long_string
    $S0 = $P0
    result.'init'('node'=>node, 'vtype'=>'.String', 'name'=>$S0)
    .return (result)
  long_string:
    $P0 = node['long_string']
    if null $P0 goto error
    $S0 = $P0
    result.'init'('node'=>node, 'vtype'=>'.String', 'name'=>$S0)
    .return (result)
  error:
    printerr "Unknown string\n"
}

=head1 AUTHORS

Klaas-Jan Stol <parrotcode@gmail.com>

=cut

