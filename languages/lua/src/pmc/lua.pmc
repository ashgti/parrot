/*
Copyright (C) 2006-2008, The Perl Foundation.
$Id$

=head1 NAME

pmc/lua.pmc - Lua native runtime

=head1 DESCRIPTION

This singleton PMC holds some static methods.

=head2 Methods

=over 4

=cut

*/

#include "lua_private.h"
#include <locale.h>

INTVAL dynpmc_LuaBoolean;
INTVAL dynpmc_LuaClosure;
INTVAL dynpmc_LuaFunction;
INTVAL dynpmc_LuaNil;
INTVAL dynpmc_LuaNumber;
INTVAL dynpmc_LuaString;
INTVAL dynpmc_LuaTable;
INTVAL dynpmc_LuaUserdata;

static PMC * Lua_PMC;

static STRING*
context_infostr(PARROT_INTERP, Parrot_Context *ctx)
{
    Parrot_Context_info info;
    STRING *res = NULL;

    Parrot_block_GC_mark(interp);

    if (Parrot_Context_get_info(interp, ctx, &info)) {
        res = Parrot_sprintf_c(interp, "\t%Ss:%d in function '%Ss'\n",
                                       info.file, info.line, info.subname);
    }

    Parrot_unblock_GC_mark(interp);

    return res;
}


pmclass Lua
    singleton
    dynpmc
    group lua_group {

/*
* Class initialization.
*/
    void class_init() {
        Lua_PMC = NULL;

        if (pass) {
            dynpmc_LuaBoolean = pmc_type(INTERP,
              const_string(INTERP, "LuaBoolean"));
            dynpmc_LuaClosure = pmc_type(INTERP,
              const_string(INTERP, "LuaClosure"));
            dynpmc_LuaFunction = pmc_type(INTERP,
              const_string(INTERP, "LuaFunction"));
            dynpmc_LuaNil = pmc_type(INTERP,
              const_string(INTERP, "LuaNil"));
            dynpmc_LuaNumber = pmc_type(INTERP,
              const_string(INTERP, "LuaNumber"));
            dynpmc_LuaString = pmc_type(INTERP,
              const_string(INTERP, "LuaString"));
            dynpmc_LuaTable = pmc_type(INTERP,
              const_string(INTERP, "LuaTable"));
            dynpmc_LuaUserdata = pmc_type(INTERP,
              const_string(INTERP, "LuaUserdata"));
        }
    }

/*

=item C<void* get_pointer()>

=item C<void set_pointer(void *ptr)>

These two functions are part of the singleton creation interface. For more
information see F<src/pmc.c>.

=cut

*/
    VTABLE void* get_pointer() {
        return Lua_PMC;
    }

    VTABLE void set_pointer(void *ptr) {
        Lua_PMC = (PMC *)ptr;
    }

/*

=item C<STRING* caller()>

=cut

*/
    METHOD STRING* caller() {
        Parrot_Context   *sub_ctx = CONTEXT(interp)->caller_ctx;
        STRING           *retval;

        /* backtrace: follow the continuation chain */
        while (1) {
            PMC *cont;
            if (sub_ctx->current_sub && PMC_metadata(sub_ctx->current_sub)) {
                Parrot_Context_info info;
                Parrot_block_GC_mark(INTERP);

                if (Parrot_Context_get_info(INTERP, sub_ctx, &info)) {
                    STRING *retval = info.subname;

                    Parrot_unblock_GC_mark(INTERP);
                    RETURN(STRING *retval);
                }
                Parrot_unblock_GC_mark(INTERP);
                break;
            }

            cont = sub_ctx->current_cont;


            if (!cont)
                break;

            sub_ctx = PMC_cont(cont)->to_ctx;

            if (!sub_ctx)
                break;
        }

        retval = const_string(INTERP, "?");
        RETURN(STRING *retval);
    }

/*

=item C<PMC* clock()>

=cut

*/
    METHOD PMC* clock() {
        PMC     *retval = pmc_new(INTERP, dynpmc_LuaNumber);
        FLOATVAL f      = (clock())/(FLOATVAL)CLOCKS_PER_SEC;
        VTABLE_set_number_native(INTERP, retval, f);
        RETURN(PMC *retval);
    }

/*

=item C<PMC* frexp(PMC *x)>

=cut

*/
    METHOD PMC* frexp(PMC *x) {
        PMC *y      = pmc_new(INTERP, dynpmc_LuaNumber);
        PMC *expn   = pmc_new(INTERP, dynpmc_LuaNumber);
        PMC *retval = pmc_new(INTERP, enum_class_Array);
        int  e;

        VTABLE_set_number_native(INTERP, y,
                                 frexp(VTABLE_get_number(INTERP, x), &e));
        VTABLE_set_integer_native(INTERP, expn, e);
        VTABLE_set_integer_native(INTERP, retval, 2);
        VTABLE_set_pmc_keyed_int(INTERP, retval, 0, y);
        VTABLE_set_pmc_keyed_int(INTERP, retval, 1, expn);

        RETURN(PMC *retval);
    }

/*

=item C<PMC* ldexp(PMC *x, PMC *expn)>

=cut

*/
    METHOD PMC* ldexp(PMC *x, PMC *expn) {
        PMC *retval = pmc_new(INTERP, dynpmc_LuaNumber);

        VTABLE_set_number_native(INTERP, retval,
                                 ldexp(VTABLE_get_number(INTERP, x),
                                       VTABLE_get_integer(INTERP, expn)));
        RETURN(PMC *retval);
    }

/*

=item C<PMC* mktime(PMC *tm)>

=cut

*/
    METHOD PMC* mktime(PMC *tm) {
        time_t t;
        struct tm ts;
        PMC *retval;

        ts.tm_sec   = VTABLE_get_integer_keyed_int(INTERP, tm, 0);
        ts.tm_min   = VTABLE_get_integer_keyed_int(INTERP, tm, 1);
        ts.tm_hour  = VTABLE_get_integer_keyed_int(INTERP, tm, 2);
        ts.tm_mday  = VTABLE_get_integer_keyed_int(INTERP, tm, 3);
        ts.tm_mon   = VTABLE_get_integer_keyed_int(INTERP, tm, 4);
        ts.tm_year  = VTABLE_get_integer_keyed_int(INTERP, tm, 5);
        ts.tm_isdst = VTABLE_get_integer_keyed_int(INTERP, tm, 8);

        t = mktime(&ts);

        if (t == -1)
            retval = pmc_new(INTERP, dynpmc_LuaNil);
        else {
            retval = pmc_new(INTERP, dynpmc_LuaNumber);
            VTABLE_set_integer_native(INTERP, retval, t);
        }

        RETURN(PMC *retval);
    }

/*

=item C<PMC* modf(PMC *x)>

=cut

*/
    METHOD PMC* modf(PMC *x) {
        PMC     *y      = pmc_new(INTERP, dynpmc_LuaNumber);
        PMC     *d      = pmc_new(INTERP, dynpmc_LuaNumber);
        PMC     *retval = pmc_new(INTERP, enum_class_Array);
        FLOATVAL _d;

        VTABLE_set_number_native(INTERP, y,
                                 modf(VTABLE_get_number(INTERP, x), &_d));
        VTABLE_set_number_native(INTERP, d, _d);
        VTABLE_set_integer_native(INTERP, retval, 2);
        VTABLE_set_pmc_keyed_int(INTERP, retval, 0, d);
        VTABLE_set_pmc_keyed_int(INTERP, retval, 1, y);

        RETURN(PMC *retval);
    }

/*

=item C<PMC* setlocale(INTVAL category, STRING *locale)>

=cut

*/
    METHOD PMC* setlocale(INTVAL category, STRING *locale) {
        static const int cat[] = {
            LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME
        };

        char *loc = (locale != NULL) ? string_to_cstring(INTERP, locale) : NULL;
        char *p   = setlocale(cat[category], loc);
        PMC  *retval;

        if (p) {
            retval = pmc_new(INTERP, dynpmc_LuaString);
            VTABLE_set_string_native(INTERP, retval,
                                     string_from_cstring(INTERP, p, 0));
        }
        else
            retval = pmc_new(INTERP, dynpmc_LuaNil);

        RETURN(PMC *retval);
    }

/*

=item C<STRING* strftime(STRING *fmt, PMC *tm)>

=cut

*/
    METHOD STRING* strftime(STRING* fmt, PMC* tm) {
        char        b[200];
        STRING     *retval;
        size_t      reslen;
        struct tm   stm;

        stm.tm_sec   = VTABLE_get_integer_keyed_int(INTERP, tm, 0);
        stm.tm_min   = VTABLE_get_integer_keyed_int(INTERP, tm, 1);
        stm.tm_hour  = VTABLE_get_integer_keyed_int(INTERP, tm, 2);
        stm.tm_mday  = VTABLE_get_integer_keyed_int(INTERP, tm, 3);
        stm.tm_mon   = VTABLE_get_integer_keyed_int(INTERP, tm, 4) - 1;
        stm.tm_year  = VTABLE_get_integer_keyed_int(INTERP, tm, 5) - 1900;
        stm.tm_wday  = VTABLE_get_integer_keyed_int(INTERP, tm, 6);
        stm.tm_yday  = VTABLE_get_integer_keyed_int(INTERP, tm, 7);
        stm.tm_isdst = VTABLE_get_integer_keyed_int(INTERP, tm, 8);

        { /* Limit s scope and lifetime */
            char *s = string_to_cstring(INTERP, fmt);
            reslen = strftime(b, sizeof b, s, &stm);
            string_cstring_free(s);
        }

        retval = string_from_cstring(INTERP, b, reslen);
        RETURN(STRING *retval);
    }

/*

=item C<STRING* tmpname()>

=cut

*/
    METHOD STRING* tmpname() {
        char    buff[32];
        STRING *retval;
        int     e;
#ifdef WIN32
        e = (tmpnam(buff) == NULL);
#else
        strcpy(buff, "/tmp/lua_XXXXXX");
        e = mkstemp(buff);

        if (e != -1)
            close(e);

        e = (e == -1);
#endif
        if (e)
            Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                "unable to generate a unique filename");

        retval = string_from_cstring(INTERP, buff, 0);
        RETURN(STRING *retval);
    }

/*

=item C<STRING* traceback(INTVAL level)>

=cut

*/
    METHOD STRING* traceback(INTVAL level) {
        STRING *bt = string_from_literal(INTERP, "stack traceback:\n");
        STRING *str;

        /* information about the current sub */
        Parrot_Context *sub_ctx = CONTEXT(interp)->caller_ctx;

        if (level == 0) {
            str = context_infostr(INTERP, sub_ctx);
            bt  = string_append(INTERP, bt, str);
        }

        /* backtrace: follow the continuation chain */
        while (1) {
            PMC *cont = sub_ctx->current_cont;


            if (!cont)
                break;

            sub_ctx = PMC_cont(cont)->to_ctx;

            if (!sub_ctx)
                break;

            str = context_infostr(INTERP, sub_ctx);


            if (!str)
                break;

            bt = string_append(INTERP, bt, str);
        }

        RETURN(STRING *bt);
    }

/*

=item C<STRING* where()>

=cut

*/
    METHOD STRING* where() {
        Parrot_Context   *sub_ctx = CONTEXT(interp)->caller_ctx;
        STRING           *retval;

        /* backtrace: follow the continuation chain */
        while (1) {
            PMC *cont;
            PMC *sub = sub_ctx->current_sub;
            if (sub
            &&  PMC_metadata(sub)
            &&  VTABLE_isa(INTERP, sub, const_string(INTERP, "LuaClosure"))) {
                Parrot_Context_info info;
                Parrot_block_GC_mark(INTERP);

                if (Parrot_Context_get_info(INTERP, sub_ctx, &info)) {
                    STRING *res = Parrot_sprintf_c(INTERP, "%Ss:%d:",
                                                   info.file, info.line);

                    Parrot_unblock_GC_mark(INTERP);
                    RETURN(STRING *res);
                }
                Parrot_unblock_GC_mark(INTERP);
                break;
            }

            cont = sub_ctx->current_cont;


            if (!cont)
                break;

            sub_ctx = PMC_cont(cont)->to_ctx;

            if (!sub_ctx)
                break;
        }

        retval = const_string(INTERP, "_._:0:");
        RETURN(STRING *retval);
    }

}

/*

=back

=head1 AUTHORS

Francois Perrad

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
