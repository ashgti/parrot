# Copyright (C) 2006-2007, The Perl Foundation.
# $Id$

=head1 NAME

lua.pg - a Lua 5.1 grammar in PGE

=head1 DESCRIPTION

=head2 GRAMMAR RULES

The grammar rules are according to the original Lua parser as defined lparser.c
in the lua distribution.

=cut

grammar Lua::Grammar;

token TOP {
  ^ <block> $
}

rule block {
  [ <statement> <';'>? ]* [ <last_statement> <';'>? ]?
}

rule statement {
  | <if_stat>
  | <while_stat>
  | <do_block>
  | <for_stat>
  | <repeat_stat>
  | <function_stat>
  | <local_stat>
  | <expression_stat>
}

rule function_stat {
  <'function'> <functionname> <function_body>
}

rule last_statement {
  | <return_statement>
  | <break_statement>
}

rule return_statement {
  <'return'> <expression_list>?
}

token break_statement {
  <'break'>
}

rule do_block {
  <'do'> <block> <?end>
}

rule local_stat {
  <'local'> [ <local_function> | <local_declaration> ]
}

rule expression_stat {
  <primary_expression> <assignment>?
}

rule assignment {
  | <','> <primary_expression> <assignment>
  | <'='> <expression_list>
}

rule while_stat {
  <'while'> <expression> <?do> <block> <?end>
}

rule repeat_stat {
  <'repeat'> <block> <?until> <expression>
}

rule for_body {
  <?do> <block> <?end>
}

rule fornum {
  <name> <'='> <expression> <?comma> <expression> [ <','> <expression> ]?
}

rule forlist {
  <name_list> <?in> <expression_list>
}

rule for_stat {
  <'for'> [ <fornum> | <forlist> ] <for_body>
}

rule if_stat {
  <'if'> <expression> <?then> <block> <elseif_block>* <else_block>? <?end>
}

rule elseif_block {
  <'elseif'> <expression> <?then> <block>
}

rule else_block {
  <'else'> <block>
}

rule local_declaration {
  <name> [ <','> <name> ]* [ <'='> <expression_list> ]?
}

rule local_function {
  <'function'> <name> <function_body>
}

rule functionname {
  <name> [ <'.'> <name> ]* [ <':'> <name> ]?
}

rule index {
  <'['> <expression> <?closebracket>
}

rule record_field {
  [ <name> | <index> ] <'='> <expression>
}

rule constructor {
  <'{'> <tablefieldlist>? <?closebrace>
}

rule tablefieldlist {
  <tablefield> [ <[,;]> <tablefield> ]* <[,;]>?
}

rule tablefield {
  <record_field> | <expression>
}

rule parameter_list {
  | <name_list> [ <','> <vararg> ]?
  | <vararg>
}

rule function_body {
  <'('> <parameter_list>? <?closeparen> <block> <?end>
}

rule expression_list {
  <expression> [ <','> <expression> ]*
}

rule name_list {
  <name> [ <','> <name> ]*
}

rule function_args {
  | <'('> <expression_list>? <?closeparen>
  | <constructor>
  | <string>
}

rule prefix_expression {
  | <name>
  | <'('> <expression> <?closeparen>
}

rule primary_expression {
  <prefix_expression>
  [ <'.'> <name>
  | <index>
  | <':'> <name> <function_args>
  | <function_args>
  ]*
}

rule simple_expression {
  | <number>
  | <string>
  | <nil>
  | <true>
  | <false>
  | <vararg>
  | <constructor>
  | <'function'> <function_body>
  | <primary_expression>
}


=head2 HELPER RULES

Helper rules will match a specific token, otherwise a syntax error is generated.
These rules make the grammar more readable, so the calls to syntax_error() are
not all over the grammar, but only in these rules.

=cut

rule do {
  <'do'> | <syntax_error: 'do' expected>
}

rule then {
  <'then'> | <syntax_error: 'then' expected>
}

rule end {
  <'end'> | <syntax_error: 'end' expected>
}

rule until {
  <'until'> | <syntax_error: 'until' expected>
}

rule comma {
  <','> | <syntax_error: ',' expected>
}

rule in {
  <'in'> | <syntax_error: 'in' expected>
}

rule closebracket {
  <']'>  | <syntax_error: ']' expected>
}

rule closebrace {
  <'}'> | <syntax_error: '}' expected>
}

rule closeparen {
  <')'> | <syntax_error: ')' expected>
}


=head2 TOKENS

Tokens not defined here (in PGE) are written in PIR in
F<languages/lua/src/lua51.pir>.

=cut

token string {
  | \" <quoted_literal: "> \"
  | \' <quoted_literal: '> \'
  | <long_string>
}

token nil {
  <'nil'>
}

token true {
  <'true'>
}

token false {
  <'false'>
}

token vararg {
  <'...'>
}

token ws {
    [ \s+
    | <'--'> <long_comment>
    | <'--'> \N*
    ]*
}


=head2 EXPRESSIONS

Operator precedence is implemented using an optable.

=cut

rule 'expression'   is optable { ... }

proto 'term:'       is precedence('=')
                    is parsed(&simple_expression)              { ... }

proto 'infix:^'     is looser('term:')      is pirop('pow')     is assoc('right')
                    is returns('.LuaNumber')                    { ... }

proto 'prefix:not'  is looser('infix:^')    is pirop('not')
                    is returns('.LuaBoolean')                   { ... }
proto 'prefix:#'    is equiv('prefix:not')  is past('len')
                    is returns('.LuaNumber')                    { ... }
proto 'prefix:-'    is equiv('prefix:not')  is pirop('neg')
                    is returns('.LuaNumber')                    { ... }

proto 'infix:*'     is looser('prefix:not') is pirop('mul')
                    is returns('.LuaNumber')                    { ... }
proto 'infix:/'     is equiv('infix:*')     is pirop('div')
                    is returns('.LuaNumber')                    { ... }
proto 'infix:%'     is equiv('infix:*')     is pirop('mod')
                    is returns('.LuaNumber')                    { ... }

proto 'infix:+'     is looser('infix:*')    is pirop('add')
                    is returns('.LuaNumber')                    { ... }
proto 'infix:-'     is equiv('infix:+')     is pirop('sub')
                    is returns('.LuaNumber')                    { ... }

proto 'infix:..'    is looser('infix:+')    is pirop('concat')  is assoc('right')
                    is returns('.LuaString')                    { ... }

proto 'infix:<'     is looser('infix:..')                       { ... }
proto 'infix:>'     is equiv('infix:<')                         { ... }
proto 'infix:<='    is equiv('infix:<')                         { ... }
proto 'infix:>='    is equiv('infix:<')                         { ... }
proto 'infix:~='    is equiv('infix:<')                         { ... }
proto 'infix:=='    is equiv('infix:<')                         { ... }

proto 'infix:and'   is looser('infix:<')                        { ... }

proto 'infix:or'    is looser('infix:and')                      { ... }


=head1 AUTHORS

Klaas-Jan Stol <parrotcode@gmail.com>

Francois Perrad

=cut

