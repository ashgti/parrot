# Copyright (C) 2007, The Perl Foundation.
# $Id$

=head1 NAME

POSTGrammar.tg - A grammar for transforming the abstract syntax tree (PAST)
into an opcode syntax tree (POST).

=head1 DESCRIPTION


=cut

grammar Lua::POST::Grammar is TGE::Grammar;


transform post (PAST::Block) :language('PIR') {
    null $P0
    set_hll_global ['Lua::POST'], '$?environ', $P0
    .local pmc endlabels
    endlabels = get_hll_global ['Lua::POST'], '@endlabels'
    $P0 = new .ResizablePMCArray
    set_hll_global ['Lua::POST'], '@endlabels', $P0
    .local pmc outerpost
    outerpost = get_hll_global ['Lua::POST'], '$?SUB'
    .local string name
    $S0 = node.'name'()
    unless $S0 == '' goto L1
    $S0 = 'anon'
  L1:
    name = node.'unique'($S0, '_')
    .local pmc post
    post = new 'POST::Sub'
    post.'init'('node'=>node, 'name'=>name, 'outer'=>outerpost, 'pragma'=>':anon :lex', 'blocktype'=>'declaration', 'result'=>'')
    $P0 = new .Hash
    post.'storage_lex'($P0)
    $P0 = new .Hash
    post.'storage_const'($P0)
    $P0 = post.'push_new'('POST::Ops')
    post.'ops_const'($P0)
    set_hll_global ['Lua::POST'], '$?SUB', post
    post.'push_pirop'('inline', '    .local pmc subr')
    post.'push_pirop'('inline', '    subr = interpinfo .INTERPINFO_CURRENT_SUB')
    .local pmc iter, cpost
    iter = node.'iterator'()
  L2:
    unless iter goto L3
    $P0 = shift iter
    cpost = tree.'get'('post', $P0)
    post.'push'(cpost)
    goto L2
  L3:
    set_hll_global ['Lua::POST'], '$?SUB', outerpost
    set_hll_global ['Lua::POST'], '@endlabels', endlabels
    .local string esc_name
    esc_name = node.'escape'(name)
    if null outerpost goto L4
    .local pmc ops
    ops = post.'new'('POST::Ops', 'node'=>node)
    ops.'push'(post)
    $S0 = node.'unique'('fct_')
    ops.'push_pirop'('inline', '    .const .Sub %0 = %1', $S0, esc_name)
    $P0 = ops.'push_pirop'('newclosure')
    $P0.'arglist'($P0, $S0)
    $P1= ops.'push_pirop'('callmethod', 'getfenv', 'subr')
    ops.'push_pirop'('callmethod', 'setfenv', $P0, $P1, 'result'=>'')
    ops.'result'($P0)
    .return (ops)
  L4:
    .local pmc start
    start = post.'new'('POST::Sub', 'name'=>'&start', 'pragma'=>':anon :main', 'result'=>'')
    start.'push_pirop'('inline', '    .param pmc args :optional')
    start.'push_pirop'('inline', '#    print "start\n"')
    start.'push_pirop'('inline', '    load_bytecode "languages/lua/lib/luaaux.pbc"')
    start.'push_pirop'('inline', '    load_bytecode "languages/lua/lib/luabasic.pbc"')
    start.'push_pirop'('inline', '    load_bytecode "languages/lua/lib/luacoroutine.pbc"')
    start.'push_pirop'('inline', '    load_bytecode "languages/lua/lib/luapackage.pbc"')
    start.'push_pirop'('inline', '    load_bytecode "languages/lua/lib/luastring.pbc"')
    start.'push_pirop'('inline', '    load_bytecode "languages/lua/lib/luaregex.pbc"')
    start.'push_pirop'('inline', '    load_bytecode "languages/lua/lib/luatable.pbc"')
    start.'push_pirop'('inline', '    load_bytecode "languages/lua/lib/luamath.pbc"')
    start.'push_pirop'('inline', '    load_bytecode "languages/lua/lib/luaio.pbc"')
    start.'push_pirop'('inline', '    load_bytecode "languages/lua/lib/luafile.pbc"')
    start.'push_pirop'('inline', '    load_bytecode "languages/lua/lib/luaos.pbc"')
    start.'push_pirop'('inline', '    load_bytecode "languages/lua/lib/luadebug.pbc"')
    start.'push_pirop'('inline', '    lua_openlibs()')
    start.'push_pirop'('inline', '    .local pmc env')
    start.'push_pirop'('inline', '    env = get_global "_G"')
    start.'push_pirop'('inline', '    .local pmc vararg')
    start.'push_pirop'('inline', '    vararg = argstolua(env, args)')
    start.'push_pirop'('inline', '    .const .Sub main = %0', esc_name)
    start.'push_pirop'('inline', '    main."setfenv"(env)')
    start.'push_pirop'('inline', '    ($I0, $P0) = docall(main, vararg :flat)')
    start.'push_pirop'('inline', '    unless $I0 goto L1')
    start.'push_pirop'('inline', '    printerr "luap: "')
    start.'push_pirop'('inline', '    printerr $P0')
    start.'push_pirop'('inline', '  L1:')
    post.'init'('outer'=>start)
    .return post.'new'('Lua::POST::Chunk', post, start, 'prologue'=><<'PIRCODE')
.include "interpinfo.pasm"
.HLL "Lua", "lua_group"
PIRCODE
}


transform post (PAST::Stmts) :language('PIR') {
    .local pmc ops
    ops =  new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc iter
    iter = node.'iterator'()
  L1:
    unless iter goto L2
    $P0 = shift iter
    $P1 = tree.'get'('void', $P0)
    ops.'push'($P1)
    goto L1
  L2:
    null $P0
    set_hll_global ['Lua::POST'], '$?environ', $P0
    .return (ops)
}


transform void (PAST::Stmts) :language('PIR') {
    .return tree.'get'('post', node)
}


transform void (PAST::Op) :language('PIR') {
    $S0 = node.'pasttype'()
    .return tree.'get'($S0, node)
}


transform cond (PAST::Op) :language('PIR') {
    $S0 = node.'pirop'()
    $I0 = index $S0, 'is'
    unless $I0 >= 0 goto L1
    .return tree.'get'('cmp', node)
  L1:
    .return tree.'get'('post', node)
}


transform post (PAST::Op) :language('PIR') {
    $S0 = node.'pasttype'()
    unless $S0 == 'call' goto L1
    .local pmc post
    post = tree.'get'($S0, node)
    $P0 = post.'push_pirop'('new')
    $P0.'arglist'($P0, '.LuaNil')
    post.'result'($P0)
    .return (post)
  L1:
    .return tree.'get'($S0, node)
}


transform pirop (PAST::Op) :language('PIR') {
    .local pmc post
    $S0 = node.'pirop'()
    $I0 = index $S0, 'is'
    unless $I0 >= 0 goto L1
    post = tree.'get'('cmp', node)
    $P0 = post.'push_pirop'('new')
    $P0.'arglist'($P0, '.LuaBoolean')
    post.'push_pirop'('set', $P0, post)
    post.'result'($P0)
    .return (post)
  L1:
    post = new 'POST::Op'
    post.'init'('node'=>node, 'pirop'=>$S0)
    .local pmc arglist, iter
    arglist = new .ResizableStringArray
    iter = node.'iterator'()
  L2:
    unless iter goto L3
    .local pmc cpost
    $P0 = shift iter
    cpost = tree.'get'('post', $P0)
    post.'push'(cpost)
    $S0 = cpost.'result'()
    push arglist, $S0
    goto L2
  L3:
    post.'arglist'(post, arglist :flat)
    .return (post)
}


transform cmp (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc expr1
    $P0 = node[0]
    expr1 = tree.'get'('post', $P0)
    ops.'push'(expr1)
    .local pmc expr2
    $P0 = node[1]
    expr2 = tree.'get'('post', $P0)
    ops.'push'(expr2)
    .local string pirop
    pirop = node.'pirop'()
    $S0 = node.'unique'('$I')
    ops.'push_pirop'(pirop, $S0, expr1, expr2)
    ops.'result'($S0)
    .return (ops)
}


transform call (PAST::Op) :language('PIR') {
    .local pmc post
    post = new 'POST::Op'
    post.'init'('node'=>node, 'pirop'=>'call', 'result'=>'')
    .local pmc arglist, iter, cpost
    arglist = new .ResizableStringArray
    iter = node.'iterator'()
    .local int first
    first = 1
  L1:
    unless iter goto L2
    $P0 = shift iter
    cpost = tree.'get'('post', $P0)
    post.'push'(cpost)
    $S0 = cpost.'result'()
    if first goto L3
    if iter goto L3
    $I0 = isa cpost, 'POST::Op'
    unless $I0 goto L3
    $S1 = cpost.'pirop'()
    unless $S1 == 'call' goto L3
    $S1 = '(' . $S0
    $S1 .= ' :slurpy)'
    cpost.'result'($S1)
    $S0 .= ' :flat'
  L3:
    first = 0
    push arglist, $S0
    goto L1
  L2:
    post.'arglist'(arglist :flat)
    null $P0
    set_hll_global ['Lua::POST'], '$?environ', $P0
    .return (post)
}


transform len (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc expr
    $P0 = node[0]
    expr = tree.'get'('post', $P0)
    ops.'push'(expr)
    $P0 = ops.'push_pirop'('callmethod', 'node'=>node)
    $S0 = node.'escape'('len')
    $P0.'arglist'($S0, expr)
    ops.'result'($P0)
    .return (ops)
}


transform and (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    .local string type
    type = node.'pasttype'()
    .local pmc expr1
    $P0 = node[0]
    expr1 = tree.'get'('post', $P0)
    ops.'push'(expr1)
    .local pmc label, endlabel
    $S0 = node.'unique'(type, '_')
    label = ops.'new'('POST::Label', 'result'=>$S0)
    $S0 = $S0 . '_end'
    endlabel = ops.'new'('POST::Label', 'result'=>$S0)
    $S0 = node.'unique'('$P')
    unless type == 'and' goto L1
    ops.'push_pirop'('if', expr1, label)
    goto L2
  L1:
    ops.'push_pirop'('unless', expr1, label)
  L2:
    ops.'push_pirop'('clone', $S0, expr1)
    ops.'push_pirop'('goto', endlabel)
    ops.'push'(label)
    .local pmc expr2
    $P0 = node[1]
    expr2 = tree.'get'('post', $P0)
    ops.'push'(expr2)
    ops.'push_pirop'('clone', $S0, expr2)
    ops.'push'(endlabel)
    ops.'result'($S0)
    .return (ops)
}


transform or (PAST::Op) :language('PIR') {
    .return tree.'get'('and', node)
}


transform vararg (PAST::Op) :language('PIR') {
    .local pmc post
    post = new 'POST::Op'
    post.'init'('node'=>node, 'pirop'=>'call')
    post.'arglist'('mkarg', 'vararg')
    $P0 = post.'push_pirop'('new')
    $P0.'arglist'($P0, '.LuaNil')
    post.'result'($P0)
    .return (post)
}


transform if (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc thenlabel, endlabel
    $S0 = node.'unique'('if_')
    thenlabel = ops.'new'('POST::Label', 'result'=>$S0)
    $S0 = $S0 . '_end'
    endlabel = ops.'new'('POST::Label', 'result'=>$S0)
    .local pmc expr
    $P0 = node[0]
    expr = tree.'get'('cond', $P0)
    ops.'push'(expr)
    ops.'push_pirop'('if', expr, thenlabel)
    .local pmc else
    $P0 = node[2]
    $I0 = defined $P0
    if $I0 == 0 goto L1
    else = tree.'get'('post', $P0)
    ops.'push'(else)
  L1:
    ops.'push_pirop'('goto', endlabel)
    ops.'push'(thenlabel)
    .local pmc then
    $P0 = node[1]
    $I0 = defined $P0
    if $I0 == 0 goto L2
    then = tree.'get'('post', $P0)
    ops.'push'(then)
  L2:
    ops.'push'(endlabel)
    .return (ops)
}


transform while (PAST::Op) :language('PIR') {
    .local pmc endlabels
    endlabels = get_hll_global ['Lua::POST'], '@endlabels'
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc looplabel, endlabel
    $S0 = node.'unique'('while_')
    looplabel = ops.'new'('POST::Label', 'result'=>$S0)
    $S0 = $S0 . '_end'
    endlabel = ops.'new'('POST::Label', 'result'=>$S0)
    unshift endlabels, endlabel
    ops.'push'(looplabel)
    .local pmc expr
    $P0 = node[0]
    expr = tree.'get'('cond', $P0)
    ops.'push'(expr)
    ops.'push_pirop'('unless', expr, endlabel)
    .local pmc blk
    $P0 = node[1]
    blk = tree.'get'('post', $P0)
    ops.'push'(blk)
    ops.'push_pirop'('goto', looplabel)
    ops.'push'(endlabel)
    $P0 = shift endlabels
    .return (ops)
}


transform repeat (PAST::Op) :language('PIR') {
    .local pmc endlabels
    endlabels = get_hll_global ['Lua::POST'], '@endlabels'
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc looplabel, endlabel
    $S0 = node.'unique'('repeat_')
    looplabel = ops.'new'('POST::Label', 'result'=>$S0)
    $S0 = $S0 . '_end'
    endlabel = ops.'new'('POST::Label', 'result'=>$S0)
    unshift endlabels, endlabel
    ops.'push'(looplabel)
    .local pmc blk
    $P0 = node[0]
    blk = tree.'get'('post', $P0)
    ops.'push'(blk)
    .local pmc expr
    $P0 = node[1]
    expr = tree.'get'('cond', $P0)
    ops.'push'(expr)
    ops.'push_pirop'('if', expr, endlabel)
    ops.'push_pirop'('goto', looplabel)
    ops.'push'(endlabel)
    $P0 = shift endlabels
    .return (ops)
}


transform fornum (PAST::Op) :language('PIR') {
    .local pmc endlabels
    endlabels = get_hll_global ['Lua::POST'], '@endlabels'
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc e_var, e_limit, e_step
    $P0 = node[1]
    $P1 = $P0[0]
    e_var = tree.'get'('post', $P1)
    ops.'push'(e_var)
    $P1 = $P0[1]
    e_limit = tree.'get'('post', $P1)
    ops.'push'(e_limit)
    $P1 = $P0[2]
    e_step = tree.'get'('post', $P1)
    ops.'push'(e_step)
    .local string var
    $P0 = node[0]
    $P0 = tree.'get'('post', $P0)
    $P0 = $P0.'pop'()
    var = $P0.'result'()
    ops.'push'($P0)
    .local string limit, step
    limit = node.'unique'('$P')
    step = node.'unique'('$P')
    ops.'push_pirop'('inline', '    (%0, %1, %2) = checkforloop(%3, %4, %5)', var, limit, step, e_var, e_limit, e_step)
    .local string incr
    $S0 = node.'unique'('$N')
    ops.'push_pirop'('set', $S0, step)
    incr = node.'unique'('$I')
    ops.'push_pirop'('isgt', incr, $S0, '0.0')
    .local pmc looplabel, endlabel, orlabel, blklabel
    $S0 = node.'unique'('fornum_')
    looplabel = ops.'new'('POST::Label', 'result'=>$S0)
    $S1 = $S0 . '_or'
    orlabel = ops.'new'('POST::Label', 'result'=>$S1)
    $S1 = $S0 . '_blk'
    blklabel = ops.'new'('POST::Label', 'result'=>$S1)
    $S1 = $S0 . '_end'
    endlabel = ops.'new'('POST::Label', 'result'=>$S1)
    unshift endlabels, endlabel
    ops.'push'(looplabel)
    ops.'push_pirop'('unless', incr, orlabel)
    ops.'push_pirop'('gt', var, limit, endlabel)
    ops.'push_pirop'('goto', blklabel)
    ops.'push'(orlabel)
    ops.'push_pirop'('lt', var, limit, endlabel)
    ops.'push'(blklabel)
    .local pmc blk
    $P0 = node[2]
    blk = tree.'get'('post', $P0)
    ops.'push'(blk)
    ops.'push_pirop'('add', var, step)
    ops.'push_pirop'('goto', looplabel)
    ops.'push'(endlabel)
    $P0 = shift endlabels
    .return (ops)
}


transform forlist (PAST::Op) :language('PIR') {
    .local pmc endlabels
    endlabels = get_hll_global ['Lua::POST'], '@endlabels'
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc explist, rpost
    explist = node[1]
    .local string func, state, var
    .local pmc iter
    new iter, .Iterator, explist
    $P0 = shift iter
    rpost = tree.'get'('post', $P0)
    ops.'push'(rpost)
    func = rpost.'result'()
    if iter goto L1
    $I0 = isa rpost, 'POST::Op'
    unless $I0 goto L1
    $S0 = rpost.'pirop'()
    unless $S0 == 'call' goto L1
    $S0 = '(' . func
    $P0 = rpost.'push_pirop'('new')
    $P0.'arglist'($P0, '.LuaNil')
    state = $P0.'result'()
    $S0 .= ', '
    $S0 .= state
    $P0 = rpost.'push_pirop'('new')
    $P0.'arglist'($P0, '.LuaNil')
    var = $P0.'result'()
    $S0 .= ', '
    $S0 .= var
    $S0 .= ')'
    rpost.'result'($S0)
  L1:
    unless iter goto L4
    $P0 = shift iter
    rpost = tree.'get'('post', $P0)
    ops.'push'(rpost)
    state = rpost.'result'()
    if iter goto L2
    $I0 = isa rpost, 'POST::Op'
    unless $I0 goto L2
    $S0 = rpost.'pirop'()
    unless $S0 == 'call' goto L2
    $S0 = '(' . state
    $P0 = rpost.'push_pirop'('new')
    $P0.'arglist'($P0, '.LuaNil')
    var = $P0.'result'()
    $S0 .= ', '
    $S0 .= var
    $S0 .= ')'
    rpost.'result'($S0)
  L2:
    unless iter goto L4
    $P0 = shift iter
    rpost = tree.'get'('post', $P0)
    ops.'push'(rpost)
    var = rpost.'result'()
  L3:
    unless iter goto L4
    $P0 = shift iter
    rpost = tree.'get'('post', $P0)
    ops.'push'(rpost)
    goto L3
  L4:
    unless state == '' goto L5
    $P0 = ops.'push_pirop'('new')
    state = $P0.'result'()
    $P0.'arglist'(state, '.LuaNil')
  L5:
    unless var == '' goto L6
    $P0 = ops.'push_pirop'('new')
    var = $P0.'result'()
    $P0.'arglist'(var, '.LuaNil')
  L6:
    .local pmc namelist, lpost, tmp
    namelist = node[0]
    new iter, .Iterator, namelist
    new tmp, .ResizableStringArray
  L7:
    unless iter goto L8
    $P0 = shift iter
    lpost = tree.'get'('post', $P0)
    $P1 = lpost.'pop'()
    $S1 = $P1.'result'()
    ops.'push'($P1)
    push tmp, $S1
    goto L7
  L8:
    .local pmc looplabel, endlabel
    $S0 = node.'unique'('forlist_')
    looplabel = ops.'new'('POST::Label', 'result'=>$S0)
    $S0 = $S0 . '_end'
    endlabel = ops.'new'('POST::Label', 'result'=>$S0)
    unshift endlabels, endlabel
    ops.'push'(looplabel)
    new iter, .Iterator, tmp
    $S0 = '('
  L9:
    unless iter goto L10
    $S1 = shift iter
    ops.'push_pirop'('new', $S1, '.LuaNil')
    if $S0 == '(' goto L11
    $S0 .= ', '
  L11:
    $S0 .= $S1
    goto L9
  L10:
    $S0 .= ')'
    $P0 = ops.'push_pirop'('call', 'node'=>node)
    $P0.'arglist'(func, state, var)
    $P0.'result'($S0)
    $P0 = ops.'push_pirop'('assign')
    $S0 = tmp[0]
    $P0.'arglist'(var, $S0)
    $S0 = node.'unique'('$I')
    ops.'push_pirop'('isa', $S0, var, '"LuaNil"')
    ops.'push_pirop'('if', $S0, endlabel)
    .local pmc blk
    $P0 = node[2]
    blk = tree.'get'('post', $P0)
    ops.'push'(blk)
    ops.'push_pirop'('goto', looplabel)
    ops.'push'(endlabel)
    $P0 = shift endlabels
    .return (ops)
}


transform return (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    .local string result
    result = '('
    .local pmc iter, cpost
    iter = node.'iterator'()
  L1:
    unless iter goto L2
    $P0 = shift iter
    cpost = tree.'get'('post', $P0)
    ops.'push'(cpost)
    $S0 = cpost.'result'()
    if iter goto L3
    $I0 = isa cpost, 'POST::Op'
    unless $I0 goto L3
    $S1 = cpost.'pirop'()
    unless $S1 == 'call' goto L3
    unless result == '(' goto L4
    cpost.'pirop'('tailcall')
    .return (ops)
  L4:
    $S1 = '(' . $S0
    $S1 .= ' :slurpy)'
    cpost.'result'($S1)
    $S0 .= ' :flat'
  L3:
    if result == '(' goto L5
    result .= ', '
  L5:
    result .= $S0
    goto L1
  L2:
    result .= ')'
    $P0 = ops.'push_pirop'('.return')
    $P0.'arglist'(result)
    .return (ops)
}


transform break (PAST::Op) :language('PIR') {
    .local pmc endlabels
    endlabels = get_hll_global ['Lua::POST'], '@endlabels'
    .local pmc post
    post = new 'POST::Op'
    post.'init'('node'=>node, 'pirop'=>'goto')
    $P0 = endlabels[0]
    post.'arglist'($P0)
    .return (post)
}


transform assign (PAST::Op) :language('PIR') {
    .local pmc rpost
    $P0 = node[1]
    rpost = tree.'get'('post', $P0)
    .local pmc lpost
    $P0 = node[0]
    lpost = tree.'get'('post', $P0)
    lpost.'arglist'(lpost, rpost)
    .local pmc ops
    ops = lpost.'new'('POST::Ops', rpost, lpost, 'node'=>node)
    .return (ops)
}


transform assignlist (PAST::Op) :language('PIR') {
    .local pmc lpost, rpost, ops
    ops =  new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc namelist, explist
    namelist = node[0]
    explist = node[1]
    .local pmc iter, tmp
    new tmp, .ResizableStringArray
    new iter, .Iterator, explist
  L1:
    unless iter goto L2
    $P0 = shift iter
    rpost = tree.'get'('post', $P0)
    ops.'push'(rpost)
    $S1 = rpost.'result'()
    push tmp, $S1
    if iter goto L1
    $I0 = isa rpost, 'POST::Op'
    unless $I0 goto L1
    $S0 = rpost.'pirop'()
    unless $S0 == 'call' goto L1
    $I1 = namelist
    $I2 = explist
    $I1 -= $I2
    unless $I1 goto L1
    $S0 = '(' . $S1
  L3:
    unless $I1 > 0 goto L4
    $P1 = rpost.'push_pirop'('new')
    $P1.'arglist'($P1, '.LuaNil')
    $S1 = $P1.'result'()
    push tmp, $S1
    $S0 .= ', '
    $S0 .= $S1
    dec $I1
    goto L3
  L4:
    $S0 .= ')'
    rpost.'result'($S0)
  L2:
    .local pmc ass
    ass = new 'POST::Ops'
    ass.'init'('node'=>node)
    new iter, .Iterator, namelist
  L5:
    unless iter goto L6
    $P0 = shift iter
    unless tmp goto L7
    $S1 = shift tmp
    goto L8
  L7:
    rpost = ops.'push_pirop'('new')
    rpost.'arglist'(rpost, '.LuaNil')
    $S1 = rpost.'result'()
  L8:
    lpost = tree.'get'('post', $P0)
    lpost.'arglist'(lpost, $S1)
    $P0 = lpost.'pop'()
    ops.'push'($P0)
    ass.'push'(lpost)
    goto L5
  L6:
    ops.'push'(ass)
    .return (ops)
}


transform parenthese (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc expr
    $P0 = node[0]
    expr = tree.'get'('post', $P0)
    ops.'push'(expr)
    ops.'result'(expr)
    .return (ops)
}


transform cond (PAST::Val) :language('PIR') {
    .return tree.'get'('post', node)
}


transform post (PAST::Val) :language('PIR') {
    .local string vtype
    vtype = node.'vtype'()
    $I0 = index vtype, '.'
    if $I0 < 0 goto L1
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc val
    val = ops.'push_pirop'('new')
    val.'arglist'(val, vtype)
    .local string name
    name = node.'name'()
    if name == '' goto L2
    unless vtype == '.LuaString' goto L3
    name = node.'escape'(name)
  L3:
    ops.'push_pirop'('set', val, name, 'result'=>val)
  L2:
    ops.'result'(val)
    .return (ops)
  L1:
    .return tree.'get'(vtype, node)
}


transform key (PAST::Val) :language('PIR') {
    .local pmc subpost
    subpost = get_hll_global ['Lua::POST'], '$?SUB'
    .local pmc storage_const
    storage_const = subpost.'storage_const'()
    .local string name
    name = node.'name'()
    $I0 = exists storage_const[name]
    if $I0 goto L1
    .local pmc ops_const
    ops_const = subpost.'ops_const'()
    $S0 = 'k_' . name
    $S1 = node.'escape'(name)
    $P0 = ops_const.'push_pirop'('inline', '    .const .LuaString %0 = %1', $S0, $S1)
    storage_const[name] = $S0
  L1:
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    $S0 = storage_const[name]
    ops.'result'($S0)
    .return (ops)
}


transform constructor (PAST::Val) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc val
    val = ops.'push_pirop'('new')
    val.'arglist'(val, '.LuaTable')
    ops.'result'(val)
    .local pmc iter, kpost, vpost
    .local string key
    .local int i
    i = 1
    iter = node.'iterator'()
  L1:
    unless iter goto L2
    $P0 = shift iter
    $I0 = does $P0, 'array'
    if $I0 goto L3
    kpost = ops.'new'('POST::Ops', 'node'=>node)
    $P1 = kpost.'push_pirop'('new')
    $P1.'arglist'($P1, '.LuaNumber')
    $S0 = i
    inc i
    kpost.'push_pirop'('set', $P1, $S0)
    kpost.'result'($P1)
    vpost = tree.'get'('post', $P0)
    if iter goto L4
    $I0 = isa vpost, 'POST::Op'
    unless $I0 goto L4
    $S0 = vpost.'pirop'()
    unless $S0 == 'call' goto L4
    ops.'push'(kpost)
    $S0 = vpost.'result'()
    $S1 = '(' . $S0
    $S1 .= ' :slurpy)'
    vpost.'result'($S1)
    ops.'push'(vpost)
    $S0 .= ' :flat'
    $P1 = ops.'push_pirop'('call', 'tconstruct', val, kpost, $S0)
    $P1.'result'(val)
    goto L2
  L3:
    $P1 = $P0[0]
    kpost = tree.'get'('post', $P1)
    $P1 = $P0[1]
    vpost = tree.'get'('post', $P1)
  L4:
    ops.'push'(kpost)
    ops.'push'(vpost)
    key = val.'result'()
    key .= '['
    $S0 = kpost.'result'()
    key .= $S0
    key .= ']'
    ops.'push_pirop'('set', key, vpost)
    goto L1
  L2:
    .return (ops)
}


transform cond (PAST::Var) :language('PIR') {
    .return tree.'get'('post', node)
}


transform post (PAST::Var) :language('PIR') {
    $S0 = node.'scope'()
    .return tree.'get'($S0, node)
}


transform parameter (PAST::Var) :language('PIR') {
    .local pmc subpost
    subpost = get_hll_global ['Lua::POST'], '$?SUB'
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    .local string name
    name = node.'name'()
    $I0 = node.'isslurpy'()
    unless $I0 goto L1
    subpost.'push_param'('pmc', name, ':slurpy')
    .return (ops)
  L1:
    .local pmc storage_lex
    storage_lex = subpost.'storage_lex'()
    .local string pname
    pname = 'param_' . name
    subpost.'push_param'('pmc', pname, ':optional')
    $S0 = node.'escape'(name)
    ops.'push_pirop'('.lex', $S0, pname)
    .local pmc vivilabel
    vivilabel = ops.'new'('POST::Label', 'name'=>'vivify_')
    ops.'push_pirop'('unless_null', pname, vivilabel)
    ops.'push_pirop'('new', pname, '.LuaNil')
    ops.'push'(vivilabel)
    ops.'result'(pname)
    storage_lex[name] = pname
    .return (ops)
}


transform lexical (PAST::Var) :language('PIR') {
    .local pmc subpost
    subpost = get_hll_global ['Lua::POST'], '$?SUB'
    .local pmc storage_lex
    storage_lex = subpost.'storage_lex'()
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    .local string name, lname
    name = node.'name'()
    lname = node.'escape'(name)
    $I0 = node.'islvalue'()
    if $I0 goto L1
    $I0 = exists storage_lex[name]
    if $I0 goto L2
    $P0 = ops.'push_pirop'('find_lex')
    $P0.'arglist'($P0, lname)
    ops.'result'($P0)
    .return (ops)
  L2:
    $S0 = storage_lex[name]
    ops.'result'($S0)
    .return (ops)
  L1:
    $I0 = node.'ismy'()
    unless $I0 goto L3
    $I0 = exists storage_lex[name]
    if $I0 goto L3
    .local string pname
    pname = 'var_' . name
    ops.'push_pirop'('.local pmc', pname)
    ops.'push_pirop'('.lex', lname, pname)
    ops.'result'(pname)
    storage_lex[name] = pname
  L3:
    .local pmc post
    post = new 'POST::Op'
    post.'init'('node'=>node, 'pirop'=>'store_lex')
    post.'push'(ops)
    post.'result'(lname)
    .return (post)
}


transform package (PAST::Var) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc basepost, keypost
    $S0 = node.'scope'()
    unless $S0 == 'keyed' goto L1
    $P0 = node[0]
    basepost = tree.'get'('post', $P0)
    ops.'push'(basepost)
    $P0 = node[1]
    keypost = tree.'get'('post', $P0)
    ops.'push'(keypost)
    goto L2
  L1:
    basepost = get_hll_global ['Lua::POST'], '$?environ'
    unless null basepost goto L3
    basepost = ops.'push_pirop'('callmethod', 'getfenv', 'subr')
    set_hll_global ['Lua::POST'], '$?environ', basepost
  L3:
    .local pmc subpost
    subpost = get_hll_global ['Lua::POST'], '$?SUB'
    .local pmc storage_const
    storage_const = subpost.'storage_const'()
    .local string name
    name = node.'name'()
    $I0 = exists storage_const[name]
    if $I0 goto L4
    .local pmc ops_const
    ops_const = subpost.'ops_const'()
    $S0 = 'k_' . name
    $S1 = node.'escape'(name)
    $P0 = ops_const.'push_pirop'('inline', '    .const .LuaString %0 = %1', $S0, $S1)
    storage_const[name] = $S0
  L4:
    keypost = new 'POST::Ops'
    keypost.'init'('node'=>node)
    $S0 = storage_const[name]
    keypost.'result'($S0)
  L2:
    .local string key
    key = basepost.'result'()
    key .= '['
    $S0 = keypost.'result'()
    key .= $S0
    key .= ']'
    ops.'result'(key)
    $I0 = node.'islvalue'()
    if $I0 goto L5
    $P0 = ops.'push_pirop'('set')
    $P0.'arglist'($P0, key)
    ops.'result'($P0)
    .return (ops)
  L5:
    .local pmc post
    post = new 'POST::Op'
    post.'init'('node'=>node, 'pirop'=>'set')
    post.'push'(ops)
    post.'result'(key)
    .return (post)
}


transform keyed (PAST::Var) :language('PIR') {
    .return tree.'get'('package', node)
}


=head1 AUTHORS

Francois Perrad

=cut

