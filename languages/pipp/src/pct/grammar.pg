# Copyright (C) 2006-2008, The Perl Foundation.
# $Id$

# PHP grammar for Pipp PCT

grammar Pipp::Grammar is PCT::Grammar;

# the starting rule
token TOP { ^ <sea_or_code>+ {*} }

# Whitespace and comments

token ws_char           { \h | \v }

token singlelinecomment { [ '#' || '//' ] \N* }    # end of line comment like Unix shell and C++

token multilinecomment  { '/*' .*?  '*/' }         # C-like multiline comment

token ws_all {
      <.ws_char>
    | <singlelinecomment>
    | <multilinecomment>
}

# whitespace rule used implicity by rules
token ws {
      <!ww> <ws_all>+
    | <ws_all>*
}

# text or PHP-code
token sea_or_code {
      <code_echo_tag>   {*}    #= code_echo_tag
    | <code_short_tag>  {*}    #= code_short_tag
    | <code_script_tag> {*}    #= code_script_tag
    | <SEA>             {*}    #= SEA
}

# text, in most cases broken HTML,
# when an '<' is encountered check whether this is the start of PHP-code 
regex SEA {
    '<'? .+? ( <before '<'> | $ )
    {*}
}

rule code_echo_tag {
    <.CODE_START_ECHO_TAG> <arguments> <.statement_delimiter>
        <statement>*
    <.CODE_END_SHORT_TAG>?
    {*}
}

rule code_script_tag {
    <.CODE_START_SCRIPT_TAG>
        <statement>*
    <.CODE_END_SCRIPT_TAG>?
    {*}
}

rule code_short_tag {
    <.CODE_START_SHORT_TAG>
        <statement>*
    <.CODE_END_SHORT_TAG>?
    {*}
}

regex CODE_START_SCRIPT_TAG {
    '<script' <ws_char>+: 'language' <ws_char>*: '=' <ws_char>*: <quoted_lang_name> <ws_char>*: '>'
}

regex CODE_END_SCRIPT_TAG { '</script' <ws_char>*: '>' }

token quoted_lang_name { '"php"' | '\'php\'' }

token CODE_START_ECHO_TAG { '<?=' }

token CODE_START_SHORT_TAG { '<?' 'php'?  }

token CODE_END_SHORT_TAG { '?>' \n?  }

# block and statements
rule block {
    '{' <statement>* '}'
    {*}
}

rule statement {
      <namespace_statement>   {*}  #= namespace_statement
    | <echo_statement>        {*}  #= echo_statement
    | <expression_statement>  {*}  #= expression_statement
    | <if_statement>          {*}  #= if_statement
    | <while_statement>       {*}  #= while_statement
    | <for_statement>         {*}  #= for_statement
    | <inline_sea_short_tag>  {*}  #= inline_sea_short_tag
    | <inline_sea_script_tag> {*}  #= inline_sea_script_tag
    | <var_assign>            {*}  #= var_assign
    | <function_definition>   {*}  #= function_definition
    | <class_definition>      {*}  #= class_definition
}

rule statement_delimiter {
      ';'
    | <before '?'>
    | $
}

rule namespace_statement {
    'namespace' <NAMESPACE_NAME> ';'
    {*}
}

token echo_statement {
    'echo' <.ws_char> <arguments> <ws> <.statement_delimiter>
    {*}
}

rule expression_statement {
    <expression> <.statement_delimiter>
    {*}
}

rule arguments {
    [ <expression> [',' <expression>]* ]?
    {*}
}

rule if_statement {
    'if' '(' <expression> ')' <block> <else_clause>?
    {*}
}

rule else_clause {
    'else' <block>
    {*}
}

rule elsif_clause {
    'elsif' '(' <expression> ')' <block>
    {*}
}

rule while_statement {
    'while' '(' <expression> ')' <block>
    {*}
}

rule for_statement {
    'for' '(' <var_assign> <expression> ';' <expression> ')' <block>
    {*}
}

token inline_sea_short_tag {
    <.CODE_END_SHORT_TAG>
        <SEA_empty_allowed>
    <.CODE_START_SHORT_TAG>
    {*}
}

token inline_sea_script_tag {
    <.CODE_END_SCRIPT_TAG>
        <SEA_empty_allowed>
    <.CODE_START_SCRIPT_TAG>
    {*}
}

regex SEA_empty_allowed {
    <-[<]>*? <before '<'>
}

rule var_assign {
    <var> '=' <expression> <.statement_delimiter>
    {*}
}


# identifiers
#
token CLASS_NAME      { <ident> }

token CONSTANT_NAME   { <ident> }

token FUNCTION_NAME   { <ident> }

token INTERFACE_NAME  { <ident> }

token MEMBER_NAME     { <ident> }

token METHOD_NAME     { <ident> }

# namespace support

token NAMESPACE_SEPARATOR { '\\' }

token NAMESPACE_NAME { <ident>? [ <.NAMESPACE_SEPARATOR> <ident> ]* }

token VAR_NAME {
    '$' <ident>
    {*}
}

# terms
rule method_call {
    <var> '->' <METHOD_NAME> '(' <arguments> ')'
    {*}
}

rule function_call {
    <FUNCTION_NAME> '(' <arguments> ')'
    {*}
}

rule constructor_call {
    'new' <CLASS_NAME>
    {*}
}

token TRUE {
    'TRUE'
    {*}
}

token FALSE {
    'FALSE'
    {*}
}

token NULL {
    'NULL'
    {*}
}

token NUMBER {
    ( \d+ )? '.' \d+
    {*}
}

token INTEGER {
    \d+
    {*}
}

token quote {
    [ <.before '"' > <quote_expression: :qq>
    | <.before \'  > <quote_expression: :q>
    ]
    {*}
}

rule constant {
    <CONSTANT_NAME>
    {*}
}

rule this {
    '$this'
    {*}
}

rule member {
    <this> '->' <MEMBER_NAME>
    {*}
}

rule array_elem {
    <VAR_NAME> '[' <expression> ']'
    {*}
}

token var {
      <this>        {*}   #= this
    | <array_elem>  {*}   #= array_elem
    | <VAR_NAME>    {*}   #= VAR_NAME
}

rule literal {
      <TRUE>    {*}    #= TRUE
    | <FALSE>   {*}    #= FALSE
    | <NULL>    {*}    #= NULL
    | <NUMBER>  {*}    #= NUMBER
    | <INTEGER> {*}    #= INTEGER
    | <quote>   {*}    #= quote
}

rule term {
      <method_call>            {*}   #= method_call
    | <function_call>          {*}   #= function_call
    | <constructor_call>       {*}   #= constructor_call
    | '(' <expression> {*} ')'       #= expression
    | <literal>                {*}   #= literal
    | <constant>               {*}   #= constant
    | <member>                 {*}   #= member
    | <var>                    {*}   #= var
}


# declarations
rule function_definition {
    'function' <FUNCTION_NAME> <.ENTER_FUNCTION_DEF> <param_list> <block> <.EXIT_FUNCTION_DEF>
    {*}
}

# special subrule for marking variable scope
token ENTER_FUNCTION_DEF {
    {*}
}

# ditto
token EXIT_FUNCTION_DEF {
    {*}
}

rule param_list {
    '(' [ <VAR_NAME> [',' <VAR_NAME>]* ]? ')'
    {*}
}

# OO

rule interface_definition {
    'interface' <INTERFACE_NAME> [ 'implements' <INTERFACE_NAME> ]? '{'
        <method_declaration>*
    '}'
    {*}
}


rule class_definition {
    'class' <CLASS_NAME> [ 'implements' <INTERFACE_NAME> ]? '{'
        <member_definition>*
        <method_definition>*
    '}'
    {*}
}

rule method_declaration {
    'function' <METHOD_NAME> <param_list> ';'
    {*}
}

rule member_definition {
    'public' <VAR_NAME> '=' <literal> <.statement_delimiter>
    {*}
}

rule method_definition {
    'function' <METHOD_NAME> <param_list> <block>
    {*}
}



token curly_interpolation {
    '{' <var> '}'
    {*}
}


# operator precedence table
rule expression is optable                                    { ... }

proto postfix:'++' is precedence('1')                         { ... }
proto postfix:'--' is equiv(postfix:<++>)                     { ... }
proto prefix:'++'  is equiv(postfix:<++>)                     { ... }
proto prefix:'--'  is equiv(postfix:<++>)                     { ... }

proto infix:'|'    is looser('postfix:++')                    { ... }
proto infix:'&'    is equiv('infix:|')                        { ... }
proto infix:'^'    is equiv('infix:|')                        { ... }

proto infix:'<'    is tighter('infix:|')                      { ... }
proto infix:'<='   is equiv('infix:<')                        { ... }
proto infix:'>'    is equiv('infix:<')                        { ... }
proto infix:'>='   is equiv('infix:<')                        { ... }
proto infix:'=='   is equiv('infix:<')                        { ... }
proto infix:'!='   is equiv('infix:<')                        { ... }

proto infix:'+'    is tighter('infix:<')                      { ... }
proto infix:'-'    is equiv('infix:+')                        { ... }
proto infix:'.'    is equiv('infix:+')    is pirop('concat')  { ... }

proto infix:'*'    is tighter('infix:+')                      { ... }
proto infix:'%'    is equiv('infix:*')                        { ... }
proto infix:'/'    is equiv('infix:*')                        { ... }

proto prefix:'-'   is tighter('infix:*')                      { ... }
proto prefix:'+'   is equiv('prefix:-')                       { ... }
proto prefix:'!'   is equiv('prefix:-')                       { ... }

proto term:''      is tighter('prefix:-') is parsed(&term)    { ... }
