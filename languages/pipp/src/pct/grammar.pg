# Copyright (C) 2006-2008, The Perl Foundation.
# $Id$

# PHP grammar for Pipp PCT

grammar Pipp::Grammar is PCT::Grammar;

# the starting rule
token TOP { ^ <sea_or_code>+ {*} }

# Whitespace and comments

token ws_char           { \h | \v }

token singlelinecomment { [ '#' || '//' ] \N* }    # end of line comment like Unix shell and C++

token multilinecomment  { '/*' .*?  '*/' }         # C-like multiline comment

token ws_all {
      <.ws_char>
    | <singlelinecomment>
    | <multilinecomment>
}

# whitespace rule used implicity by rules
token ws {
      <!ww> <ws_all>+
    | <ws_all>*
}

# text or PHP-code
token sea_or_code {
      <code_echo_tag>   {*}    #= code_echo_tag
    | <code_short_tag>  {*}    #= code_short_tag
    | <code_script_tag> {*}    #= code_script_tag
    | <SEA>             {*}    #= SEA
}

# text, in most cases broken HTML,
# when an '<' is encountered check whether this is the start of PHP-code 
regex SEA {
    '<'? .+? ( <before '<'> | $ )
    {*}
}

rule code_echo_tag {
    <.CODE_START_ECHO_TAG> <arguments> <.statement_delimiter>
        <statement>*
    <.close_short_tag>?
    {*}
}

rule code_script_tag {
    <.open_script_tag>
        <statement>*
    <.close_script_tag>?
    {*}
}

rule code_short_tag {
    <.open_short_tag>
        <statement>*
    <.close_short_tag>?
    {*}
}

regex open_script_tag {
    '<script' <ws_char>+: 'language' <ws_char>*: '=' <ws_char>*: <quoted_lang_name> <ws_char>*: '>'
    {{ $P0 = new 'String'
       $P0 = "script"
        set_global "tag_type", $P0
    }}
}

regex close_script_tag { 
    '</script' <ws_char>*: '>'
    {{  $S0 = "script"
        $P0 = get_global "tag_type"
        $S1 = $P0
        if $S0 != $S1 goto fail
        .return(1)
    fail:
    }} <.fail>
}

token quoted_lang_name { '"php"' | '\'php\'' }

token CODE_START_ECHO_TAG {     
    '<?=' 
    {{ $P0 = new 'String'
       $P0 = "short"
        set_global "tag_type", $P0
    }}
}

token open_short_tag { 
    '<?' 'php'?  
    {{ $P0 = new 'String'
       $P0 = "short"
        set_global "tag_type", $P0
    }}
}

token close_short_tag { 
    '?>' \n?  
    {{  $S0 = "short"
        $P0 = get_global "tag_type"
        $S1 = $P0
        if $S0 != $S1 goto fail
        .return(1)
    fail:
    }} <.fail>
}

# block and statements
rule block {
    '{' <statement>* '}'
    {*}
}

rule statement {
      <namespace_statement>   {*}  #= namespace_statement
    | <echo_statement>        {*}  #= echo_statement
    | <expression_statement>  {*}  #= expression_statement
    | <if_statement>          {*}  #= if_statement
    | <while_statement>       {*}  #= while_statement
    | <for_statement>         {*}  #= for_statement
    | <inline_sea_short_tag>  {*}  #= inline_sea_short_tag
    | <inline_sea_script_tag> {*}  #= inline_sea_script_tag
    | <var_assign>            {*}  #= var_assign
    | <function_definition>   {*}  #= function_definition
    | <class_definition>      {*}  #= class_definition
}

rule statement_delimiter {
      ';'
    | <before '?'>
    | $
}

rule namespace_statement {
    'namespace' <NAMESPACE_NAME> ';'
    {*}
}

token echo_statement {
    'echo' <.ws_char> <arguments> <ws> <.statement_delimiter>
    {*}
}

rule expression_statement {
    <expression> <.statement_delimiter>
    {*}
}

rule arguments {
    [ <expression> [',' <expression>]* ]?
    {*}
}

rule if_statement {
    'if' '(' <expression> ')' <block> <else_clause>?
    {*}
}

rule else_clause {
    'else' <block>
    {*}
}

rule elsif_clause {
    'elsif' '(' <expression> ')' <block>
    {*}
}

rule while_statement {
    'while' '(' <expression> ')' <block>
    {*}
}

rule for_statement {
    'for' '(' <var_assign> <expression> ';' <expression> ')' <block>
    {*}
}

token inline_sea_short_tag {
    <.close_short_tag>
        <SEA_empty_allowed>
    <.open_short_tag>
    {*}
}

token inline_sea_script_tag {
    <.close_script_tag>
        <SEA_empty_allowed>
    <.open_script_tag>
    {*}
}

regex SEA_empty_allowed {
    <-[<]>*? <before '<'>
}

rule var_assign {
    <var> '=' <expression> <.statement_delimiter>
    {*}
}


# identifiers
#
token CLASS_NAME               { <ident> }

token CONSTANT_NAME            { <ident> }

token CLASS_CONSTANT_ACCESSOR  { '::' }

token STATIC_METHOD_ACCESSOR   { '::' }

token FUNCTION_NAME            { <ident> }

token INTERFACE_NAME           { <ident> }

token MEMBER_NAME              { <ident> }

token METHOD_NAME              { <ident> }

# namespace support

token NAMESPACE_SEPARATOR { '\\' }

token NAMESPACE_NAME { <ident>? [ <.NAMESPACE_SEPARATOR> <ident> ]* }

token VAR_NAME {
    '$' <ident>
    {*}
}

# terms
rule method_call {
    <var> '->' <METHOD_NAME> '(' <arguments> ')'
    {*}
}

rule function_call {
    <FUNCTION_NAME> '(' <arguments> ')'
    {*}
}

rule constructor_call {
    'new' <CLASS_NAME>
    {*}
}

token TRUE {
    'TRUE'
    {*}
}

token FALSE {
    'FALSE'
    {*}
}

token NULL {
    'NULL'
    {*}
}

token NUMBER {
    ( \d+ )? '.' \d+
    {*}
}

token INTEGER {
    \d+
    {*}
}

token quote {
    [ <.before '"' > <quote_expression: :qq>
    | <.before \'  > <quote_expression: :q>
    ]
    {*}
}

token constant {
    <CONSTANT_NAME>
    {*}
}

token class_constant {
    <.CLASS_NAME> <.CLASS_CONSTANT_ACCESSOR> <.CONSTANT_NAME>
    {*}
}

rule this {
    '$this'
    {*}
}

rule member {
    <this> '->' <MEMBER_NAME>
    {*}
}

rule array_elem {
    <VAR_NAME> '[' <expression> ']'
    {*}
}

token var {
      <this>        {*}   #= this
    | <array_elem>  {*}   #= array_elem
    | <VAR_NAME>    {*}   #= VAR_NAME
}

rule literal {
      <TRUE>    {*}    #= TRUE
    | <FALSE>   {*}    #= FALSE
    | <NULL>    {*}    #= NULL
    | <NUMBER>  {*}    #= NUMBER
    | <INTEGER> {*}    #= INTEGER
    | <quote>   {*}    #= quote
}

rule term {
      <method_call>            {*}   #= method_call
    | <function_call>          {*}   #= function_call
    | <constructor_call>       {*}   #= constructor_call
    | '(' <expression> {*} ')'       #= expression
    | <literal>                {*}   #= literal
    | <class_constant>         {*}   #= class_constant
    | <constant>               {*}   #= constant
    | <member>                 {*}   #= member
    | <var>                    {*}   #= var
}


# declarations
rule function_definition {
    'function' <FUNCTION_NAME> <.ENTER_FUNCTION_DEF> <param_list> <block> <.EXIT_FUNCTION_DEF>
    {*}
}

# special subrule for marking variable scope
token ENTER_FUNCTION_DEF {
    {*}
}

# ditto
token EXIT_FUNCTION_DEF {
    {*}
}

rule param_list {
    '(' [ <VAR_NAME> [',' <VAR_NAME>]* ]? ')'
    {*}
}

# OO

rule interface_definition {
    'interface' <INTERFACE_NAME> [ 'implements' <INTERFACE_NAME> ]? '{'
        <method_declaration>*
    '}'
    {*}
}

rule method_declaration {
    'function' <METHOD_NAME> <param_list> ';'
    {*}
}

rule class_definition {
    'class' <CLASS_NAME> [ 'implements' <INTERFACE_NAME> ]? '{'
        <class_constant_definition>*
        <class_member_definition>*
        <class_method_definition>*
    '}'
    {*}
}

rule class_constant_definition {
    'const' <CONSTANT_NAME> '=' <literal> <.statement_delimiter>
    {*}
}

rule class_member_definition {
    'public' <VAR_NAME> '=' <literal> <.statement_delimiter>
}

rule class_method_definition {
    'function' <METHOD_NAME> <param_list> <block>
    {*}
}



token curly_interpolation {
    '{' <var> '}'
    {*}
}


# operator precedence table
rule expression is optable                                    { ... }

proto postfix:'++' is precedence('1')                         { ... }
proto postfix:'--' is equiv(postfix:<++>)                     { ... }
proto prefix:'++'  is equiv(postfix:<++>)                     { ... }
proto prefix:'--'  is equiv(postfix:<++>)                     { ... }

proto infix:'|'    is looser('postfix:++')                    { ... }
proto infix:'&'    is equiv('infix:|')                        { ... }
proto infix:'^'    is equiv('infix:|')                        { ... }

proto infix:'<'    is tighter('infix:|')                      { ... }
proto infix:'<='   is equiv('infix:<')                        { ... }
proto infix:'>'    is equiv('infix:<')                        { ... }
proto infix:'>='   is equiv('infix:<')                        { ... }
proto infix:'=='   is equiv('infix:<')                        { ... }
proto infix:'!='   is equiv('infix:<')                        { ... }

proto infix:'+'    is tighter('infix:<')                      { ... }
proto infix:'-'    is equiv('infix:+')                        { ... }
proto infix:'.'    is equiv('infix:+')    is pirop('concat')  { ... }

proto infix:'*'    is tighter('infix:+')                      { ... }
proto infix:'%'    is equiv('infix:*')                        { ... }
proto infix:'/'    is equiv('infix:*')                        { ... }

proto prefix:'-'   is tighter('infix:*')                      { ... }
proto prefix:'+'   is equiv('prefix:-')                       { ... }
proto prefix:'!'   is equiv('prefix:-')                       { ... }

proto term:''      is tighter('prefix:-') is parsed(&term)    { ... }
