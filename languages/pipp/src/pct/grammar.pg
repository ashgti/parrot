# Copyright (C) 2006-2008, The Perl Foundation.
# $Id$

# PHP grammar for Pipp PCT

grammar Pipp::Grammar is PCT::Grammar;

# the starting rule
token TOP                   { ^ <sea_or_code>+                                       {*} }

# whitespace and comments
token ws                    { [ \h
                              | \v
                              | <singlelinecomment>
                              | <multilinecomment>
                              ]*
                            }
token singlelinecomment     { '#'  \N*
                            | '//' \N*
                            }
token multilinecomment      { '/*' .*? '*/' }

# embedding code into a sea of HTML
token sea_or_code           { <code_tp1> {*}               #= code_tp1
                            | <code_tp2> {*}               #= code_tp2
                            | <SEA> {*}                    #= SEA
                            }
regex SEA                   { '<'? .+? ( <before '<'> | $ )                          {*} } 
rule  code_tp1              { <.CODE_START_TP1> <statement>* <.CODE_END_TP1>?        {*} }
rule  code_tp2              { <.CODE_START_TP2> <statement>* <.CODE_END_TP2>?        {*} }
token CODE_START_TP1        { '<?php'                                                    }
token CODE_START_TP2        { '<script language="php">'                                  }
token CODE_END_TP1          { '?>' \n?                                                   }
token CODE_END_TP2          { '</script>' \n?                                            }

# block and statements
rule  block                 { '{' <statement>* '}'                                   {*} }
rule  statement             { <echo_statement> {*}         #= echo_statement
                            | <expression_statement> {*}   #= expression_statement
                            | <if_statement> {*}           #= if_statement
                            | <inline_sea_tp1> {*}         #= inline_sea_tp1
                            | <inline_sea_tp2> {*}         #= inline_sea_tp2
                            | <var_assign> {*}             #= var_assign
                            | <function_definition> {*}    #= function_definition
                            | <class_definition> {*}       #= class_definition
                            }
rule  statement_delimiter   { ';'
                            | <before '?'>
                            | $
                            }
rule  echo_statement        { 'echo' <arguments> <.statement_delimiter>              {*} }
rule  expression_statement  { <expression> <.statement_delimiter>                    {*} }
rule  arguments             { [ <expression> [',' <expression>]* ]?                  {*} }
rule  if_statement          { 'if' '(' <expression> ')' <block> <else_clause>?       {*} }
rule  else_clause           { 'else' <block>                                         {*} }
token inline_sea_tp1        { <.CODE_END_TP1> <SEA_empty_allowed> <.CODE_START_TP1>  {*} }
token inline_sea_tp2        { <.CODE_END_TP2> <SEA_empty_allowed> <.CODE_START_TP2>  {*} }
regex SEA_empty_allowed     { <-[<]>*? <before '<'>                                      }
rule  var_assign            { <var>        '=' <expression> <.statement_delimiter>   {*} }

# identifiers
token FUNCTION_NAME         { <ident>                                                    }
token METHOD_NAME           { <ident>                                                    }
token CONSTANT_NAME         { <ident>                                                    }
token CLASS_NAME            { <ident> [ '::' <ident> ]*                                  }
token VAR_NAME              {  '$' <ident>                                           {*} }

# terms
rule  method_call           { <var> '->' <METHOD_NAME> '(' <arguments> ')'           {*} }
rule  function_call         { <FUNCTION_NAME> '(' <arguments> ')'                    {*} }
rule  constructor_call      { 'new' <CLASS_NAME>                                     {*} }
token TRUE                  { 'TRUE'                                                 {*} }
token FALSE                 { 'FALSE'                                                {*} }
token NULL                  { 'NULL'                                                 {*} }
token NUMBER                { ( \d+ )? '.' \d+                                       {*} }
token INTEGER               { \d+                                                    {*} }
token quote                 { [ <.before '"' > <quote_expression: :qq>
                              | <.before \'  > <quote_expression: :q>
                              ]
                                                                                     {*}
                            }
rule  constant              { <CONSTANT_NAME>                                        {*} }
rule  this                  { '$this'                                                {*} } 
rule  array_elem            { <VAR_NAME> '[' <expression> ']'                        {*} }
token var                   { <this> {*}                   #= this
                            | <array_elem> {*}             #= array_elem
                            | <VAR_NAME> {*}               #= VAR_NAME
                            }
rule  literal               { <TRUE> {*}                   #= TRUE
                            | <FALSE> {*}                  #= FALSE
                            | <NULL> {*}                   #= NULL
                            | <NUMBER> {*}                 #= NUMBER
                            | <INTEGER> {*}                #= INTEGER
                            | <quote> {*}                  #= quote
                            }
rule  term                  { <method_call> {*}            #= method_call
                            | <function_call> {*}          #= function_call
                            | <constructor_call> {*}       #= constructor_call
                            | '(' <expression> {*} ')'     #= expression
                            | <literal> {*}                #= literal
                            | <constant> {*}               #= constant
                            | <var> {*}                    #= var
                            }

# declarations
rule  function_definition   { 'function' <FUNCTION_NAME> <param_list> <block>        {*} }
rule  method_definition     { 'function' <METHOD_NAME> <param_list> <block>          {*} }
rule  param_list            { '(' [ <VAR_NAME> [',' <VAR_NAME>]* ]? ')'              {*} }
rule  member_definition     { 'public' <var> '=' <literal> <.statement_delimiter>    {*} }
rule  class_definition      { 'class' <CLASS_NAME>
                              '{'
                                   <member_definition>*
                                   <method_definition>*
                              '}'
                                                                                     {*} }

token curly_interpolation   { '{' <var> '}'                                          {*} }

# operator precedence table
rule  expression  is optable                                                       { ... }

proto 'infix:|'   is precedence('1')                                               { ... }
proto 'infix:&'   is equiv('infix:|')                                              { ... }
proto 'infix:^'   is equiv('infix:|')                                              { ... }

proto 'infix:<'   is tighter('infix:|')                                            { ... }
proto 'infix:<='  is equiv('infix:<')                                              { ... }
proto 'infix:>'   is equiv('infix:<')                                              { ... }
proto 'infix:>='  is equiv('infix:<')                                              { ... }
proto 'infix:=='  is equiv('infix:<')                                              { ... }
proto 'infix:!='  is equiv('infix:<')                                              { ... }

proto 'infix:+'   is tighter('infix:<')  is pirop('n_add')                         { ... }
proto 'infix:-'   is equiv('infix:+')    is pirop('n_sub')                         { ... }
proto 'infix:.'   is equiv('infix:+')    is pirop('n_concat')                      { ... }

proto 'infix:*'   is tighter('infix:+')  is pirop('n_mul')                         { ... }
proto 'infix:%'   is equiv('infix:*')    is pirop('n_mod')                         { ... }
proto 'infix:/'   is equiv('infix:*')    is pirop('n_div')                         { ... }

proto 'prefix:-'  is tighter('infix:*')  is pirop('n_neg')                         { ... }
proto 'prefix:+'  is equiv('prefix:-')                                             { ... }

proto 'term:'     is tighter('prefix:-') is parsed(&term)                          { ... }
