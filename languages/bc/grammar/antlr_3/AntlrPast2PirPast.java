// $ANTLR 3.0b3 grammar/antlr_3/antlr_past2pir_past.g 2006-08-14 11:59:18

import org.antlr.runtime.*;
import org.antlr.runtime.tree.*;import java.util.Stack;
import java.util.List;
import java.util.ArrayList;

public class AntlrPast2PirPast extends TreeParser {
    public static final String[] tokenNames = new String[] {
        "<invalid>", "<EOR>", "<DOWN>", "<UP>", "PRINT", "PROGRAM", "SAY", "UNARY_MINUS", "VAR", "Quit", "ASSIGN_OP", "STRING", "LETTER", "PLUS", "MINUS", "MUL_OP", "NUMBER", "INTEGER", "INCR_DECR", "ML_COMMENT", "WS", "NEWLINE", "';'", "'('", "')'"
    };
    public static final int INCR_DECR=18;
    public static final int MINUS=14;
    public static final int LETTER=12;
    public static final int WS=20;
    public static final int NUMBER=16;
    public static final int STRING=11;
    public static final int MUL_OP=15;
    public static final int Quit=9;
    public static final int PROGRAM=5;
    public static final int NEWLINE=21;
    public static final int VAR=8;
    public static final int ASSIGN_OP=10;
    public static final int INTEGER=17;
    public static final int SAY=6;
    public static final int PRINT=4;
    public static final int UNARY_MINUS=7;
    public static final int EOF=-1;
    public static final int ML_COMMENT=19;
    public static final int PLUS=13;

        public AntlrPast2PirPast(TreeNodeStream input) {
            super(input);
        }
        

    public String[] getTokenNames() { return tokenNames; }
    public String getGrammarFileName() { return "grammar/antlr_3/antlr_past2pir_past.g"; }


      // used for generating unique register names
      public static int reg_num = 100;



    // $ANTLR start gen_pir_past
    // grammar/antlr_3/antlr_past2pir_past.g:21:1: gen_pir_past : ^( PROGRAM ( expression["stmts"] )+ ) ;
    public void gen_pir_past() throws RecognitionException {   
        try {
            // grammar/antlr_3/antlr_past2pir_past.g:22:5: ( ^( PROGRAM ( expression[\"stmts\"] )+ ) )
            // grammar/antlr_3/antlr_past2pir_past.g:22:5: ^( PROGRAM ( expression[\"stmts\"] )+ )
            {

                  System.out.println( 
                      "#!/usr/bin/env parrot                                             \n"
                    + "                                                                  \n"
                    + "# Do not edit this file.                                          \n"
                    + "# This file has been generated by Bc.java.                        \n"
                    + "                                                                  \n"
                    + "# entering 'gen_pir_past'                                         \n"
                    + ".sub bc :main                                                     \n"
                    + "  load_bytecode 'languages/punie/lib/ASTGrammar.pir'              \n"
                    + "  load_bytecode 'languages/punie/lib/PunieOpLookup.pir'           \n"              
                    + "  load_bytecode 'TGE.pbc'                                         \n"
                    + "  load_bytecode 'PAST.pbc'                                        \n"
                    + "  load_bytecode 'languages/punie/lib/POST.pir'                    \n"
                    + "  load_bytecode 'languages/punie/lib/OSTGrammar.pir'              \n"
                    + "                                                                  \n"
                    + "  # initialize the 26 up named vars                               \n"
                    + "  .sym pmc stmts                                                  \n"
                    + "  stmts = new 'PAST::Stmts'                                       \n"
                    + "  _init_named_var( stmts, 'a' )                                   \n"
                    + "  _init_named_var( stmts, 'b' )                                   \n"
                    + "  _init_named_var( stmts, 'c' )                                   \n"
                    + "  _init_named_var( stmts, 'd' )                                   \n"
                    + "  _init_named_var( stmts, 'e' )                                   \n"
                    + "  _init_named_var( stmts, 'f' )                                   \n"
                    + "  _init_named_var( stmts, 'g' )                                   \n"
                    + "  _init_named_var( stmts, 'h' )                                   \n"
                    + "  _init_named_var( stmts, 'i' )                                   \n"
                    + "  _init_named_var( stmts, 'j' )                                   \n"
                    + "  _init_named_var( stmts, 'k' )                                   \n"
                    + "  _init_named_var( stmts, 'l' )                                   \n"
                    + "  _init_named_var( stmts, 'm' )                                   \n"
                    + "  _init_named_var( stmts, 'n' )                                   \n"
                    + "  _init_named_var( stmts, 'o' )                                   \n"
                    + "  _init_named_var( stmts, 'p' )                                   \n"
                    + "  _init_named_var( stmts, 'q' )                                   \n"
                    + "  _init_named_var( stmts, 'r' )                                   \n"
                    + "  _init_named_var( stmts, 's' )                                   \n"
                    + "  _init_named_var( stmts, 't' )                                   \n"
                    + "  _init_named_var( stmts, 'u' )                                   \n"
                    + "  _init_named_var( stmts, 'v' )                                   \n"
                    + "  _init_named_var( stmts, 'w' )                                   \n"
                    + "  _init_named_var( stmts, 'x' )                                   \n"
                    + "  _init_named_var( stmts, 'y' )                                   \n"
                    + "  _init_named_var( stmts, 'z' )                                   \n"
                    + "                                                                  \n"
                    + "  .sym pmc reg_expression_stmt                                    \n"
                    + "  .sym pmc reg_expression_topexp                                  \n"
                    + "  .sym pmc reg_print_op                                           \n"
                    + "  .sym pmc reg_expression_exp                                     \n"
                    + "  .sym pmc reg_expression_stmt                                    \n"
                    + "  .sym pmc reg_expression_newline                                 \n"
                    + "                                                                  \n"
                    + "  .sym pmc reg_temp                                               \n"
                    + "                                                                  \n"
                    + "  .sym pmc reg_assign_lhs                                         \n"
                    + "                                                                  \n"
                    + "  .sym pmc reg_unary_val                                          \n"
                    + "  .sym pmc reg_unary_op                                           \n"
                    + "                                                                  \n"
                    + "  .sym pmc reg_adding_expression_op                               \n"
                  );
                
            match(input,PROGRAM,FOLLOW_PROGRAM_in_gen_pir_past65); 

            match(input, Token.DOWN, null); 
            // grammar/antlr_3/antlr_past2pir_past.g:85:15: ( expression[\"stmts\"] )+
            int cnt1=0;
            loop1:
            do {
                int alt1=2;
                int LA1_0 = input.LA(1);
                if ( (LA1_0==PRINT||LA1_0==SAY||LA1_0==ASSIGN_OP) ) {
                    alt1=1;
                }


                switch (alt1) {
            	case 1 :
            	    // grammar/antlr_3/antlr_past2pir_past.g:85:15: expression[\"stmts\"]
            	    {
            	    pushFollow(FOLLOW_expression_in_gen_pir_past67);
            	    expression("stmts");
            	    _fsp--;


            	    }
            	    break;

            	default :
            	    if ( cnt1 >= 1 ) break loop1;
                        EarlyExitException eee =
                            new EarlyExitException(1, input);
                        throw eee;
                }
                cnt1++;
            } while (true);


            match(input, Token.UP, null); 

                  System.out.print( 
                      "                                                                  \n"
                    + "  # say 'AST tree dump:'                                          \n"
                    + "  # stmts.dump()                                                  \n"
                    + "                                                                  \n"
                    + "  # Compile the abstract syntax tree                              \n"
                    + "  # down to an opcode syntax tree                                 \n"
                    + "  .sym string ost_tg_src                                          \n"
                    + "  .sym pmc tge_compiler                                           \n"
                    + "  .sym pmc ost_grammar, ost_builder, ost                          \n"
                    + "  tge_compiler = new 'TGE::Compiler'                              \n"
                    + "  ost_tg_src = _slurp_file('languages/punie/lib/OSTGrammar.tg')   \n"
                    + "  ost_grammar = tge_compiler.'compile'(ost_tg_src)                \n"
                    + "  ost_builder = ost_grammar.apply(stmts)                          \n"
                    + "  ost = ost_builder.get('result')                                 \n"
                    + "  unless ost goto ERR_NO_OST                                      \n"
                    + "                                                                  \n"
                    + "  # Compile the OST down to PIR                                   \n"
                    + "  .sym string pir_tg_src                                          \n"
                    + "  .sym pmc pir_grammar, pir_builder, pir                          \n"
                    + "  pir_tg_src = _slurp_file('languages/punie/lib/PIRGrammar.tg')   \n"
                    + "  pir_grammar = tge_compiler.'compile'(pir_tg_src)                \n"
                    + "  pir_builder = pir_grammar.apply(ost)                            \n"
                    + "  pir = pir_builder.get('result')                                 \n"
                    + "  unless pir goto ERR_NO_PIR                                      \n"
                    + "                                                                  \n"
                    + "  # execute                                                       \n"
                    + "  .sym pmc pir_compiler, pir_compiled                             \n"
                    + "  pir_compiler = compreg 'PIR'                                    \n"
                    + "  pir_compiled = pir_compiler( pir )                              \n"
                    + "  pir_compiled()                                                  \n"
                    + "  say ''                                                          \n"
                    + "  goto CLEANUP                                                    \n"
                    + "                                                                  \n"
                    + "  ERR_NO_OST:                                                     \n"
                    + "    say 'Unable to construct OST.'                                \n"
                    + "    goto CLEANUP                                                  \n"
                    + "                                                                  \n"
                    + "  ERR_NO_PIR:                                                     \n"
                    + "    say 'Unable to construct PIR.'                                \n"
                    + "    goto CLEANUP                                                  \n"
                    + "                                                                  \n"
                    + "  CLEANUP:                                                        \n"
                    + ".end                                                              \n"
                    + "                                                                  \n"
                    + ".sub _slurp_file                                                  \n"
                    + "  .param string filename                                          \n"
                    + "                                                                  \n"
                    + "  .sym pmc filehandle                                             \n"
                    + "  .sym string content                                             \n"
                    + "  filehandle = open filename, '<'                                 \n"
                    + "  unless filehandle goto ERR_NO_FILE                              \n"
                    + "  content = read filehandle, 65535                                \n"
                    + "  close filehandle                                                \n"
                    + "                                                                  \n"
                    + "  .return ( content )                                             \n"
                    + "                                                                  \n"
                    + "  ERR_NO_FILE:                                                    \n"
                    + "    print 'Unable to open file: '                                 \n"
                    + "    say filename                                                  \n"
                    + "    end                                                           \n"
                    + "                                                                  \n"
                    + ".end                                                              \n"
                    + "                                                                  \n"
                    + ".sub _init_named_var                                              \n"
                    + "  .param pmc mother_node                                          \n"
                    + "  .param string var_name                                          \n"
                    + "                                                                  \n"
                    + "    .sym pmc past_exp                                             \n"
                    + "    past_exp = new 'PAST::Exp'                                    \n"
                    + "      .sym pmc past_op                                            \n"
                    + "      past_op = new 'PAST::Op'                                    \n"
                    + "      past_op.'op'( 'infix:=' )                                   \n"
                    + "        .sym pmc past_var                                         \n"
                    + "        past_var = new 'PAST::Var'                                \n"
                    + "        past_var.'varname'( var_name )                            \n"
                    + "        past_var.'vartype'( 'scalar' )                            \n"
                    + "        past_var.'scope'( 'global' )                              \n"
                    + "      past_op.'add_child'( past_var )                             \n"
                    + "        .sym pmc past_val                                         \n"
                    + "        past_val = new 'PAST::Val'                                \n"
                    + "        past_val.'value'( 0 )                                     \n"
                    + "        past_val.'valtype'( 'int' )                               \n"
                    + "      past_op.'add_child'( past_val )                             \n"
                    + "    past_exp.'add_child'( past_op )                               \n"
                    + "  mother_node.'add_child'( past_exp )                             \n"
                    + ".end                                                              \n"
                    + "                                                                  \n"
                    + "# leaving 'gen_pir_past'                                          \n"
                  );
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end gen_pir_past


    // $ANTLR start expression
    // grammar/antlr_3/antlr_past2pir_past.g:180:1: expression[String reg_mother] : ( ^( SAY ( adding["reg_expression_exp"] | ^( UNARY_MINUS adding["reg_expression_exp"] ) ) ) | ( ^( PRINT string[ mother_for_string ] ) | ^( ASSIGN_OP assign[ mother_for_string ] ) ) );
    public void expression(String reg_mother) throws RecognitionException {   
        try {
            // grammar/antlr_3/antlr_past2pir_past.g:181:5: ( ^( SAY ( adding[\"reg_expression_exp\"] | ^( UNARY_MINUS adding[\"reg_expression_exp\"] ) ) ) | ( ^( PRINT string[ mother_for_string ] ) | ^( ASSIGN_OP assign[ mother_for_string ] ) ) )
            int alt4=2;
            int LA4_0 = input.LA(1);
            if ( (LA4_0==SAY) ) {
                alt4=1;
            }
            else if ( (LA4_0==PRINT||LA4_0==ASSIGN_OP) ) {
                alt4=2;
            }
            else {
                NoViableAltException nvae =
                    new NoViableAltException("180:1: expression[String reg_mother] : ( ^( SAY ( adding[\"reg_expression_exp\"] | ^( UNARY_MINUS adding[\"reg_expression_exp\"] ) ) ) | ( ^( PRINT string[ mother_for_string ] ) | ^( ASSIGN_OP assign[ mother_for_string ] ) ) );", 4, 0, input);

                throw nvae;
            }
            switch (alt4) {
                case 1 :
                    // grammar/antlr_3/antlr_past2pir_past.g:181:5: ^( SAY ( adding[\"reg_expression_exp\"] | ^( UNARY_MINUS adding[\"reg_expression_exp\"] ) ) )
                    {

                          System.out.print( 
                              "                                                                  \n"
                            + "  # entering 'expression'                                         \n"
                            + "    reg_expression_stmt = new 'PAST::Stmt'                        \n"
                            + "      reg_expression_topexp = new 'PAST::Exp'                     \n"
                            + "        reg_print_op = new 'PAST::Op'                             \n"
                            + "        reg_print_op.'op'( 'print' )                              \n"
                            + "          reg_expression_exp = new 'PAST::Exp'                    \n"
                          );
                        
                    match(input,SAY,FOLLOW_SAY_in_expression99); 

                    match(input, Token.DOWN, null); 
                    // grammar/antlr_3/antlr_past2pir_past.g:192:12: ( adding[\"reg_expression_exp\"] | ^( UNARY_MINUS adding[\"reg_expression_exp\"] ) )
                    int alt2=2;
                    int LA2_0 = input.LA(1);
                    if ( (LA2_0==VAR||(LA2_0>=PLUS && LA2_0<=NUMBER)) ) {
                        alt2=1;
                    }
                    else if ( (LA2_0==UNARY_MINUS) ) {
                        alt2=2;
                    }
                    else {
                        NoViableAltException nvae =
                            new NoViableAltException("192:12: ( adding[\"reg_expression_exp\"] | ^( UNARY_MINUS adding[\"reg_expression_exp\"] ) )", 2, 0, input);

                        throw nvae;
                    }
                    switch (alt2) {
                        case 1 :
                            // grammar/antlr_3/antlr_past2pir_past.g:192:14: adding[\"reg_expression_exp\"]
                            {
                            pushFollow(FOLLOW_adding_in_expression103);
                            adding("reg_expression_exp");
                            _fsp--;

                             
                                           System.out.print( 
                                               "                                                                \n"
                                             + "      reg_print_op.'add_child'( reg_expression_exp )            \n"
                                           );
                                         

                            }
                            break;
                        case 2 :
                            // grammar/antlr_3/antlr_past2pir_past.g:200:14: ^( UNARY_MINUS adding[\"reg_expression_exp\"] )
                            {
                            match(input,UNARY_MINUS,FOLLOW_UNARY_MINUS_in_expression151); 

                            match(input, Token.DOWN, null); 
                            pushFollow(FOLLOW_adding_in_expression153);
                            adding("reg_expression_exp");
                            _fsp--;


                            match(input, Token.UP, null); 
                             
                                           System.out.print( 
                                               "                                                                \n"
                                             + "   # multiply by -1                                             \n"
                                             + "   reg_unary_op = new 'PAST::Op'                                \n"
                                             + "   reg_unary_op.'op'( 'infix:*' )                               \n"
                                             + "     reg_unary_val = new 'PAST::Val'                            \n"
                                             + "     reg_unary_val.value( -1 )                                  \n"
                                             + "     reg_unary_val.valtype( 'num' )                             \n"
                                             + "   reg_unary_op.'add_child'( reg_unary_val )                    \n"
                                             + "   reg_unary_op.'add_child'( reg_expression_exp )               \n"
                                             + "      reg_print_op.'add_child'( reg_unary_op )                  \n"
                                           );
                                         

                            }
                            break;

                    }


                    match(input, Token.UP, null); 

                          System.out.print( 
                              "                                                                  \n"
                            + "      reg_expression_topexp.'add_child'( reg_print_op      )      \n"
                            + "    reg_expression_stmt.'add_child'( reg_expression_topexp )      \n"
                            + "  " + reg_mother + ".'add_child'( reg_expression_stmt ) \n"
                            + "                                                                  \n"
                            + "  # Now print a newline                                           \n"
                            + "    reg_expression_stmt = new 'PAST::Stmt'                        \n"
                            + "      reg_expression_topexp = new 'PAST::Exp'                     \n"
                            + "        reg_print_op = new 'PAST::Op'                        \n"
                            + "          reg_expression_exp = new 'PAST::Exp'                    \n"
                            + "            reg_expression_newline = new 'PAST::Val'              \n"
                            + "            reg_expression_newline.value( '\\n' )                 \n"
                            + "            reg_expression_newline.valtype( 'strqq' )             \n"
                            + "          reg_expression_exp.'add_child'( reg_expression_newline )\n"
                            + "        reg_print_op.'add_child'( reg_expression_exp )       \n"
                            + "        reg_print_op.'op'( 'print' )                         \n"
                            + "      reg_expression_topexp.'add_child'( reg_print_op )      \n"
                            + "    reg_expression_stmt.'add_child'( reg_expression_topexp )      \n"
                            + "  " + reg_mother + ".'add_child'( reg_expression_stmt )\n"
                            + "  # leaving 'expression'                                          \n"
                          );
                        

                    }
                    break;
                case 2 :
                    // grammar/antlr_3/antlr_past2pir_past.g:242:5: ( ^( PRINT string[ mother_for_string ] ) | ^( ASSIGN_OP assign[ mother_for_string ] ) )
                    {

                          String mother_for_string = reg_mother;
                        
                    // grammar/antlr_3/antlr_past2pir_past.g:245:5: ( ^( PRINT string[ mother_for_string ] ) | ^( ASSIGN_OP assign[ mother_for_string ] ) )
                    int alt3=2;
                    int LA3_0 = input.LA(1);
                    if ( (LA3_0==PRINT) ) {
                        alt3=1;
                    }
                    else if ( (LA3_0==ASSIGN_OP) ) {
                        alt3=2;
                    }
                    else {
                        NoViableAltException nvae =
                            new NoViableAltException("245:5: ( ^( PRINT string[ mother_for_string ] ) | ^( ASSIGN_OP assign[ mother_for_string ] ) )", 3, 0, input);

                        throw nvae;
                    }
                    switch (alt3) {
                        case 1 :
                            // grammar/antlr_3/antlr_past2pir_past.g:246:7: ^( PRINT string[ mother_for_string ] )
                            {
                            match(input,PRINT,FOLLOW_PRINT_in_expression224); 

                            match(input, Token.DOWN, null); 
                            pushFollow(FOLLOW_string_in_expression226);
                            string( mother_for_string );
                            _fsp--;


                            match(input, Token.UP, null); 

                            }
                            break;
                        case 2 :
                            // grammar/antlr_3/antlr_past2pir_past.g:248:7: ^( ASSIGN_OP assign[ mother_for_string ] )
                            {
                            match(input,ASSIGN_OP,FOLLOW_ASSIGN_OP_in_expression247); 

                            match(input, Token.DOWN, null); 
                            pushFollow(FOLLOW_assign_in_expression249);
                            assign( mother_for_string );
                            _fsp--;


                            match(input, Token.UP, null); 

                            }
                            break;

                    }


                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end expression


    // $ANTLR start string
    // grammar/antlr_3/antlr_past2pir_past.g:252:1: string[ String reg_mother ] : STRING ;
    public void string(String reg_mother) throws RecognitionException {   
        CommonTree STRING1=null;

        try {
            // grammar/antlr_3/antlr_past2pir_past.g:253:5: ( STRING )
            // grammar/antlr_3/antlr_past2pir_past.g:253:5: STRING
            {
            STRING1=(CommonTree)input.LT(1);
            match(input,STRING,FOLLOW_STRING_in_string273); 

                  // TODO: strip String
                  System.out.print(     
                      "                                                                \n"
                    + "# entering 'string'                                             \n"
                    + "    reg_expression_stmt = new 'PAST::Stmt'                      \n"
                    + "      reg_expression_topexp = new 'PAST::Exp'                   \n"
                    + "        reg_print_op = new 'PAST::Op'                      \n"
                    + "        reg_print_op.'op'( 'print' )                       \n"
                    + "          reg_expression_exp = new 'PAST::Exp'                  \n"
                    + "            reg_temp = new 'PAST::Val'                          \n"
                    + "            reg_temp.value( " + STRING1.getText() + " )              \n"
                    + "            reg_temp.valtype( 'strqq' )                         \n"
                    + "          reg_expression_exp.'add_child'( reg_temp )            \n"
                    + "          null reg_temp                                         \n"
                    + "        reg_print_op.'add_child'( reg_expression_exp )     \n"
                    + "      reg_expression_topexp.'add_child'( reg_print_op )         \n"
                    + "    reg_expression_stmt.'add_child'( reg_expression_topexp )    \n"
                    + "  " + reg_mother + ".'add_child'( reg_expression_stmt ) \n"
                    + "# leaving 'string'                                              \n"
                  );
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end string


    // $ANTLR start assign
    // grammar/antlr_3/antlr_past2pir_past.g:278:1: assign[ String reg_mother ] : ^( VAR LETTER ) adding["reg_assign_lhs"] ;
    public void assign(String reg_mother) throws RecognitionException {   
        CommonTree LETTER2=null;

        try {
            // grammar/antlr_3/antlr_past2pir_past.g:279:5: ( ^( VAR LETTER ) adding[\"reg_assign_lhs\"] )
            // grammar/antlr_3/antlr_past2pir_past.g:279:5: ^( VAR LETTER ) adding[\"reg_assign_lhs\"]
            {

                  System.out.print( 
                      "                                                                  \n"
                    + "  # entering 'assign'                                             \n"
                    + "    reg_assign_lhs = new 'PAST::Exp'                              \n"
                  );
                
            match(input,VAR,FOLLOW_VAR_in_assign301); 

            match(input, Token.DOWN, null); 
            LETTER2=(CommonTree)input.LT(1);
            match(input,LETTER,FOLLOW_LETTER_in_assign303); 

            match(input, Token.UP, null); 
            pushFollow(FOLLOW_adding_in_assign306);
            adding("reg_assign_lhs");
            _fsp--;


                  // TODO: strip String
                  System.out.print(     
                      "                                                                  \n"
                    + "    # entering 'ASSIGN_OP ^(VAR LETTER) adding'        \n"
                    + "      .sym pmc past_op                                            \n"
                    + "      past_op = new 'PAST::Op'                                    \n"
                    + "      past_op.'op'( 'infix:=' )                                   \n"
                    + "        .sym pmc past_var                                         \n"
                    + "        past_var = new 'PAST::Var'                                \n"
                    + "        past_var.'varname'( '" + LETTER2.getText() + "' )              \n"
                    + "        past_var.'vartype'( 'scalar' )                            \n"
                    + "        past_var.'scope'( 'global' )                              \n"
                    + "      past_op.'add_child'( past_var )                             \n"
                    + "      past_op.'add_child'( reg_assign_lhs )                       \n"
                    + "    " + reg_mother + ".'add_child'( past_op )             \n"
                    + "    # leaving  'ASSIGN_OP named_expression NUMBER'                \n"
                  );
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end assign


    // $ANTLR start integer
    // grammar/antlr_3/antlr_past2pir_past.g:309:1: integer[ String reg_mother ] : NUMBER ;
    public void integer(String reg_mother) throws RecognitionException {   
        CommonTree NUMBER3=null;

        try {
            // grammar/antlr_3/antlr_past2pir_past.g:310:5: ( NUMBER )
            // grammar/antlr_3/antlr_past2pir_past.g:310:5: NUMBER
            {
            NUMBER3=(CommonTree)input.LT(1);
            match(input,NUMBER,FOLLOW_NUMBER_in_integer328); 

                  System.out.print(     
                      "                                                                \n"
                    + "# entering 'integer'                                            \n"
                    + "reg_temp = new 'PAST::Val'                                      \n"
                    + "reg_temp.value( " + NUMBER3.getText() + " )                             \n"
                    + "reg_temp.valtype( 'num' )                                       \n"
                    + reg_mother + ".'add_child'( reg_temp )                  \n"
                    + "null reg_temp                                                   \n"
                    + "# leaving 'integer'                                             \n"
                  );
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end integer


    // $ANTLR start adding
    // grammar/antlr_3/antlr_past2pir_past.g:325:1: adding[String reg_mother] : ( integer[ mother_for_int ] | ^(infix= (PLUS|MINUS|MUL_OP) adding[reg] adding[reg] ) | named_expression[ mother_for_int ] ) ;
    public void adding(String reg_mother) throws RecognitionException {   
        CommonTree infix=null;

        try {
            // grammar/antlr_3/antlr_past2pir_past.g:326:5: ( ( integer[ mother_for_int ] | ^(infix= (PLUS|MINUS|MUL_OP) adding[reg] adding[reg] ) | named_expression[ mother_for_int ] ) )
            // grammar/antlr_3/antlr_past2pir_past.g:326:5: ( integer[ mother_for_int ] | ^(infix= (PLUS|MINUS|MUL_OP) adding[reg] adding[reg] ) | named_expression[ mother_for_int ] )
            {

                  System.out.print( 
                      "                                                                  \n"
                    + "  # entering 'adding'                                  \n"
                  );
                  // Why can't I say:   integer[ reg_mother ] ???
                  String mother_for_int = reg_mother;
                
            // grammar/antlr_3/antlr_past2pir_past.g:334:5: ( integer[ mother_for_int ] | ^(infix= (PLUS|MINUS|MUL_OP) adding[reg] adding[reg] ) | named_expression[ mother_for_int ] )
            int alt5=3;
            switch ( input.LA(1) ) {
            case NUMBER:
                alt5=1;
                break;
            case PLUS:
            case MINUS:
            case MUL_OP:
                alt5=2;
                break;
            case VAR:
                alt5=3;
                break;
            default:
                NoViableAltException nvae =
                    new NoViableAltException("334:5: ( integer[ mother_for_int ] | ^(infix= (PLUS|MINUS|MUL_OP) adding[reg] adding[reg] ) | named_expression[ mother_for_int ] )", 5, 0, input);

                throw nvae;
            }

            switch (alt5) {
                case 1 :
                    // grammar/antlr_3/antlr_past2pir_past.g:334:7: integer[ mother_for_int ]
                    {
                    pushFollow(FOLLOW_integer_in_adding356);
                    integer( mother_for_int );
                    _fsp--;


                    }
                    break;
                case 2 :
                    // grammar/antlr_3/antlr_past2pir_past.g:336:7: ^(infix= (PLUS|MINUS|MUL_OP) adding[reg] adding[reg] )
                    {

                            reg_num++;
                            String reg = "reg_" + reg_num;
                            System.out.print( 
                                "                                                                \n"
                              + "    # entering '( PLUS | MINUS | MUL | DIV ) adding adding'       \n"
                              + "      .sym pmc " + reg + "                                      \n"
                              + "      " + reg + " = new 'PAST::Op'                              \n"
                            );
                          
                    infix=(CommonTree)input.LT(1);
                    if ( (input.LA(1)>=PLUS && input.LA(1)<=MUL_OP) ) {
                        input.consume();
                        errorRecovery=false;
                    }
                    else {
                        MismatchedSetException mse =
                            new MismatchedSetException(null,input);
                        recoverFromMismatchedSet(input,mse,FOLLOW_set_in_adding387);    throw mse;
                    }


                    match(input, Token.DOWN, null); 
                    pushFollow(FOLLOW_adding_in_adding399);
                    adding(reg);
                    _fsp--;

                    pushFollow(FOLLOW_adding_in_adding402);
                    adding(reg);
                    _fsp--;


                    match(input, Token.UP, null); 

                            System.out.print( 
                                "      " + reg + ".'op'( 'infix:" + infix.getText() + "' )   \n"
                              + "    reg_temp = new 'PAST::Exp'                                  \n"
                              + "    reg_temp.'add_child'( " + reg + " )                         \n"
                              + "      null " + reg + "                                          \n"
                              + "  " + reg_mother + ".'add_child'( reg_temp ) \n"
                              + "    null reg_temp                                               \n"
                              + "    # leaving '( PLUS | MINUS | MUL | DIV ) adding adding'        \n"
                            );
                          

                    }
                    break;
                case 3 :
                    // grammar/antlr_3/antlr_past2pir_past.g:359:7: named_expression[ mother_for_int ]
                    {
                    pushFollow(FOLLOW_named_expression_in_adding429);
                    named_expression( mother_for_int );
                    _fsp--;


                    }
                    break;

            }


                  System.out.print( 
                      "  # leaving 'adding'                                   \n"
                  );
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end adding


    // $ANTLR start named_expression
    // grammar/antlr_3/antlr_past2pir_past.g:368:1: named_expression[String reg_mother] : ^( VAR LETTER ) ;
    public void named_expression(String reg_mother) throws RecognitionException {   
        CommonTree LETTER4=null;

        try {
            // grammar/antlr_3/antlr_past2pir_past.g:369:5: ( ^( VAR LETTER ) )
            // grammar/antlr_3/antlr_past2pir_past.g:369:5: ^( VAR LETTER )
            {

                  System.out.print( 
                      "                                                                  \n"
                    + "  # entering 'named_expression'                                  \n"
                  );
                
            match(input,VAR,FOLLOW_VAR_in_named_expression464); 

            match(input, Token.DOWN, null); 
            LETTER4=(CommonTree)input.LT(1);
            match(input,LETTER,FOLLOW_LETTER_in_named_expression466); 

            match(input, Token.UP, null); 

                  System.out.print( 
                      "                                                                     \n"
                    + " # entering '( VAR LETTER )                                    \n"
                    + "    reg_temp = new 'PAST::Var'                                 \n"
                    + "    reg_temp.'varname'( '" + LETTER4.getText() + "' )               \n"
                    + "    reg_temp.'vartype'( 'scalar' )                             \n"
                    + "    reg_temp.'scope'( 'global' )                               \n"
                    + "  " + reg_mother + ".'add_child'( reg_temp ) \n"
                    + "    null reg_temp                                              \n"
                    + "  # leaving '(VAR LETTER)'                                     \n"
                  );
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end named_expression


 

    public static final BitSet FOLLOW_PROGRAM_in_gen_pir_past65 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_expression_in_gen_pir_past67 = new BitSet(new long[]{0x0000000000000458L});
    public static final BitSet FOLLOW_SAY_in_expression99 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_adding_in_expression103 = new BitSet(new long[]{0x0000000000000008L});
    public static final BitSet FOLLOW_UNARY_MINUS_in_expression151 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_adding_in_expression153 = new BitSet(new long[]{0x0000000000000008L});
    public static final BitSet FOLLOW_PRINT_in_expression224 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_string_in_expression226 = new BitSet(new long[]{0x0000000000000008L});
    public static final BitSet FOLLOW_ASSIGN_OP_in_expression247 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_assign_in_expression249 = new BitSet(new long[]{0x0000000000000008L});
    public static final BitSet FOLLOW_STRING_in_string273 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VAR_in_assign301 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_LETTER_in_assign303 = new BitSet(new long[]{0x0000000000000008L});
    public static final BitSet FOLLOW_adding_in_assign306 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NUMBER_in_integer328 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_integer_in_adding356 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_set_in_adding387 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_adding_in_adding399 = new BitSet(new long[]{0x000000000001E100L});
    public static final BitSet FOLLOW_adding_in_adding402 = new BitSet(new long[]{0x0000000000000008L});
    public static final BitSet FOLLOW_named_expression_in_adding429 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_VAR_in_named_expression464 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_LETTER_in_named_expression466 = new BitSet(new long[]{0x0000000000000008L});

}