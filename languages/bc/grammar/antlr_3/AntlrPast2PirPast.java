// $ANTLR 3.0ea10 grammar/antlr_3/antlr_past2pir_past.g 2006-06-19 22:46:01

import org.antlr.runtime.*;
import org.antlr.runtime.tree.*;import java.util.Stack;
import java.util.List;
import java.util.ArrayList;

public class AntlrPast2PirPast extends TreeParser {
    public static final String[] tokenNames = new String[] {
        "<invalid>", "<EOR>", "<DOWN>", "<UP>", "PROGRAM", "UNARY_MINUS", "INT", "ML_COMMENT", "WS", "'-'", "'quit'"
    };
    public static final int UNARY_MINUS=5;
    public static final int INT=6;
    public static final int EOF=-1;
    public static final int WS=8;
    public static final int ML_COMMENT=7;
    public static final int PROGRAM=4;
        public AntlrPast2PirPast(TreeNodeStream input) {
            super(input);    }
        

    public String[] getTokenNames() { return tokenNames; }
    public String getGrammarFileName() { return "grammar/antlr_3/antlr_past2pir_past.g"; }



    // $ANTLR start gen_pir_past
    // grammar/antlr_3/antlr_past2pir_past.g:14:1: gen_pir_past : ^( PROGRAM ( expr )+ ) ;
    public void gen_pir_past() throws RecognitionException {   
        try {
            // grammar/antlr_3/antlr_past2pir_past.g:16:3: ( ^( PROGRAM ( expr )+ ) )
            // grammar/antlr_3/antlr_past2pir_past.g:16:3: ^( PROGRAM ( expr )+ )
            {

                String pirBefore =
                    "#!/usr/bin/env parrot                                             \n"
                  + "                                                                  \n"
                  + "# Do not edit this file.                                          \n"
                  + "# This file has been generated by Bc.java.                        \n"
                  + "                                                                  \n"
                  + ".sub bc :main                                                     \n"
                  + "  load_bytecode 'languages/punie/lib/ASTGrammar.pir'              \n"
                  + "  load_bytecode 'TGE.pbc'                                         \n"
                  + "  load_bytecode 'PAST.pbc'                                        \n"
                  + "  load_bytecode 'languages/punie/lib/POST.pir'                    \n"
                  + "  load_bytecode 'languages/punie/lib/OSTGrammar.pir'              \n"
                  + "                                                                  \n"
                  + "# entering gen_pir_past                                           \n"
                  + "  .local pmc stmts                                                \n"
                  + "  stmts = new 'PAST::Stmts'                                       \n"
                  + "  stmts.'source'('1')                                             \n"
                  + "  stmts.'pos'(1)                                                  \n"
                  + "                                                                  \n"
                  ;
                System.out.println( pirBefore );    
              
            match(input,PROGRAM,FOLLOW_PROGRAM_in_gen_pir_past52); 

            match(input, Token.DOWN, null); 
            // grammar/antlr_3/antlr_past2pir_past.g:39:13: ( expr )+
            int cnt1=0;
            loop1:
            do {
                int alt1=2;
                int LA1_0 = input.LA(1);
                if ( LA1_0==INT ) {
                    alt1=1;
                }


                switch (alt1) {
            	case 1 :
            	    // grammar/antlr_3/antlr_past2pir_past.g:39:13: expr
            	    {
            	    pushFollow(FOLLOW_expr_in_gen_pir_past54);
            	    expr();
            	    _fsp--;


            	    }
            	    break;

            	default :
            	    if ( cnt1 >= 1 ) break loop1;
                        EarlyExitException eee =
                            new EarlyExitException(1, input);
                        throw eee;
                }
                cnt1++;
            } while (true);


            match(input, Token.UP, null); 

                  String pirAfter = 
                      "                                                                \n"
                    + "  # Compile the abstract syntax tree                            \n"
                    + "  # down to an opcode syntax tree                               \n"
                    + "  .local string ost_tg_source                                   \n"
                    + "  ost_tg_source = _slurp_file('languages/punie/lib/OSTGrammar.tg') \n"
                    + "  .local pmc tge_compiler, ost_grammar                          \n"
                    + "  tge_compiler = new 'TGE::Compiler'                            \n"
                    + "  ost_grammar = tge_compiler.'compile'(ost_tg_source)           \n"
                    + "  .local pmc ost_builder                                        \n"
                    + "  ost_builder = ost_grammar.apply(stmts)                        \n"
                    + "  .local pmc ost                                                \n"
                    + "  ost = ost_builder.get('result')                               \n"
                    + "  $I0 = defined ost                                            \n"
                    + "  unless $I0 goto err_no_ost # if OST fails stop               \n"
                    + "                                                                \n"
                    + "  # Compile the OST down to PIR                                 \n"
                    + "  .local string pir_tg_source                                   \n"
                    + "  pir_tg_source = _slurp_file('languages/punie/lib/PIRGrammar.tg') \n"
                    + "  .local pmc pir_grammar                                        \n"
                    + "  pir_grammar = tge_compiler.'compile'(pir_tg_source)           \n"
                    + "  .local pmc pir_builder                                        \n"
                    + "  pir_builder = pir_grammar.apply(ost)                          \n"
                    + "  .local pmc pir                                                \n"
                    + "  pir = pir_builder.get('result')                               \n"
                    + "  unless pir goto err_no_pir # if PIR not generated, stop       \n"
                    + "                                                                \n"
                    + "  # Execute                                                     \n"
                    + "  .local pmc pir_compiler                                       \n"
                    + "  .local pmc pir_compiled                                       \n"
                    + "  pir_compiler = compreg \"PIR\"                                \n"
                    + "  pir_compiled = pir_compiler( pir )                            \n"
                    + "                                                                \n"
                    + "  pir_compiled()                                                \n"
                    + "                                                                \n"
                    + "  say ''                                                        \n"
                    + "  end                                                           \n"
                    + "                                                                \n"
                    + "  err_match_fail:                                               \n"
                    + "    say 'parse failed'                                          \n"
                    + "    goto cleanup                                                \n"
                    + "                                                                \n"
                    + "  err_no_ast:                                                   \n"
                    + "    say 'Unable to construct AST.'                              \n"
                    + "    goto cleanup                                                \n"
                    + "                                                                \n"
                    + "  err_no_ost:                                                   \n"
                    + "    say 'Unable to construct OST.'                              \n"
                    + "    goto cleanup                                                \n"
                    + "                                                                \n"
                    + "  err_no_pir:                                                   \n"
                    + "    say 'Unable to construct PIR.'                              \n"
                    + "    goto cleanup                                                \n"
                    + "                                                                \n"
                    + "  cleanup:                                                      \n"
                    + ".end                                                            \n"
                    + "                                                                \n"
                    + ".sub _slurp_file                                                \n"
                    + "  .param string filename                                        \n"
                    + "  .local pmc filehandle                                         \n"
                    + "  filehandle = open filename, '<'                               \n"
                    + "  unless filehandle goto err_no_file                            \n"
                    + "  $S1 = read filehandle, 65535                                 \n"
                    + "  close filehandle                                              \n"
                    + "  .return ($S1)                                                \n"
                    + "  err_no_file:                                                  \n"
                    + "    print 'Unable to open file: '                               \n"
                    + "    say filename                                                \n"
                    + "    end                                                         \n"
                    + ".end                                                            \n"
                    + "# leaving gen_pir_past                                          \n"
                    ;
                  System.out.print( pirAfter );    
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end gen_pir_past

    public static class expr_int_1_return extends TreeRuleReturnScope {
    };

    // $ANTLR start expr_int_1
    // grammar/antlr_3/antlr_past2pir_past.g:117:1: expr_int_1 : INT ;
    public expr_int_1_return expr_int_1() throws RecognitionException {   
        expr_int_1_return retval = new expr_int_1_return();
        retval.start = input.LT(1);

        try {
            // grammar/antlr_3/antlr_past2pir_past.g:119:3: ( INT )
            // grammar/antlr_3/antlr_past2pir_past.g:119:3: INT
            {
            match(input,INT,FOLLOW_INT_in_expr_int_178); 

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
            retval.stop = input.LT(-1);

        }
        return retval;
    }
    // $ANTLR end expr_int_1


    // $ANTLR start expr
    // grammar/antlr_3/antlr_past2pir_past.g:123:1: expr returns [String reg] : expr_int_1 ;
    public String expr() throws RecognitionException {   
        String reg;
        expr_int_1_return expr_int_11 = null;



              reg = "reg_expr_1";
            
        try {
            // grammar/antlr_3/antlr_past2pir_past.g:129:3: ( expr_int_1 )
            // grammar/antlr_3/antlr_past2pir_past.g:129:3: expr_int_1
            {
            pushFollow(FOLLOW_expr_int_1_in_expr109);
            expr_int_11=expr_int_1();
            _fsp--;


                  String pir = 
                      "                                                                \n"
                    + "# entering 'expr_int_1'                                         \n"
                    + ".local pmc reg_expr_1, reg_expr_2, reg_expr_3, reg_expr_4       \n"
                    + ".local pmc reg_expr_5, reg_expr_6, reg_expr_7, reg_expr_8       \n"
                    + ".local pmc reg_expr_9, reg_expr_10                              \n"
                    + "                                                                \n"
                    + "reg_expr_1 = new 'PAST::Val'                                    \n"
                    + "reg_expr_1.value( " + input.toString(expr_int_11.start,expr_int_11.stop) + " )                    \n"
                    + "reg_expr_1.'source'('1')                                        \n"
                    + "reg_expr_1.'pos'(0)                                             \n"
                    + "reg_expr_1.valtype( 'num' )                                     \n"
                    + "# leaving expr                                                  \n"
                    + "               reg_expr_2 = new 'PAST::Exp'                     \n"
                    + "               reg_expr_2.'add_child'( reg_expr_1 )             \n"
                    + "               reg_expr_2.'source'('1')                         \n"
                    + "               reg_expr_2.'pos'(1)                              \n"
                    + "       reg_expr_3 = new 'PAST::Op'                              \n"
                    + "       reg_expr_3.'add_child'( reg_expr_2 )                     \n"
                    + "       reg_expr_3.'op'( 'print' )                               \n"
                    + "       reg_expr_3.'source'('1')                                 \n"
                    + "       reg_expr_3.'pos'(1)                                      \n"
                    + "               reg_expr_4 = new 'PAST::Exp'                     \n"
                    + "               reg_expr_4.'add_child'( reg_expr_3 )             \n"
                    + "               reg_expr_4.'source'('1')                         \n"
                    + "               reg_expr_4.'pos'(1)                              \n"
                    + "  reg_expr_5 = new 'PAST::Stmt'                                      \n"
                    + "  reg_expr_5.'add_child'( reg_expr_4 )                               \n"
                    + "  reg_expr_5.'source'('1')                                           \n"
                    + "  reg_expr_5.'pos'(1)                                                \n"
                    + "  stmts.'add_child'( reg_expr_5 )                                    \n"
                    + "               reg_expr_6 = new 'PAST::Val'                          \n"
                    + "               reg_expr_6.value( '\\n' )                             \n"
                    + "               reg_expr_6.'source'('1')                              \n"
                    + "               reg_expr_6.'pos'(0)                                   \n"
                    + "               reg_expr_6.valtype( 'strqq' )                         \n"
                    + "               reg_expr_7 = new 'PAST::Exp'                          \n"
                    + "               reg_expr_7.'add_child'( reg_expr_6 )                       \n"
                    + "               reg_expr_7.'source'('1')                              \n"
                    + "               reg_expr_7.'pos'(1)                                   \n"
                    + "       reg_expr_8 = new 'PAST::Op'                                   \n"
                    + "       reg_expr_8.'add_child'( reg_expr_7 )                               \n"
                    + "       reg_expr_8.'op'( 'print' )                                    \n"
                    + "       reg_expr_8.'source'('1')                                      \n"
                    + "       reg_expr_8.'pos'(1)                                           \n"
                    + "               reg_expr_9 = new 'PAST::Exp'                          \n"
                    + "               reg_expr_9.'add_child'( reg_expr_8 )                       \n"
                    + "               reg_expr_9.'source'('1')                              \n"
                    + "               reg_expr_9.'pos'(1)                                   \n"
                    + "  reg_expr_10 = new 'PAST::Stmt'                                     \n"
                    + "  reg_expr_10.'add_child'( reg_expr_9 )                                   \n"
                    + "  reg_expr_10.'source'('1')                                          \n"
                    + "  reg_expr_10.'pos'(1)                                               \n"
                    + "  stmts.'add_child'( reg_expr_10 )                                   \n"
                    + "# leaving 'expr_int_1'                                          \n"
                    + "                                                                \n"
                    ;
                  System.out.println( pir );    
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return reg;
    }
    // $ANTLR end expr





    public static final BitSet FOLLOW_PROGRAM_in_gen_pir_past52 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_expr_in_gen_pir_past54 = new BitSet(new long[]{0x0000000000000048L});
    public static final BitSet FOLLOW_INT_in_expr_int_178 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_expr_int_1_in_expr109 = new BitSet(new long[]{0x0000000000000002L});

}