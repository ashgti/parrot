// $ANTLR 3.0b3 grammar/antlr_3/antlr_past2pir_past.g 2006-07-26 23:32:55

import org.antlr.runtime.*;
import org.antlr.runtime.tree.*;import java.util.Stack;
import java.util.List;
import java.util.ArrayList;

public class AntlrPast2PirPast extends TreeParser {
    public static final String[] tokenNames = new String[] {
        "<invalid>", "<EOR>", "<DOWN>", "<UP>", "PROGRAM", "PLUS", "MINUS", "INT", "ML_COMMENT", "WS", "'quit'"
    };
    public static final int MINUS=6;
    public static final int INT=7;
    public static final int EOF=-1;
    public static final int WS=9;
    public static final int PLUS=5;
    public static final int ML_COMMENT=8;
    public static final int PROGRAM=4;

        public AntlrPast2PirPast(TreeNodeStream input) {
            super(input);
        }
        

    public String[] getTokenNames() { return tokenNames; }
    public String getGrammarFileName() { return "grammar/antlr_3/antlr_past2pir_past.g"; }



    // $ANTLR start gen_pir_past
    // grammar/antlr_3/antlr_past2pir_past.g:15:1: gen_pir_past : ^( PROGRAM ( expression )+ ) ;
    public void gen_pir_past() throws RecognitionException {   
        try {
            // grammar/antlr_3/antlr_past2pir_past.g:17:3: ( ^( PROGRAM ( expression )+ ) )
            // grammar/antlr_3/antlr_past2pir_past.g:17:3: ^( PROGRAM ( expression )+ )
            {

                String pirBefore =
                    "#!/usr/bin/env parrot                                             \n"
                  + "                                                                  \n"
                  + "# Do not edit this file.                                          \n"
                  + "# This file has been generated by Bc.java.                        \n"
                  + "                                                                  \n"
                  + "  # entering gen_pir_past                                         \n"
                  + ".sub bc :main                                                     \n"
                  + "  load_bytecode 'languages/punie/lib/ASTGrammar.pir'              \n"
                  + "  load_bytecode 'languages/punie/lib/PunieOpLookup.pir'           \n"              
                  + "  load_bytecode 'TGE.pbc'                                         \n"
                  + "  load_bytecode 'PAST.pbc'                                        \n"
                  + "  load_bytecode 'languages/punie/lib/POST.pir'                    \n"
                  + "  load_bytecode 'languages/punie/lib/OSTGrammar.pir'              \n"
                  + "                                                                  \n"
                  + "  # set up named registers                                        \n"
                  + "  .sym pmc reg_adding_expression                                  \n"
                  + "  .sym pmc reg_adding_expression_plus                             \n"
                  + "  .sym pmc reg_int_expression_left                                \n"
                  + "  .sym pmc reg_int_expression_right                               \n"
                  + "  .sym pmc reg_expr_2, reg_expr_3, reg_expr_4                     \n"
                  + "  .sym pmc reg_expr_5, reg_expr_6, reg_expr_7, reg_expr_8         \n"
                  + "  .sym pmc reg_expr_9, reg_expr_10                                \n"
                  + "                                                                  \n"
                  + "  # root of the AST                                               \n"
                  + "  .sym pmc stmts                                                  \n"
                  + "  stmts = new 'PAST::Stmts'                                       \n"
                  + "                                                                  \n"
                  ;
                System.out.println( pirBefore );    
              
            match(input,PROGRAM,FOLLOW_PROGRAM_in_gen_pir_past59); 

            match(input, Token.DOWN, null); 
            // grammar/antlr_3/antlr_past2pir_past.g:49:13: ( expression )+
            int cnt1=0;
            loop1:
            do {
                int alt1=2;
                int LA1_0 = input.LA(1);
                if ( (LA1_0==PLUS||LA1_0==INT) ) {
                    alt1=1;
                }


                switch (alt1) {
            	case 1 :
            	    // grammar/antlr_3/antlr_past2pir_past.g:49:13: expression
            	    {
            	    pushFollow(FOLLOW_expression_in_gen_pir_past61);
            	    expression();
            	    _fsp--;


            	    }
            	    break;

            	default :
            	    if ( cnt1 >= 1 ) break loop1;
                        EarlyExitException eee =
                            new EarlyExitException(1, input);
                        throw eee;
                }
                cnt1++;
            } while (true);


            match(input, Token.UP, null); 

                  String pirAfter = 
                      "                                                                \n"
                    + "  # say 'AST tree dump:'                                        \n"
                    + "  # stmts.dump()                                                \n"
                    + "  # Compile the abstract syntax tree                            \n"
                    + "  # down to an opcode syntax tree                               \n"
                    + "  .sym string ost_tg_src                                        \n"
                    + "  .sym pmc tge_compiler                                         \n"
                    + "  .sym pmc ost_grammar, ost_builder, ost                        \n"
                    + "  tge_compiler = new 'TGE::Compiler'                            \n"
                    + "  ost_tg_src = _slurp_file('languages/punie/lib/OSTGrammar.tg') \n"
                    + "  ost_grammar = tge_compiler.'compile'(ost_tg_src)              \n"
                    + "  ost_builder = ost_grammar.apply(stmts)                        \n"
                    + "  ost = ost_builder.get('result')                               \n"
                    + "  unless ost goto ERR_NO_OST                                    \n"
                    + "                                                                \n"
                    + "  # Compile the OST down to PIR                                 \n"
                    + "  .sym string pir_tg_src                                        \n"
                    + "  .sym pmc pir_grammar, pir_builder, pir                        \n"
                    + "  pir_tg_src = _slurp_file('languages/punie/lib/PIRGrammar.tg') \n"
                    + "  pir_grammar = tge_compiler.'compile'(pir_tg_src)              \n"
                    + "  pir_builder = pir_grammar.apply(ost)                          \n"
                    + "  pir = pir_builder.get('result')                               \n"
                    + "  unless pir goto ERR_NO_PIR                                    \n"
                    + "                                                                \n"
                    + "  # execute                                                     \n"
                    + "  .sym pmc pir_compiler, pir_compiled                           \n"
                    + "  pir_compiler = compreg 'PIR'                                  \n"
                    + "  pir_compiled = pir_compiler( pir )                            \n"
                    + "  pir_compiled()                                                \n"
                    + "  say ''                                                        \n"
                    + "  goto CLEANUP                                                  \n"
                    + "                                                                \n"
                    + "  ERR_NO_OST:                                                   \n"
                    + "    say 'Unable to construct OST.'                              \n"
                    + "    goto CLEANUP                                                \n"
                    + "                                                                \n"
                    + "  ERR_NO_PIR:                                                   \n"
                    + "    say 'Unable to construct PIR.'                              \n"
                    + "    goto CLEANUP                                                \n"
                    + "                                                                \n"
                    + "  CLEANUP:                                                      \n"
                    + ".end                                                            \n"
                    + "                                                                \n"
                    + ".sub _slurp_file                                                \n"
                    + "  .param string filename                                        \n"
                    + "                                                                \n"
                    + "  .sym pmc filehandle                                           \n"
                    + "  .sym string content                                           \n"
                    + "  filehandle = open filename, '<'                               \n"
                    + "  unless filehandle goto ERR_NO_FILE                            \n"
                    + "  content = read filehandle, 65535                              \n"
                    + "  close filehandle                                              \n"
                    + "                                                                \n"
                    + "  .return ( content )                                           \n"
                    + "                                                                \n"
                    + "  ERR_NO_FILE:                                                  \n"
                    + "    print 'Unable to open file: '                               \n"
                    + "    say filename                                                \n"
                    + "    end                                                         \n"
                    + "                                                                \n"
                    + ".end                                                            \n"
                    + "# leaving gen_pir_past                                          \n"
                    ;
                  System.out.print( pirAfter );    
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end gen_pir_past


    // $ANTLR start expression
    // grammar/antlr_3/antlr_past2pir_past.g:119:1: expression : adding_expression ;
    public void expression() throws RecognitionException {   
        try {
            // grammar/antlr_3/antlr_past2pir_past.g:121:3: ( adding_expression )
            // grammar/antlr_3/antlr_past2pir_past.g:121:3: adding_expression
            {
            pushFollow(FOLLOW_adding_expression_in_expression85);
            adding_expression();
            _fsp--;


                  String pir = 
                      "                                                                \n"
                    + "    # entering 'expression'                                     \n"
                    + "               reg_expr_2 = new 'PAST::Exp'                     \n"
                    + "               reg_expr_2.'add_child'( reg_adding_expression )  \n"
                    + "       reg_expr_3 = new 'PAST::Op'                              \n"
                    + "       reg_expr_3.'add_child'( reg_expr_2 )                     \n"
                    + "       reg_expr_3.'op'( 'print' )                               \n"
                    + "               reg_expr_4 = new 'PAST::Exp'                     \n"
                    + "               reg_expr_4.'add_child'( reg_expr_3 )             \n"
                    + "  reg_expr_5 = new 'PAST::Stmt'                                 \n"
                    + "  reg_expr_5.'add_child'( reg_expr_4 )                          \n"
                    + "  stmts.'add_child'( reg_expr_5 )                               \n"
                    + "               reg_expr_6 = new 'PAST::Val'                     \n"
                    + "               reg_expr_6.value( '\\n' )                        \n"
                    + "               reg_expr_6.valtype( 'strqq' )                    \n"
                    + "               reg_expr_7 = new 'PAST::Exp'                     \n"
                    + "               reg_expr_7.'add_child'( reg_expr_6 )             \n"
                    + "       reg_expr_8 = new 'PAST::Op'                              \n"
                    + "       reg_expr_8.'add_child'( reg_expr_7 )                     \n"
                    + "       reg_expr_8.'op'( 'print' )                               \n"
                    + "               reg_expr_9 = new 'PAST::Exp'                     \n"
                    + "               reg_expr_9.'add_child'( reg_expr_8 )             \n"
                    + "  reg_expr_10 = new 'PAST::Stmt'                                \n"
                    + "  reg_expr_10.'add_child'( reg_expr_9 )                         \n"
                    + "  stmts.'add_child'( reg_expr_10 )                              \n"
                    + "# leaving 'expression'                                          \n"
                    + "                                                                \n"
                    ;
                  System.out.println( pir );    
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end expression


    // $ANTLR start int_expression
    // grammar/antlr_3/antlr_past2pir_past.g:156:1: int_expression : INT ;
    public void int_expression() throws RecognitionException {   
        CommonTree INT1=null;

        try {
            // grammar/antlr_3/antlr_past2pir_past.g:158:3: ( INT )
            // grammar/antlr_3/antlr_past2pir_past.g:158:3: INT
            {
            INT1=(CommonTree)input.LT(1);
            match(input,INT,FOLLOW_INT_in_int_expression106); 

                  String pir = 
                      "                                                                \n"
                    + "# entering 'INT'                                                \n"
                    + "reg_adding_expression = new 'PAST::Val'                         \n"
                    + "reg_adding_expression.value( " + INT1.getText() + " )                \n"
                    + "reg_adding_expression.valtype( 'num' )                          \n"
                    + "# leaving INT                                                   \n"
                    ;
                  System.out.println( pir );    
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end int_expression


    // $ANTLR start int_expression_left
    // grammar/antlr_3/antlr_past2pir_past.g:172:1: int_expression_left : INT ;
    public void int_expression_left() throws RecognitionException {   
        CommonTree INT2=null;

        try {
            // grammar/antlr_3/antlr_past2pir_past.g:174:3: ( INT )
            // grammar/antlr_3/antlr_past2pir_past.g:174:3: INT
            {
            INT2=(CommonTree)input.LT(1);
            match(input,INT,FOLLOW_INT_in_int_expression_left127); 

                  String pir = 
                      "                                                                \n"
                    + "# entering 'int_expression_left'                                \n"
                    + "reg_int_expression_left = new 'PAST::Val'                       \n"
                    + "reg_int_expression_left.value( " + INT2.getText() + " )              \n"
                    + "reg_int_expression_left.valtype( 'num' )                        \n"
                    + "# leaving 'int_expression_left'                                 \n"
                    ;
                  System.out.println( pir );    
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end int_expression_left


    // $ANTLR start int_expression_right
    // grammar/antlr_3/antlr_past2pir_past.g:188:1: int_expression_right : INT ;
    public void int_expression_right() throws RecognitionException {   
        CommonTree INT3=null;

        try {
            // grammar/antlr_3/antlr_past2pir_past.g:190:3: ( INT )
            // grammar/antlr_3/antlr_past2pir_past.g:190:3: INT
            {
            INT3=(CommonTree)input.LT(1);
            match(input,INT,FOLLOW_INT_in_int_expression_right148); 

                  String pir = 
                      "                                                                \n"
                    + "# entering 'int_expression_right'                               \n"
                    + "reg_int_expression_right = new 'PAST::Val'                      \n"
                    + "reg_int_expression_right.value( " + INT3.getText() + " )             \n"
                    + "reg_int_expression_right.valtype( 'num' )                       \n"
                    + "# leaving 'int_expression_right'                                \n"
                    ;
                  System.out.println( pir );    
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end int_expression_right


    // $ANTLR start adding_expression
    // grammar/antlr_3/antlr_past2pir_past.g:204:1: adding_expression : ( int_expression | ^( PLUS int_expression_left int_expression_right ) );
    public void adding_expression() throws RecognitionException {   
        try {
            // grammar/antlr_3/antlr_past2pir_past.g:206:3: ( int_expression | ^( PLUS int_expression_left int_expression_right ) )
            int alt2=2;
            int LA2_0 = input.LA(1);
            if ( (LA2_0==INT) ) {
                alt2=1;
            }
            else if ( (LA2_0==PLUS) ) {
                alt2=2;
            }
            else {
                NoViableAltException nvae =
                    new NoViableAltException("204:1: adding_expression : ( int_expression | ^( PLUS int_expression_left int_expression_right ) );", 2, 0, input);

                throw nvae;
            }
            switch (alt2) {
                case 1 :
                    // grammar/antlr_3/antlr_past2pir_past.g:206:3: int_expression
                    {
                    pushFollow(FOLLOW_int_expression_in_adding_expression169);
                    int_expression();
                    _fsp--;


                    }
                    break;
                case 2 :
                    // grammar/antlr_3/antlr_past2pir_past.g:208:3: ^( PLUS int_expression_left int_expression_right )
                    {
                    match(input,PLUS,FOLLOW_PLUS_in_adding_expression179); 

                    match(input, Token.DOWN, null); 
                    pushFollow(FOLLOW_int_expression_left_in_adding_expression181);
                    int_expression_left();
                    _fsp--;

                    pushFollow(FOLLOW_int_expression_right_in_adding_expression183);
                    int_expression_right();
                    _fsp--;


                    match(input, Token.UP, null); 

                          String pir = 
                              "                                                                \n"
                            + "# entering 'PLUS int_expression_left int_expression_right '     \n"
                            + "       reg_adding_expression = new 'PAST::Exp'                  \n"
                            + "       reg_adding_expression_plus = new 'PAST::Op'              \n"
                            + "       reg_adding_expression_plus.'add_child'( reg_int_expression_left )   \n"
                            + "       reg_adding_expression_plus.'add_child'( reg_int_expression_right )  \n"
                            + "       reg_adding_expression_plus.'op'( 'infix:+' )             \n"
                            + "       reg_adding_expression.'add_child'( reg_adding_expression_plus )     \n"
                            + "# leaving 'PLUS int_expression_left int_expression_right'       \n"
                            ;
                          System.out.println( pir );    
                        

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end adding_expression


 

    public static final BitSet FOLLOW_PROGRAM_in_gen_pir_past59 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_expression_in_gen_pir_past61 = new BitSet(new long[]{0x00000000000000A8L});
    public static final BitSet FOLLOW_adding_expression_in_expression85 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INT_in_int_expression106 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INT_in_int_expression_left127 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INT_in_int_expression_right148 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_int_expression_in_adding_expression169 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_PLUS_in_adding_expression179 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_int_expression_left_in_adding_expression181 = new BitSet(new long[]{0x0000000000000080L});
    public static final BitSet FOLLOW_int_expression_right_in_adding_expression183 = new BitSet(new long[]{0x0000000000000008L});

}