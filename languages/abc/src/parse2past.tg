transform root (ROOT) :language('PIR') {
    .local pmc past
    past = new 'PAST::Block'
    past.'init'('node'=>node, 'name'=>'anon')
    .local pmc cpast
    cpast = tree.'get'('past', node, 'ABC::Grammar::statement')
    past.'push'(cpast)
    .return (past)
}


transform past (ABC::Grammar::statement) :language('PIR') {
  if_statement:
    $P0 = node['if_statement']
    if null $P0 goto while_statement
    .return tree.'get'('past', $P0, 'ABC::Grammar::if_statement')
  while_statement:
    $P0 = node['while_statement']
    if null $P0 goto compound_statement
    .return tree.'get'('past', $P0, 'ABC::Grammar::while_statement')
  compound_statement:
    $P0 = node['compound_statement']
    if null $P0 goto expression
    .return tree.'get'('past', $P0, 'ABC::Grammar::compound_statement')
  expression:
    $P0 = node['expression']
    .local pmc past
    past = tree.'get'('past', $P0, 'ABC::Grammar::expression')
    ##   if the statement isn't an assignment, we print the resulting value
    $I0 = isa past, 'PAST::Op'
    if $I0 == 0 goto say_result
    $S0 = past.'pasttype'()
    if $S0 == 'assign' goto end
  say_result:
    past = past.'new'('PAST::Op', past, 'node'=>node, 'pirop'=>'say')
  end:
    .return (past)
}


transform past (ABC::Grammar::if_statement) :language('PIR') {
    .local pmc exprnode, thennode, elsenode
    exprnode = node['expression']
    $P0 = node['statement']
    thennode = $P0[0]
    elsenode = $P0[1]

    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'if')
    .local pmc exprpast, thenpast, elsepast
    exprpast = tree.'get'('past', exprnode, 'ABC::Grammar::expression')
    past.'push'(exprpast)
    thenpast = tree.'get'('past', thennode, 'ABC::Grammar::statement')
    past.'push'(thenpast)
    $I0 = defined elsenode
    if $I0 == 0 goto done_else
    elsepast = tree.'get'('past', elsenode, 'ABC::Grammar::statement')
    past.'push'(elsepast)
  done_else:
    .return (past)
}


transform past (ABC::Grammar::while_statement) :language('PIR') {
    .local pmc exprnode, stmtnode
    exprnode = node['expression']
    stmtnode = node['statement']

    .local pmc past, exprpast, stmtpast
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'while')
    exprpast = tree.'get'('past', exprnode, 'ABC::Grammar::expression')
    past.'push'(exprpast)
    stmtpast = tree.'get'('past', stmtnode, 'ABC::Grammar::statement')
    past.'push'(stmtpast)
    .return (past)
}


transform past (ABC::Grammar::compound_statement) :language('PIR') {
    .local pmc past
    past = new 'PAST::Stmts'
    past.'init'('node'=>node)

    .local pmc iter
    $P0 = node['statement']
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'ABC::Grammar::statement')
    past.'push'(cpast)
    goto iter_loop
  iter_end:
    .return (past)
}
    

transform past (ABC::Grammar::expression) :language('PIR') {
    $P0 = node['expr']
    .return tree.'get'('past', $P0, 'ABC::Grammar::expr')
}


transform past (ABC::Grammar::expr) :language('PIR') {
    .local string type
    type = node['type']
    if type == 'term:' goto past_term

    .local pmc optable, optok
    .local string pasttype, pirop, returns
    optable = get_hll_global [ 'ABC::Grammar' ], '$optable'
    optok = optable[type]
    pasttype = optok['past']
    pirop = optok['pirop']
    returns = optok['returns']

    .local pmc past, iter
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'name'=>type, 'pasttype'=>pasttype, 'pirop'=>pirop, 'returns'=>returns)

    $P0 = node.'get_array'()
    if null $P0 goto iter_end
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'ABC::Grammar::expr')
    if null cpast goto iter_loop
    past.'push'(cpast)
    goto iter_loop
  iter_end:
    .return (past)

  past_term:
    .return tree.'get'('past_term', node, 'ABC::Grammar::expr')
}


transform past_term (ABC::Grammar::expr) :language('PIR') {
    .local pmc past
    $P0 = node['ident']
    unless null $P0 goto term_ident

  term_integer:
    $I0 = node
    past = new 'PAST::Val'
    past.'init'('node'=>node, 'vtype'=>'.Integer', 'name'=>node, 'ctype'=>'n')
    .return (past)

  term_ident:
    $S0 = node['ident']
    past = new 'PAST::Var'
    past.'init'('node'=>node, 'name'=>$S0)
    .return (past)
}

