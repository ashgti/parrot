grammar ABC::Grammar;

## DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT DRAFT

## an example 'bc' grammar
## This version uses a Perl 6 subset to build the abstract
## syntax tree as the program is being parsed, instead of a separate
## parse->PAST step in TGE.  It's still incomplete:
##     - build PAST from operator precedence parser
##     - handle lvalue contexts
## It won't even parse yet, so don't try.  :-)

token TOP { <program> {*} }

## recognize terms
token float { [ \d+ '.' \d* | '.' \d+ ]  {*}  }

token integer { \d+  {*} }

##  FIXME: still need to handle lvalue variables
token variable { <[a..z]><[_a..z0..9]>*  {*} }

##  FIXME: still need to handle lvalue array
token term {
    | <float>                     {*#<float>}
    | <integer>                   {*#<integer>}
    | <variable> 
        [ '[' <expression> ']'    {*#<array>}
        | '(' <expression> ')'    {*#<call>}
        | <null>                  {*#<variable>}
        ]
}
                                
## Standalone strings do not handle backslashed caracters.
## However, when a string is passed to 'print', special chars are handled.
token string { <-["]>* }

## 'print' is a GNU extension to bc
## backslashed characters are ignored for now
rule print {
    print [ <string> | <expression> ] [ , [ <string> | <expression> ] ]*
}

rule compound_statement { 
    '{' <statement_list> '}'     {*}
}

rule if_statement { 
    'if' '(' <expression> ')' <statement> 
    [ 'else' <statement> ]? 
    {*}
}

rule while_statement {
    'while' '(' <expression> ')' <statement>
    {*}
}

rule for_statement {
    'for' '(' <expression> ; <expression> ; <expression> ')' <statement>
    {*}
}

rule statement {
    | <if_statement>          {*#<if>}
    | <while_statement>       {*#<while>}
    | <for_statement>         {*#<for>}
    | <compound_statement>    {*#<compound>} 
    | \" <string> \"
    | break
    | continue
    | halt
    | return [ \( <expression> \) ]?
    | <expression>            {*#<expression> }
}

rule statement_list { 
    <statement>? [ ; <statement>? ]* 
    {*}
}

rule program { 
    ^ <statement_list> [ $ | <die: parse error> ] 
    {*}
}

rule pseudo_statement { limits | quit | warranty }

## FIXME :  still don't handle $<expression> as PAST
## create operator precedence parser

rule expression {
    <EXPR> 
    {*}
}

token term:<> is prec('z=') { ... }

token circumfix:<( )> is equiv(&term:<>) is pirop('set') { ... }

## autoincrement
token postfix:<++> is looser(&circumfix:<( )>) 
    is lvalue(1) 
    { ... }
token postfix:<--> is equiv(&postfix:<++>) is lvalue(1) { ... }
token prefix:<++>  is equiv(&postfix:<++>) is lvalue(1) { ... }
token prefix:<-->  is equiv(&postfix:<++>) is lvalue(1) { ... }

## negation
token prefix:<->   is looser(&postfix:<++>)    
    is pirop('neg')
    { ... }

## exponentiation
token infix:<^>    is looser(&prefix:<->)    { ... }

## multiplicative
token infix:<*>    is looser(&infix:<^>)
    is pirop('mul')
    { ... }

token infix:</>    is equiv(&infix:<*>)
    is pirop('div')
    { ... }

token infix:<%>    is equiv(&infix:<*>)
    is pirop('mod')
    { ... }


## additive
token infix:<+>    is looser(&infix:<*>)
    is pirop('add')
    { ... }

token infix:<->    is equiv(&infix:<+>)
    is pirop('sub')
    { ... }

## assignment
token infix:<=>    is looser(&infix:<+>)
    is assoc('right')
    is past('assign')
    is lvalue(1)
    { ... }

## relational
token infix:<==>   is looser(&infix:<=>)
    is assoc('non')
    {...}

token infix:<!=>   is equiv(&infix:<==>) { ... }
token infix:«<»    is equiv(&infix:<==>) { ... }
token infix:«<=»   is equiv(&infix:<==>) { ... }
token infix:«>»    is equiv(&infix:<==>) { ... }
token infix:«>=»   is equiv(&infix:<==>) { ... }

## boolean
token prefix:<!>   is looser(&infix:<==>)
    is pirop('not')
    is returns('.Integer')
    { ... }
token infix:<&&>   is looser(&prefix:<!>) is assoc('left') { ... }
token infix:<||>   is looser(&infix:<&&>) is assoc('left') { ... }

## vim: expandtab sw=4
