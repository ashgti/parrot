/*
Copyright (C) 2006, The Perl Foundation.
$Id$

=head1 NAME

pmc/wmlsboolean.pmc - WMLScript Boolean

=head1 DESCRIPTION

C<WmlsBoolean> extends C<Boolean> to provide a class with the behaviour of
the WMLScript C<Boolean> type.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "pmc_wmlsstring.h"

static INTVAL dynpmc_WmlsBoolean;
static INTVAL dynpmc_WmlsFloat;
static INTVAL dynpmc_WmlsInteger;
static INTVAL dynpmc_WmlsInvalid;
static INTVAL dynpmc_WmlsString;

static inline INTVAL num_cmp(FLOATVAL v1, FLOATVAL v2)
{
    if (v1 == v2) {
        return 0;
    }
    else if (v1 > v2) {
        return 1;
    }
    else {
        return -1;
    }
}

static inline INTVAL int_cmp(INTVAL v1, INTVAL v2)
{
    if (v1 == v2) {
        return 0;
    }
    else if (v1 > v2) {
        return 1;
    }
    else {
        return -1;
    }
}


pmclass WmlsBoolean
    extends Boolean
    does scalar
    does boolean
    does integer
    dynpmc
    group wmls_group
    hll Lua maps Boolean {

/* Class initialization. Caches constant strings that will be used later.
*/
    void class_init() {
        if (pass) {
            dynpmc_WmlsBoolean = pmc_type(INTERP,
              const_string(INTERP, "WmlsBoolean"));
            dynpmc_WmlsFloat = pmc_type(INTERP,
              const_string(INTERP, "WmlsFloat"));
            dynpmc_WmlsInteger = pmc_type(INTERP,
              const_string(INTERP, "WmlsInteger"));
            dynpmc_WmlsInvalid = pmc_type(INTERP,
              const_string(INTERP, "WmlsInvalid"));
            dynpmc_WmlsString = pmc_type(INTERP,
              const_string(INTERP, "WmlsString"));
        }
    }

/*

=item C<STRING* get_string ()>

Return the string "true" or "false".

=cut

*/
    STRING* get_string () {
        if (PMC_int_val(SELF))
            return const_string(INTERP, "true");
        else
            return const_string(INTERP, "false");
    }

/*

=item C<void increment()>

=cut

*/
    void increment () {
        const INTVAL a = VTABLE_get_integer(INTERP, SELF);
        VTABLE_morph(INTERP, SELF, dynpmc_WmlsInteger);
        VTABLE_set_integer_native(INTERP, SELF, a);
        VTABLE_increment(INTERP, SELF);
    }

/*

=item C<void decrement ()>

=cut

*/
    void decrement () {
        const INTVAL a = VTABLE_get_integer(INTERP, SELF);
        VTABLE_morph(INTERP, SELF, dynpmc_WmlsInteger);
        VTABLE_set_integer_native(INTERP, SELF, a);
        VTABLE_decrement(INTERP, SELF);
    }

/*

=item C<PMC* absolute(PMC *dest)>

=item C<void i_absolute ()>

=cut

*/
    PMC* absolute (PMC* dest) {
        return pmc_new(INTERP, dynpmc_WmlsInvalid);
    }

    void i_absolute () {
        DYNSELF.morph(dynpmc_WmlsInvalid);
    }

/*

=item C<PMC* neg(PMC *dest)>

=item C<void i_neg ()>

=cut

*/
    PMC* neg (PMC* dest) {
        dest = pmc_new(INTERP, dynpmc_WmlsInteger);
        PMC_int_val(dest) = - DYNSELF.get_bool();
        return dest;
    }

    void i_neg () {
        INTVAL result = - DYNSELF.get_bool();
        DYNSELF.morph(dynpmc_WmlsInteger);
        DYNSELF.set_integer_native(result);
    }

/*

=item C<PMC* bitwise_not(PMC *dest)>

=item C<void i_bitwise_not ()>

=cut

*/
    PMC* bitwise_not (PMC* dest) {
        dest = pmc_new(INTERP, dynpmc_WmlsInteger);
        PMC_int_val(dest) = ~ DYNSELF.get_bool();
        return dest;
    }

    void i_bitwise_not () {
        INTVAL result = ~ DYNSELF.get_bool();
        DYNSELF.morph(dynpmc_WmlsInteger);
        DYNSELF.set_integer_native(result);
    }

/*

=item C<PMC* logical_not(PMC *dest)>

=item C<void i_logical_not ()>

=cut

*/
    PMC* logical_not (PMC* dest) {
        dest = pmc_new(INTERP, dynpmc_WmlsBoolean);
        VTABLE_set_bool(INTERP, dest, ! DYNSELF.get_bool());
        return dest;
    }

    void i_logical_not () {
        INTVAL result = ! DYNSELF.get_bool();
        DYNSELF.set_integer_native(result);
    }

/*

=back

=head2 non-Vtable Methods

=over 4

=item C<void add(PMC *value, PMC *dest)>

=item C<void i_add(PMC *value)>

=cut

*/
    PMC* add (PMC* value, PMC* dest) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          + VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          + VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsFloat: {
            FLOATVAL result = DYNSELF.get_number()
                            + VTABLE_get_number(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsFloat);
            VTABLE_set_number_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsString: {
            STRING* result = string_concat(INTERP,
                  DYNSELF.get_string(),
                  VTABLE_get_string(INTERP, value), 0);
            dest = pmc_new(INTERP, dynpmc_WmlsString);
            VTABLE_set_string_native(INTERP, dest, result);
            return dest;
        }
MMD_DEFAULT: {
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
    }

    void i_add (PMC* value) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          + VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          + VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsFloat: {
            FLOATVAL result = DYNSELF.get_number()
                            + VTABLE_get_number(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsFloat);
            DYNSELF.set_number_native(result);
        }
MMD_WmlsString: {
            STRING* result = string_concat(INTERP,
                  DYNSELF.get_string(),
                  VTABLE_get_string(INTERP, value), 0);
            DYNSELF.morph(dynpmc_WmlsString);
            DYNSELF.set_string_native(result);
        }
MMD_DEFAULT: {
            DYNSELF.morph(dynpmc_WmlsInvalid);
        }
    }

/*

=item C<PMC* subtract(PMC *value, PMC *dest)>

=item C<void i_subtract(PMC *value)>

=cut

*/
    PMC* subtract (PMC* value, PMC* dest) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          - VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          - VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsFloat: {
            FLOATVAL result = DYNSELF.get_number()
                            - VTABLE_get_number(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsFloat);
            VTABLE_set_number_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              - VTABLE_get_integer(INTERP, trans);
                dest = pmc_new(INTERP, dynpmc_WmlsInteger);
                VTABLE_set_integer_native(INTERP, dest, result);
                return dest;
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_DEFAULT: {
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
    }

    void i_subtract (PMC* value) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          - VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          - VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsFloat: {
            FLOATVAL result = DYNSELF.get_number()
                            - VTABLE_get_number(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsFloat);
            DYNSELF.set_number_native(result);
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              - VTABLE_get_integer(INTERP, trans);
                DYNSELF.morph(dynpmc_WmlsInteger);
                DYNSELF.set_integer_native(result);
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_DEFAULT: {
            DYNSELF.morph(dynpmc_WmlsInvalid);
        }
    }

/*

=item C<PMC* multiply(PMC *value, PMC *dest)>

=item C<void i_multiply(PMC *value)>

=cut

*/
    PMC* multiply (PMC* value, PMC* dest) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          * VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          * VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsFloat: {
            FLOATVAL result = DYNSELF.get_number()
                            * VTABLE_get_number(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsFloat);
            VTABLE_set_number_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              * VTABLE_get_integer(INTERP, trans);
                dest = pmc_new(INTERP, dynpmc_WmlsInteger);
                VTABLE_set_integer_native(INTERP, dest, result);
                return dest;
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_DEFAULT: {
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
    }

    void i_multiply (PMC* value) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          * VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          * VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsFloat: {
            FLOATVAL result = DYNSELF.get_number()
                            * VTABLE_get_number(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsFloat);
            DYNSELF.set_number_native(result);
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              * VTABLE_get_integer(INTERP, trans);
                DYNSELF.morph(dynpmc_WmlsInteger);
                DYNSELF.set_integer_native(result);
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_DEFAULT: {
            DYNSELF.morph(dynpmc_WmlsInvalid);
        }
    }

/*

=item C<PMC* divide(PMC *value, PMC *dest)>

=item C<void i_divide(PMC *value)>

=cut

*/
    PMC* divide (PMC* value, PMC* dest) {
MMD_WmlsFloat: {
            FLOATVAL d = VTABLE_get_number(INTERP, value);
            if (d != 0.0) {
                FLOATVAL result = DYNSELF.get_number() / d;
                dest = pmc_new(INTERP, dynpmc_WmlsFloat);
                VTABLE_set_number_native(INTERP, dest, result);
                return dest;
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_WmlsInteger: {
            FLOATVAL d = VTABLE_get_number(INTERP, value);
            if (d != 0.0) {
                FLOATVAL result = DYNSELF.get_number() / d;
                dest = pmc_new(INTERP, dynpmc_WmlsFloat);
                VTABLE_set_number_native(INTERP, dest, result);
                return dest;
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_WmlsBoolean: {
            FLOATVAL d = VTABLE_get_number(INTERP, value);
            if (d != 0.0) {
                FLOATVAL result = DYNSELF.get_number() / d;
                dest = pmc_new(INTERP, dynpmc_WmlsFloat);
                VTABLE_set_number_native(INTERP, dest, result);
                return dest;
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                FLOATVAL d = VTABLE_get_number(INTERP, trans);
                if (d != 0.0) {
                    FLOATVAL result = DYNSELF.get_number() / d;
                    dest = pmc_new(INTERP, dynpmc_WmlsFloat);
                    VTABLE_set_number_native(INTERP, dest, result);
                    return dest;
                }
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_DEFAULT: {
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
    }

    void i_divide (PMC* value) {
MMD_WmlsFloat: {
            FLOATVAL d = VTABLE_get_number(INTERP, value);
            if (d != 0.0) {
                FLOATVAL result = DYNSELF.get_number() / d;
                DYNSELF.morph(dynpmc_WmlsFloat);
                DYNSELF.set_number_native(result);
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_WmlsInteger: {
            FLOATVAL d = VTABLE_get_number(INTERP, value);
            if (d != 0.0) {
                FLOATVAL result = DYNSELF.get_number() / d;
                DYNSELF.morph(dynpmc_WmlsFloat);
                DYNSELF.set_number_native(result);
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_WmlsBoolean: {
            FLOATVAL d = VTABLE_get_number(INTERP, value);
            if (d != 0.0) {
                FLOATVAL result = DYNSELF.get_number() / d;
                DYNSELF.morph(dynpmc_WmlsFloat);
                DYNSELF.set_number_native(result);
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                FLOATVAL d = VTABLE_get_integer(INTERP, trans);
                if (d != 0.0) {
                    FLOATVAL result = DYNSELF.get_number() / d;
                    DYNSELF.morph(dynpmc_WmlsFloat);
                    DYNSELF.set_number_native(result);
                }
                else {
                    DYNSELF.morph(dynpmc_WmlsInvalid);
                }
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_DEFAULT: {
            DYNSELF.morph(dynpmc_WmlsInvalid);
        }
    }

/*

=item C<PMC* floor_divide(PMC *value, PMC *dest)>

=item C<void i_floor_divide(PMC *value)>

=cut

*/
    PMC* floor_divide (PMC* value, PMC* dest) {
MMD_WmlsInteger: {
            INTVAL d = VTABLE_get_integer(INTERP, value);
            if (d != 0) {
                INTVAL result = DYNSELF.get_integer() / d;
                dest = pmc_new(INTERP, dynpmc_WmlsInteger);
                VTABLE_set_integer_native(INTERP, dest, result);
                return dest;
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_WmlsBoolean: {
            INTVAL d = VTABLE_get_integer(INTERP, value);
            if (d != 0) {
                INTVAL result = DYNSELF.get_integer() / d;
                dest = pmc_new(INTERP, dynpmc_WmlsInteger);
                VTABLE_set_integer_native(INTERP, dest, result);
                return dest;
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL d = VTABLE_get_integer(INTERP, trans);
                if (d != 0) {
                    INTVAL result = DYNSELF.get_integer() / d;
                    dest = pmc_new(INTERP, dynpmc_WmlsInteger);
                    VTABLE_set_integer_native(INTERP, dest, result);
                    return dest;
                }
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_DEFAULT: {
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
    }

    void i_floor_divide (PMC* value) {
MMD_WmlsInteger: {
            INTVAL d = VTABLE_get_integer(INTERP, value);
            if (d != 0) {
                INTVAL result = DYNSELF.get_integer() / d;
                DYNSELF.morph(dynpmc_WmlsInteger);
                DYNSELF.set_integer_native(result);
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_WmlsBoolean: {
            INTVAL d = VTABLE_get_integer(INTERP, value);
            if (d != 0) {
                INTVAL result = DYNSELF.get_integer() / d;
                DYNSELF.morph(dynpmc_WmlsInteger);
                DYNSELF.set_integer_native(result);
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL d = VTABLE_get_integer(INTERP, trans);
                if (d != 0) {
                    INTVAL result = DYNSELF.get_integer() / d;
                    DYNSELF.morph(dynpmc_WmlsInteger);
                    DYNSELF.set_integer_native(result);
                }
                else {
                    DYNSELF.morph(dynpmc_WmlsInvalid);
                }
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_DEFAULT: {
            DYNSELF.morph(dynpmc_WmlsInvalid);
        }
    }

/*

=item C<PMC* cmodulus(PMC *value, PMC *dest)>

=item C<void i_cmodulus(PMC *value)>

=cut

*/
    PMC* cmodulus (PMC* value, PMC* dest) {
MMD_WmlsInteger: {
            INTVAL d = VTABLE_get_integer(INTERP, value);
            if (d != 0) {
                INTVAL result = DYNSELF.get_integer() % d;
                dest = pmc_new(INTERP, dynpmc_WmlsInteger);
                VTABLE_set_integer_native(INTERP, dest, result);
                return dest;
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_WmlsBoolean: {
            INTVAL d = VTABLE_get_integer(INTERP, value);
            if (d != 0) {
                INTVAL result = DYNSELF.get_integer() % d;
                dest = pmc_new(INTERP, dynpmc_WmlsInteger);
                VTABLE_set_integer_native(INTERP, dest, result);
                return dest;
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL d = VTABLE_get_integer(INTERP, trans);
                if (d != 0) {
                    INTVAL result = DYNSELF.get_integer() % d;
                    dest = pmc_new(INTERP, dynpmc_WmlsInteger);
                    VTABLE_set_integer_native(INTERP, dest, result);
                    return dest;
                }
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_DEFAULT: {
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
    }

    void i_cmodulus (PMC* value) {
MMD_WmlsInteger: {
            INTVAL d = VTABLE_get_integer(INTERP, value);
            if (d != 0) {
                INTVAL result = DYNSELF.get_integer() % d;
                DYNSELF.morph(dynpmc_WmlsInteger);
                DYNSELF.set_integer_native(result);
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_WmlsBoolean: {
            INTVAL d = VTABLE_get_integer(INTERP, value);
            if (d != 0) {
                INTVAL result = DYNSELF.get_integer() % d;
                DYNSELF.morph(dynpmc_WmlsInteger);
                DYNSELF.set_integer_native(result);
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL d = VTABLE_get_integer(INTERP, trans);
                if (d != 0) {
                    INTVAL result = DYNSELF.get_integer() % d;
                    DYNSELF.morph(dynpmc_WmlsInteger);
                    DYNSELF.set_integer_native(result);
                }
                else {
                    DYNSELF.morph(dynpmc_WmlsInvalid);
                }
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_DEFAULT: {
            DYNSELF.morph(dynpmc_WmlsInvalid);
        }
    }

/*

=item C<PMC* bitwise_or(PMC *value, PMC *dest)>

=item C<void i_bitwise_or(PMC *value)>

=cut

*/
    PMC* bitwise_or (PMC* value, PMC* dest) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          | VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          | VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              | VTABLE_get_integer(INTERP, trans);
                dest = pmc_new(INTERP, dynpmc_WmlsInteger);
                VTABLE_set_integer_native(INTERP, dest, result);
                return dest;
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_DEFAULT: {
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
    }

    void i_bitwise_or (PMC* value) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          | VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          | VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              | VTABLE_get_integer(INTERP, trans);
                DYNSELF.morph(dynpmc_WmlsInteger);
                DYNSELF.set_integer_native(result);
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_DEFAULT: {
            DYNSELF.morph(dynpmc_WmlsInvalid);
        }
    }

/*

=item C<PMC* bitwise_and(PMC *value, PMC *dest)>

=item C<void i_bitwise_and(PMC *value)>

=cut

*/
    PMC* bitwise_and (PMC* value, PMC* dest) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          & VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          & VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              & VTABLE_get_integer(INTERP, trans);
                dest = pmc_new(INTERP, dynpmc_WmlsInteger);
                VTABLE_set_integer_native(INTERP, dest, result);
                return dest;
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_DEFAULT: {
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
    }

    void i_bitwise_and (PMC* value) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          & VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          & VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              & VTABLE_get_integer(INTERP, trans);
                DYNSELF.morph(dynpmc_WmlsInteger);
                DYNSELF.set_integer_native(result);
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_DEFAULT: {
            DYNSELF.morph(dynpmc_WmlsInvalid);
        }
    }

/*

=item C<void bitwise_xor(PMC *value, PMC *dest)>

=item C<void i_bitwise_xor(PMC *value)>

=cut

*/
    PMC* bitwise_xor (PMC* value, PMC* dest) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          ^ VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          ^ VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              ^ VTABLE_get_integer(INTERP, trans);
                dest = pmc_new(INTERP, dynpmc_WmlsInteger);
                VTABLE_set_integer_native(INTERP, dest, result);
                return dest;
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_DEFAULT: {
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
    }

    void i_bitwise_xor (PMC* value) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          ^ VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          ^ VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              ^ VTABLE_get_integer(INTERP, trans);
                DYNSELF.morph(dynpmc_WmlsInteger);
                DYNSELF.set_integer_native(result);
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_DEFAULT: {
            DYNSELF.morph(dynpmc_WmlsInvalid);
        }
    }

/*

=item C<PMC* bitwise_shr(PMC *value, PMC *dest)>

=item C<void i_bitwise_shr(PMC *value)>

=cut

*/
    PMC* bitwise_shr (PMC* value, PMC* dest) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          >> VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          >> VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              >> VTABLE_get_integer(INTERP, trans);
                dest = pmc_new(INTERP, dynpmc_WmlsInteger);
                VTABLE_set_integer_native(INTERP, dest, result);
                return dest;
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_DEFAULT: {
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
    }

    void i_bitwise_shr (PMC* value) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          >> VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          >> VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              >> VTABLE_get_integer(INTERP, trans);
                DYNSELF.morph(dynpmc_WmlsInteger);
                DYNSELF.set_integer_native(result);
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_DEFAULT: {
            DYNSELF.morph(dynpmc_WmlsInvalid);
        }
    }

/*

=item C<PMC* bitwise_lsr(PMC *value, PMC *dest)>

=item C<void i_bitwise_lsr(PMC *value)>

=cut

*/
    PMC* bitwise_lsr (PMC* value, PMC* dest) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          >> VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          >> VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              >> VTABLE_get_integer(INTERP, trans);
                dest = pmc_new(INTERP, dynpmc_WmlsInteger);
                VTABLE_set_integer_native(INTERP, dest, result);
                return dest;
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_DEFAULT: {
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
    }

    void i_bitwise_lsr (PMC* value) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          >> VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          >> VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              >> VTABLE_get_integer(INTERP, trans);
                DYNSELF.morph(dynpmc_WmlsInteger);
                DYNSELF.set_integer_native(result);
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_DEFAULT: {
            DYNSELF.morph(dynpmc_WmlsInvalid);
        }
    }

/*

=item C<PMC* bitwise_shl(PMC *value, PMC *dest)>

=item C<void i_bitwise_shl(PMC *value)>

=cut

*/
    PMC* bitwise_shl (PMC* value, PMC* dest) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          << VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          << VTABLE_get_integer(INTERP, value);
            dest = pmc_new(INTERP, dynpmc_WmlsInteger);
            VTABLE_set_integer_native(INTERP, dest, result);
            return dest;
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              << VTABLE_get_integer(INTERP, trans);
                dest = pmc_new(INTERP, dynpmc_WmlsInteger);
                VTABLE_set_integer_native(INTERP, dest, result);
                return dest;
            }
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
MMD_DEFAULT: {
            return pmc_new(INTERP, dynpmc_WmlsInvalid);
        }
    }

    void i_bitwise_shl (PMC* value) {
MMD_WmlsInteger: {
            INTVAL result = DYNSELF.get_integer()
                          << VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsBoolean: {
            INTVAL result = DYNSELF.get_integer()
                          << VTABLE_get_integer(INTERP, value);
            DYNSELF.morph(dynpmc_WmlsInteger);
            DYNSELF.set_integer_native(result);
        }
MMD_WmlsString: {
            PMC * trans = Parrot_WmlsString_parseInt(INTERP, value);
            if (trans->vtable->base_type == dynpmc_WmlsInteger) {
                INTVAL result = DYNSELF.get_integer()
                              << VTABLE_get_integer(INTERP, trans);
                DYNSELF.morph(dynpmc_WmlsInteger);
                DYNSELF.set_integer_native(result);
            }
            else {
                DYNSELF.morph(dynpmc_WmlsInvalid);
            }
        }
MMD_DEFAULT: {
            DYNSELF.morph(dynpmc_WmlsInvalid);
        }
    }

/*

=item C<PMC* is_equal (PMC* value)>

=cut

*/
    INTVAL is_equal (PMC* value) {
MMD_WmlsFloat: {
            return DYNSELF.get_number() == VTABLE_get_number(INTERP, value);
        }
MMD_WmlsInteger: {
            return DYNSELF.get_integer() == VTABLE_get_integer(INTERP, value);
        }
MMD_WmlsBoolean: {
            return DYNSELF.get_integer() == VTABLE_get_integer(INTERP, value);
        }
MMD_WmlsString: {
            return !string_equal(INTERP,
                DYNSELF.get_string(), VTABLE_get_string(INTERP, value));
        }
MMD_DEFAULT: {
            return 4;
        }
    }

/*

=item C<PMC* cmp (PMC *value)>

=cut

*/
    INTVAL cmp (PMC* value) {
MMD_WmlsFloat: {
            return num_cmp(DYNSELF.get_number(),
                           VTABLE_get_number(INTERP, value));
        }
MMD_WmlsInteger: {
            return int_cmp(DYNSELF.get_integer(),
                           VTABLE_get_integer(INTERP, value));
        }
MMD_WmlsBoolean: {
            return int_cmp(DYNSELF.get_integer(),
                           VTABLE_get_integer(INTERP, value));
        }
MMD_WmlsString: {
            return string_compare(INTERP,
                DYNSELF.get_string(), VTABLE_get_string(INTERP, value));
        }
MMD_DEFAULT: {
            return 4;
        }
    }

}

/*

=back

=head1 AUTHORS

Francois Perrad.

=cut

*/

