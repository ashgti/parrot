# Copyright (C) 2007, The Perl Foundation.
# $Id$

grammar NQP::Grammar is PCT::Grammar;


token TOP {
  {*}                                                      #= open
  <statement_list>
  [ $ | <panic: Syntax error> ]
  {*}                                                      #= close
}

##  The <ws> and <pod_comment> rules handle whitespace and comments.
##  These are taken from an earlier draft of Perl 6, so they do not
##  yet handle all valid forms of Perl 6 whitespace.
token ws {
    {{  $P0 = match.'to'()
        $P1 = get_hll_global [ 'NQP::Grammar' ], '$!ws'
        if null $P1 goto set_new_ws
        $P2 = $P1.'to'()
        if $P0 != $P2 goto set_new_ws
        .return (1)
      set_new_ws:
        set_hll_global [ 'NQP::Grammar' ], '$!ws', match
    }}
    [ \s+
    | ^^ [ \# \N*
         | <?pod_comment>
         ]
    | \# \N*
    ]*
}


token afterws {
    ##  <?{ $Â¢ == $!ws_to != $!ws_from }>
    {{  $P0 = match.'to'()
        $P1 = get_hll_global [ 'NQP::Grammar' ], '$!ws'
        $P2 = $P1.'to'()
        if $P0 != $P2 goto end
        $P2 = $P1.'from'()
        if $P0 == $P1 goto end
        .return (1)
      end:
    }}
    <fail>
}


regex pod_comment {
    ^^ '=' [ [ 'cut' \h*: | 'end' [\h\N*]? ]
           | 'for' [ \h\N+: ] \n [ \N+\n ]*:
           | \w\N*: \n .*? \n '=' [ 'cut' \h*: | 'end' [\h\N*:]? ]
           ]
           [\n|$]
}


#### Blocks and Statements ####

##  Parse a list of statements.
rule statement_list {
    [ <statement>
        [  <?statement_end> || <panic: Statement not terminated properly> ]
    ]*
    {*}
}


##  Parse a single statement, which may be either a bare block
##  or an expression.  Any statement termination is handled by
##  the calling rule.
rule statement {
    | <if_statement> {*}                                   #= if_statement
    | <for_statement> {*}                                  #= for_statement
    | <return_statement> {*}                               #= return_statement
    | <block> {*}                                          #= block
    | <EXPR> {*}                                           #= EXPR
}


##  The statement_end rule detects when we're at valid statement
##  termination point.  A semicolon always acts as a valid
##  statement ending point, as does the presence of any expression
##  terminator.  Here we also handle the special case of a closing
##  '}' on a line by itself (which will have been detected by
##  a previous <block> rule).

token terminator { <[ } \] ) ]> | $ }

token statement_end {
     || ';'
     || <?before <terminator>>
     || {{  $P0 = get_hll_global ['NQP::Grammar'], '$!endstmt'
            $P1 = get_hll_global ['NQP::Grammar'], '$!ws'
            $P2 = $P1.'from'()
            if $P0 != $P2 goto end
            .return (1)
            end:
        }} <fail>
}


##  The if_statement handles conditional statements such as 'if' and
##  'unless'.

rule if_statement {
    $<sym>:=['if'|'unless'] <EXPR> <block>
    [ 'else' <block> ]?
    {*}
}


rule for_statement {
    $<sym>:=['for'] <EXPR> <block>
    {*}
}


rule return_statement {
    $<sym>:=['return']
    [ <EXPR> | <panic: Unable to parse argument to 'return'> ]
    {*}
}


##  Parse a block.  If the closing brace is at the end of a line,
##  then we grab any whitespace and set C<$!endstmt> to the resulting
##  position so that the <statement_end> rule can detect it.

token block {
    '{'
    {*}                                                    #= open
    <statement_list>
    [ '}' | <panic: Missing '}'> ]
    [
        \h* [ \# \N* ]? \n
        {{  $P0 = match.'to'()
            $P0 = clone $P0
            set_hll_global ['NQP::Grammar'], '$!endstmt', $P0
        }}
        <?ws>
    ]?
    {*}                                                    #= close
}


#### Subroutine and method definitions ####

rule routine_def {
    $<declarator>:=['sub'|'method']
    <ident>
    '(' <signature> ')'
    <block>
    {*}
}

rule signature {
    ( <param_var> ( ',' | <?before ')'> ) )*
    ( <colonpair> ( ',' | <?before ')'> ) )*
    {*}
}

token param_var {
    | '$/'
    | <sigil> <ident>
    {*}
}


#### Terms ####

token term {
    <noun>
    <postfix>*
    {*}                                                    #= end
}

token postfix {
    <!afterws>
    [ <methodop> {*}                                       #= methodop
    | <postcircumfix> {*}                                  #= postcircumfix
    ]
}

token methodop {
    '.' <ident>
    '(' <arglist>
    [ <?ws> ')' | <panic: Missing ')'> ]
    {*}                                                    #= methodop
}

token postcircumfix {
    | '(' <arglist> ')' {*}                                #= ( )
    | '[' <EXPR> <?ws> ']' {*}                             #= [ ]
    | '{' <EXPR> <?ws> '}' {*}                             #= { }
    | '<' <string_literal: \>> '>' {*}                     #= < >
}

rule arglist {
    <EXPR>?
    {*}
}

token noun {
    | <colonpair> {*}                                      #= colonpair
    | <scope_declarator> {*}                               #= scope_declarator
    | <routine_def> {*}                                    #= routine_def
    | <circumfix> {*}                                      #= circumfix
    | <variable> {*}                                       #= variable
    | <quote> {*}                                          #= quote
    | <number> {*}                                         #= number
    | <subcall> {*}                                        #= subcall
    | <name> {*}                                           #= name
}


token colonpair {
    | ':' <ident> [ '(' <EXPR> <?ws> ')' ] {*}
}


rule scope_declarator {
    $<declarator>:=[my|our]
    <variable>
    {*}
}


token circumfix {
    | '(' <EXPR>? <?ws> ')' {*}                            #= ( )
    | '$(' <EXPR>? <?ws> ')' {*}                           #= $( )
    | '@(' <EXPR>? <?ws> ')' {*}                           #= @( )
}


token variable {
    | '$<' ( <-[\>]>* ) '>' {*}                            #= $< >
    | '$/' {*}                                             #= $/
    | <sigil> <ident> {*}                                  #= $var
}

token sigil { '$' }


token quote {
    [ \'  <string_literal: '> \'
    | '"' <string_literal: "> '"'
    | '<' <string_literal: \>> '>'
    ]
    {*}
}


token name {
    <ident> [ '::' <ident> ]*
    {*}
}


token number { \d+ {*} }


token subcall {
    <name> '(' <arglist> ')'
    {*}
}



#### Expressions and operators ####

rule EXPR is optable { ... }

proto 'term:' is precedence('z=')
    is parsed(&term)
    { ... }

proto prefix:<+> is looser('term:')
    is pasttype('inline')
    { ... }

proto prefix:<~> is equiv(prefix:<+>)
    is pasttype('inline')
    { ... }

proto prefix:<+> is equiv(prefix:<~>)
    { ... }

proto prefix:<-> is equiv(prefix:<+>)
    is pirop('n_neg')
    { ... }

proto infix:<+> is looser(prefix:<~>)
    is pirop('n_add')
    { ... }

proto infix:<-> is equiv(prefix:<+>)
    is pirop('n_sub')
    { ... }

proto infix:<==> is looser(infix:<+>)
    is pasttype('inline')
    { ... }
proto infix:<!=> is equiv(infix:<==>)
    is pasttype('inline')
    { ... }
proto infix:<eq> is equiv(infix:<==>)
    { ... }
proto infix:<ne> is equiv(infix:<==>)
    { ... }

proto infix:<&&> is looser(infix:<==>)
    is pasttype('if')
    { ... }

proto infix:<||> is looser(infix:<&&>)
    is pasttype('unless')
    { ... }

proto infix:<:=> is looser(infix:<||>)
    is lvalue(1)
    is pasttype('bind')
    { ... }

proto infix:<,> is looser(infix:<:=>)
    is assoc('list')
    { ... }

