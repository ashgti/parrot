# Copyright (C) 2007, The Perl Foundation.
# $Id$

grammar NQP::Grammar is PCT::Grammar;


token TOP { <statement_list> [ $ | <panic: Syntax error> ] {*} }

##  The <ws> and <pod_comment> rules handle whitespace and comments.
##  These are taken from an earlier draft of Perl 6, so they do not
##  yet handle all valid forms of Perl 6 whitespace.
token ws {
    [ \s+
    | ^^ [ \# \N*
         | <?pod_comment>
         ]
    | \# \N*
    ]*
}

regex pod_comment {
    ^^ '=' [ [ 'cut' \h*: | 'end' [\h\N*]? ]
           | 'for' [ \h\N+: ] \n [ \N+\n ]*:
           | \w\N*: \n .*? \n '=' [ 'cut' \h*: | 'end' [\h\N*:]? ]
           ]
           [\n|$]
}


#### Blocks and Statements ####

##  Parse a list of statements.
rule statement_list {
    [ <statement>
        [  <?statement_end> || <panic: Statement not terminated properly> ]
    ]*
    {*}
}


##  Parse a single statement, which may be either a bare block
##  or an expression.  Any statement termination is handled by
##  the calling rule.
rule statement {
    | <if_statement> {*}                                   #= if_statement
    | <block> {*}                                          #= block
    | <EXPR> {*}                                           #= EXPR
}


##  The statement_end rule detects when we're at valid statement
##  termination point.  A semicolon always acts as a valid
##  statement ending point, as does the presence of any expression
##  terminator.  Here we also handle the special case of a closing
##  '}' on a line by itself (which will have been detected by
##  a previous <block> rule).

token terminator { <[ } \] ) ]> | $ }

token statement_end {
     || ';'
     || <?before <terminator>>
     || {{  $P0 = match.'to'()
            $P1 = get_hll_global ['NQP::Grammar'], '$!endstmt'
            if $P0 != $P1 goto end
            .return (1)
            end:
        }} <fail>
}


##  The if_statement handles conditional statements such as 'if' and
##  'unless'.

rule if_statement {
    $<sym>:=['if'|'unless'] <EXPR> <block>
    [ 'else' <block> ]?
    {*}
}


##  Parse a block.  If the closing brace is at the end of a line,
##  then we grab any whitespace and set C<$!endstmt> to the resulting
##  position so that the <statement_end> rule can detect it.

token block {
    '{'
    <statement_list>
    '}'
    [
        \h* [ \# \N* ]? \n <?ws>
        {{  $P0 = match.'to'()
            $P0 = clone $P0
            set_hll_global ['NQP::Grammar'], '$!endstmt', $P0
        }}
    ]?
    {*}                                                    #= end
}


#### Subroutine and method definitions ####

rule routine_def {
    $<declarator>:=['sub'|'method']
    <ident>
    '(' <signature> ')'
    <block>
    {*}
}

rule signature {
    ( <param_var> ( ',' | <?before ')'> ) )*
    ( <colonpair> ( ',' | <?before ')'> ) )*
    {*}
}

token param_var {
    <sigil> <ident>
    {*}
}


#### Terms ####

token term {
    <noun>
    <methodop>*
    {*}                                                    #= end
}


token methodop {
    '.' <ident> '(' <EXPR>? ')'
}


token noun {
    | <colonpair> {*}                                      #= colonpair
    | <routine_def> {*}                                    #= routine_def
    | <variable> {*}                                       #= variable
    | <quote> {*}                                          #= quote
    | <number> {*}                                         #= number
    | <subcall> {*}                                        #= subcall
}


token colonpair {
    | ':' <ident> [ '(' <EXPR> ')' ] {*}
}


token variable {
    | '$<' ( <-[\>]>* ) '>' {*}                            #= $< >
    | '$/' {*}                                             #= $/
    | <sigil> <ident> {*}                                  #= $var
}

token sigil { '$' }


token quote {
    <quote_literal> {*}
}


token name {
    <ident> [ '::' <ident> ]*
    {*}
}


token number { \d+ {*} }


token subcall {
    <name> '(' <EXPR>? ')'
    {*}
}



#### Expressions and operators ####

rule EXPR is optable { ... }

proto 'term:' is precedence('z=')
    is parsed(&term)
    { ... }

proto prefix:<~> is looser('term:')
    { ... }

proto prefix:<+> is equiv(prefix:<~>)
    { ... }

proto infix:<+> is looser(prefix:<~>)
    is pirop('add')
    { ... }

proto infix:<,> is looser(infix:<+>)
    is assoc('list')
    { ... }
