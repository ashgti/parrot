#!/usr/bin/perl -w
#
# jakoc - compile a Jako source file Parrot assembly file.
#
# by Gregor N. Purdy <gregor@focusresearch.com>
#
# Copyright (C) 2001-2003 Gregor N. Purdy. All rights reserved.
# This program is free software. It is subject to the same license
# as Perl itself.
#
# $Id$
#

use strict;

use Carp;

use Jako::Compiler::Message; # $source_file, $line, $debug
use Jako::Parser::Block;
use Jako::Parser::Identifier;

our @CARP_NOT = qw(Jako::Compiler::Message);

use FileHandle;

$debug = 1;

$|++ if $debug;

use Data::Dumper;
$Data::Dumper::Useqq  = 1;
$Data::Dumper::Terse  = 1;
$Data::Dumper::Indent = 0;

use Getopt::Std;

my %opts;
getopts('t', \%opts);

die "$0: usage: $0 <source>\n" unless @ARGV == 1;
$source_file = shift @ARGV;


#
# Global variables:
#

my %ident;   # Identifiers

my %reg_count = ( # Registers
  I => 0,
  N => 0,
  P => 0,
  S => 0
);

sub temp_reg { my $type = shift; return '$$' . $type . $reg_count{$type}++; }
sub temp_int { return temp_reg('I'); }
sub temp_num { return temp_reg('N'); }
sub temp_str { return temp_reg('S'); }

my %type_name = (
  'I' => 'int',
  'N' => 'num',
  'P' => 'obj',
  'S' => 'str',
);

my %type_code = (
  'int' => 'I',
  'num' => 'N',
  'obj' => 'P',
  'str' => 'S'
);

my %imcc_type_name = (
  I => 'int',
  N => 'float',
  P => 'PMC',
  S => 'string'
);


###############################################################################
###############################################################################
##
## Tokenizer
##
###############################################################################
###############################################################################

sub tokenize
{
  my $source_file = shift;

  my $fh = FileHandle->new($source_file);

  die "$0: IO Error. Unable to open file '$source_file' for reading.\n"
    unless $fh;

  my @tokens;

  while(<$fh>) {
    $line = $.;

    if (m{^(\s*([a-zA-Z][a-zA-Z0-9_]*)\s*:)(.*)$}) {
      push @tokens, {
        LINE    => $.,
        CLASS   => 'label',
        VALUE   => $2
      };
  
      $_ = $3;
    }

    while (defined $_ and $_ ne '') {
      next if s{^\s+}{};
      next if s{^#.*?$}{};

      #
      # Numeric literals:
      #

      if (m{^(-?[0-9]+\.[0-9]+)($|\W.*$)}x) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'literal',
          TYPE    => 'N',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      #
      # Integer literals:
      #

      if (m{^( 0 | (-?[1-9][0-9]*))($|\W.*$)}x) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'literal',
          TYPE    => 'I',
          VARIANT => 'dec',
          VALUE   => $1
        };

        $_ = $3;
        next;
      }

      if (m{^( 0x[0-9a-fA-F]+ )($|\W.*$)}x) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'literal',
          TYPE    => 'I',
          VARIANT => 'hex',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      #
      # String literals:
      #

      if (m{^((?:\'(?:\\\'|(?!\').)*\'))(.*)$}) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'literal',
          TYPE    => 'S',
          VARIANT => 'single',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      if (m{^((?:\"(?:\\\"|(?!\").)*\"))(.*)$}) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'literal',
          TYPE    => 'S',
          VARIANT => 'double',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      #
      # Declarators:
      #

      if (m{^(sub)(?!\w)(.*)$}) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'decl',
          VARIANT => 'code',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      if (m{^(var|const)(?!\w)(.*)$}) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'decl',
          VARIANT => 'data',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      #
      # Type:
      #

      if (m{^(int|num|obj|str)(?!\w)(.*)$}) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'type',
          VALUE   => $1,
          TYPE    => $1 eq 'obj' ? 'P' : uc substr($1, 0, 1)
        };

        $_ = $2;
        next;
      }

      #
      # Separating:
      #

      if (m{^([,])(.*)$}) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'sep',
          VARIANT => 'expr',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      if (m{^([;])(.*)$}) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'sep',
          VARIANT => 'stmt',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      #
      # Grouping:
      #

      if (m{^([\(\)])(.*)$}) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'group',
          VARIANT => 'paren',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      if (m{^([\[\]])(.*)$}) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'group',
          VARIANT => 'bracket',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      if (m{^([\{\}])(.*)$}) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'group',
          VARIANT => 'brace',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      #
      # Control:
      #

      if (m{^(if|else|elsif|unless)(?!\w)(.*)$}) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'control',
          VARIANT => 'cond',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      if (m{^(while|until|for|continue)(?!\w)(.*)$}) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'control',
          VARIANT => 'iter',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      if (m{^(next|last|redo|goto|return)(?!\w)(.*)$}) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'control',
          VARIANT => 'other',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      #
      # Ops:
      #

      if (m{^( == | >= | <= | != | < | > )(.*)$}x) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'op',
          VARIANT => 'rel',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      if (m{^( = )(.*)$}x) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'op',
          VARIANT => 'assign',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      if (m{^( \+= | \*= | -= | /= | %= )(.*)$}x) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'op',
          VARIANT => 'arith_assign',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      if (m{^( \+\+ | -- | \+ | - | \* | / | % )(.*)$}x) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'op',
          VARIANT => 'arith',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }

      #
      # Identifiers:
      #

      if (m{^([a-zA-Z][a-zA-Z0-9_]*)(.*)$}) {
        push @tokens, {
          LINE    => $.,
          CLASS   => 'ident',
          VALUE   => $1
        };

        $_ = $2;
        next;
      }
   
      #
      # Anything else is a syntax error:
      #

      PARSE_ERROR("Unrecognized text '$_'.");
    }
  }

  return @tokens;
}


#
# dump_token()
#

sub dump_token
{
  my $token = shift;
  return unless $token;

  print STDERR "{\n";
  foreach my $key (sort keys %$token) {
    printf STDERR "%10s => %s\n", $key, $token->{$key};
  }
  print STDERR "}\n";
}


###############################################################################
###############################################################################
##
## The Block Stack
##
##   $block_count         The total number of blocks begun (used for labels)
##   @block_stack         The stack of active blocks. We keep a block on the
##                          stack for the file scope.
##
## NOTE: Do NOT access the block stack directly. Access it via routines in
## this section of code.
##
###############################################################################
###############################################################################

my $anon_block_count = 0;
my $block_count      = 0;
my @block_stack;

my $root_block = Jako::Parser::Block->new(
  undef,  # No parent
  'file', # File scope
  undef,  # No return type
  undef   # No prefix
);

push @block_stack, $root_block;


#
# block_depth()
#
# Block depth zero is when the only block on the block stack is the file
# scope block. Therefore, we return one less than the number of blocks on
# the stack.
#

sub block_depth
{
  return scalar(@block_stack - 1);
}


#
# current_block()
#
# Returns the block on the top of the block stack.
#

sub current_block
{
  INTERNAL_ERROR("Attempt to reference top block with empty block stack!")
    if @block_stack == 0;

  return  $block_stack[-1];
}


#
# push_block()
#
# Push a block on the top of the block stack.
#

sub push_block
{
  push @block_stack, shift;
}


#
# pop_block()
#
# Pop the top block off the block stack and return it. Bounds checks the block
# stack to make sure we don't pop off the file scope block.
#

sub pop_block
{
  INTERNAL_ERROR("Attempt to pop file-scope block off block stack!")
    if @block_stack == 1;

  return pop @block_stack;
}


#
# find_ident()
#
# Scans through the block stack, from the top down, looking for the identifier.
# If it is found, returns a hashref containing the number of levels away the
# identifier is declared and the definition of the identifier.
#

sub find_ident
{
  my ($name) = @_;

  my $count = 0;

  foreach my $block (reverse @block_stack) {
    my $ident = $block->identifier($name);
    return { LEVELS => $count, IDENT => $ident } if $ident;
    $count++;
  }

  return undef;
}


#
# find_block()
#
# Scans through the block stack, from the top down, looking for a block of
# the appropriate kind (and, if label is given, with a matching label. If
# it is found, returns a hashref containing the number of levels away the
# block was found and the block info hashref. If it is not found, then
# undef is returned.
#

sub find_block
{
  my ($kind, $label) = @_;

  my $count = 0;

  foreach my $block (reverse @block_stack) {
    next unless $block->kind eq $kind;
    next unless !defined($label) or $block->prefix eq $label;
 
    return { LEVELS => $count, BLOCK => $block };
  }

  return undef;
}


###############################################################################
###############################################################################
##
## Miscellany
##
###############################################################################
###############################################################################

my %subs;

my %void_functions = (

);

my %assign_funcs = (
  acos   => [ 'N',    1, '[IN]'     ],
  and    => [ 'I',    2, 'II'       ],
  asec   => [ 'N',    1, '[IN]'     ],
  asin   => [ 'N',    1, '[IN]'     ],
  atan   => [ 'N',    1, '[IN]'     ],
  atan2  => [ 'N',    2, '[IN][IN]' ],
  cos    => [ 'N',    1, '[IN]'     ],
  cosh   => [ 'N',    1, '[IN]'     ],
  exp    => [ 'N',    1, '[IN]'     ],
  ln     => [ 'N',    1, '[IN]'     ],
  log10  => [ 'N',    1, '[IN]'     ],
  log2   => [ 'N',    1, '[IN]'     ],
  not    => [ 'I',    1, 'I'        ],
  or     => [ 'I',    2, 'II'       ],
  pow    => [ 'N',    2, '[IN][IN]' ],
  sec    => [ 'N',    1, '[IN]'     ],
  sech   => [ 'N',    1, '[IN]'     ],
  sin    => [ 'N',    1, '[IN]'     ],
  sinh   => [ 'N',    1, '[IN]'     ],
  substr => [ 'S',    3, 'SII'      ],
  tan    => [ 'N',    1, '[IN]'     ],
  tanh   => [ 'N',    1, '[IN]'     ],
  time   => [ '[IN]', 0             ],
  xor    => [ 'I',    2, 'II'       ],
);


#
# Regular Expressions:
#
# NOTE: These are not in use right now.
#

my $t_ident   = qr{[A-Za-z][A-Za-z0-9_]*};
my $t_integer = qr{-?\d+};
my $t_string  = qr{\"[^\\\"]*(?:\\.[^\\\"]*)*\"};
my $t_number  = qr{-?\d+\.\d+};


###############################################################################
###############################################################################
##
## Assembly Code Output
##
###############################################################################
###############################################################################


#
# push_label()
#
# Used to push a label onto a stack of labels that will get
# printed at the beginning of the next emit_code() call.
#
# Actually, pushes as many labels as there are arguments.
#

my @label_stack = ( );

sub push_label
{
  push @label_stack, grep { defined $_ and $_ ne '' } @_;
}


#
# push_comment()
#
# Used to push a comment onto a stack of comments that will get
# printed at the beginning of the next emit_code() call.
#
# Actually, pushes as many comments as there are arguments.
#

my @comment_stack = ( );

sub push_comment
{
  push @comment_stack, grep { defined $_ and $_ ne '' } @_;
}


#
# push_source()
#
# Used to push source code comments. This allows them to be
# indented.
#

sub push_source
{
  my $block_indent = '  ' x block_depth();
  push_comment map { $block_indent . $_ } @_;
}


#
# emit_code()
#
# emit_code LABEL
# emit_code LABEL OP
# emit_code LABEL OP ARGS
# emit_code LABEL OP ARGS COMMENT
#
# Label can be undef.
#

my $last_op = 'noop';

sub emit_code
{
  my ($op, $args, $comment) = @_;

  #
  # Incorporate any comments into the comment stack:
  #

  push_comment($comment) if defined $comment and $comment ne '';
  $comment = undef;

  #
  # Complain about any undefined arguments:
  #

  if (defined $args and grep { !defined $_ } @$args) {
    INTERNAL_ERROR("Undefined arguments to emit_code()!");
    return;
  }

  #
  # Print out all but the last comment, each on a line by itself:
  #
  # NOTE: As of 2001-09-20, the assembler doesn't handle lines with
  # only a label and a comment. So, we write these out separately.
  #

  $comment = pop @comment_stack if @comment_stack;

  foreach my $comment (@comment_stack) {
    printf "%-16s %-8s %-25s # %s\n", '', '', '', $comment;
  }

  @comment_stack = ( );

  #
  # Print out all but the last label, each on a line by itself:
  #

  my $label = pop @label_stack if @label_stack;

  foreach my $label (@label_stack) {
    print "$label:\n";
  }

  @label_stack = ( );

  #
  # Print out the label for the actual code line (if any):
  #

  if (defined $label and $label ne '') {
    printf "%-16s ", "$label:";
  } else {
    printf "%-16s ", '';
  }

  #
  # Print out the op mnemonic, if any:
  #

  if (defined $op) {
    printf "%-8s", $op;
    $last_op = $op;
  } else {
    printf "%-8s", '';
  }

  #
  # Print out the arguments, if any:
  #

  if (defined $args and @$args) {
    printf " %-25s", join(", ", map { s/^\$//; $_ } @$args);
  } else {
    printf " %-25s", '';
  }

  #
  # Print out the comment, if any:
  #

  if (defined $comment) {
    printf(" # %s", $comment) if defined $comment;
  }

  #
  # End the line like a good text generator:
  #

  print "\n";
}


###############################################################################
###############################################################################
##
## Typing Predicates
##
## These are used throughout the code to check the type of an argument.
##
###############################################################################
###############################################################################


#
# int_lit_q()
#

sub int_lit_q
{
  my ($value) = @_;
  return $value =~ m/^-?\d+$/;
}


#
# num_lit_q()
#

sub num_lit_q
{
  my ($value) = @_;
  return $value =~ m/^-?\d+\.\d+$/;
}


#
# int_or_num_lit_q()
#

sub int_or_num_lit_q
{
  my ($value) = @_;
  return int_lit_q($value) || num_lit_q($value);
}


#
# str_lit_q()
#

sub str_lit_q
{
  my ($value) = @_;
  return $value =~ m/^"/;
}


#
# lit_q()
#

sub lit_q
{
  my ($value) = @_;
  return str_lit_q($value) || int_lit_q($value) || num_lit_q($value);
}


#
# int_reg_q()
#

sub int_reg_q
{
  my ($value) = @_;
  return $value =~ m/^(\$\$)?I\d+$/;
}


#
# num_reg_q()
#

sub num_reg_q
{
  my ($value) = @_;
  return $value =~ m/^(\$\$)?N\d+$/;
}


#
# obj_reg_q()
#

sub obj_reg_q
{
  my ($value) = @_;
  return $value =~ m/^(\$\$)?P\d+$/;
}


#
# str_reg_q()
#

sub str_reg_q
{
  my ($value) = @_;
  return $value =~ m/^(\$\$)?S\d+$/;
}


#
# reg_q()
#

sub reg_q
{
  my ($value) = @_;
  return $value =~ m/^(\$\$)?[INPS]\d+$/;
}


#
# var_q()
#

sub var_q
{
  my ($value) = @_;
  return $value =~ m/^\$[^\$]/;
}



#
# class_of()
#

sub class_of
{
  my $value = shift;

  return 'reg' if reg_q($value);
  return 'var' if var_q($value);
  return 'lit' if lit_q($value);

  INTERNAL_ERROR("Cannot determine class of '$value'!");
}


#
# type_of()
#

sub type_of
{
  my $value = shift;

  return substr($value, 2, 1) if reg_q($value);

  if ($value =~ m/^\$\$([INPS])\d+$/) { # IMCC "VIRTUAL" REGISTERS ($$I99 to jakoc, $I99 to imcc)
    return $1;
  }

  return 'S' if str_lit_q($value);
  return 'N' if num_lit_q($value);
  return 'I' if int_lit_q($value);

  if ($value =~ m/^[a-zA-Z_][a-zA-Z0-9_]*$/) {
    my $block = current_block();
    my $ident = $block->find_identifier($value);
    INTERNAL_ERROR("Cannot find identifier '$value' to determine type!") unless defined $ident;
    return $ident->type;
  }

  INTERNAL_ERROR("Cannot determine type of '$value'!");
}

sub int_q { return type_of(shift) eq 'I'; }
sub num_q { return type_of(shift) eq 'N'; }
sub str_q { return type_of(shift) eq 'S'; }

sub int_or_num_q { my $type = type_of(shift); return $type eq 'I' or $type eq 'N'; }


###############################################################################
###############################################################################
##
## Operation Support
##
###############################################################################
###############################################################################


#
# op_comp()
#
# There are three kinds of entries in the %comp_ops hash:
#
#   * Perl expressions to optimize all-constant ops to branches.
#
#   * Entries to map source tokens to the op name. This is used
#     in parsing conditionals.
#
#   * Entries to determine the opposite comparison operator if
#     we need to reverse the sense of the operator as it appears
#     in the source.
#
# TODO: Handle numeric comparisons, too!
#

my %comp_ops = (
  'eq' => sub { $_[0] == $_[1] },
  'ne' => sub { $_[0] != $_[1] },
  'le' => sub { $_[0] <= $_[1] },
  'lt' => sub { $_[0] <  $_[1] },
  'ge' => sub { $_[0] >= $_[1] },
  'gt' => sub { $_[0] >  $_[1] },

  '==' => 'eq',
  '!=' => 'ne',
  '<=' => 'le',
  '<'  => 'lt',
  '>=' => 'ge',
  '>'  => 'gt',

  '!eq' => 'ne',
  '!ne' => 'eq',
  '!le' => 'gt',
  '!lt' => 'ge',
  '!ge' => 'lt',
  '!gt' => 'le',
);

sub op_comp
{
  my ($type, $op, $a, $b, $true, $false) = @_;

  $op = $comp_ops{$op} unless ref $comp_ops{$op}; # Map, e.g., '>=' to 'ge'

  #
  # OPTIMIZE const-const comparisons to unconditional branches:
  #

  if (int_or_num_lit_q($a) and int_or_num_lit_q($b)) {
    if (&{$comp_ops{$op}}($a, $b)) {
      emit_code('branch', [$true]);
    } else {
      emit_code('branch', [$false]);
    }

    return;
  }

  #
  # CONVERT const-reg comparisons to reg-const comparisons:
  #
  # We do this by reversing the operand order and inverting the comparison.
  #

  if (int_or_num_lit_q($a) and reg_q($b)) {
    ($a, $op, $b) = ($b, $comp_ops{"!$op"}, $a);
  }

  #
  # CONVERT num-int and int-num comparisons to num-num comparisons:
  #

  my $a_type = type_of($a);
  my $b_type = type_of($b);

  if (int_or_num_lit_q($b)) {
    #
    # reg-const comparisons:
    #
    # NOTE: We count on the assembler to promote the integer constant
    # in the case of num-reg-to-int-const comparisons.
    #

    if ($a_type eq 'I' and num_q($b)) {
      my $temp = temp_num();
      emit_code('set', [$temp, $a]);
      $a = $temp;
    }
  } else {
    #
    # reg-reg comparisons:
    #

    if ($a_type ne $b_type) {
      if ($a_type eq 'I') {
        my $temp = temp_num();
        emit_code('set', [$temp, $a]);
        $a = $temp;
      } elsif ($b_type eq 'I') {
        my $temp = temp_num();
        emit_code('set', [$temp, $b]);
        $b = $temp;
      } else {
        INTERNAL_ERROR("Expected to have to use iton op.");
      }
    }
  }

  #
  # EMIT code:
  #

  if (defined $true) {
    emit_code($op, [$a, $b, $true]);
    if (defined $false) {
      emit_code('branch', [$false]);
    }
  } else {
    if (defined $false) {
      op_comp($type, $comp_ops{"!$op"}, $a, $b, $false, $true);
    } else {
      INTERNAL_ERROR("op_comp called without any destinations!");
    }
  }
}


#
# op_eq()
#
# Handle a 'eq' op. This includes pseudo-ops for cases that aren't covered in
# by Parrot, such as comparing a register to constant.
#
# eq_i_i    # TRUE op
# eq_i_ic   # PSEUDO op
# eq_ic_i   # PSEUDO op
# eq_ic_ic  # OPTIMIZED to non-conditional branch
#
# TODO: Handle numeric and string comparisons
#

sub op_eq
{
  my ($label, $a, $b, $le, $gt) = @_;
  push_label($label);
  op_comp(undef, 'eq', $a, $b, $le, $gt);
}


#
# op_ne()
#
# Handle a 'ne' op. This includes pseudo-ops for cases that aren't covered in
# by Parrot, such as comparing a register to constant.
#
# ne_i_i    # TRUE op
# ne_i_ic   # PSEUDO op
# ne_ic_i   # PSEUDO op
# ne_ic_ic  # OPTIMIZED to non-conditional branch
#
# TODO: Handle numeric and string comparisons
#

sub op_ne
{
  my ($label, $a, $b, $le, $gt) = @_;
  push_label($label);
  op_comp(undef, 'ne', $a, $b, $le, $gt);
}


#
# op_le()
#
# Handle a 'le' op. This includes pseudo-ops for cases that aren't covered in
# by Parrot, such as comparing a register to constant.
#
# le_i_i    # TRUE op
# le_i_ic   # PSEUDO op
# le_ic_i   # PSEUDO op
# le_ic_ic  # OPTIMIZED to non-conditional branch
#
# TODO: Handle numeric and string comparisons
#

sub op_le
{
  my ($label, $a, $b, $le, $gt) = @_;
  push_label($label);
  op_comp(undef, 'le', $a, $b, $le, $gt);
}


#
# op_lt()
#
# Handle a 'lt' op. This includes pseudo-ops for cases that aren't covered in
# by Parrot, such as comparing a register to constant.
#
# lt_i_i    # TRUE op
# lt_i_ic   # PSEUDO op
# lt_ic_i   # PSEUDO op
# lt_ic_ic  # OPTIMIZED to non-conditional branch
#
# TODO: Handle numeric and string comparisons
#

sub op_lt
{
  my ($label, $a, $b, $le, $gt) = @_;
  push_label($label);
  op_comp(undef, 'lt', $a, $b, $le, $gt);
}


#
# op_ge()
#
# Handle a 'ge' op. This includes pseudo-ops for cases that aren't covered in
# by Parrot, such as comparing a register to constant.
#
# ge_i_i    # TRUE op
# ge_i_ic   # PSEUDO op
# ge_ic_i   # PSEUDO op
# ge_ic_ic  # OPTIMIZED to non-conditional branch
#
# TODO: Handle numeric and string comparisons
#

sub op_ge
{
  my ($label, $a, $b, $le, $gt) = @_;
  push_label($label);
  op_comp(undef, 'ge', $a, $b, $le, $gt);
}


#
# op_gt()
#
# Handle a 'gt' op. This includes pseudo-ops for cases that aren't covered in
# by Parrot, such as comparing a register to constant.
#
# gt_i_i    # TRUE op
# gt_i_ic   # PSEUDO op
# gt_ic_i   # PSEUDO op
# gt_ic_ic  # OPTIMIZED to non-conditional branch
#
# TODO: Handle numeric and string comparisons
#

sub op_gt
{
  my ($label, $a, $b, $le, $gt) = @_;
  push_label($label);
  op_comp(undef, 'gt', $a, $b, $le, $gt);
}



###############################################################################
###############################################################################
##
## Identifier Declarations
##
###############################################################################
###############################################################################


#
# declare_var()
#
# Assign a register to the identifier within the scope of the current block.
#
# Access is one of 'const', 'var' or 'arg'.
#

sub declare_var
{
  my ($name, $type, $access) = @_;

  #
  # Check for a few bad conditions.
  #
  # NOTE: These are compiler internal consistency checks. They really should not be
  # triggered in normal operation, even with bad source code as input.
  #

  my $type_name = $type_name{$type};

  INTERNAL_ERROR("Variable declaration involves undefined access!")
    unless defined $access;

  INTERNAL_ERROR("Variable declaration involves undefined type code!")
    unless defined $type;

  INTERNAL_ERROR("Variable declaration involves undefined type name!")
    unless defined $type_name;

  INTERNAL_ERROR("Variable declaration involves undefined variable name!")
    unless defined $name;

  #
  # Lookup the identifier:
  #

  my $block = current_block();

  my $ident = $block->find_identifier($name);

  #
  # If the identifier is already defined at this lexical scope, we want to complain
  # about the redefinition. Otherwise, we assume the programmer wanted to shadow the
  # previous definition.
  #

  if (defined $ident and $ident->block eq $block) {
    SYNTAX_ERROR("Redeclaration of identifier '%s'. Previous declaration on line %d.",
      $name, $ident->line);
  }

  #
  # Now that we've decided to actually declare the variable, we will place its
  # definition into the block at the top of the block stack. First, we assign
  # it a register number, then we fill in the IDENT entry within the block,
  # and then we link the register to the identifier and the block.
  #

  $ident = Jako::Parser::Identifier->new(
    $block,
    $access,
    $type,
    $name,
    $source_file,
    $line,
    "\$$name"     # IMCC Name
  );

  $block->identifier($name, $ident);

  #
  # Push the source comment about the variable declaration.
  #

  push_source "var $type_name{$type} $name;";

  my $imcc_type = $imcc_type_name{$type};

  emit_code(".local", [ "$imcc_type $name" ]);

  return 1;
}


#
# declare_const()
#

sub declare_const
{
  my ($name, $type, $value) = @_;

  #
  # Check for a few bad conditions.
  #
  # NOTE: These are compiler internal consistency checks. They really should not be
  # triggered in normal operation, even with bad source code as input.
  #

  my $type_name = $type_name{$type};

  INTERNAL_ERROR("Constant definition involves undefined type code!")
    unless defined $type;

  INTERNAL_ERROR("Constant definition involves undefined type name!")
    unless defined $type_name;

  INTERNAL_ERROR("Constant definition involves undefined constant name!")
    unless defined $name;

  INTERNAL_ERROR("Constant definition involves undefined value!")
    unless defined $value;

  #
  # Lookup the identifier:
  #
  # NOTE: This lookup doesn't give the info itself, but rather a hashref with
  # the LEVELS away the definition was found, and IDENT with the actual info
  # about the identifier.
  #

  my $block = current_block();

  my $ident = $block->find_identifier($name);

  #
  # If the identifier is already defined at this lexical scope, we want to complain
  # about the redefinition. Otherwise, we assume the programmer wanted to shadow the
  # previous definition.
  #

  if (defined $ident and $ident->block eq $block) {
    SYNTAX_ERROR("Redeclaration of identifier '%s'. Previous declaration on line %d.",
      $name, $ident->line);
  }

  #
  # Now that we've decided to actually declare the constant, we will place its
  # definition into the block at the top of the block stack. We fill in the
  # IDENT entry within the block.
  #

  $ident = Jako::Parser::Identifier->new(
    $block,
    'const',
    $type,
    $name,
    $source_file,
    $line
  );

  $block->identifier($name, $ident);

  #
  # Push the source comment about the constant definition and
  # emit the code to assign a value.
  #

  push_source "const $type_name $name = $value;";

  my %imcc_types = ( I => 'int', N => 'float', P => 'PMC', S => 'string');
  my $imcc_type = $imcc_types{$type};

  emit_code(".local", [ "$imcc_type $name" ]);
  emit_code("$name =", [ $value ]);

  return 1;
}


###############################################################################
###############################################################################
##
## Variable Assignments
##
###############################################################################
###############################################################################


#
# assign_var()
#

sub assign_var
{
  my ($name, $type, $value) = @_;

  #
  # Lookup the identifier:
  #
  # NOTE: This lookup doesn't give the info itself, but rather a hashref with
  # the LEVELS away the definition was found, and IDENT with the actual info
  # about the identifier.
  #

  my $block = current_block();

  my $ident = $block->find_identifier($name);

  #
  # Reject cases where LHS isn't declared:
  #

  SYNTAX_ERROR("Assignment to undeclared variable '%s'.", $ident)
    unless defined $ident;

  #
  # Now that we've confirmed we could find the identifier, we make sure it is
  # bound to a variable, not a constant.
  #

  SYNTAX_ERROR("Cannot assign to constant '%s'.", $name)
    unless $ident->is_variable;

  #
  # Remember the source code:
  #

  push_source "$name = $value;";

  #
  # Handle var-const (for manifest constants) assignments:
  #
  # int_var = 1;
  # num_var = 2.0;
  # str_var = "foo";
  #

  if ($ident->type eq $type) {
    emit_code("$name =", [ $value ]);
    return;
  }

  #
  # Catch incompatible assigns:
  #

  SYNTAX_ERROR("Assignment of '%s' variable from '%s' value not allowed.", $ident->type, $type)
    if $type ne '*';

  #
  # If what remains is not an identifier we've seen, we've got trouble:
  #

  my $value_ident = $block->find_identifier($value);

  SYNTAX_ERROR("Assignment from undeclared identifier '%s'.", $value)
    unless defined $value_ident;

  INTERNAL_ERROR("Undefined name for identifier (%s)!", join(", ", %$value_ident))
    unless defined $value_ident->name;

  #
  # Emit code if the types are the same:
  #

  if ($ident->type eq $value_ident->type) {
    emit_code("$name =", [ $value_ident->name ]);
    return;
  }

  #
  # Handle conversion cases:
  #

  if ($ident->type eq "N" and $value_ident->type eq "I") {
    emit_code("$name =", [ $value_ident->name ]);
  } elsif ($ident->type eq "I" and $value_ident->type eq "N") {
    emit_code("$name =", [ $value_ident->name ]);
  } else {
    SYNTAX_ERROR("Cannot assign type '%s' to type '%s'.", $value_ident->type, $ident->type);
  }

  return;
}


#
# new_obj()
#

sub new_obj
{
  my ($ident, $class) = @_;

  #
  # Lookup the identifier:
  #
  # NOTE: This lookup doesn't give the info itself, but rather a hashref with
  # the LEVELS away the definition was found, and IDENT with the actual info
  # about the identifier.
  #

  my $ident_info = find_ident($ident);

  #
  # Reject cases where LHS isn't a variable (either it is undeclared or a constant):
  #

  unless (defined $ident_info) {
    SYNTAX_ERROR("Assignment to undeclared variable '%s'.", $ident);
  }

  $ident_info = $ident_info->{IDENT};

  #
  # Now that we've confirmed we could find the identifier, we make sure it is
  # bound to a variable, not a constant.
  #

  if ($ident_info->{CLASS} eq 'const') {
    SYNTAX_ERROR("Cannot assign to constant '%s'.", $ident);
  }

  #
  # Now that we've confirmed its not a constant, we make sure it is an object
  # type
  #

  if ($ident_info->{TYPE} ne 'P') {
    SYNTAX_ERROR("Cannot store new object in non-object variable '%s'.", $ident);
  }

  #
  # Remember the source code:
  #

  push_source "$ident = new $class";

  #
  # Emit the new code:
  #

  emit_code('new', [$ident_info->{VALUE}, $class]);

  return;
}


###############################################################################
###############################################################################
##
## Argument Handling
##
###############################################################################
###############################################################################


#
# map_args()
#

sub map_args
{
  my (@args) = @_;
  my @result;

  foreach my $arg (@args) {
    INTERNAL_ERROR("map_args(): Undefined argument in array!") unless defined $arg;

    $arg =~ s/^\s+//;
    $arg =~ s/\s+$//;

    if (lit_q($arg)) {
      push @result, $arg;
    }
    elsif (reg_q($arg)) {
      push @result, substr($arg, 1, );
    }
    else {
      my $arg_ident_info = find_ident($arg);

      if (defined $arg_ident_info) {
        $arg_ident_info = $arg_ident_info->{IDENT};

        INTERNAL_ERROR("Unable to fetch value for identifier '$arg'!")
          unless defined $arg_ident_info->{VALUE};

        push @result, $arg_ident_info->{VALUE};
      } else {
        INTERNAL_ERROR("Unrecognized argument '%s'.", $arg);
      }
    }
  }

  return @result;
}


###############################################################################
###############################################################################
##
## Function Calls
##
###############################################################################
###############################################################################


#
# void_func()
#

sub void_func
{
  my ($name, @args) = @_;

  push_source "$name(...);";

  @args = map { str_lit_q($_) ? interpolate_string($_) : $_ } @args;

  if ($name eq 'print') {
    foreach my $arg (@args) {
      emit_code('print', [$arg]);
    }
  } elsif ($name eq 'sleep') {
    emit_code('sleep', [ shift @args ]); # TODO: Really need to complain if > 1 arg.
  } elsif (exists $subs{$name}) {
    #
    # First, we make sure everything is in order for the call:
    #

    WARNING("Call to non-void function %s in void context.", $name)
      if defined $subs{$name}{RETURN};

    #
    # Now, we have to push (save) the arguments onto the stack in reverse
    # order. That way they can be pulled off by the subroutine in declaration
    # order, which will be convenient later for handling variable argument
    # subroutines.
    #

    foreach my $arg (reverse @args) {
      emit_code('.arg', [ $arg ]);
    }

    emit_code "call", [ "_$name" ];

  } else {
    SYNTAX_ERROR("Call to unrecognized void function '%s' (Not in {%s}).",
      $name, join(", ", sort keys %subs));
  }
}


#
# assign_func()
#

sub assign_func
{
  my ($dest, $name, @args) = @_;

  push_source "$dest = $name(" . join(", ", @args) . ");";

#  ($dest, @args) = map_args($dest, @args);

  if ($assign_funcs{$name}) {
    emit_code($name, [$dest, @args]);
  } elsif (exists $subs{$name}) {
    #
    # First, we make sure everything is in order for the call:
    #

    WARNING("Call to void function %s in non-void context.", $name)
      unless defined $subs{$name}{RETURN};

    my $dest_type   = type_of($dest);
    my $return_type = uc $subs{$name}{RETURN};

    WARNING("Type mismatch in destination type (%s) and call to %s (returns %s).", $dest_type, $name, $return_type)
      if $dest_type ne $return_type;

    #
    # Now, we have to push (save) the arguments onto the stack in reverse
    # order. That way they can be pulled off by the subroutine in declaration
    # order, which will be convenient later for handling variable argument
    # subroutines.
    #
    # Arguments that are already in registers are easy. Constant arguments
    # have to be placed in the appropriate zero (temporary) register and then
    # saved.
    #

    foreach my $arg (reverse @args) {
      emit_code('.arg', [ $arg ]);
    }

    #
    # Now, we can jump to the subroutine's entry point:
    #

    emit_code('call', [ "_$name" ]);

    #
    # Our calling convention dictates that upon return from the subroutine,
    # the result will be on the top of the stack.
    #

    emit_code('.result', [ $dest ]);
  } else {
    SYNTAX_ERROR("Call to unrecognized assign function '%s' (Not in {%s}).",
      $name, join(", ", sort keys %assign_funcs));
  }
}


###############################################################################
###############################################################################
##
## Block Handling
##
###############################################################################
###############################################################################


#
# begin_cond_block()
#

sub begin_cond_block
{
  my ($block, $prefix, $type, $left, $relop, $right) = @_;

  DEBUG(0, "Begining cond block '%s'...", $prefix || '');

#  my $next   = $block_types{$type}{NEXT};
#  my $redo   = $block_types{$type}{REDO};
#  my $last   = $block_types{$type}{LAST};

  push_source "$prefix: $type ($left $relop $right) {";

  push_label "${prefix}_" . uc $type;

  if ($type eq 'while') {
    push_label "${prefix}_NEXT";
  } elsif ($type eq 'if') {
    push_label "${prefix}_TEST";
  } else {
    INTERNAL_ERROR("Unrecognized conditional block type '$type'");
  }

  if ($type eq 'while') {
    op_comp($type, $relop, $left, $right, undef, "${prefix}_LAST");
  } elsif ($type eq 'if') {
    op_comp($type, $relop, $left, $right, undef, "${prefix}_ELSE");
  }

  push_label "${prefix}_REDO";
}


#
# begin_sub_block()
#

sub begin_sub_block
{
  my ($block, $name, $return_type, @formal_args) = @_;

  #
  # Flush any pending comments or labels.
  #

  emit_code();

  #
  # Generate the source code comment for the assembly listing.
  #

  my $arg_source = join(', ', map({ join(' ', @$_) } @formal_args));

  if (defined $return_type) {
    push_source "sub $type_name{$return_type} $name ($arg_source) {";
  } else {
    push_source "sub $name ($arg_source) {";
  }

  #
  # Emit code to jump over the subroutine.
  #
  # NOTE: We do this because we don't have a calling convention for starting
  # the program anywhere other than the first byte code op. Therefore, since
  # subroutines have to be defined before being called, the main program
  # will be at the end of the file, and we need to jump over the subroutines
  # to get there.
  #
  # This also implies that we can actually have code interspersed with
  # subroutine definitions just like Perl.
  #

  push_label "${name}_BEFORE";
  emit_code 'branch', [ "${name}_AFTER" ];

  #
  # Here we have the actual subroutine entry point:
  #

  push_label "_$name";
  push_label "${name}_ENTER";
  emit_code();

  #
  # Record the subroutine information.
  #
  # We track the line number of definition, the return type, and the info
  # about the formal arguments.
  #

  $subs{$name} = {
    LINE   => $line,
    RETURN => $return_type,
    ARGS   => \@formal_args
  };

  $block->{RETURN}    = $return_type;

  #
  # Declare the formal arguments as variables:
  #
  # We need to have registers assigned to the formal arguments just like we do
  # for any other variable, and they need to go out of scope at the end of the
  # subroutine, so we put them through the standard variable declaration
  # procedure.
  #
  # TODO: When we make declared variables auto-initialize to zero, this will
  # be inefficient, since we are going to grab the value from the stack as
  # our next step. So eventually, we'll want an internal way to declare the
  # variable uninitialized without having it auto initialize to zero.
  #

  foreach my $formal_arg (@formal_args) {
    my ($arg_type, $arg_name) = @$formal_arg;

    declare_var($arg_name, uc substr($arg_type, 0, 1), 'arg');
  }

  #
  # Generate code to load the arguments into their registers:
  #
  # First, we pop the argument count off the top of the stack, then we pop the
  # arguments off the stack.
  #
  # NOTE: We restore them in their order of declaration, which means they must
  # be saved in reverse order. This will come in handy later for being able to
  # handle variable numbers of arguments, since we'll be able to restore an
  # arg count before having to restore the variable args themselves.
  #
  # TODO: Should we bother checking that argc is what we expected?
  #

  foreach my $formal_arg (@formal_args) {
    my ($arg_type, $arg_name) = @$formal_arg;

    my $ident_info = find_ident($arg_name);
    $ident_info = $ident_info->{IDENT};

    push_comment "(argument " . $arg_name . ")";

    my $param_type = $imcc_type_name{$arg_type};

    emit_code '.param', [ "$param_type $arg_name" ];
  }
}


#
# begin_block()
#
# return_type is used by subroutines.
#

my %block_types = (
  'while'    => { PREFIX => "_W", NEXT => 'CONT', REDO => 'REDO', LAST => 'LAST' },
  'if'       => { PREFIX => "_I", NEXT => 'TEST', REDO => 'THEN', LAST => 'ELSE' },
  'sub'      => { PREFIX => "_S", NEXT => 'TEST', REDO => 'THEN', LAST => 'ELSE' }, # TODO: fix these
);

my %block_names = ( );

sub begin_block
{
  my ($prefix, $kind, $cond, $type, @formal_args) = @_;
  
  my ($left, $relop, $right) = @$cond if $cond;

  $block_count++;

  if (defined $prefix) {
    if ($block_names{$prefix}) {
      SYNTAX_ERROR("Loop named '%s' already defined at line %d (previously defined at line %d)!",
        $prefix, $line, $block_names{$prefix});
    }
  } else {
    $prefix = "$block_types{$kind}{PREFIX}$block_count";
  }

  $block_names{$prefix} = $line;

  my $parent = current_block();

  my $block = Jako::Parser::Block->new(
    $parent,
    $kind,
    $type,
    $prefix
  );

  push_block($block);

  emit_code(".namespace", [ (uc $block->kind) . "_BLOCK" ]);

  if ($kind eq 'if') {
    begin_cond_block($block, $prefix, $kind, $left, $relop, $right);
  } elsif ($kind eq 'while') {
    begin_cond_block($block, $prefix, $kind, $left, $relop, $right);
  } elsif ($kind eq 'sub') {
    begin_sub_block($block, $prefix, $type, @formal_args);
  } else {
    INTERNAL_ERROR("Unknown block kind '$kind' in begin_block()!");
  }
}


#
# end_block()
#
# TODO: else (and elsif?) blocks.
#

sub end_block
{
  my ($continue) = @_;

  #
  # If we are not currently 'inside' a block, then we've got no business
  # seeing a close-brace.
  #

  SYNTAX_ERROR("Closing brace without open block.")
    unless block_depth();

  #
  # Pop the block info off the block stack and cache its prefix for use
  # in what follows. At this point we are no longer 'inside' a block.
  # Although, we may re-enter the block in certain cases (see below).
  #

  my $block  = pop_block();
  my $prefix = $block->{PREFIX};

  #
  # 'while' blocks:
  #
  # When we are ending the 'while' block, we might be beginning the
  # 'continue' block, so we check for that case. The while block and
  # the continue block form one logical block, with the identifiers
  # delcared in the former available in the latter. This means that
  # semantically, the 'continue' block is really like a 'continue'
  # label, since control falls through the 'while' block into the
  # 'continue' block by default, and we get to the 'continue' block
  # via a 'next' statement in the 'while' block's body, which is
  # essentially a 'goto my_continue' statement.
  #
  # NOTE: This is different from some languages. Some languages
  # treat the continue block as a truly separate block, and the
  # identifiers declared in the 'while' portion are *not* available
  # in the 'continue' portion.
  #

  if ($block->kind eq 'while') {
    if (defined $continue) {
      if (defined $block->cont) {
        SYNTAX_ERROR("No more than one continue block allowed.");
      } else {
        $block->cont($line);
      }

      push_label "${prefix}_CONT";
      push_source "} continue {";

      push_block($block);        # Push it back on for a minute...
      undef $block;              # ... and forget about it.
    } else {
      push_source "}";
      push_label "${prefix}_CONT" unless defined $block->cont;
      emit_code('branch', ["${prefix}_NEXT"]);
      push_label "${prefix}_LAST";
    }
  }

  #
  # 'if' blocks:
  #
  # Continuation of 'if' blocks happens by $continue being 'else'. In that
  # case, we push the block back on the stack.
  #

  elsif ($block->kind eq 'if') {
    if (defined $continue) { # for 'else'
      if (defined $block->else) {
        SYNTAX_ERROR("No more than one else block allowed.");
      } else {
        $block->else = $line;
      }

      emit_code("branch", [ "${prefix}_LAST" ]); # Jump over the 'else'.
      push_label "${prefix}_ELSE";
      push_source "} else {";

      #
      # We push the block back onto the block stack, since we are
      # ending up still in a block.
      #
      # NOTE: We are not doing 'undef $block' here because we want
      # the code below to undeclare the variables from the 'if' block.
      #
      # TODO: Should we really be allocating a whole new block? Its
      # nice to reuse this one (and we set ELSE in it to know we
      # can't have *another* else continuation).
      #

      push_block($block);
    } else {
      push_source "}";
      emit_code();
      push_label "${prefix}_ELSE" unless defined $block->{ELSE};
      push_label "${prefix}_LAST";
    }
  }

  #
  # Handle the ending of subroutine blocks:
  #

  elsif ($block->kind eq 'sub') {
    push_source "}";
    push_label "${prefix}_LEAVE";

    #
    # TODO: Complain if we haven't seen 'return' statement in a
    # subroutine that returns results (else we are going to be
    # very unhappy later...)
    #

    #
    # Now, actually return.
    #

    emit_code "ret", [ ];

    push_label "${prefix}_AFTER";
#    emit_code('noop'); # XXX: Needed by IMCC
  }

  #
  # If there is any other kind of block, we have an internal compiler error.
  #

  else {
    INTERNAL_ERROR("End of unknown kind of block " . $block->kind . "!");
  }

  #
  # If $block is still defined, then we didn't push it back on the block
  # stack and we are ending the scope.
  #

  if (defined $block) {
    emit_code(".endnamespace", [ (uc $block->kind) . "_BLOCK" ]);
  }
}


###############################################################################
###############################################################################
##
## Flow Control Statements
##
###############################################################################
###############################################################################


#
# do_loop_control()
#

sub do_loop_control
{
  my ($control_op, $loop_label, $cond, $left, $test, $right) = @_;

  my $type = 'while';

  #
  # Locate the block we'll be applying the control statement to:
  #

  my $block = find_block($type, $loop_label);

  unless (defined $block) {
    if (defined $loop_label) {
      SYNTAX_ERROR("No loop '%s' in loop control.", $loop_label);
    } else {
      SYNTAX_ERROR("No loop active in loop control.");
    }

    emit_code('err');
  }

  $block = $block->{BLOCK};

  #
  # Generate the code:
  #

  my $prefix = $block->{PREFIX};
  my $which  = $block_types{$type}{uc $control_op};

  if (defined $cond) {
    push_source "$control_op ${prefix} $cond ($left $test $right)";
  } else {
    push_source "$control_op ${prefix}";
  }

  if (defined $block->{CONT} and $control_op eq 'next') {
    $which = $block_types{$type}{NEXT};      # Hard-coded to NEXT in continue { ... }
  }

  my $label = "${prefix}_$which";

  if (!defined $cond) {
    emit_code('branch', [ $label ]);
  } else {
    op_comp $cond, $test, $left, $right, $label, undef;
  }
}


#
# do_return()
#

sub do_return
{
  my ($arg) = @_;

  my $arg_type = defined $arg ? type_of($arg) : undef;

  if (defined $arg) {
    push_source "return $arg";
  } else {
    push_source "return";
  }

  #
  # Find the enclosing subroutine block:
  #

  my $block = find_block('sub');

  unless (defined $block) {
    SYNTAX_ERROR("Cannot use 'return' outside of subroutine.");
  }

  $block = $block->{BLOCK}; # find_block() returns a hash with LEVELS and BLOCK

  #
  # Generate code:
  #

  my $prefix = $block->prefix;
  my $return = $block->type;

  if (defined $return and not defined $arg_type) {
    SYNTAX_ERROR("'return' without argument in subroutine that returns a value.");
  }

  if (not defined $return and defined $arg_type) {
    SYNTAX_ERROR("'return' with argument in subroutine that does not return a value.");
  }

  #
  # Determine the type of the return value.
  #

  if (defined $arg_type and $arg_type eq '*') {
    $arg_type = type_of($arg);
  }

  #
  # Make sure what we are returning is of the appropriate type.
  #

  if (defined $return and defined $arg_type and uc $return ne uc $arg_type) {
    SYNTAX_ERROR("'return' with argument of incorrect type (got '%s', but expected '%s').",
      $arg_type, $return);
  }

  #
  # According to our calling conventions, the return value ends up on the
  # stack, below the return address so the caller can restore it off.
  #

  if (defined $return) {
     emit_code('.return', [ $arg ]);
  }

  #
  # The *_LEAVE label for the subroutine is where the assembly code to
  # actually complete the return portion of the calling convention lives.
  #

  emit_code('branch', ["${prefix}_LEAVE"]);
}


###############################################################################
###############################################################################
##
## Arithmetic Operations
##
###############################################################################
###############################################################################


#
# do_arith()
#

sub do_arith
{
  my ($dest, $a, $op, $b) = @_;

  push_source "$dest = $a $op $b;";

  #
  # Determine the type to use to calculate the result:
  #

  SYNTAX_ERROR("Cannot perform arithmetic on strings")
    if grep { $_ eq 'S' } map { type_of($_) } ($dest, $a, $b);

  my $calc_type = 'I';

  $calc_type = 'N' if grep { $_ eq 'N' } map { type_of($_) } ($dest, $a, $b);
  $calc_type = 'P' if grep { $_ eq 'P' } map { type_of($_) } ($dest, $a, $b);

  my $dest_type = type_of($dest);

  #
  # Convert the operands into the calculation type:
  #
  
  if (type_of($a) ne $calc_type) {
    my $temp = temp_reg($calc_type);
    emit_code('set', [$temp, $a]);
    $a = $temp;
  }
  
  if (type_of($b) ne $calc_type) {
    my $temp = temp_reg($calc_type);
    emit_code('set', [$temp, $b]);
    $b = $temp;
  }

  #
  # Perform the calculation:
  #

  if ($dest_type eq $calc_type) {
    emit_code("$dest =", [ "$a $op $b" ]);
  }
  else {
    my $temp = temp_reg($calc_type);
    emit_code("$temp =", [ "$a $op $b" ]);
    emit_code("$dest =", [ "$temp" ]);
  }
}


#
# do_add()
#

sub do_add
{
  my ($dest, $a, $b) = @_;
  do_arith($dest, $a, '+', $b);
}


#
# do_inc()
#

sub do_inc
{
  my ($dest, $amount) = @_;

  $amount = 1 unless defined $amount;

  if (defined $amount) {
    if (int_q($amount)) {
      push_source "$dest += $amount;";
#      ($dest, $amount) = map_args($dest, $amount);
      emit_code('add', [$dest, $amount]);
    } else {
      do_add($dest, $dest, $amount);
    }
  } else {
    push_source "$dest++;";
#    ($dest, $amount) = map_args($dest);
    emit_code('inc', [$dest]);
  }
}


#
# do_sub()
#

sub do_sub
{
  my ($dest, $a, $b) = @_;

  push_source "$dest = $a - $b;";

  ($dest, $a, $b) = map_args($dest, $a, $b);

  if (int_or_num_lit_q($a)) {
    if (int_or_num_lit_q($b)) {
      my $temp = $a - $b;
      $temp .= ".0" if (num_q($a) or num_q($b)) and not $temp =~ m/\./;
      emit_code('set', [$dest, $temp]);
    } elsif (reg_q($b) or var_q($b)) {
      if ($dest eq $b && int_q($a)) {
        emit_code('sub', [$dest, $a]);
      } else {
        my $temp = int_q($a) ? temp_int() : temp_num();
        emit_code('set', [$temp, $a]);
        emit_code('sub', [$dest, $temp, $b]);
      }
    } else {
      SYNTAX_ERROR("Can't determine type of '$b' in subtraction.");
    }
  } elsif (reg_q($a) or var_q($a)) {
    if (int_or_num_lit_q($b)) {
      if ($dest eq $a && int_q($b)) {
        emit_code('sub', [$dest, $b]);
      } else {
        my $temp = int_q($b) ? temp_int() : temp_num();
        emit_code('set', [$temp, $b]);
        emit_code('sub', [$dest, $a, $temp]);
      }
    } elsif (reg_q($b) or var_q($b)) {
      emit_code('sub', [$dest, $a, $b]);
    } else {
      SYNTAX_ERROR("Can't determine type of '$b' in subtraction.");
    }
  } else {
    SYNTAX_ERROR("Can't determine type of '$a' in subtraction.");
  }
}


#
# do_dec()
#

sub do_dec
{
  my ($dest, $amount) = @_;

  if (defined $amount) {
    if (int_q($amount)) {
      push_source "$dest -= $amount;";
#      ($dest, $amount) = map_args($dest, $amount);
      emit_code('sub', [$dest, $amount]);
    } else {
      do_sub($dest, $dest, $amount);
    }
  } else {
    push_source "$dest--;";
#    ($dest, $amount) = map_args($dest);
    emit_code('dec', [$dest]);
  }
}


#
# do_mul()
#

sub do_mul
{
  my ($dest, $a, $b) = @_;

  push_source "$dest = $a * $b;";

  ($dest, $a, $b) = map_args($dest, $a, $b);

  if (int_or_num_lit_q($a)) {
    if (int_or_num_lit_q($b)) {
      my $temp = $a * $b;
      $temp .= ".0" if (num_q($a) or num_q($b)) and not $temp =~ m/\./;
      emit_code('set', [$dest, $temp]);
    } elsif (reg_q($b) or var_q($b)) {
      my $temp = int_q($a) ? temp_int() : temp_num();
      emit_code('set', [$temp, $a]);
      emit_code('mul', [$dest, $temp, $b]);
    } else {
      SYNTAX_ERROR("Can't determine type of '$b' in multiplication.");
    }
  } elsif (reg_q($a) or var_q($a)) {
    if (int_or_num_lit_q($b)) {
      my $temp = int_q($b) ? temp_int() : temp_num();
      emit_code('set', [$temp, $b]);
      emit_code('mul', [$dest, $a, $temp]);
    } elsif (reg_q($b) or var_q($b)) {
      emit_code('mul', [$dest, $a, $b]);
    } else {
      SYNTAX_ERROR("Can't determine type of '$b' in multiplication.");
    }
  } else {
    SYNTAX_ERROR("Can't determine type of '$a' in multiplication.");
  }
}


#
# do_div()
#

sub do_div
{
  my ($dest, $a, $b) = @_;

  push_source "$dest = $a / $b;";

  ($dest, $a, $b) = map_args($dest, $a, $b);

  my $dest_type = type_of($dest);
  my $a_type    = type_of($a);
  my $b_type    = type_of($b);

  if ($dest_type ne $a_type) {
    my $temp = temp_reg($dest_type);
    emit_code('set', [$temp, $a]);
    $a = $temp;
    $a_type = $dest_type;
  }

  if ($dest_type ne $b_type) {
    my $temp = int_q($dest) ? temp_int() : temp_num();
    emit_code('set', [$temp, $b]);
    $b = $temp;
    $b_type = $dest_type;
  }

  #
  # TODO: Should we really do the calculation in N if a or b is N,
  # then convert that to I if dest is I?
  #

  if (int_or_num_lit_q($a)) {
    if (int_or_num_lit_q($b)) {
      my $temp = $a / $b;
      $temp .= ".0" if (num_q($dest) and not $temp =~ m/\./);
      emit_code('set', [$dest, $temp]);
    } elsif (reg_q($b) or var_q($b)) {
      emit_code('div', [$dest, $a, $b]);
    } else {
      SYNTAX_ERROR("Can't determine type of '$b' in division.");
    }
  } elsif (reg_q($a) or var_q($a)) {
    if (int_or_num_lit_q($b)) {
      emit_code('div', [$dest, $a, $b]);
    } elsif (reg_q($b) or var_q($b)) {
      emit_code('div', [$dest, $a, $b]);
    } else {
      SYNTAX_ERROR("Can't determine type of '$b' in division.");
    }
  } else {
    SYNTAX_ERROR("Can't determine type of '$a' in division.");
  }
}


#
# do_mod()
#
# a =  b % c
# a =  b % 4
# a = 17 % c
# a = 17 % 4
#

sub do_mod
{
  my ($dest, $a, $b) = @_;

  push_source "$dest = $a % $b;";

  ($dest, $a, $b) = map_args($dest, $a, $b);

  if (int_lit_q($a)) {
    if (int_lit_q($b)) {
      emit_code('set', [$dest, $a % $b]);
    } elsif (reg_q($b) or var_q($b)) {
      my $temp = temp_int();
      emit_code('set', [$temp, $a]);
      emit_code('mod', [$dest, $temp, $b]);
    } else {
      SYNTAX_ERROR("Can't determine type of '$b' in modulo.");
    }
  } elsif (reg_q($a) or var_q($a)) {
    if (int_lit_q($b)) {
      my $temp = temp_int();
      emit_code('set', [$temp, $b]);
      emit_code('mod', [$dest, $a, $temp]);
    } elsif (reg_q($b) or var_q($b)) {
      emit_code('mod', [$dest, $a, $b]);
    } else {
      SYNTAX_ERROR("Can't determine type of '$b' in modulo.");
    }
  } else {
    SYNTAX_ERROR("Can't determine type of '$a' in modulo.");
  }
}


#
# do_bit_and()
#

sub do_bit_and
{
  my ($dest, $a, $b) = map_args(@_);
  emit_code("band", [$dest, $a, $b]);
}


#
# do_bit_or()
#

sub do_bit_or
{
  my ($dest, $a, $b) = map_args(@_);
  emit_code("bor", [$dest, $a, $b]);
}


#
# do_shift()
#

sub do_shift
{
  my $dir = shift;
  my ($dest, $a, $amount) = map_args(@_);
  emit_code("sh$dir", [$dest, $a, $amount]);
}


###############################################################################
###############################################################################
##
## Argument Handling
##
###############################################################################
###############################################################################


#
# interpolate_string()
#
# Converts a single string argument:
#
#     "Foo $a ${b}ar\n"
#
# to multiple arguments:
#
#     "Foo ", a, " ", b, "ar ", b, "\n"
#
# to effect string interpolation.
#

sub interpolate_string
{
  my ($string) = @_;

  return $string unless $string =~ m/(^"|^".*?[^\\])\$/; # Double-quote with an unescaped '$'.

  $string = substr($string, 1, -1); # Without the surrounding double quotes.

  my $temp = temp_str();          # Allocate and clear a temporary string register
  emit_code("set", [ $temp, '""' ]);

  while (1) {
    last unless defined $string and
      $string =~ m/(^|^.*?[^\\])\$((([A-Za-z][A-Za-z0-9_]*)\b)|({[A-Za-z][A-Za-z0-9_]*}))(.*)$/;

    emit_code("concat", [ $temp, '"' . $1 . '"' ])
      if defined $1 and $1 ne '';

    my $interp = $2;
    $interp =~ s/^{(.*)}$/$1/; # Strip '{' and '}'.

    if (type_of($interp) ne 'S') {
      my $temp2 = temp_str();
      emit_code("set", [ $temp2, $interp ]);
      $interp = $temp2;
    }

    emit_code("concat", [ $temp, $interp ]);

    $string = $6;
  }

  emit_code("concat", [ $temp, '"' . $string . '"' ])
    if defined $string and $string ne '';

  return $temp;
}


#
# parse_args()
#

sub parse_args
{
  my ($args) = @_;
  my @args;

  while ($args ne '') {
    $args =~ s/^\s+//;

    if ($args =~ m/^(\"[^\\\"]*(?:\\.[^\\\"]*)*\")\s*(,\s*(.*))?$/) {
      $args = $3 || '';
      push @args, interpolate_string($1);
    } elsif ($args =~ m/^([^,]+)\s*(,\s*(.*))?$/) {
      push @args, $1;
      $args = $3 || '';
    } else {
      SYNTAX_ERROR("Cannot parse argument list '$args'");
    }
  }

  return @args;
}


###############################################################################
###############################################################################
##
## MAIN PROGRAM
##
###############################################################################
###############################################################################


#
# Tokenize the input, and possibly dump the tokens.
#

my @tokens = tokenize($source_file);

if ($opts{t}) {
  foreach my $tok (@tokens) {
    printf "%-10s: %1s : %-10s : %s\n",
      $tok->{CLASS},
      $tok->{TYPE}    || '',
      $tok->{VARIANT} || '',
      $tok->{VALUE};
  }

  exit 0;
}


#
# Compile.
#

emit_code('.sub', [ "__MODULE__" ]);

my $last_token;
my $token;

while(@tokens) {
  $last_token = $token;
  $token = shift @tokens;

  DEBUG(0, "\$last_token is now a label (%s).", $last_token->{VALUE})
    if $last_token->{CLASS} eq 'label';

  $line = $token->{LINE};
  $_    = $token->{VALUE};

  last if (/^__END__$/);         # Done after __END__ token

  #
  # Labels:
  #

  if ($token->{CLASS} eq 'label') {
    push_label($_);
    next;
  }

  #
  # Variable declarations:
  #
  # var int foo;
  # var int foo = 5;
  #
  # var num bar;
  # var num bar = 3.14;
  #
  # var str splee;
  # var str splee = "Howdy";
  #
  # var obj quux;
  #
  # var int foo, bar;
  # var int foo, bar = 5;
  #
  # var num bar, splee;
  # var num bar, splee = 3.14;
  #
  # var str splee, quux;
  # var str splee, quux = "Howdy";
  #
  # var obj quux, baz;
  #
  # const int foo   = 5;
  # const num bar   = 3.14;
  # const str splee = "Howdy";
  #

  if ($token->{CLASS} eq 'decl' and $token->{VARIANT} eq 'data') {
    my $access = $_; # 'const' or 'var'.

    SYNTAX_ERROR("Expected type name after '$access', but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected type name after '$access', but got '$tokens[0]{VALUE}'.")
      unless $tokens[0]{CLASS} eq 'type';

    my $type_token = shift @tokens;
    $line = $type_token->{LINE};
    my $type = $type_token->{VALUE};
    my $type_code = $type_code{$type};

    SYNTAX_ERROR("Cannot declare constants of type '$type'.")
      if ($access eq 'const' and $type eq 'obj');

    my @identifiers = ();

    while (1) {
      SYNTAX_ERROR("Expected identifier after '$access $type [ <ident>, ]*', but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected identifier after '$access $type [ <ident>, ]*', but got '$tokens[0]{VALUE}'.")
        unless $tokens[0]{CLASS} eq 'ident';

      my $ident_token = shift @tokens;
      $line = $ident_token->{LINE};
      push @identifiers, $ident_token->{VALUE};

      last unless @tokens and $tokens[0]{CLASS} eq 'sep' and $tokens[0]{VALUE} eq ',';

      my $sep_token = shift @tokens;
      $line = $sep_token->{LINE};
    }

    my $value;

    if (@tokens and $tokens[0]{CLASS} eq 'op' and $tokens[0]{VALUE} eq '=') {
#      DEBUG(0, "Assigning %s...", join(", ", @identifiers));

      my $op_token = shift @tokens;
      $line = $op_token->{LINE};

      SYNTAX_ERROR("Expected literal after '$access $type [ <ident>, ]* <ident> =', but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected literal after '$access $type [ <ident>, ]* <ident> = ', but got '$tokens[0]{VALUE}'.")
        unless $tokens[0]{CLASS} eq 'literal';

      my $literal_token = shift @tokens;
      $line = $literal_token->{LINE};

      $value = $literal_token->{VALUE};

      $value = interpolate_string($value)
        if str_lit_q($value);

#      DEBUG(0, "%s", $value);
    }
    else {
#      DEBUG(0, "NOT assigning %s...", join(", ", @identifiers));
    }
#    dump_token($tokens[0]);

    SYNTAX_ERROR("Expected ';' after declaration of identifier(s) " . join(', ', @identifiers) . ", but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected ';' after declaration of identifier(s) " . join(', ', @identifiers) . ", but got '$tokens[0]{VALUE}'.")
      unless ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{VALUE} eq ';');

    my $sep_token = shift @tokens;
    $line = $sep_token->{LINE};

    SYNTAX_ERROR("Cannot declare constant without assigning a value.")
      if ($access eq 'const' and not defined $value);

    foreach my $ident (@identifiers) {
      if ($access eq 'var') {
        declare_var($ident, $type_code, $access);
        assign_var($ident, $type_code, $value) if defined $value;
      }
      elsif ($access eq 'const') {
        declare_const($ident, $type_code, $value);
      }
      else {
        INTERNAL_ERROR("Unexpected data declaration access '$access'.");
      }
    }

    next;
  }

  #
  # Bare Blocks:
  #
  # LABEL: {
  #
  # {
  #
 
  if ($token->{CLASS} eq 'group' and $token->{VALUE} eq '{') {
    my $label;

    $label = $last_token->{VALUE}
      if $last_token->{CLASS} eq 'label';
    
    begin_block($label, 'bare', undef);

    next;
  }

  #
  # Subroutines:
  #
  # sub     NAME (...) {
  # sub int NAME (...) {
  # sub num NAME (...) {
  # sub str NAME (...) {
  #

  if ($token->{CLASS} eq 'decl' and $token->{VARIANT} eq 'code') {
    SYNTAX_ERROR("Expected type or identifier after 'sub', but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected type or identifier after 'sub', but got '$tokens[0]{VALUE}'.")
      unless ($tokens[0]{CLASS} eq 'type' or $tokens[0]{CLASS} eq 'ident');

    my $type;

    if ($tokens[0]{CLASS} eq 'type') {
      my $type_token = shift @tokens;
      $line = $type_token->{LINE};
      $type = $type_token->{TYPE};

      SYNTAX_ERROR("Expected type or identifier after 'sub %s', but got end of source.", $type_token->value)
        unless @tokens;

      SYNTAX_ERROR("Expected type or identifier after 'sub %s', but got '$tokens[0]{VALUE}'.", $type_token->value)
        unless ($tokens[0]{CLASS} eq 'ident');
    }

    my $ident_token = shift @tokens;
    $line = $ident_token->{LINE};
    my $name = $ident_token->{VALUE};

    #
    # Open paren of arg list:
    #

    SYNTAX_ERROR("Expected '(' after '$_', but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected '(' after '$_', but got '$tokens[0]{VALUE}'.")
      unless ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq '(');

    my $open_paren = shift @tokens;
    $line = $open_paren->{LINE};

    #
    # Formal argument list:
    #

    my @formal_args;

    while (1) {
      SYNTAX_ERROR("Expected formal argument or ')', but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected formal argument or ')', but got '$tokens[0]{VALUE}'.")
        unless ($tokens[0]{CLASS} eq 'type')
        or ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')');

      last if $tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')';

      my $arg_type_token = shift @tokens;
      $line = $arg_type_token->{LINE};
      my $arg_type = $arg_type_token->{TYPE};

      SYNTAX_ERROR("Expected identifier after formal argument type, but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected identifier after formal argument type, but got '$tokens[0]{VALUE}'.")
        unless $tokens[0]{CLASS} eq 'ident';

      my $arg_name_token = shift @tokens;
      $line = $arg_type_token->{LINE};
      my $arg_name = $arg_name_token->{VALUE};

      push @formal_args, [ $arg_type, $arg_name ];

      SYNTAX_ERROR("Expected ',' or ')' after formal argument, but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected ',' or ')' after formal argument, but got '$tokens[0]{VALUE}'.")
        unless ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{VALUE} eq ',')
        or ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')');

      last if $tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')';

      my $sep_token = shift @tokens;
      $line = $sep_token->{LINE};
    }

    #
    # Close paren of arg list:
    #

    SYNTAX_ERROR("Expected ')' after formal arguments, but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected ')' after formal arguments, but got '$tokens[0]{VALUE}'.")
      unless ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')');

    my $close_paren = shift @tokens;
    $line = $close_paren->{LINE};

    #
    # Open brace of block:
    #

    SYNTAX_ERROR("Expected '{' after formal argument list, but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected '{' after formal argument list, but got '$tokens[0]{VALUE}'.")
      unless ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq '{');

    my $open_brace = shift @tokens;
    $line = $open_brace->{LINE};
    
    #
    # GOOD TO GO:
    #

    begin_block($name, 'sub', undef, $type, @formal_args);

    next;
  }

  #
  # Loops:
  #
  # LABEL: until (...) {
  #        until (...) {
  #
  # LABEL: while (...) {
  #        while (...) {
  #
 
  if ($token->{CLASS} eq 'control' and $token->{VARIANT} eq 'iter') {
    my $prefix;

    DEBUG(0, "Starting $_...");

    if ($last_token->{CLASS} eq 'label') {
      $prefix = $last_token->{VALUE};
      DEBUG(0, "... with prefix '$prefix'...");
    }

    #
    # Open paren of condition:
    #

    SYNTAX_ERROR("Expected '(' after '$_', but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected '(' after '$_', but got '$tokens[0]{VALUE}'.")
      unless ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq '(');

    my $open_paren = shift @tokens;
    $line = $open_paren->{LINE};

    #
    # Left token of condition:
    #

    SYNTAX_ERROR("Expected identifier or literal after '(', but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected identifier or literal after '(', but got '$tokens[0]{VALUE}'.")
      unless ($tokens[0]{CLASS} eq 'ident' or $tokens[0]{CLASS} eq 'literal');

    my $left_token = shift @tokens;
    $line = $left_token->{LINE};
    my $left = $left_token->{VALUE};

    #
    # Relational operator of condition:
    #

    SYNTAX_ERROR("Expected relational operator after '$left', but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected relational operator after '$left', but got '$tokens[0]{VALUE}'.")
      unless ($tokens[0]{CLASS} eq 'op' and $tokens[0]{VARIANT} eq 'rel');

    my $relop_token = shift @tokens;
    $line = $relop_token->{LINE};
    my $relop = $relop_token->{VALUE};

    #
    # Right token of condition:
    #

    SYNTAX_ERROR("Expected identifier or literal after '$relop', but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected identifier or literal after '$relop', but got '$tokens[0]{VALUE}'.")
      unless ($tokens[0]{CLASS} eq 'ident' or $tokens[0]{CLASS} eq 'literal');

    my $right_token = shift @tokens;
    $line = $right_token->{LINE};
    my $right = $right_token->{VALUE};

    #
    # Close paren of condition:
    #

    SYNTAX_ERROR("Expected ')' after condition, but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected ')' after condition, but got '$tokens[0]{VALUE}'.")
      unless ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')');

    my $close_paren = shift @tokens;
    $line = $close_paren->{LINE};

    #
    # Open brace of block:
    #

    SYNTAX_ERROR("Expected '{' after condition, but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected '{' after condition, but got '$tokens[0]{VALUE}'.")
      unless ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq '{');

    my $open_brace = shift @tokens;
    $line = $open_brace->{LINE};
    
    #
    # GOOD TO GO:
    #

    begin_block($prefix, $_, [$left, $relop, $right]);
    
    next;
  }

  #
  # Increment and Decrement:
  #
  #   <sum> ++
  #   <difference> -- 
  #
  # a++
  # b--
  #

  if ($token->{CLASS} eq 'ident'
    and @tokens >= 1
    and $tokens[0]{CLASS} eq 'op'
    and ($tokens[0]{VALUE} eq '++' or $tokens[0]{VALUE} eq '--')
  ) {
    #
    # Operator:
    #

    my $op_token = shift @tokens;
    $line = $op_token->{LINE};
    my $op = $op_token->{VALUE};

    #
    # Statement separator:
    #

    SYNTAX_ERROR("Expected ';' after '$op', but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected ';' after '$op', but got '$tokens[0]{VALUE}'.")
      unless ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{VALUE} eq ';');

    my $sep_token = shift @tokens;
    $line = $sep_token->{LINE};
   
    #
    # GOOD TO GO:
    #

    if ($op eq '++') {
      do_inc($_);
    }
    else {
      do_dec($_);
    }

    next;
  }

  #
  # Arithmetic assigns:
  #
  #   <sum> += <incremend>
  #
  #   <a> -= <b>
  #   <a> *= <b>
  #   <a> /= <b>
  #   <a> %= <b>
  #
  # a += b;
  # a += 5;
  # a += 3.14;
  #

  if ($token->{CLASS} eq 'ident' and @tokens >= 1 and $tokens[0]{CLASS} eq 'op' and $tokens[0]{VARIANT} eq 'arith_assign') {
    my $op_token = shift @tokens;
    $line = $op_token->{LINE};

    my $op = substr($op_token->{VALUE}, 0, 1);

    #
    # Right hand side:
    #

    SYNTAX_ERROR("Expected literal or identifier after '[ <ident> = ]* <ident> =', but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected literal or identifier after '[ <ident> = ]* <ident> = ', but got '$tokens[0]{VALUE}'.")
      unless $tokens[0]{CLASS} eq 'literal' or $tokens[0]{CLASS} eq 'ident';

    my $value_token = shift @tokens;
    my $line = $value_token->{LINE};

    my $value = $value_token->{VALUE};

    #
    # Statement separator:
    #

    SYNTAX_ERROR("Expected ';' after assignment, but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected ';' after assignment, but got '$tokens[0]{VALUE}'.")
      unless ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{VALUE} eq ';');

    my $sep_token = shift @tokens;
    $line = $sep_token->{LINE};
    
    #
    # GOOD TO GO:
    #

    do_arith($_, $_, $op, $value);

    next;
  }

  #
  # Block Termination:
  #
  # }
  # } continue {
  # } else {
  #
 
  if ($token->{CLASS} eq 'group' and $token->{VALUE} eq '}') {
    my $cont;
    
    if (@tokens and $tokens[0]{CLASS} eq 'control' and ($tokens[0]{VALUE} eq 'continue' or $tokens[0]{VALUE} eq 'else')) {
      my $cont_token = shift @tokens;
      $line = $cont_token->{LINE};

      $cont = $cont_token->{VALUE};

      #
      # Open brace of block:
      #

      SYNTAX_ERROR("Expected '{' after '$cont', but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected '{' after '$cont', but got '$tokens[0]{VALUE}'.")
        unless ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq '{');

      my $open_brace = shift @tokens;
      $line = $open_brace->{LINE};
    }

    end_block($cont);

    next;
  }

  #
  # Arithmetic Operators:
  #
  # a = b % c;
  # a = b % 4;
  # a = 9 % b;
  # a = 9 % 4;
  #
  # a %= b;
  # a %= 4;
  #
  # TODO: Numbers in mod (follow Calendrical calculations definition? Knuth definition?)
  #

  if (@tokens >= 5
    and $token->{CLASS} eq 'ident'
    and ($tokens[0]{CLASS} eq 'op' and $tokens[0]{VALUE} eq '=')
    and ($tokens[1]{CLASS} eq 'literal' or $tokens[1]{CLASS} eq 'ident')
    and ($tokens[2]{CLASS} eq 'op' and $tokens[2]{VARIANT} eq 'arith')
    and ($tokens[3]{CLASS} eq 'literal' or $tokens[3]{CLASS} eq 'ident')
    and ($tokens[4]{CLASS} eq 'sep' and $tokens[4]{VALUE} eq ';')
  ) {
    my $assign_op  = shift @tokens;
    my $left_expr  = shift @tokens;
    my $arith_op   = shift @tokens;
    my $right_expr = shift @tokens;
    my $sep        = shift @tokens;

    $line = $sep->{LINE};

    do_arith($_, $left_expr->{VALUE}, $arith_op->{VALUE}, $right_expr->{VALUE});

    next;
  }

  #
  # Subroutine Calls:
  #
  #     foo(...);
  #
 
  if ($token->{CLASS} eq 'ident'
    and @tokens 
    and ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq '(')
  ) {
    #
    # Open paren of call:
    #

    my $open_paren = shift @tokens;
    $line = $open_paren->{LINE};

    my @args = ();

    while (1) {
      SYNTAX_ERROR("Expected expression or ')' after '$_([ <expr>, ]*', but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected expression or ')' after '$_([ <expr>, ]*', but got '$tokens[0]{VALUE}'.")
        unless $tokens[0]{CLASS} eq 'literal' or $tokens[0]{CLASS} eq 'ident'
        or ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')');

      last if ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')');

      my $expr_token = shift @tokens;
      $line = $expr_token->{LINE};
      push @args, $expr_token->{VALUE};

      last unless @tokens and $tokens[0]{CLASS} eq 'sep' and $tokens[0]{VALUE} eq ',';

      SYNTAX_ERROR("Expected ',' or ')' after expression, but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected ',' or ')' after expression, but got '$tokens[0]{VALUE}'.")
        unless ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{VALUE} eq ',')
        or ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')');

      last if ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')');

      my $sep_token = shift @tokens;
      $line = $sep_token->{LINE};
    }

    #
    # Close paren of call:
    #

    my $close_paren = shift @tokens;
    $line = $close_paren->{LINE};
 
    #
    # Statement separator:
    #

    SYNTAX_ERROR("Expected ';' after call, but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected ';' after call, but got '$tokens[0]{VALUE}'.")
      unless ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{VALUE} eq ';');

    my $sep_token = shift @tokens;
    $line = $sep_token->{LINE};

    #
    # GOOD TO GO:
    #

    void_func($_, @args);
    
    next;
  }

  #
  # Function Calls:
  #
  # a = foo(...);
  #

  if ($token->{CLASS} eq 'ident'
    and @tokens >= 3
    and ($tokens[0]{CLASS} eq 'op' and $tokens[0]{VALUE} eq '=')
    and $tokens[1]{CLASS} eq 'ident'
    and ($tokens[2]{CLASS} eq 'group' and $tokens[2]{VALUE} eq '(')
  ) {
    #
    # Assignment operator:
    #

    my $op_token = shift @tokens;
    $line = $op_token->{LINE};

    #
    # Function name:
    #

    my $func_name_token = shift @tokens;
    $line = $func_name_token->{LINE};
    my $func_name = $func_name_token->{VALUE};

    #
    # Open paren of call:
    #

    my $open_paren = shift @tokens;
    $line = $open_paren->{LINE};

    my @args = ();

    while (1) {
      SYNTAX_ERROR("Expected expression or ')' after '$_([ <expr>, ]*', but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected expression or ')' after '$_([ <expr>, ]*', but got '$tokens[0]{VALUE}'.")
        unless $tokens[0]{CLASS} eq 'literal' or $tokens[0]{CLASS} eq 'ident'
        or ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')');

      last if ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')');

      my $expr_token = shift @tokens;
      $line = $expr_token->{LINE};
      push @args, $expr_token->{VALUE};

      last unless @tokens and $tokens[0]{CLASS} eq 'sep' and $tokens[0]{VALUE} eq ',';

      SYNTAX_ERROR("Expected ',' or ')' after expression, but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected ',' or ')' after expression, but got '$tokens[0]{VALUE}'.")
        unless ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{VALUE} eq ',')
        or ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')');

      last if ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')');

      my $sep_token = shift @tokens;
      $line = $sep_token->{LINE};
    }

    #
    # Close paren of call:
    #

    my $close_paren = shift @tokens;
    $line = $close_paren->{LINE};
 
    #
    # Statement separator:
    #

    SYNTAX_ERROR("Expected ';' after call, but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected ';' after call, but got '$tokens[0]{VALUE}'.")
      unless ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{VALUE} eq ';');

    my $sep_token = shift @tokens;
    $line = $sep_token->{LINE};

    assign_func($_, $func_name, @args);
    next;
  }

  #
  # Variable Assignments:
  #
  # var int a, b, c;
  # var num d, e;
  # var str f, g;
  #
  # a = 5;
  # a = b = c = 5;
  #
  # d = 3.14;
  # d = e = 3.14;
  #
  # f = "Howdy";
  # f = g = "Howdy";
  #
  # a = b;
  # a = b = c;
  #
 
  if ($token->{CLASS} eq 'ident'
    and @tokens >= 1
    and ($tokens[0]{CLASS} eq 'op' and $tokens[0]{VALUE} eq '=')
  ) {
    my $op_token = shift @tokens;
    $line = $op_token->{LINE};

    #
    # Left hand side:
    #

    my @identifiers = ($_);

    while (@tokens >= 2 and $tokens[0]{CLASS} eq 'ident' and $tokens[1]{CLASS} eq 'op' and $tokens[1]{VALUE} eq '=') {
      my $ident_token = shift @tokens;
      $line = $ident_token->{LINE};
      my $op_token = shift @tokens;
      $line = $op_token->{LINE};

      push @identifiers, $ident_token->{VALUE};
    }

    #
    # Right hand side:
    #

    SYNTAX_ERROR("Expected literal or identifier after '[ <ident> = ]* <ident> =', but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected literal or identifier after '[ <ident> = ]* <ident> = ', but got '$tokens[0]{VALUE}'.")
      unless $tokens[0]{CLASS} eq 'literal' or $tokens[0]{CLASS} eq 'ident';

    my $value_token = shift @tokens;
    my $line = $value_token->{LINE};

    my $value = $value_token->{VALUE};

    #
    # Statement separator:
    #

    SYNTAX_ERROR("Expected ';' after assignment, but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected ';' after assignment, but got '%s'.", $tokens[0]{VALUE})
      unless ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{VALUE} eq ';');

    my $sep_token = shift @tokens;
    $line = $sep_token->{LINE};
    
    #
    # GOOD TO GO:
    #

    foreach my $ident (@identifiers) {
      if ($value_token->{CLASS} eq 'literal') {
        assign_var($ident, $value_token->{TYPE}, $value_token->{VALUE});
      }
      elsif ($value_token->{CLASS} eq 'ident') {
        assign_var($ident, '*', $value_token->{VALUE}); # TODO: Cloning for 'obj' vars?
      }
      else {
        INTERNAL_ERROR("Unexpected value token class.");
      }
    }

    next;
  }

  #
  # Subroutine Return Statements:
  #
  # return
  # return 0
  # return 0.0
  # return "foo"
  # return bar
  #

  if ($token->{CLASS} eq 'control' and $token->{VALUE} eq 'return') {
    #
    # Return value:
    #

#    DEBUG(0, "TOKENS: %s", join(" | ", map { $_->{VALUE} } @tokens[0..10]));

    SYNTAX_ERROR("Expected expression or ';' after 'return' but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected expression or ';' after 'return' but got '$tokens[0]{VALUE}'.")
      unless $tokens[0]{CLASS} eq 'ident'
      or $tokens[0]{CLASS} eq 'literal'
      or ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{CLASS} eq ';');

    my $value;

    unless ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{CLASS} eq ';') {
      my $value_token = shift @tokens;
      $line = $value_token->{LINE};
      $value = $value_token->{VALUE};

#      DEBUG(0, "Got return value '%s'", $value);
    }

    #
    # Statement separator:
    #

    SYNTAX_ERROR("Expected ';' after return statement, but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected ';' after return statement, but got '%s'.", $tokens[0]{VALUE})
      unless ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{VALUE} eq ';');

    my $sep_token = shift @tokens;
    $line = $sep_token->{LINE};
    
    #
    # GOOD TO GO:
    #

    do_return($value);

    next;
  }

  #
  # Goto Statements:
  #
  # goto LABEL
  # goto LABEL if (...)
  # goto LABEL unless (...)
  #

  if ($token->{CLASS} eq 'control' and $token->{VALUE} eq 'goto') {
    #
    # Target label:
    #

    SYNTAX_ERROR("Expected label after 'goto', but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected label after 'goto', but got '%s'.", $tokens[0]{VALUE})
      unless $tokens[0]{CLASS} eq 'ident';

    my $target_token = shift @tokens;
    $line = $target_token->{LINE};
    my $target = $target_token->{VALUE};

    #
    # Check for statement modifiers:
    #

    SYNTAX_ERROR("Expected 'if', 'unless' or ';' after label, but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected 'if', 'unless' or ';' after label, but got '%s'.", $tokens[0]{VALUE})
      unless ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{VARIANT} eq 'stmt')
      or ($tokens[0]{CLASS} eq 'control' and ($tokens[0]{VALUE} eq 'if' or $tokens[0]{VALUE} eq 'unless'));
    
    my $cond;

    my $left;
    my $relop;
    my $right;

    if ($tokens[0]{CLASS} ne 'sep') {
      my $cond_token = shift @tokens;
      $line = $cond_token->{LINE};
      $cond = $cond_token->{VALUE};

      #
      # Open paren of condition:
      #

      SYNTAX_ERROR("Expected '(' after '$cond', but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected '(' after '$cond', but got '$tokens[0]{VALUE}'.")
        unless ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq '(');

      my $open_paren = shift @tokens;
      $line = $open_paren->{LINE};

      #
      # Left token of condition:
      #

      SYNTAX_ERROR("Expected identifier or literal after '(', but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected identifier or literal after '(', but got '$tokens[0]{VALUE}'.")
        unless ($tokens[0]{CLASS} eq 'ident' or $tokens[0]{CLASS} eq 'literal');

      my $left_token = shift @tokens;
      $line = $left_token->{LINE};
      $left = $left_token->{VALUE};

      #
      # Relational operator of condition:
      #

      SYNTAX_ERROR("Expected relational operator after '$left', but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected relational operator after '$left', but got '$tokens[0]{VALUE}'.")
        unless ($tokens[0]{CLASS} eq 'op' and $tokens[0]{VARIANT} eq 'rel');

      my $relop_token = shift @tokens;
      $line = $relop_token->{LINE};
      $relop = $relop_token->{VALUE};

      #
      # Right token of condition:
      #

      SYNTAX_ERROR("Expected identifier or literal after '$relop', but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected identifier or literal after '$relop', but got '$tokens[0]{VALUE}'.")
        unless ($tokens[0]{CLASS} eq 'ident' or $tokens[0]{CLASS} eq 'literal');

      my $right_token = shift @tokens;
      $line = $right_token->{LINE};
      $right = $right_token->{VALUE};

      #
      # Close paren of condition:
      #

      SYNTAX_ERROR("Expected ')' after condition, but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected ')' after condition, but got '$tokens[0]{VALUE}'.")
        unless ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')');

      my $close_paren = shift @tokens;
      $line = $close_paren->{LINE};
    }
 
    #
    # Terminating semicolon:
    #

    SYNTAX_ERROR("Expected ';' after goto statement, but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected ';' after goto statement, but got '%s'.", $tokens[0]{VALUE})
      unless ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{VARIANT} eq 'stmt');

    my $sep_token = shift @tokens;
    $line = $sep_token->{LINE};

    #
    # GOOD TO GO:
    #

    if ($cond) {
      push_source "goto $target $cond ($left $relop $right);";
      op_comp $cond, $relop, $left, $right, $target, undef;
    }
    else {
      push_source "goto $target;";
      emit_code('branch', [ $target ]);
    }
    
    next;
  }

  #
  # Loop Control Statements:
  #
  # next
  # next          if (...)
  # next          unless (...)
  # next LOOPNAME
  # next LOOPNAME if (...)
  # next LOOPNAME unless (...)
  #
  # last
  # last          if (...)
  # last          unless (...)
  # last LOOPNAME
  # last LOOPNAME if (...)
  # last LOOPNAME unless (...)
  #
  # redo
  # redo          if (...)
  # redo          unless (...)
  # redo LOOPNAME
  # redo LOOPNAME if (...)
  # redo LOOPNAME unless (...)
  #
  # NOTE: A LOOPNAME is just the label used when introducing a LOOP.
  #

  if ($token->{CLASS} eq 'control' and $token->{VARIANT} eq 'other'
    and ($token->{VALUE} eq 'next' or $token->{VALUE} eq 'last' or $token->{VALUE} eq 'redo')
  ) {
    my $control = $_;

    #
    # Target label:
    #

    my $target;

    if (@tokens and $tokens[0]{CLASS} eq 'ident') {
      my $target_token = shift @tokens;
      $line = $target_token->{LINE};
      $target = $target_token->{VALUE};
      $_ = $target;
    }

    #
    # Check for statement modifiers:
    #

    SYNTAX_ERROR("Expected 'if', 'unless' or ';' after '$_', but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected 'if', 'unless' or ';' after '$_', but got '%s'.", $tokens[0]{VALUE})
      unless ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{VARIANT} eq 'stmt')
      or ($tokens[0]{CLASS} eq 'control' and ($tokens[0]{VALUE} eq 'if' or $tokens[0]{VALUE} eq 'unless'));
    
    my $cond;

    my $left;
    my $relop;
    my $right;

    if ($tokens[0]{CLASS} ne 'sep') {
      my $cond_token = shift @tokens;
      $line = $cond_token->{LINE};
      $cond = $cond_token->{VALUE};

      #
      # Open paren of condition:
      #

      SYNTAX_ERROR("Expected '(' after '$cond', but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected '(' after '$cond', but got '$tokens[0]{VALUE}'.")
        unless ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq '(');

      my $open_paren = shift @tokens;
      $line = $open_paren->{LINE};

      #
      # Left token of condition:
      #

      SYNTAX_ERROR("Expected identifier or literal after '(', but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected identifier or literal after '(', but got '$tokens[0]{VALUE}'.")
        unless ($tokens[0]{CLASS} eq 'ident' or $tokens[0]{CLASS} eq 'literal');

      my $left_token = shift @tokens;
      $line = $left_token->{LINE};
      $left = $left_token->{VALUE};

      #
      # Relational operator of condition:
      #

      SYNTAX_ERROR("Expected relational operator after '$left', but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected relational operator after '$left', but got '$tokens[0]{VALUE}'.")
        unless ($tokens[0]{CLASS} eq 'op' and $tokens[0]{VARIANT} eq 'rel');

      my $relop_token = shift @tokens;
      $line = $relop_token->{LINE};
      $relop = $relop_token->{VALUE};

      #
      # Right token of condition:
      #

      SYNTAX_ERROR("Expected identifier or literal after '$relop', but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected identifier or literal after '$relop', but got '$tokens[0]{VALUE}'.")
        unless ($tokens[0]{CLASS} eq 'ident' or $tokens[0]{CLASS} eq 'literal');

      my $right_token = shift @tokens;
      $line = $right_token->{LINE};
      $right = $right_token->{VALUE};

      #
      # Close paren of condition:
      #

      SYNTAX_ERROR("Expected ')' after condition, but got end of source.")
        unless @tokens;

      SYNTAX_ERROR("Expected ')' after condition, but got '$tokens[0]{VALUE}'.")
        unless ($tokens[0]{CLASS} eq 'group' and $tokens[0]{VALUE} eq ')');

      my $close_paren = shift @tokens;
      $line = $close_paren->{LINE};
    }
 
    #
    # Terminating semicolon:
    #

    SYNTAX_ERROR("Expected ';' after goto statement, but got end of source.")
      unless @tokens;

    SYNTAX_ERROR("Expected ';' after goto statement, but got '%s'.", $tokens[0]{VALUE})
      unless ($tokens[0]{CLASS} eq 'sep' and $tokens[0]{VARIANT} eq 'stmt');

    my $sep_token = shift @tokens;
    $line = $sep_token->{LINE};

    #
    # GOOD TO GO:
    #

    do_loop_control($control, $target, $cond, $left, $relop, $right);
    
    next;
  }




  #
  # TODO: Implement other stuff and put it before this.
  #

  SYNTAX_ERROR("Don't know what to do with token '$_'.");




  #
  # Arithmetic Operators:
  #
  # a %= b;
  # a %= 4;
  #

  if (m/^([A-Za-z][A-Za-z0-9_]*)\s*[%]=\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+))$/) {
    push_source "$1 \%= $2";
    do_mod($1, $1, $2);
    next;
  }

  #
  # Object Construction:
  #
  # a = new Foo;
  #

  if (m/^([A-Za-z][A-Za-z0-9_]*)\s*=\s*new\s+([A-Za-z][A-Za-z0-9_]*)$/) {
    new_obj($1, $2);
    next;
  }

  #
  # Conditionals:
  #
  #   if     (...) {
  #   unless (...) {
  #
  # } elsif  (...) {
  #

  if (m/^(if|unless)\s*\(\s*(.*)\s*\)\s*{$/) {
    begin_block(undef, $1, $2);
    next;
  }

  if (m/^}\s*(elsif)\s*\(\s*(.*)\s*\)\s*{$/) {
    begin_block(undef, $1, $2);
    # TODO
    next;
  }

  #
  # Additive Operators:
  #
  # a = b    + c;     # add_[in]
  # a = b    + 5;     # add_i_ic (psuedo-op)
  # a = b    + 3.14;  # add_n_nc (psuedo-op)
  # a = 5    + b;     # add_ic_i (pseudo-op)
  # a = 3.14 + b;     # add_nc_n (pseudo-op)
  # a = 5    + 2;     # set_i (COMPILE-TIME EVALUATION)
  # a = 3.14 + 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 5    + 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 3.14 + 2;     # set_n (COMPILE-TIME EVALUATION)
  #

  if (m!^([A-Za-z][A-Za-z0-9_]*)\s*=\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+(\.\d+)?))\s*[+]\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+(\.\d+)?))$!) {
    #
    # Regexp Captures:
    #
    #  1. LHS sum (variable name)
    #  2. RHS augend
    #  3. RHS augend (variable name)
    #  4. RHS augend (number)
    #  5. RHS augend (number's decimal places) -- used for grouping, not capture
    #  6. RHS addend
    #  7. RHS addend (variable name)
    #  8. RHS addend (number)
    #  9. RHS addend (number's decimal places) -- used for grouping, not capture
    #

    if (defined $3 or defined $7) {
      do_add($1, $2, $6);
    } elsif (defined $4 and defined $8) {
      assign_var($1, (defined $5 or defined $9 ? 'N' : 'I'), $4 + $8);
    } else {
      SYNTAX_ERROR("Bad addition '%s'.", $_);
    }
    next;
  }

  #
  # Subtractive Operators:
  #
  # a = b    - c;     # sub_[in]
  # a = b    - 5;     # sub_i_ic (pseudo-op)
  # a = b    - 3.14;  # sub_n_nc (pseudo-op)
  # a = 5    - b;     # sub_ic_i (pseudo-op)
  # a = 3.14 - b;     # sub_nc_n (pseudo-op)
  # a = 5    - 2;     # set_i (COMPILE-TIME EVALUATION)
  # a = 3.14 - 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 5    - 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 3.14 - 2;     # set_n (COMPILE-TIME EVALUATION)
  #
  # a -= b;           # dec_{i_i,n_n} (pseudo-op)
  # a -= 5;           # sub_i_ic (pseudo-op)
  # a -= 3.14;        # sub_n_nc (pseudo-op)
  #
  # a--;              # dec_[in]
  #

  if (m!^([A-Za-z][A-Za-z0-9_]*)\s*=\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+(\.\d+)?))\s*[-]\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+(\.\d+)?))$!) {
    #
    # Regexp Captures:
    #
    #  1. LHS difference (variable name)
    #  2. RHS minuend
    #  3. RHS minuend (variable name)
    #  4. RHS minuend (number)
    #  5. RHS minuend (number's decimal places) -- used for grouping, not capture
    #  6. RHS subtrahend
    #  7. RHS subtrahend (variable name)
    #  8. RHS subtrahend (number)
    #  9. RHS subtrahend (number's decimal places) -- used for grouping, not capture
    #

    if (defined $3 or defined $7) {
      do_sub($1, $2, $6);
    } elsif (defined $4 and defined $8) {
      assign_var($1, (defined $5 or defined $9 ? 'N' : 'I'), $4 - $8);
    } else {
      SYNTAX_ERROR("... in subtraction");
    }
    next;
  }

  if (m!^([A-Za-z][A-Za-z0-9_]*)\s*[-]=\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+(\.\d+)?))$!) {
    if (defined $3) {
      do_sub($1, $1, $2);
    } else {
      do_dec($1, $2);
    }
    next;
  }

  if (m!^([A-Za-z][A-Za-z0-9_]*)\s*[-][-]$!) {
    do_dec($1);
    next;
  }

  #
  # Multiplicative Operators:
  #
  # a = b    * c;     # mul_[in]
  # a = b    * 5;     # mul_i_ic (psuedo-op)
  # a = b    * 3.14;  # mul_n_nc (psuedo-op)
  # a = 5    * b;     # mul_ic_i (pseudo-op)
  # a = 3.14 * b;     # mul_nc_n (pseudo-op)
  # a = 5    * 2;     # set_i (COMPILE-TIME EVALUATION)
  # a = 3.14 * 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 5    * 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 3.14 * 2;     # set_n (COMPILE-TIME EVALUATION)
  #
  # a *= b;           # mul_[in]
  # a *= 5;           # mul_i_ic (pseudo-op)
  # a *= 3.14;        # mul_n_nc (pseudo-op)
  #

  if (m!^([A-Za-z][A-Za-z0-9_]*)\s*=\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+(\.\d+)?))\s*[*]\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+(\.\d+)?))$!) {
    #
    # Regexp Captures:
    #
    #  1. LHS product (variable name)
    #  2. RHS multiplicand
    #  3. RHS multiplicand (variable name)
    #  4. RHS multiplicand (number)
    #  5. RHS multiplicand (number's decimal places) -- used for grouping, not capture
    #  6. RHS multiplier
    #  7. RHS multiplier (variable name)
    #  8. RHS multiplier (number)
    #  9. RHS multiplier (number's decimal places) -- used for grouping, not capture
    #

    if (defined $3 or defined $7) {
      do_mul($1, $2, $6);
    } elsif (defined $4 and defined $8) {
      assign_var($1, (defined $5 or defined $9 ? 'N' : 'I'), $4 * $8);
    } else {
      SYNTAX_ERROR("... in multiplication.");
    }
    next;
  }

  if (m!^([A-Za-z][A-Za-z0-9_]*)\s*[*]=\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+(\.\d+)?))$!) {
    do_mul($1, $1, $2);
    next;
  }

  #
  # Divisive Operators:
  #
  # a = b    / c;     # div_[in]
  # a = b    / 5;     # div_i_ic (psuedo-op)
  # a = b    / 3.14;  # div_n_nc (psuedo-op)
  # a = 5    / b;     # div_ic_i (pseudo-op)
  # a = 3.14 / b;     # div_nc_n (pseudo-op)
  # a = 5    / 2;     # set_i (COMPILE-TIME EVALUATION)
  # a = 3.14 / 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 5    / 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 3.14 / 2;     # set_n (COMPILE-TIME EVALUATION)
  #
  # a /= b;           # div_[in]
  # a /= 5;           # div_i_ic (pseudo-op)
  # a /= 3.14;        # div_n_nc (pseudo-op)
  #

  if (m!^([A-Za-z][A-Za-z0-9_]*)\s*=\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+(\.\d+)?))\s*[/]\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+(\.\d+)?))$!) {
    #
    # Regexp Captures:
    #
    #  1. LHS quotient (variable name)
    #  2. RHS dividend
    #  3. RHS dividend (variable name)
    #  4. RHS dividend (number)
    #  5. RHS dividend (number's decimal places) -- used for grouping, not capture
    #  6. RHS divisor
    #  7. RHS divisor (variable name)
    #  8. RHS divisor (number)
    #  9. RHS divisor (number's decimal places) -- used for grouping, not capture
    #

    push_source "$1 = $2 / $6";

    if (defined $3 or defined $7) {
      do_div($1, $2, $6);
    } elsif (defined $4 and defined $8) {
      assign_var($1, (defined $5 or defined $9 ? 'N' : 'I'), $4 / $8);
    } else {
      SYNTAX_ERROR("... in division.");
    }

    next;
  }

  if (m!^([A-Za-z][A-Za-z0-9_]*)\s*[\/]=\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+(\.\d+)?))$!) {
    do_div($1, $1, $2);
    next;
  }

  #
  # Bitwise Operators:
  #
  # a = b << 4;
  # a <<= 4;
  # a = b & c;
  # a = b | c;
  #
  # TODO: Can't really support shift amount as arg until sh[lr]_i_i ops are implemented.
  #
  # TODO: Should we really be allowing the shift contant to be negative?
  #

  if (m/^([A-Za-z][A-Za-z0-9_]*)\s*=\s*([A-Za-z][A-Za-z0-9_]*)\s*(<<|>>)\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+))$/) {
    do_shift($3 eq '<<' ? 'l' : 'r', $1, $2, $4);
    next;
  }

  if (m/^([A-Za-z][A-Za-z0-9_]*)\s*((<<|>>)=)\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+))$/) {
    do_shift($4 eq '<<' ? 'l' : 'r', $1, $2, $5);
    next;
  }

  if (m/^([A-Za-z][A-Za-z0-9_]*)\s*=\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+))\s*[&]\s*(([A-Za-z][A-Za-z0-9_]*)|((-?\d+)|(0b[01]+)|(0[0-7]+)|(0x[0-9a-f]+)))$/) {
    push_source "$1 = $2 \& $5";
    do_bit_and($1, $2, $5);
    next;
  }

  if (m/^([A-Za-z][A-Za-z0-9_]*)\s*[&]=\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+))$/) {
    push_source "$1 \&= $2";
    do_bit_and($1, $1, $2);
    next;
  }

  if (m/^([A-Za-z][A-Za-z0-9_]*)\s*=\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+))\s*[|]\s*(([A-Za-z][A-Za-z0-9_]*)|((-?\d+)|(0b[01]+)|(0[0-7]+)|(0x[0-9a-f]+)))$/) {
    push_source "$1 = $2 | $5";
    do_bit_or($1, $2, $5);
    next;
  }

  if (m/^([A-Za-z][A-Za-z0-9_]*)\s*[|]=\s*(([A-Za-z][A-Za-z0-9_]*)|(-?\d+))$/) {
    push_source "$1 |= $2";
    do_bit_or($1, $1, $2);
    next;
  }

  #
  # Miscellany:
  #

  if (m/^end$/) {
    emit_code('end');
    next;
  }

  PARSE_ERROR("Unparsable line.");
}

emit_code('end') unless $last_op eq 'end';

emit_code(".end");

exit 0;

#
# End of file.
#
