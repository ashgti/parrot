#! /usr/bin/perl -w
#
# compile.pl - compile a Jako source file Parrot assembly file.
#
# Jako is a *very* simple language with just enough complexity to allow the
# implementation of little programs with while loops.
#
#   * Global data only
#   * No user subroutine definitions
#
# by Gregor N. Purdy <gregor@focusresearch.com>
#
# Copyright (C) 2001 Gregor N. Purdy. All rights reserved.
# This program is free software. It is subject to the same license
# as Perl itself.
#
# $Id$
#

use strict;


#
# Global variables:
#

my $line;    # Current source line number
my %ident;   # Identifiers
my %regs = ( # Registers
  I => [ undef ], # $regs{I}[0] reserved for integral  temporaries
  N => [ undef ], # $regs{N}[0] reserved for numeric   temporaries
  P => [ undef ], # $regs{P}[0] reserved for polytypic temporaries
  S => [ undef ], # $regs{S}[0] reserved for string    temporaries
);

my $block_count = 0;
my @block_stack = ();

my %void_functions = (

);

my %true_functions = (
  acos  => [ 'N', 1, '[IN]'],
  and   => [ 'I', 2, 'II'  ],
  asec  => [ 'N', 1, '[IN]' ],
  asin  => [ 'N', 1, '[IN]' ],
  atan  => [ 'N', 1, '[IN]' ],
  atan2 => [ 'N', 2, '[IN][IN]' ],
  cos   => [ 'N', 1, '[IN]' ],
  cosh  => [ 'N', 1, '[IN]' ],
  exp   => [ 'N', 1, '[IN]' ],
  ln    => [ 'N', 1, '[IN]' ],
  log10 => [ 'N', 1, '[IN]' ],
  log2  => [ 'N', 1, '[IN]' ],
  not   => [ 'I', 1, 'I' ],
  or    => [ 'I', 2, 'II' ],
  pow   => [ 'N', 2, '[IN][IN]' ],
  sec   => [ 'N', 1, '[IN]' ],
  sech  => [ 'N', 1, '[IN]' ],
  sin   => [ 'N', 1, '[IN]' ],
  sinh  => [ 'N', 1, '[IN]' ],
  tan   => [ 'N', 1, '[IN]' ],
  tanh  => [ 'N', 1, '[IN]' ],
  xor   => [ 'I', 2, 'II' ],
);


#
# emit_code()
#
# emit_code LABEL
# emit_code LABEL OP
# emit_code LABEL OP ARGS
#
# Label can be undef.
#

sub emit_code
{
  my ($label, $op, @args) = @_;

  printf "%-12s ", ((defined $label and $label ne '') ? "$label:" : '');
  printf "%-8s", $op if defined $op; 
  print " " if @args;
  print join(", ", @args) if @args;
  print "\n";
}


#
# int_q()
#

sub int_q
{
  my ($value) = @_;

  return $value =~ m/^-?\d+$/;
}


#
# reg_q()
#

sub reg_q
{
  my ($value) = @_;

  return $value =~ m/^[INPS]\d+$/;
}


#
# op_comp()
#
# There are three kinds of entries in the %comp_ops hash:
#
#   * Perl expressions to optimize all-constant ops to branches.
#
#   * Entries to map source tokens to the op name. This is used
#     in parsing conditionals.
#
#   * Entries to determine the opposite comparison operator if
#     we need to reverse the sense of the operator as it appears
#     in the source.
#

my %comp_ops = (
  'eq' => sub { $_[0] == $_[1] },
  'ne' => sub { $_[0] != $_[1] },
  'le' => sub { $_[0] <= $_[1] },
  'lt' => sub { $_[0] <  $_[1] },
  'ge' => sub { $_[0] >= $_[1] },
  'gt' => sub { $_[0] >  $_[1] },

  '==' => 'eq',
  '!=' => 'ne',
  '<=' => 'le',
  '<'  => 'lt',
  '>=' => 'ge',
  '>'  => 'gt',

  '!eq' => 'ne',
  '!ne' => 'eq',
  '!le' => 'gt',
  '!lt' => 'ge',
  '!ge' => 'lt',
  '!gt' => 'le',
);

sub op_comp
{
  my ($label, $op, $a, $b, $true, $false) = @_;

  $op = $comp_ops{$op} unless ref $comp_ops{$op}; # Map, e.g., '>=' to 'ge'

  if (int_q($b)) {
    if (int_q($a)) {
      if (&{$comp_ops{$op}}($a, $b)) {
        emit_code($label, 'branch', $true);
      } else {
        emit_code($label, 'branch', $false);
      }
    } elsif (reg_q($a)) {
      emit_code($label, 'set', 'I0', $b);
      emit_code(undef, $op, $a, 'I0', $true);
      emit_code('', 'branch', $false);
    } else {
      printf STDERR "jako: Syntax error on line %d!\n", $line;
    }
  } elsif (reg_q($b)) {
    if (int_q($a)) {
      emit_code($label, 'set', 'I0', $a);
      emit_code(undef, $op, 'I0', $b, $true);
      emit_code('', 'branch', $false);
    } elsif (reg_q($a)) {
      emit_code($label, $op, $a, $b, $true);
      emit_code('', 'branch', $false);
    } else {
      printf STDERR "jako: Syntax error on line %d!\n", $line;
    }
  } else {
    printf STDERR "jako: Syntax error on line %d!\n", $line;
  }
}


#
# op_eq()
#
# Handle a 'eq' op. This includes pseudo-ops for cases that aren't covered in
# by Parrot, such as comparing a register to constant.
#
# eq_i_i    # TRUE op
# eq_i_ic   # PSEUDO op
# eq_ic_i   # PSEUDO op
# eq_ic_ic  # OPTIMIZED to non-conditional branch
#
# TODO: Handle numeric and string comparisons
#

sub op_eq
{
  my ($label, $a, $b, $le, $gt) = @_;
  op_comp($label, 'eq', $a, $b, $le, $gt);
}


#
# op_ne()
#
# Handle a 'ne' op. This includes pseudo-ops for cases that aren't covered in
# by Parrot, such as comparing a register to constant.
#
# ne_i_i    # TRUE op
# ne_i_ic   # PSEUDO op
# ne_ic_i   # PSEUDO op
# ne_ic_ic  # OPTIMIZED to non-conditional branch
#
# TODO: Handle numeric and string comparisons
#

sub op_ne
{
  my ($label, $a, $b, $le, $gt) = @_;
  op_comp($label, 'ne', $a, $b, $le, $gt);
}


#
# op_le()
#
# Handle a 'le' op. This includes pseudo-ops for cases that aren't covered in
# by Parrot, such as comparing a register to constant.
#
# le_i_i    # TRUE op
# le_i_ic   # PSEUDO op
# le_ic_i   # PSEUDO op
# le_ic_ic  # OPTIMIZED to non-conditional branch
#
# TODO: Handle numeric and string comparisons
#

sub op_le
{
  my ($label, $a, $b, $le, $gt) = @_;
  op_comp($label, 'le', $a, $b, $le, $gt);
}


#
# op_lt()
#
# Handle a 'lt' op. This includes pseudo-ops for cases that aren't covered in
# by Parrot, such as comparing a register to constant.
#
# lt_i_i    # TRUE op
# lt_i_ic   # PSEUDO op
# lt_ic_i   # PSEUDO op
# lt_ic_ic  # OPTIMIZED to non-conditional branch
#
# TODO: Handle numeric and string comparisons
#

sub op_lt
{
  my ($label, $a, $b, $le, $gt) = @_;
  op_comp($label, 'lt', $a, $b, $le, $gt);
}


#
# op_ge()
#
# Handle a 'ge' op. This includes pseudo-ops for cases that aren't covered in
# by Parrot, such as comparing a register to constant.
#
# ge_i_i    # TRUE op
# ge_i_ic   # PSEUDO op
# ge_ic_i   # PSEUDO op
# ge_ic_ic  # OPTIMIZED to non-conditional branch
#
# TODO: Handle numeric and string comparisons
#

sub op_ge
{
  my ($label, $a, $b, $le, $gt) = @_;
  op_comp($label, 'ge', $a, $b, $le, $gt);
}


#
# op_gt()
#
# Handle a 'gt' op. This includes pseudo-ops for cases that aren't covered in
# by Parrot, such as comparing a register to constant.
#
# gt_i_i    # TRUE op
# gt_i_ic   # PSEUDO op
# gt_ic_i   # PSEUDO op
# gt_ic_ic  # OPTIMIZED to non-conditional branch
#
# TODO: Handle numeric and string comparisons
#

sub op_gt
{
  my ($label, $a, $b, $le, $gt) = @_;
  op_comp($label, 'gt', $a, $b, $le, $gt);
}


#
# declare_var()
#

sub declare_var
{
  my ($name, $type) = @_;

#  printf(STDERR "jako: debug: Declaring variable '%s' of type '%s'...\n", $name, $type);

  if ($ident{$name}) {
    printf STDERR "jako: Redeclaration of variable '%s' on line %d. Previous declaration on line %d.\n",
      $name, $line, $ident{$name}{LINE};
    return 0;
  } else {
    my $num = scalar @{$regs{$type}};

    $ident{$name}{LINE} = $line;
    $ident{$name}{TYPE} = $type;
    $ident{$name}{NUM}  = $num;
    $ident{$name}{REG}  = "$type$num";

    $regs{$type}[$num]{LINE} = $line;
    $regs{$type}[$num]{NAME} = $name;

    print "# $name: $type$num\n";

    return 1;
  }
}


#
# assign_var()
#

sub assign_var
{
  my ($name, $type, $value) = @_;

  if ($ident{$name}) {
    if ($type eq '*') {
      if ($ident{$value}) {
        if ($ident{$name}{TYPE} ne $ident{$value}{TYPE}) {
          if ($ident{$name}{TYPE} eq "N" and $ident{$value}{TYPE} eq "I") {
            printf "%-12s %-8s %s\n", '', 'iton', "$ident{$name}{REG}, $ident{$value}{REG}";
          } elsif ($ident{$name}{TYPE} eq "I" and $ident{$value}{TYPE} eq "N") {
            printf "%-12s %-8s %s\n", '', 'ntoi', "$ident{$name}{REG}, $ident{$value}{REG}";
          } else {
            printf(STDERR "jako: Cannot assign type '%s' to type '%s' on line %d.\n", 
                    $ident{$value}{TYPE}, $ident{$name}{TYPE}, $line);
          }
        } else {
            printf "%-12s %-8s %s\n", '', 'set', "$ident{$name}{REG}, $ident{$value}{REG}";
        }
      } else {
        printf(STDERR "jako: Assignment from undefined variable '%s' on line %d.\n",
          $value, $line);
      }
    } elsif ($ident{$name}{TYPE} eq $type) {
      printf "%-12s %-8s %s\n", '', 'set', "$ident{$name}{REG}, $value";
    } else {
      printf(STDERR "jako: Assignment of %s variable from %s value not allowed on line %d.\n", 
        $ident{$name}{TYPE}, $type, $line);
    }
  } else {
    printf(STDERR "jako: Assignment to undefined variable '%s' on line %d.\n",
      $name, $line);
  }
}


#
# map_args()
#

sub map_args
{
  my (@args) = @_;
  my @result;

  foreach my $arg (@args) {
    $arg =~ s/^\s+//;
    $arg =~ s/\s+$//;

    if ($ident{$arg}) {
      push @result, $ident{$arg}{REG};
    } elsif ($arg =~ m/^"/) {
      push @result, $arg;
    } elsif ($arg =~ m/^\d+$/) {
      push @result, $arg;
    } elsif ($arg =~ m/^\d+\.\d+$/) {
      push @result, $arg;
    } else {
      printf(STDERR "jako: Unrecognized argument '%s' on line %d.\n", $arg, $line);
      push @result, "<err>";
    }
  }

  return @result;
}


#
# void_func()
#

sub void_func
{
  my ($name, @args) = @_;

  if ($name eq 'print') {
    @args = map_args(@args);
    foreach my $arg (@args) {
      printf "%-12s %-8s %s\n", '', $name, $arg;
    }
  } else {
    printf(STDERR "jako: Unrecognized function '%s' on line %d.\n", $name, $line);
  }
}


#
# assign_func()
#

sub assign_func
{
  my ($dest, $name, @args) = @_;

  if ($name eq 'mod') {
    @args = map_args($dest, @args);
    printf "%-12s %-8s %s\n", '', $name, join(", ", @args);
  } else {
    printf(STDERR "jako: Unrecognized function '%s' on line %d.\n", $name, $line);
  }
}


#
# begin_block()
#

sub begin_block
{
  my ($type,$cond) = @_;
  my %prefix = ( "while" => "_W", "if" => "_I" );
  $block_count++;

  my $prefix = "$prefix{$type}$block_count";
  
  push @block_stack, { TYPE => $type, NEXT => $line, PREFIX => $prefix };

  if ($cond =~ m/^(.*)\s*(==|!=|<=|<|>=|>)\s*(.*)$/) {
    op_comp("${prefix}_NEXT", $2, map_args($1, $3), "${prefix}_REDO", "${prefix}_LAST");
    emit_code("${prefix}_REDO");
  } else {
    printf(STDERR "jako: Syntax error. Unrecognized condition in '%s' on line %d.\n", $type, $line);
  }
}


#
# end_block()
#

sub end_block
{
  unless (@block_stack) {
    printf(STDERR "jako: Syntax error. Closing brace without open block on line %d.\n", $line);
    return;
  }

  my $block  = pop @block_stack;
  my $prefix = $block->{PREFIX};

  if ($block->{TYPE} eq 'while') {
    printf("%-12s %-8s %s\n", '', 'branch', "${prefix}_NEXT", );
  }

  printf "%s_LAST:\n", $prefix;
}


#
# do_loop_control()
#

sub do_loop_control
{
  my $which = uc shift;

  foreach (reverse @block_stack) {
    if ($_->{TYPE} eq 'while') {
      my $prefix = $_->{PREFIX};
      printf("%-12s %-8s %s\n", '', 'branch', "${prefix}_$which", );
      last;
    }
  }
}


#
# do_add()
#

sub do_add
{
  my ($dest, $a, $b) = @_;

  printf("%-12s %-8s %s\n", '', 'add', join(", ", map_args($dest, $a, $b)));
}


#
# do_inc()
#

sub do_inc
{
  printf("%-12s %-8s %s\n", '', 'inc', join(", ", map_args(@_)));
}


#
# do_sub()
#

sub do_sub
{
  my ($dest, $a, $b) = @_;

  printf("%-12s %-8s %s\n", '', 'sub', join(", ", map_args($dest, $a, $b)));
}


#
# do_dec()
#

sub do_dec
{
  printf("%-12s %-8s %s\n", '', 'dec', join(", ", map_args(@_)));
}


#
# do_mul()
#

sub do_mul
{
  my ($dest, $a, $b) = @_;

  printf("%-12s %-8s %s\n", '', 'mul', join(", ", map_args($dest, $a, $b)));
}


#
# do_div()
#

sub do_div
{
  my ($dest, $a, $b) = @_;

  printf("%-12s %-8s %s\n", '', 'div', join(", ", map_args($dest, $a, $b)));
}


#
# do_mod()
#

sub do_mod
{
  my ($dest, $a, $b) = @_;

  printf("%-12s %-8s %s\n", '', 'mod', join(", ", map_args($dest, $a, $b)));
}


#
# do_shift()
#

sub do_shift
{
  my ($dir, $dest, $a, $amount) = @_;

  printf("%-12s %-8s %s\n", '', "sh$dir", join(", ", map_args($dest, $a, $amount)));
}


#
# interpolate_string()
#
# Converts a single string argument:
#
#     "Foo $a ${b}ar\n"
#
# to multiple arguments:
#
#     "Foo ", a, " ", b, "ar ", b, "\n"
#
# to effect string interpolation.
#

sub interpolate_string
{
  my ($string) = @_;

  return $string unless $string =~ m/[^\\]\$/;

  $string =~ s/([^\\])\$((([A-Za-z][A-Za-z0-9_]*)\b)|({[A-Za-z][A-Za-z0=9_]*}))/$1", $2, "/g;

  return parse_args($string);
}


#
# parse_args()
#

sub parse_args
{
  my ($args) = @_;
  my @args;

  while ($args ne '') {
    $args =~ s/^\s+//;

    if ($args =~ m/^(\"[^\\\"]*(?:\\.[^\\\"]*)*\")\s*(,\s*(.*))?$/) {
      $args = $3 || '';
      push @args, interpolate_string($1);
    } elsif ($args =~ m/^([^,]+)\s*(,\s*(.*))?$/) {
      push @args, $1;
      $args = $3 || '';
    } else {
      printf(STDERR "jako: Syntax error. Cannot parse argument list '$args' on line %d.\n", $line);
      return ();
    }
  }

  return @args;
}


#
# MAIN PROGRAM:
#

print "# This file produced by the Jako Compiler\n";

while(<>) {
  $line++;

  if (m/^\s*#/) { print; next; } # Pass comment-only lines through intact.
  if (m/^\s*$/) { print; next; } # Pass whitespace-only lines through intact.

  chomp;                         # Trim trailing newline
  s/^\s*//;                      # Trim leading whitespace
  s/\s*$//;                      # Trim trailing whitespace
  last if (/^__END__$/);         # Done after __END__ token

  s/\s*;\s*$//; # Remove trailing semicolons

  #
  # Variable declarations:
  #
  # var int      foo;
  # var integer  foo;
  # var int      foo = 5;
  # var integer  foo = 5;
  #
  # var num      bar;
  # var number   bar;
  # var num      bar = 3.14;
  # var number   bar = 3.14;
  #
  # var str      splee;
  # var string   splee;
  # var str      splee = "Howdy";
  # var string   splee = "Howdy";
  #
  # var poly     quux;
  # var polytype quux;
  #

  if ((m/^var\s+(i)nt(eger)?\s+([A-Za-z][A-Za-z0-9_]*)(\s*=\s*(\d+))?$/) ||
      (m/^var\s+(n)um(ber)?\s+([A-Za-z][A-Za-z0-9_]*)(\s*=\s*(\d+(\.\d+)))?$/) ||
      (m/^var\s+(s)tr(ing)?\s+([A-Za-z][A-Za-z0-9_]*)(\s*=\s*(\"[^\\\"]*(?:\\.[^\\\"]*)*\"))?$/)) { 
    declare_var($3, uc($1));
    assign_var($3, uc($1), $5) if defined $5;
    next;
  }

  if (m/^var\s+poly(type)?\s+([A-Za-z][A-Za-z0-9_]*)$/) {
    declare_var($2, 'P');
    next;
  }

  #
  # Variable Assignments:
  #
  # a = 5;
  # a = 3.14;
  # a = "Howdy";
  #
 
  if (m/^([A-Za-z][A-Za-z0-9_]*)\s*=\s*(\d+)$/) {
    assign_var($1, 'I', $2);
    next;
  }
 
  if (m/^([A-Za-z][A-Za-z0-9_]*)\s*=\s*(\d+\.\d+)$/) {
    assign_var($1, 'N', $2);
    next;
  }

  if (m/^([A-Za-z][A-Za-z0-9_]*)\s*=\s*(\"[^\\\"]*(?:\\.[^\\\"]*)*\")$/) {
    assign_var($1, 'S', $2);
    next;
  }

  if (m/^([A-Za-z][A-Za-z0-9_]*)\s*=\s*([A-Za-z][A-Za-z0-9_]*)$/) {
    assign_var($1, '*', $2);
    next;
  }

  #
  # Function Calls:
  #
  #     foo(...);
  # a = foo(...);
  #
 
  if (m/^([A-Za-z][A-Za-z0-9_]*)\((.*)\)$/) {
    void_func($1, parse_args($2));
    next;
  }

  if (m/^([A-Za-z][A-Za-z0-9_]*)\s*=\s*([A-Za-z][A-Za-z0-9_]*)\((.*)\)$/) {
    assign_func($1, $2, split(/\s*,\s*/, $3));
    next;
  }

  #
  # Blocks:
  #
  if (m/^(while|if)\s*\(\s*(.*)\s*\)\s*{$/) {
    begin_block($1,$2);
    next;
  }

  #
  # Block Termination:
  #
  # }
  #

  if (m/^}$/) {
    end_block();
    next;
  }

  #
  # Loop Control Statements:
  #
  # next;
  # last;
  # redo;
  #

  if (m/^(next|last|redo)$/) {
    do_loop_control($1);
    next;
  }

  #
  # Additive Operators:
  #
  # a = b    + c;     # add_[in]
  # a = b    + 5;     # add_i_ic (psuedo-op)
  # a = b    + 3.14;  # add_n_nc (psuedo-op)
  # a = 5    + b;     # add_ic_i (pseudo-op)
  # a = 3.14 + b;     # add_nc_n (pseudo-op)
  # a = 5    + 2;     # set_i (COMPILE-TIME EVALUATION)
  # a = 3.14 + 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 5    + 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 3.14 + 2;     # set_n (COMPILE-TIME EVALUATION)
  #
  # a += b;           # add_[in]
  # a += 5;           # add_i_ic (pseudo-op)
  # a += 3.14;        # add_n_nc (pseudo-op)
  #
  # a++;              # inc_[in]
  #

  if (m/([A-Za-z][A-Za-z0-9]*)\s*=\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+(\.\d+)))\s*[+]\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+(\.\d+)))$/) {
    if (defined $3 or defined $7) {
      do_add($1, $3, $7);
    } elsif (defined $3 and defined $8) {
      assign_var($1, (defined $5 or defined $9 ? 'N' : 'I'), $4 + $8);
    } else {
      printf(STDERR "jako: Syntax error in addition on line %d: '%s'\n", $line, $_);
    }
    next;
  }

  if (m/([A-Za-z][A-Za-z0-9]*)\s*[+]=\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+(\.\d+)))$/) {
    if (defined $3) {
      do_add($1, $1, $2);
    } else {
      do_inc($1, $2);
    }
    next;
  }

  if (m/([A-Za-z][A-Za-z0-9_]*)\s*[+][+]$/) {
    do_inc($1);
    next;
  }

  #
  # Subtractive Operators:
  #
  # a = b    - c;     # sub_[in]
  # a = b    - 5;     # sub_i_ic (pseudo-op)
  # a = b    - 3.14;  # sub_n_nc (pseudo-op)
  # a = 5    - b;     # sub_ic_i (pseudo-op)
  # a = 3.14 - b;     # sub_nc_n (pseudo-op)
  # a = 5    - 2;     # set_i (COMPILE-TIME EVALUATION)
  # a = 3.14 - 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 5    - 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 3.14 - 2;     # set_n (COMPILE-TIME EVALUATION)
  #
  # a -= b;           # dec_{i_i,n_n} (pseudo-op)
  # a -= 5;           # sub_i_ic (pseudo-op)
  # a -= 3.14;        # sub_n_nc (pseudo-op)
  #
  # a--;              # dec_[in]
  #

  if (m/([A-Za-z][A-Za-z0-9]*)\s*=\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+(\.\d+)))\s*[-]\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+(\.\d+)))$/) {
    if (defined $3 or defined $7) {
      do_sub($1, $3, $7);
    } elsif (defined $3 and defined $8) {
      assign_var($1, (defined $5 or defined $9 ? 'N' : 'I'), $4 - $8);
    } else {
      printf(STDERR "jako: Syntax error in subtraction on line %d: '%s'\n", $line, $_);
    }
    next;
  }

  if (m/([A-Za-z][A-Za-z0-9]*)\s*[-]=\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+(\.\d+)))$/) {
    if (defined $3) {
      do_sub($1, $1, $2);
    } else {
      do_dec($1, $2);
    }
    next;
  }

  if (m/([A-Za-z][A-Za-z0-9_]*)\s*[-][-]$/) {
    do_dec($1, 1);
    next;
  }

  #
  # Multiplicative Operators:
  #
  # a = b    * c;     # mul_[in]
  # a = b    * 5;     # mul_i_ic (psuedo-op)
  # a = b    * 3.14;  # mul_n_nc (psuedo-op)
  # a = 5    * b;     # mul_ic_i (pseudo-op)
  # a = 3.14 * b;     # mul_nc_n (pseudo-op)
  # a = 5    * 2;     # set_i (COMPILE-TIME EVALUATION)
  # a = 3.14 * 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 5    * 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 3.14 * 2;     # set_n (COMPILE-TIME EVALUATION)
  #
  # a *= b;           # mul_[in]
  # a *= 5;           # mul_i_ic (pseudo-op)
  # a *= 3.14;        # mul_n_nc (pseudo-op)
  #

  if (m/([A-Za-z][A-Za-z0-9]*)\s*=\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+(\.\d+)))\s*[*]\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+(\.\d+)))$/) {
    if (defined $3 or defined $7) {
      do_mul($1, $3, $7);
    } elsif (defined $3 and defined $8) {
      assign_var($1, (defined $5 or defined $9 ? 'N' : 'I'), $4 * $8);
    } else {
      printf(STDERR "jako: Syntax error in multiplication on line %d: '%s'\n", $line, $_);
    }
    next;
  }

  if (m/([A-Za-z][A-Za-z0-9]*)\s*[*]=\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+(\.\d+)))$/) {
    do_mul($1, $1, $2);
    next;
  }

  #
  # Divisive Operators:
  #
  # a = b    / c;     # div_[in]
  # a = b    / 5;     # div_i_ic (psuedo-op)
  # a = b    / 3.14;  # div_n_nc (psuedo-op)
  # a = 5    / b;     # div_ic_i (pseudo-op)
  # a = 3.14 / b;     # div_nc_n (pseudo-op)
  # a = 5    / 2;     # set_i (COMPILE-TIME EVALUATION)
  # a = 3.14 / 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 5    / 0.16;  # set_n (COMPILE-TIME EVALUATION)
  # a = 3.14 / 2;     # set_n (COMPILE-TIME EVALUATION)
  #
  # a /= b;           # div_[in]
  # a /= 5;           # div_i_ic (pseudo-op)
  # a /= 3.14;        # div_n_nc (pseudo-op)
  #

  if (m/([A-Za-z][A-Za-z0-9]*)\s*=\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+(\.\d+)))\s*[\/]\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+(\.\d+)))$/) {
    if (defined $3 or defined $7) {
      do_div($1, $3, $7);
    } elsif (defined $3 and defined $8) {
      assign_var($1, (defined $5 or defined $9 ? 'N' : 'I'), $4 / $8);
    } else {
      printf(STDERR "jako: Syntax error in division on line %d: '%s'\n", $line, $_);
    }
    next;
  }

  if (m/([A-Za-z][A-Za-z0-9]*)\s*[\/]=\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+(\.\d+)))$/) {
    do_div($1, $1, $2);
    next;
  }

  #
  # Modular Arithmetic Operators:
  #
  # NOTE: No decimal numbers.
  #
  # a = b % c;
  # a = b % 4;
  # a = 9 % b;
  # a = 9 % 4;
  #
  # a %= b;
  # a %= 4;
  #

  if (m/([A-Za-z][A-Za-z0-9]*)\s*=\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+))\s*[%]\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+))$/) {
    do_mod($1, $2, $5);
    next;
  }

  if (m/([A-Za-z][A-Za-z0-9]*)\s*[%]=\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+))$/) {
    do_mod($1, $1, $2);
    next;
  }

  #
  # Bitwise Operators:
  #
  # a = b << 4;
  # a <<= 4;
  #
  # TODO: Can't really support shift amount as arg until sh[lr]_i_i ops are implemented.
  #

  if (m/([A-Za-z][A-Za-z0-9]*)\s*=\s*([A-Za-z][A-Za-z0-9_]*)\s*(<<|>>)\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+))$/) {
    do_shift($3 eq '<<' ? 'l' : 'r', $1, $2, $4);
    next;
  }

  if (m/([A-Za-z][A-Za-z0-9]*)\s*((<<|>>)=)\s*(([A-Za-z][A-Za-z0-9_]*)|(\d+))$/) {
    do_shift($4 eq '<<' ? 'l' : 'r', $1, $2, $5);
    next;
  }

  #
  # Miscellany:
  #

  if (m/^end$/) {
    printf "%-12s %-8s\n", '', 'end';
    next;
  }

  print STDERR "jako: Syntax error on line $line: '$_'.\n";
}

exit 0;

#
# End of file.
#
