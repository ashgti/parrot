/*
 * $Id$
 * Copyright (C) 2006-2008, Parrot Foundation.
 */

/* .NET CLI Bytecode PMC */


#include "parrot/extend.h"
#include "tableinfo.h"
#include "structures.h"


pmclass DotNetBytecode dynpmc group dotnet {

    /* Instance initialization. We need a custom GC marking and destroy. */
    void init()
    {
        PObj_custom_mark_SET(SELF);
        PObj_active_destroy_SET(SELF);
    }


    /* Garbage Collection mark routine. */
    void mark()
    {
        /* Tell the GC about stuff we're holding on to. */
        dotnet_bytecode *bc = (dotnet_bytecode *)PMC_struct_val(SELF);
        if (bc->parent)
            pobject_lives(INTERP, (PObj *)bc->parent);
        if (bc->eh)
            pobject_lives(INTERP, (PObj *)bc->eh);
    }


    /* Destructor. */
    void destroy()
    {
        /* Cleanup any memory we're using. */
        if (PMC_struct_val(SELF)) {
            dotnet_bytecode *bc = (dotnet_bytecode *)PMC_struct_val(SELF);
            if (bc->body)
                mem_sys_free(bc->body);
            mem_sys_free(bc);
            PMC_struct_val(SELF) = NULL;
        }
    }


    /* Get local variables signature blob location. */
    METHOD INTVAL get_locals_sig()
    {
        dotnet_bytecode *bc = (dotnet_bytecode *)PMC_struct_val(SELF);
        INTVAL           result;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        result = (INTVAL)bc->locals_signature;
        RETURN(INTVAL result);
    }


    /* Initialize local variables flag. */
    METHOD INTVAL init_locals()
    {
        dotnet_bytecode *bc = (dotnet_bytecode *)PMC_struct_val(SELF);
        INTVAL           result;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        result = bc->init_locals_flag;
        RETURN(INTVAL result);
    }


    /* Get length of bytecode. */
    METHOD INTVAL get_length()
    {
        dotnet_bytecode *bc = (dotnet_bytecode *)PMC_struct_val(SELF);
        INTVAL           result;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        result = bc->body_size;
        RETURN(INTVAL result);
    }


    /* Get current bytecode position, for when walking bytecode. */
    METHOD INTVAL get_pos()
    {
        dotnet_bytecode *bc = (dotnet_bytecode *)PMC_struct_val(SELF);
        INTVAL           result;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        result = bc->cur_pos;
        RETURN(INTVAL result);
    }


    /* Set current bytecode position, for when walking bytecode. */
    METHOD void set_pos(INTVAL pos)
    {
        dotnet_bytecode *bc = (dotnet_bytecode *)PMC_struct_val(SELF);

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        bc->cur_pos = pos;
    }


    /* Get error handlers PMC array. */
    METHOD PMC* get_eh()
    {
        dotnet_bytecode *bc = (dotnet_bytecode *)PMC_struct_val(SELF);
        PMC             *result;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        result = bc->eh;
        RETURN(PMC *result);
    }


    /* Read a signed 8-bit integer. */
    METHOD INTVAL read_int8()
    {
        dotnet_bytecode *bc = (dotnet_bytecode *)PMC_struct_val(SELF);
        INTVAL           result = 0;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        /* Ensure we won't read past the end. */
        if (bc->cur_pos >= bc->body_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Read past end of bytecode");

        /* Otherwise read the value. */
        result = (INTVAL)bc->body[bc->cur_pos];
        bc->cur_pos++;
        RETURN(INTVAL result);
    }


    /* Read an unsigned 8-bit integer. */
    METHOD INTVAL read_uint8()
    {
        dotnet_bytecode *bc = (dotnet_bytecode *)PMC_struct_val(SELF);
        INTVAL           result = 0;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        /* Ensure we won't read past the end. */
        if (bc->cur_pos >= bc->body_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Read past end of bytecode");

        /* Otherwise read the value. */
        result = (INTVAL)((unsigned char)bc->body[bc->cur_pos]);
        bc->cur_pos++;
        RETURN(INTVAL result);
    }


    /* Read a signed 16-bit integer. */
    METHOD INTVAL read_int16()
    {
        INTVAL           result  = 0;
        dotnet_bytecode *bc      = (dotnet_bytecode *)PMC_struct_val(SELF);
        char            *val_ptr = (char *)&result;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        /* Ensure we won't read past the end. */
        if (bc->cur_pos + 1 >= bc->body_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Read past end of bytecode");

        /* Otherwise read the value. */
        if (PARROT_BIGENDIAN)
        {
            val_ptr[1] = bc->body[bc->cur_pos];
            val_ptr[0] = bc->body[bc->cur_pos + 1];
        }
        else
        {
            val_ptr[0] = bc->body[bc->cur_pos];
            val_ptr[1] = bc->body[bc->cur_pos + 1];
        }
        bc->cur_pos += 2;
        RETURN(INTVAL result);
    }


    /* Read an unsigned 16-bit integer. */
    METHOD INTVAL read_uint16()
    {
        INTVAL           result  = 0;
        dotnet_bytecode *bc      = (dotnet_bytecode *)PMC_struct_val(SELF);
        char            *val_ptr = (char *)&result;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        /* Ensure we won't read past the end. */
        if (bc->cur_pos + 1 >= bc->body_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Read past end of bytecode");

        /* Otherwise read the value. */
        if (PARROT_BIGENDIAN)
        {
            val_ptr[1] = bc->body[bc->cur_pos];
            val_ptr[0] = bc->body[bc->cur_pos + 1];
        }
        else
        {
            val_ptr[0] = bc->body[bc->cur_pos];
            val_ptr[1] = bc->body[bc->cur_pos + 1];
        }
        bc->cur_pos += 2;
        RETURN(INTVAL result);
    }


    /* Read a signed 32-bit integer. */
    METHOD INTVAL read_int32()
    {
        INTVAL           result  = 0;
        dotnet_bytecode *bc      = (dotnet_bytecode *)PMC_struct_val(SELF);
        char            *val_ptr = (char *)&result;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        /* Ensure we won't read past the end. */
        if (bc->cur_pos + 3 >= bc->body_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Read past end of bytecode");

        /* Otherwise read the value. */
        if (PARROT_BIGENDIAN)
        {
            val_ptr[3] = bc->body[bc->cur_pos];
            val_ptr[2] = bc->body[bc->cur_pos + 1];
            val_ptr[1] = bc->body[bc->cur_pos + 2];
            val_ptr[0] = bc->body[bc->cur_pos + 3];
        }
        else
        {
            val_ptr[0] = bc->body[bc->cur_pos];
            val_ptr[1] = bc->body[bc->cur_pos + 1];
            val_ptr[2] = bc->body[bc->cur_pos + 2];
            val_ptr[3] = bc->body[bc->cur_pos + 3];
        }
        bc->cur_pos += 4;
        RETURN(INTVAL result);
    }


    /* Read an unsigned 32-bit integer. */
    METHOD INTVAL read_uint32()
    {
        INTVAL           result  = 0;
        dotnet_bytecode *bc      = (dotnet_bytecode *)PMC_struct_val(SELF);
        char            *val_ptr = (char *)&result;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        /* Ensure we won't read past the end. */
        if (bc->cur_pos + 3 >= bc->body_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Read past end of bytecode");

        /* Otherwise read the value. */
        if (PARROT_BIGENDIAN)
        {
            val_ptr[3] = bc->body[bc->cur_pos];
            val_ptr[2] = bc->body[bc->cur_pos + 1];
            val_ptr[1] = bc->body[bc->cur_pos + 2];
            val_ptr[0] = bc->body[bc->cur_pos + 3];
        }
        else
        {
            val_ptr[0] = bc->body[bc->cur_pos];
            val_ptr[1] = bc->body[bc->cur_pos + 1];
            val_ptr[2] = bc->body[bc->cur_pos + 2];
            val_ptr[3] = bc->body[bc->cur_pos + 3];
        }
        bc->cur_pos += 4;
        RETURN(INTVAL result);
    }


    /* Read a 32-bit (single precision) floating pointer number. */
    METHOD FLOATVAL read_float32()
    {
        FLOATVAL         result  = 0;
        dotnet_bytecode *bc      = (dotnet_bytecode *)PMC_struct_val(SELF);
        char            *val_ptr = (char *)&result;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        /* Ensure we won't read past the end. */
        if (bc->cur_pos + 3 >= bc->body_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Read past end of bytecode");

        /* Otherwise read the value. */
        if (PARROT_BIGENDIAN)
        {
            val_ptr[3] = bc->body[bc->cur_pos];
            val_ptr[2] = bc->body[bc->cur_pos + 1];
            val_ptr[1] = bc->body[bc->cur_pos + 2];
            val_ptr[0] = bc->body[bc->cur_pos + 3];
        }
        else
        {
            val_ptr[0] = bc->body[bc->cur_pos];
            val_ptr[1] = bc->body[bc->cur_pos + 1];
            val_ptr[2] = bc->body[bc->cur_pos + 2];
            val_ptr[3] = bc->body[bc->cur_pos + 3];
        }
        bc->cur_pos += 4;
        RETURN(FLOATVAL result);
    }


    /* Read a 64-bit (double precision) floating pointer number. */
    METHOD FLOATVAL read_float64()
    {
        int              i;
        FLOATVAL         result  = 0;
        dotnet_bytecode *bc      = (dotnet_bytecode *)PMC_struct_val(SELF);
        char            *val_ptr = (char *)&result;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        /* Ensure we won't read past the end. */
        if (bc->cur_pos + 7 >= bc->body_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Read past end of bytecode");

        /* Otherwise read the value. */
        for (i = 0; i <= 4; i += 4) {
            if (PARROT_BIGENDIAN)
            {
                val_ptr[i + 3] = bc->body[bc->cur_pos + i];
                val_ptr[i + 2] = bc->body[bc->cur_pos + i + 1];
                val_ptr[i + 1] = bc->body[bc->cur_pos + i + 2];
                val_ptr[i] = bc->body[bc->cur_pos + i + 3];
            }
            else
            {
                val_ptr[i] = bc->body[bc->cur_pos + i];
                val_ptr[i + 1] = bc->body[bc->cur_pos + i + 1];
                val_ptr[i + 2] = bc->body[bc->cur_pos + i + 2];
                val_ptr[i + 3] = bc->body[bc->cur_pos + i + 3];
            }
        }
        bc->cur_pos += 8;
        RETURN(FLOATVAL result);
    }


    /* Read a field token (32 bits, unsigned). */
    METHOD INTVAL read_tfield()
    {
        INTVAL           result  = 0;
        dotnet_bytecode *bc      = (dotnet_bytecode *)PMC_struct_val(SELF);
        char            *val_ptr = (char *)&result;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        /* Ensure we won't read past the end. */
        if (bc->cur_pos + 3 >= bc->body_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Read past end of bytecode");

        /* Otherwise read the value. */
        if (PARROT_BIGENDIAN)
        {
            val_ptr[3] = bc->body[bc->cur_pos];
            val_ptr[2] = bc->body[bc->cur_pos + 1];
            val_ptr[1] = bc->body[bc->cur_pos + 2];
            val_ptr[0] = bc->body[bc->cur_pos + 3];
        }
        else
        {
            val_ptr[0] = bc->body[bc->cur_pos];
            val_ptr[1] = bc->body[bc->cur_pos + 1];
            val_ptr[2] = bc->body[bc->cur_pos + 2];
            val_ptr[3] = bc->body[bc->cur_pos + 3];
        }
        bc->cur_pos += 4;
        RETURN(INTVAL result);
    }


    /* Read a method token (32 bits, unsigned). */
    METHOD INTVAL read_tmethod()
    {
        INTVAL           result  = 0;
        dotnet_bytecode *bc      = (dotnet_bytecode *)PMC_struct_val(SELF);
        char            *val_ptr = (char *)&result;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        /* Ensure we won't read past the end. */
        if (bc->cur_pos + 3 >= bc->body_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Read past end of bytecode");

        /* Otherwise read the value. */
        if (PARROT_BIGENDIAN)
        {
            val_ptr[3] = bc->body[bc->cur_pos];
            val_ptr[2] = bc->body[bc->cur_pos + 1];
            val_ptr[1] = bc->body[bc->cur_pos + 2];
            val_ptr[0] = bc->body[bc->cur_pos + 3];
        }
        else
        {
            val_ptr[0] = bc->body[bc->cur_pos];
            val_ptr[1] = bc->body[bc->cur_pos + 1];
            val_ptr[2] = bc->body[bc->cur_pos + 2];
            val_ptr[3] = bc->body[bc->cur_pos + 3];
        }
        bc->cur_pos += 4;
        RETURN(INTVAL result);
    }


    /* Read a type token (32 bits, unsigned). */
    METHOD INTVAL read_ttype()
    {
        INTVAL           result  = 0;
        dotnet_bytecode *bc      = (dotnet_bytecode *)PMC_struct_val(SELF);
        char            *val_ptr = (char *)&result;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        /* Ensure we won't read past the end. */
        if (bc->cur_pos + 3 >= bc->body_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Read past end of bytecode");

        /* Otherwise read the value. */
        if (PARROT_BIGENDIAN)
        {
            val_ptr[3] = bc->body[bc->cur_pos];
            val_ptr[2] = bc->body[bc->cur_pos + 1];
            val_ptr[1] = bc->body[bc->cur_pos + 2];
            val_ptr[0] = bc->body[bc->cur_pos + 3];
        }
        else
        {
            val_ptr[0] = bc->body[bc->cur_pos];
            val_ptr[1] = bc->body[bc->cur_pos + 1];
            val_ptr[2] = bc->body[bc->cur_pos + 2];
            val_ptr[3] = bc->body[bc->cur_pos + 3];
        }

        bc->cur_pos += 4;
        RETURN(INTVAL result);
    }


    /* Read a string token (32 bits, unsigned). */
    METHOD INTVAL read_tstring()
    {
        INTVAL           result  = 0;
        dotnet_bytecode *bc      = (dotnet_bytecode *)PMC_struct_val(SELF);
        char            *val_ptr = (char *)&result;

        /* Handle cases where we've an invalid PMC. */
        if (!bc)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Invalid DotNetBytecode PMC");

        /* Ensure we won't read past the end. */
        if (bc->cur_pos + 3 >= bc->body_size)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
               "Read past end of bytecode");

        /* Otherwise read the value. */
        if (PARROT_BIGENDIAN)
        {
            val_ptr[3] = bc->body[bc->cur_pos];
            val_ptr[2] = bc->body[bc->cur_pos + 1];
            val_ptr[1] = bc->body[bc->cur_pos + 2];
            val_ptr[0] = bc->body[bc->cur_pos + 3];
        }
        else
        {
            val_ptr[0] = bc->body[bc->cur_pos];
            val_ptr[1] = bc->body[bc->cur_pos + 1];
            val_ptr[2] = bc->body[bc->cur_pos + 2];
            val_ptr[3] = bc->body[bc->cur_pos + 3];
        }
        bc->cur_pos += 4;
        RETURN(INTVAL result);
    }
}


/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
