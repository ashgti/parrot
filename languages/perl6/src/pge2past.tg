## $Id$

transform past (ROOT) :language('PIR') {
    .local pmc past
    past = new 'Perl6::PAST::Block'
    past.'init'('node'=>node, 'name'=>'anon', 'blocktype'=>'block')
    store_global 'Perl6::PAST', '$?BLOCK', past
    .local pmc cpast, cpost
    cpast = node['statement_list']
    cpost = tree.'get'('past', cpast, 'Perl6::Grammar::statement_list')
    past.'add_child'(cpost)
    .return (past)
}


transform past (Perl6::Grammar::statement_list) :language('PIR') {
    .local pmc past
    .local pmc iter

    past = new 'Perl6::PAST::Stmts'
    past.'init'('node'=>node)

    $P0 = node['statement']
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    $P1 = shift iter
    $P2 = tree.'get'('past', $P1, 'Perl6::Grammar::statement')
    if null $P2 goto iter_loop
    past.'add_child'($P2)
    goto iter_loop
  iter_end:
    .return (past)
}


transform past (Perl6::Grammar::statement) :language('PIR') {
    $P0 = node['statement_control']
    if $P0 goto statement_control
    $P0 = node['block']
    if $P0 goto statement_block
    $P0 = node['use_statement']
    if $P0 goto statement_use

  expression:
    .local pmc stmt
    $P0 = node['expression']
    stmt = tree.'get'('past', $P0, 'Perl6::Grammar::expression')
    $P0 = node['statement_modifier']
    unless $P0 goto expression_1
  stmt_modifier:
    # handle if/unless modifier
    .local pmc modifier, exprpast, thenpast, elsepast
    modifier = $P0[0]
    thenpast = stmt
    null elsepast
    $S0 = modifier['KEY']
    if $S0 != 'unless' goto stmt_modifier_1
    exchange thenpast, elsepast
  stmt_modifier_1:
    $P0 = modifier['expression']
    exprpast = tree.'get'('past', $P0, 'Perl6::Grammar::expression')
    stmt = new 'Perl6::PAST::Op'
    stmt.'init'(exprpast, thenpast, elsepast, 'name'=>'statement_control:if', 'node'=>modifier)

  expression_1:
    .local pmc past
    past = new 'Perl6::PAST::Stmt'
    past.'init'(stmt, 'node'=>node)
    .return (past)

  statement_control:
    $P1 = tree.'get'('past', $P0, 'Perl6::Grammar::statement_control')
    past = new 'Perl6::PAST::Stmt'
    past.'init'($P1, 'node'=>node)
    .return (past)

  statement_block:
    $P1 = tree.'get'('past', $P0, 'Perl6::Grammar::block')
    $P1.'blocktype'('immediate')
    past = new 'Perl6::PAST::Stmt'
    past.'init'($P1, 'node'=>node)
    .return (past)

  statement_use:
    null $P0
    .return ($P0)
}


transform past (Perl6::Grammar::statement_control) :language('PIR') {
    .local pmc key, exprlist, blocklist
    key = node['KEY']
    exprlist = node['expression']
    blocklist = node['block']

    ##   do we have an else clause?
    .local pmc exprpast, thenpast, elsepast
    .local int exprc, blockc
    null elsepast
  else_block:
    exprc = elements exprlist
    blockc = elements blocklist
    if blockc <= exprc goto expr_block_pair
    dec blockc
    $P0 = blocklist[blockc]
    elsepast = tree.'get'('past', $P0, 'Perl6::Grammar::block')
    elsepast.'blocktype'('immediate')

  expr_block_pair:
    ##   each remaining block is paired with an "if" (or "elsif")
    ##   expression, except the first which could be "unless".
    dec exprc
    dec blockc
    $P0 = exprlist[exprc]
    exprpast = tree.'get'('past', $P0, 'Perl6::Grammar::expression')
    $P0 = blocklist[blockc]
    thenpast = tree.'get'('past', $P0, 'Perl6::Grammar::block')
    thenpast.'blocktype'('immediate')
    if exprc > 0 goto if_op
    if key != 'unless' goto if_op
    exchange thenpast, elsepast

  if_op:
    .local pmc past
    past = new "Perl6::PAST::Op"
    past.init(exprpast, thenpast, elsepast, 'node'=>node, 'name'=>'statement_control:if')
    elsepast = past
    if exprc > 0 goto expr_block_pair
    .return (past)
}


transform past (Perl6::Grammar::expression) :language('PIR') {
    .local pmc past

    $P0 = node['expr']
    $P1 = tree.'get'('past', $P0, 'Perl6::Grammar::expr')
    past = new 'Perl6::PAST::Exp'
    past.'init'($P1, 'node'=>node)
    .return (past)
}


transform past (Perl6::Grammar::expr) :language('PIR') {
    .local string type
    type = node['type']
    if type != "" goto pastrule
    null $P0
    .return ($P0)

  pastrule:
    .local pmc optable, optok
    optable = find_global 'Perl6::Grammar', '$optable'
    optok = optable[type]
    $S0 = optok['pastrule']
    unless $S0 goto no_pastrule
    .return tree.'get'($S0, node, 'Perl6::Grammar::expr')
  no_pastrule:

    .local pmc past, children, iter
    past = new 'Perl6::PAST::Op'
    past.'init'('node'=>node, 'name'=>type)
    $P0 = node.'get_array'()
    if null $P0 goto iter_end
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    $P0 = shift iter
    $S0 = $P0
    if $S0 == "" goto iter_loop
    $P1 = tree.'get'('past', $P0, 'Perl6::Grammar::expr')
    if null $P1 goto iter_loop
    past.'add_child'($P1)
    goto iter_loop
  iter_end:
    if type == 'infix:or' goto infix_or
    if type != 'infix:||' goto end
  infix_or:
    ##   We cheat a bit here, moving the "then" portion of an 'or'
    ##   node to the 'else' portion.
    $P0 = past[1]
    past[2] = $P0
    null $P0
    past[1] = $P0
  end:
    .return (past)
}


transform past_term (Perl6::Grammar::expr) :language('PIR') {
    .local pmc iter, past
    ##   listop requires special handling
    $I0 = defined node['listop']
    if $I0 goto term_listop

    ##   for all other terms, we can call a different
    ##   rule based on the subrule matched
    $P0 = node.'get_hash'()
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto term_error
    $S0 = shift iter
    if $S0 == 'type' goto iter_loop
    if $S0 == 'postop' goto iter_loop
    $P0 = iter[$S0]
    $S1 = concat 'Perl6::Grammar::', $S0
    past = tree.'get'('past', $P0, $S1)
    if null past goto iter_loop
    goto term_postop

  term_listop:
    ##   convert the listop name to &name var
    .local string name
    name = node['listop';'ident']
    name = concat '&', name
    past = new 'Perl6::PAST::Var'
    past.'init'('name'=>name, 'node'=>node)
    $I0 = defined node['listop_expression']
    if $I0 == 0 goto no_listop_args
    .local pmc cpast
    $P0 = node['listop_expression';0;'expr']
    cpast = tree.'get'('past', $P0, 'Perl6::Grammar::expr')
    past = past.'new'('Perl6::PAST::Op', past, cpast, 'name'=>'postcircumfix:( )')
    goto term_postop
  no_listop_args:
    $I0 = defined node['postop']
    if $I0 goto term_postop
    past = past.'new'('Perl6::PAST::Op', past, 'name'=>'postcircumfix:( )')

  term_postop:
    ##   now, add any post[circum]fix ops that might have occurred
    $I0 = exists node['postop']
    if $I0 == 0 goto postop_end
    $P0 = node['postop']
    iter = new .Iterator, $P0
  postop_loop:
    unless iter goto postop_end
    ##   process a single postop
    .local pmc postop
    postop = shift iter
    $P0 = postop.'get_hash'()
    $P0 = new .Iterator, $P0
    .local string opname
    opname = shift $P0
    postop = $P0[opname]
    opname = concat opname, ':'
    $S0 = postop['KEY']
    opname = concat opname, $S0
    $S0 = postop['KEY_CLOSE']
    if $S0 == '' goto with_opname
    opname = concat opname, ' '
    opname = concat opname, $S0
  with_opname:
    past = past.'new'('Perl6::PAST::Op', past, 'name'=>opname)
    $I0 = exists postop['expression';0;'expr']
    if $I0 == 0 goto postop_loop
    $P1 = postop['expression';0;'expr']
    $P1 = tree.'get'('past', $P1, 'Perl6::Grammar::expr')
    past.'add_child'($P1)
    goto postop_loop
  postop_end:
    .return (past)

  term_error:
    print "error: 'term' node has incorrect structure.\n"
    end
}


transform past (Perl6::Grammar::circumfix) :language('PIR') {
    .local string name
    $S0 = node['KEY']
    $S1 = node['KEY_CLOSE']
    name = concat 'circumfix:', $S0
    name = concat name, ' '
    name = concat name, $S1
    .local pmc past
    past = new 'Perl6::PAST::Op'
    past.'init'('node'=>node, 'name'=>name)
    $I0 = exists node['expression';0]
    if $I0 == 0 goto end
    $P0 = node['expression';0;'expr']
    $P1 = tree.'get'('past', $P0, 'Perl6::Grammar::expr')
    past.'add_child'($P1)
  end:
    .return (past)
}



transform past (Perl6::Grammar::scoped_variables) :language('PIR') {
    .local string scope, name
    scope = node['scope_declarator']
    name = node['variable']

    if scope == 'my' goto scope_my
    scope = 'package'
    goto make_past
  scope_my:
    scope = 'lexical'

  make_past:
    .local pmc past
    past = new 'Perl6::PAST::Var'
    past.'init'('node'=>node, 'name'=>name, 'scope'=>scope)

    .local pmc block
    block = find_global 'Perl6::PAST', '$?BLOCK'
    block.'vardecl'(name, past)
    .return (past)
}


transform past (Perl6::Grammar::variable) :language('PIR') {
    .local string name
    name = node
    .local pmc past
    past = new 'Perl6::PAST::Var'
    past.'init'('node'=>node, 'name'=>name)

    .local pmc block, vdecl
    block = find_global 'Perl6::PAST', '$?BLOCK'
    vdecl = block.'vardecl'(name)
    $I0 = isa vdecl, 'Perl6::PAST::Var'
    if $I0 == 0 goto declare_var
    $S0 = vdecl.'scope'()
    past.'scope'($S0)
    .return (past)
  declare_var:
    past.'scope'('outer')
    block.'vardecl'(name, past)
    .return (past)
}


transform past (Perl6::Grammar::integer) :language('PIR') {
    .local pmc past
    $P0 = new .Perl6Str
    $S0 = node
    $P0 = $S0
    $I0 = $P0
    past = new 'Perl6::PAST::Val'
    past.'init'('node'=>node, 'valtype'=>'int', 'name'=>$I0)
    .return (past)
}


transform past (Perl6::Grammar::number) :language('PIR') {
    .local pmc past
    $N0 = node
    past = new 'Perl6::PAST::Val'
    past.'init'('node'=>node, 'valtype'=>'num', 'name'=>$N0)
    .return (past)
}


transform past (Perl6::Grammar::string_literal) :language('PIR') {
    .local pmc past
    $P0 = node['quoted_literal']
    $P0 = $P0.'get_array'()
    .local pmc iter
    iter = new .Iterator, $P0
    null past
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    $S0 = cnode['type']
    if $S0 == 'str' goto cpast_str
    cpast = tree.'get'('past', cnode, $S0)
    goto cpast_add
  cpast_str:
    $S0 = cnode
    cpast = new 'Perl6::PAST::Val'
    cpast.'init'('node'=>node, 'valtype'=>'str', 'name'=>$S0)
  cpast_add:
    unless null past goto cpast_concat
    past = cpast
    goto iter_loop
  cpast_concat:
    past = past.'new'('Perl6::PAST::Op', past, cpast, 'node'=>node, 'name'=>'infix:~')
    goto iter_loop
  iter_end:
    .return (past)
}


transform past (Perl6::Grammar::version) :language('PIR') {
    $S0 = node
    $S0 = concat "'", $S0
    $S0 = concat $S0, "'"
    .local pmc past
    past = new 'Perl6::PAST::Val'
    past.'init'('node'=>node, 'valtype'=>'str', 'name'=>$S0)
    .return (past)
}


transform past (Perl6::Grammar::block) :language('PIR') {
    .local pmc outer, past
    outer = find_global 'Perl6::PAST', '$?BLOCK'
    past = new 'Perl6::PAST::Block'
    past.'init'('node'=>node, 'outer'=>outer, 'blocktype'=>'block')
    store_global 'Perl6::PAST', '$?BLOCK', past
    .local pmc cpast
    $P0 = node['statement_list']
    cpast = tree.'get'('past', $P0, 'Perl6::Grammar::statement_list')
    past.'add_child'(cpast)
    store_global 'Perl6::PAST', '$?BLOCK', outer
    .return (past)
}


transform past (Perl6::Grammar::regex_term) :language('PIR') {
    .local pmc outer, past
    outer = find_global 'Perl6::PAST', '$?BLOCK'
    past = new 'Perl6::PAST::Block'
    past.'init'('node'=>node, 'outer'=>outer, 'blocktype'=>'regex')
    $P0 = node['regex']
    past.'add_child'($P0)
    .return (past)
}


transform past (Perl6::Grammar::subroutine) :language('PIR') {
    .local pmc outer, past
    outer = find_global 'Perl6::PAST', '$?BLOCK'
    past = new 'Perl6::PAST::Block'
    past.'init'('node'=>node, 'outer'=>outer, 'blocktype'=>'sub')
    store_global 'Perl6::PAST', '$?BLOCK', past

    $P0 = node['ident']
    unless $P0 goto with_ident
    $S0 = $P0[0]
    past.'name'($S0)
  with_ident:

    $I0 = exists node['signature']
    if $I0 == 0 goto with_signature
    $P0 = node['signature';0;'invocants';'parameter']
    .local pmc iter
    iter = new .Iterator, $P0
  invocant_loop:
    unless iter goto invocant_end
    .local pmc pnode
    .local string pname
    pnode = shift iter
    pname = pnode['variable']
    $P0 = past.'add_child_new'('Perl6::PAST::Var', 'node'=>pnode, 'name'=>pname, 'scope'=>'parameter')
    past.'vardecl'(pname, $P0)
    goto invocant_loop
  invocant_end:
  with_signature:

    .local pmc cpast
    $P0 = node['block';'statement_list']
    cpast = tree.'get'('past', $P0, 'Perl6::Grammar::statement_list')
    past.'add_child'(cpast)
    store_global 'Perl6::PAST', '$?BLOCK', outer
    .return (past)
}

## vim: expandtab sw=4
