## $Id$

ROOT: past(.) = {
    .local pmc past
    past = new 'Perl6::PAST::Block'
    past.'init'('node'=>node, 'name'=>'anon', 'blocktype'=>'block')
    store_global 'Perl6::PAST', '$?BLOCK', past
    .local pmc cpast, cpost
    cpast = node['statement_list']
    cpost = tree.'get'('past', cpast, 'Perl6::Grammar::statement_list')
    past.'add_child'(cpost)
    .return (past)
}


Perl6::Grammar::statement_list:  past(.) = {
    .local pmc past
    .local pmc iter

    past = new 'Perl6::PAST::Stmts'
    past.'init'('node'=>node)

    $P0 = node['statement']
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    $P1 = shift iter
    $P2 = tree.'get'('past', $P1, 'Perl6::Grammar::statement')
    if null $P2 goto iter_loop
    past.'add_child'($P2)
    goto iter_loop
  iter_end:
    .return (past)
}


Perl6::Grammar::statement: past(.) = {
    $P0 = node['statement_control']
    if $P0 goto statement_control
    $P0 = node['block']
    if $P0 goto block

  expression:
    .local pmc stmt
    $P0 = node['expression']
    stmt = tree.'get'('past', $P0, 'Perl6::Grammar::expression')
    $P0 = node['statement_modifier']
    unless $P0 goto expression_1
  stmt_modifier:
    # handle if/unless modifier
    .local pmc modifier, exprpast, thenpast, elsepast
    modifier = $P0[0]
    thenpast = stmt
    null elsepast
    $S0 = modifier['KEY']
    if $S0 != 'unless' goto stmt_modifier_1
    exchange thenpast, elsepast
  stmt_modifier_1:
    $P0 = modifier['expression']
    exprpast = tree.'get'('past', $P0, 'Perl6::Grammar::expression')
    stmt = new 'Perl6::PAST::Op'
    stmt.'init'(exprpast, thenpast, elsepast, 'op'=>'statement_control:if', 'node'=>modifier)

  expression_1:
    .local pmc past
    past = new 'Perl6::PAST::Stmt'
    past.'init'(stmt, 'node'=>node)
    .return (past)

  statement_control:
    $P1 = tree.'get'('past', $P0, 'Perl6::Grammar::statement_control')
    past = new 'Perl6::PAST::Stmt'
    past.'init'($P1, 'node'=>node)
    .return (past)

  block:
    $P1 = tree.'get'('past', $P0, 'Perl6::Grammar::block')
    $P1.'blocktype'('immediate')
    past = new 'Perl6::PAST::Stmt'
    past.'init'($P1, 'node'=>node)
    .return (past)
}


Perl6::Grammar::statement_control: past(.) = {
    .local pmc key, exprlist, blocklist
    key = node['KEY']
    exprlist = node['expression']
    blocklist = node['block']

    ##   do we have an else clause?
    .local pmc exprpast, thenpast, elsepast
    .local int exprc, blockc
    null elsepast
  else_block:
    exprc = elements exprlist
    blockc = elements blocklist
    if blockc <= exprc goto expr_block_pair
    dec blockc
    $P0 = blocklist[blockc]
    elsepast = tree.'get'('past', $P0, 'Perl6::Grammar::block')
    elsepast.'blocktype'('immediate')

  expr_block_pair:
    ##   each remaining block is paired with an "if" (or "elsif")
    ##   expression, except the first which could be "unless".
    dec exprc
    dec blockc
    $P0 = exprlist[exprc]
    exprpast = tree.'get'('past', $P0, 'Perl6::Grammar::expression')
    $P0 = blocklist[blockc]
    thenpast = tree.'get'('past', $P0, 'Perl6::Grammar::block')
    thenpast.'blocktype'('immediate')
    if exprc > 0 goto if_op
    if key != 'unless' goto if_op
    exchange thenpast, elsepast

  if_op:
    .local pmc past
    past = new "Perl6::PAST::Op"
    past.init(exprpast, thenpast, elsepast, 'node'=>node, 'op'=>'statement_control:if')
    elsepast = past
    if exprc > 0 goto expr_block_pair
    .return (past)
}


Perl6::Grammar::expression: past(.) = {
    .local pmc past

    $P0 = node['expr']
    $P1 = tree.'get'('past', $P0, 'Perl6::Grammar::expr')
    past = new 'Perl6::PAST::Exp'
    past.'init'($P1, 'node'=>node)
    .return (past)
}


Perl6::Grammar::expr: past(.) = {
    .local string type
    type = node['type']
    if type != "" goto pastrule
    null $P0
    .return ($P0)

  pastrule:
    .local pmc optable, optok
    optable = find_global 'Perl6::Grammar', '$optable'
    optok = optable[type]
    $S0 = optok['pastrule']
    unless $S0 goto no_pastrule
    .return tree.'get'($S0, node, 'Perl6::Grammar::expr')
  no_pastrule:

    .local string postop
    postop = optok['post']
    if postop > '' goto with_postop
    postop = concat "'", type
    postop = concat postop, "'"
  with_postop:

    .local pmc past, children, iter
    past = new 'Perl6::PAST::Op'
    past.'init'('node'=>node, 'op'=>type, 'name'=>postop)
    $P0 = node.'get_array'()
    if null $P0 goto iter_end
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    $P0 = shift iter
    $S0 = $P0
    if $S0 == "" goto iter_loop
    $P1 = tree.'get'('past', $P0, 'Perl6::Grammar::expr')
    if null $P1 goto iter_loop
    past.'add_child'($P1)
    goto iter_loop
  iter_end:
    if type == 'infix:or' goto infix_or
    if type != 'infix:||' goto end
  infix_or:
    ##   We cheat a bit here, moving the "then" portion of an 'or'
    ##   node to the 'else' portion.
    $P0 = past[1]
    past[2] = $P0
    null $P0
    past[1] = $P0
  end:
    .return (past)
}


Perl6::Grammar::expr: past_term(.) = {
    .local pmc iter
    $P0 = node.'get_hash'()
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto term_error
    $S0 = shift iter
    $P0 = iter[$S0]
    $S1 = concat 'Perl6::Grammar::', $S0
    $P1 = tree.'get'('past', $P0, $S1)
    if null $P1 goto iter_loop
    .return ($P1)

  term_error:
    print "error: 'term' node has incorrect structure.\n"
    end
}


Perl6::Grammar::expr: past_listop(.) = {
    .local string name
    ##   get the listop name, convert it to &name var
    name = node['ident']
    name = concat '&', name
    .local pmc vpast
    vpast = new 'Perl6::PAST::Var'
    vpast.'init'('node'=>node, 'name'=>name)
    ##   if we have no children, then we're the lhs of a postfix op
    $I0 = defined node[0]
    if $I0 goto has_child
    .return (vpast)

  has_child:
    .local pmc past, cpast
    past = new 'Perl6::PAST::Op'
    past.'init'(vpast, 'node'=>node, 'op'=>'postcircumfix:( )')   
    $P0 = node[0]
    cpast = tree.'get'('past', $P0, 'Perl6::Grammar::expr')
    if null cpast goto has_child_1
    past.'add_child'(cpast)
  has_child_1:
    .return (past)
}
    

Perl6::Grammar::type: past(.) = {
    null $P0
    .return ($P0)
}


Perl6::Grammar::scoped_variables: past(.) = {
    .local string scope, name
    scope = node['scope_declarator']
    name = node['variable']

    if scope == 'my' goto scope_my
    scope = 'package'
    goto make_past
  scope_my:
    scope = 'lexical'

  make_past:
    .local pmc past
    past = new 'Perl6::PAST::Var'
    past.'init'('node'=>node, 'name'=>name, 'scope'=>scope)

    .local pmc block
    block = find_global 'Perl6::PAST', '$?BLOCK'
    block.'vardecl'(name, past)
    .return (past)
}


Perl6::Grammar::variable: past(.) = {
    .local string name
    name = node
    .local pmc past
    past = new 'Perl6::PAST::Var'
    past.'init'('node'=>node, 'name'=>name)

    .local pmc block, vdecl
    block = find_global 'Perl6::PAST', '$?BLOCK'
    vdecl = block.'vardecl'(name)
    $I0 = isa vdecl, 'Perl6::PAST::Var'
    if $I0 == 0 goto declare_var
    .return (past)
  declare_var:
    past.'scope'('outer')
    block.'vardecl'(name, past)
    .return (past)
}


Perl6::Grammar::integer: past(.) = {
    .local pmc past
    $P0 = new .Perl6Str
    $S0 = node
    $P0 = $S0
    $I0 = $P0
    past = new 'Perl6::PAST::Val'
    past.'init'('node'=>node, 'valtype'=>'int', 'name'=>$I0)
    .return (past)
}


Perl6::Grammar::number: past(.) = {
    .local pmc past
    $N0 = node
    past = new 'Perl6::PAST::Val'
    past.'init'('node'=>node, 'valtype'=>'num', 'name'=>$N0)
    .return (past)
}


Perl6::Grammar::string_literal: past(.) = {
    .local pmc past
    $P0 = node['quoted_literal']
    $P0 = $P0.'get_array'()
    .local pmc iter
    iter = new .Iterator, $P0
    null past
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    $S0 = cnode['type']
    if $S0 == 'str' goto cpast_str
    cpast = tree.'get'('past', cnode, $S0)
    goto cpast_add
  cpast_str:
    $S0 = cnode
    cpast = new 'Perl6::PAST::Val'
    cpast.'init'('node'=>node, 'valtype'=>'str', 'name'=>$S0)
  cpast_add:
    unless null past goto cpast_concat
    past = cpast
    goto iter_loop
  cpast_concat:
    past = past.'new'('Perl6::PAST::Op', past, cpast, 'node'=>node, 'op'=>'infix:~', 'name'=>'concat')
    goto iter_loop
  iter_end:
    .return (past)
}


Perl6::Grammar::version: past(.) = {
    $S0 = node
    $S0 = concat "'", $S0
    $S0 = concat $S0, "'"
    .local pmc past
    past = new 'Perl6::PAST::Val'
    past.'init'('node'=>node, 'valtype'=>'str', 'name'=>$S0)
    .return (past)
}


Perl6::Grammar::block: past(.) = {
    .local pmc outer, past
    outer = find_global 'Perl6::PAST', '$?BLOCK'
    past = new 'Perl6::PAST::Block'
    past.'init'('node'=>node, 'outer'=>outer, 'blocktype'=>'block')
    store_global 'Perl6::PAST', '$?BLOCK', past
    .local pmc cpast
    $P0 = node['statement_list']
    cpast = tree.'get'('past', $P0, 'Perl6::Grammar::statement_list')
    past.'add_child'(cpast)
    store_global 'Perl6::PAST', '$?BLOCK', outer
    .return (past)
}


Perl6::Grammar::regex_term: past(.) = {
    .local pmc outer, past
    outer = find_global 'Perl6::PAST', '$?BLOCK'
    past = new 'Perl6::PAST::Block'
    past.'init'('node'=>node, 'outer'=>outer, 'blocktype'=>'regex')
    $P0 = node['regex']
    past.'add_child'($P0)
    .return (past)
}


## vim: expandtab sw=4
