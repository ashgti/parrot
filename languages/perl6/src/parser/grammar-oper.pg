# Copyright (C) 2007, The Perl Foundation.
# $Id$

## autoincrement
proto postfix:<++> is precedence('x=') is lvalue(1) { ... }
proto postfix:<--> is equiv(postfix:<++>) is lvalue(1) { ... }
proto prefix:<++> is equiv(postfix:<++>) is lvalue(1) { ... }
proto prefix:<--> is equiv(postfix:<++>) is lvalue(1) { ... }

## exponentiation
proto infix:<**> is precedence('w=') { ... }

## symbolic unary
proto prefix:<+> is precedence('v=') { ... }
proto prefix:<-> is equiv(prefix:<+>) { ... }
proto prefix:<~> is equiv(prefix:<+>) { ... }
proto prefix:<?> is equiv(prefix:<+>) { ... }
proto prefix:<!> is equiv(prefix:<+>) { ... }
proto prefix:<+^> is equiv(prefix:<+>)
    is pirop('n_bnot')
    { ... }
proto prefix:<=> is equiv(prefix:<+>) { ... }
proto prefix:<^> is equiv(prefix:<+>) { ... }

## multiplicative operators
proto infix:<*> is precedence('u=') { ... }
proto infix:</> is equiv(infix:<*>) { ... }
proto infix:<%> is equiv(infix:<*>) { ... }
proto infix:<+&> is equiv(infix:<*>) { ... }
proto infix:<+^> is equiv(infix:<*>) { ... }
proto infix:«+<» is equiv(infix:<*>) { ... }
proto infix:«+>» is equiv(infix:<*>) { ... }
proto infix:<~&> is equiv(infix:<*>) { ... }
proto infix:«~<» is equiv(infix:<*>) { ... }
proto infix:«~>» is equiv(infix:<*>) { ... }
proto infix:<?&> is equiv(infix:<*>) { ... }
proto infix:<div> is equiv(infix:<*>) { ... }
proto infix:<mod> is equiv(infix:<*>) { ... }

## additive operators
proto infix:<+> is precedence('t=') { ... }
proto infix:<-> is equiv(infix:<+>) { ... }
proto infix:<+|> is equiv(infix:<+>) { ... }
proto infix:<+^> is equiv(infix:<+>) { ... }
proto infix:<~|> is equiv(infix:<+>) { ... }
proto infix:<~^> is equiv(infix:<+>) { ... }
proto infix:<?|> is equiv(infix:<+>) { ... }
proto infix:<?^> is equiv(infix:<+>) { ... }

## replication
proto infix:<x> is precedence('s=') { ... }
proto infix:<xx> is equiv(infix:<x>) { ... }

## concatenation
proto infix:<~> is precedence('r=') { ... }

## junctive and
proto infix:<&> is precedence('q=')
    is assoc('list')
    { ... }

## junctive or
proto infix:<|> is precedence('p=')
    is assoc('list')
    { ... }
proto infix:<^> is equiv(infix:<|>)
    is assoc('list')
    { ... }

## named unary
proto prefix:<rand> is precedence('o=') { ... }
proto prefix:<sleep> is equiv(prefix:<rand>) { ... }
proto prefix:<abs> is equiv(prefix:<rand>)
    is pirop('n_abs')
    { ... }

## nonchaining
proto infix:<..> is precedence('n=') { ... }
proto infix:<..^> is equiv(infix:<..>) { ... }
proto infix:<^..> is equiv(infix:<..>) { ... }
proto infix:<^..^> is equiv(infix:<..>) { ... }
proto infix:«<=>» is equiv(infix:<..>) { ... }
proto infix:<cmp> is equiv(infix:<..>) { ... }
proto infix:<leg> is equiv(infix:<..>) { ... }
proto infix:<=:=> is equiv(infix:<..>) { ... }
proto infix:<!=:=> is equiv(infix:<..>) { ... }

## chaining
proto infix:<==>  is precedence('m=') is pasttype('chain') { ... }
proto infix:<!=>  is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:<!==>  is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:«<»   is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:«<=»  is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:«>»   is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:«>=»  is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:<eq>  is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:<!eq>  is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:<ne>  is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:<lt>  is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:<le>  is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:<gt>  is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:<ge>  is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:<~~>  is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:<!~~>  is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:<===> is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:<!===> is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:<eqv> is equiv(infix:<==>) is pasttype('chain') { ... }
proto infix:<!eqv> is equiv(infix:<==>) is pasttype('chain') { ... }

## tight and
proto infix:<&&> is precedence('l=')
    is pasttype('if')
    { ... }

## tight or
proto infix:<||> is precedence('k=')
    is pasttype('unless')
    { ... }
proto infix:<^^> is equiv(infix:<||>)
    is pasttype('xor')
    { ... }
proto infix:<//> is equiv(infix:<||>)
    is pasttype('def_or')
    { ... }
proto infix:<min> is equiv(infix:<||>) 
    is assoc('list')
    { ... }
proto infix:<max> is equiv(infix:<||>)
    is assoc('list')
    { ... }

## item assignment
proto infix:<:=> is precedence('i=') is pasttype('bind') { ... }
proto infix:<::=> is equiv(infix:<:=>) { ... }
proto infix:<.=> is equiv(infix:<:=>) { ... }
proto infix:<~=> is equiv(infix:<:=>) { ... }
proto infix:<+=> is equiv(infix:<:=>) { ... }
proto infix:<-=> is equiv(infix:<:=>) { ... }
proto infix:<*=> is equiv(infix:<:=>) { ... }
proto infix:</=> is equiv(infix:<:=>) { ... }
proto infix:<%=> is equiv(infix:<:=>) { ... }
proto infix:<x=> is equiv(infix:<:=>) { ... }
proto infix:<Y=> is equiv(infix:<:=>) { ... }
proto infix:<**=> is equiv(infix:<:=>) { ... }
proto infix:<xx=> is equiv(infix:<:=>) { ... }
proto infix:<||=> is equiv(infix:<:=>) { ... }
proto infix:<&&=> is equiv(infix:<:=>) { ... }
proto infix:<//=> is equiv(infix:<:=>) { ... }
proto infix:<^^=> is equiv(infix:<:=>) { ... }
proto infix:«+<=» is equiv(infix:<:=>) { ... }
proto infix:«+>=» is equiv(infix:<:=>) { ... }
proto infix:<+|=> is equiv(infix:<:=>) { ... }
proto infix:<+&=> is equiv(infix:<:=>) { ... }
proto infix:<+^=> is equiv(infix:<:=>) { ... }
proto infix:<~|=> is equiv(infix:<:=>) { ... }
proto infix:<~&=> is equiv(infix:<:=>) { ... }
proto infix:<~^=> is equiv(infix:<:=>) { ... }
proto infix:<?|=> is equiv(infix:<:=>) { ... }
proto infix:<?&=> is equiv(infix:<:=>) { ... }
proto infix:<?^=> is equiv(infix:<:=>) { ... }
proto infix:<|=> is equiv(infix:<:=>) { ... }
proto infix:<&=> is equiv(infix:<:=>) { ... }
proto infix:<^=> is equiv(infix:<:=>) { ... }
proto infix:«=>» is equiv(infix:<:=>) { ... }

## loose unary
proto prefix:<true> is precedence('h=') { ... }
proto prefix:<not> is equiv(prefix:<true>) { ... }

## comma
proto infix:<,> is precedence('g=')
    is assoc('list')
    is nullterm
    { ... }

## list infix
proto infix:<X> is precedence('f=')
    is assoc('list')
    { ... }
proto infix:<Z> is precedence('f=')
    is assoc('list')
    { ... }

## list assignment
proto infix:<=> is precedence('e=')
#    is pasttype('copy')
    is assoc('right')
    is lvalue(1)
    { ... }

## loose and
proto infix:<and> is precedence('d=')
    is pasttype('if')
    { ... }
proto infix:<andthen> is equiv(infix:<and>) { ... }

## loose or
proto infix:<or> is precedence('c=')
    is pasttype('unless')
    { ... }
proto infix:<xor> is equiv(infix:<or>)
    is pasttype('xor')
    { ... }
proto infix:<orelse> is equiv(infix:<or>) { ... }
