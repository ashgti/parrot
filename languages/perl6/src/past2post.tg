transform root (Perl6::PAST::Block) :language('PIR') {
    $P0 = new .Undef
    store_global 'Perl6::POST', '$?BLOCK', $P0
    store_global 'Perl6::PAST', '$?BLOCK', $P0
    .return tree.'get'('post', node)
}


transform post (Perl6::PAST::Block) :language('PIR') {
    .local string name, blocktype
    name = node.'name'()
    blocktype = node.'blocktype'()
    if name > '' goto with_name
    name = concat '_', blocktype
    name = node.'unique'(name)
  with_name:
    .local pmc outerpost, outerpast
    outerpost = find_global 'Perl6::POST', '$?BLOCK'
    outerpast = find_global 'Perl6::PAST', '$?BLOCK'
    .local pmc post
    post = new 'Perl6::POST::Sub'
    post.'init'('node'=>node, 'name'=>name, 'outer'=>outerpost, 'subtype'=>blocktype)
    store_global 'Perl6::POST', '$?BLOCK', post
    store_global 'Perl6::PAST', '$?BLOCK', node
    .local pmc iter
    iter = node.'child_iter'()
  iter_loop:
    unless iter goto iter_end
    .local pmc cpast, cpost
    cpast = shift iter
    cpost = tree.'get'('post', cpast)
    post.'add_child'(cpost)
    goto iter_loop
  iter_end:
    .local pmc value
    value = cpost.'value'()
    value = clone value
    post.'value'(value)
    store_global 'Perl6::POST', '$?BLOCK', outerpost
    store_global 'Perl6::PAST', '$?BLOCK', outerpast
    
    ##   For immediate blocks, generate code to execute the block.
    $S0 = node.'blocktype'()
    if $S0 != 'immediate' goto end
    $P0 = post
    post = post.'new'('Perl6::POST::Ops', $P0, 'node'=>node)
    post.'add_child_new'('Perl6::POST::Op', post, 'name'=>$P0, 'node'=>node)
  end:
    .return (post)
}


transform post (Perl6::Grammar) :language('PIR') {
    ##   We generally get here because of a PGE regex in the 
    ##   code that is stored as a child of a Block.  The regex
    ##   AST is already reduced to what we want to pass to
    ##   the PGE compiler, so we just return it directly.
    ##   But clear any 'value' of the Match object, first.
    node.'value'('')
    .return (node)
}


transform post (Perl6::PAST::Stmts) :language('PIR') {
    .local pmc iter, ops
    ops = new 'Perl6::POST::Ops'
    ops.'init'('node'=>node)
    iter = node.'child_iter'()
  iter_loop:
    unless iter goto iter_end
    $P0 = shift iter
    $P1 = tree.'get'('post', $P0)
    ops.'add_child'($P1)
    goto iter_loop
  iter_end:
    .local string value
    value = $P1.'value'()
    ops.'value'(value)
    .return (ops)
}


transform post (Perl6::PAST::Stmt) :language('PIR') {
    .local pmc past, post
    past = node[0]
    post = tree.'get'('post', past)
    .return (post)
}


transform post (Perl6::PAST::Exp) :language('PIR') {
    $P0 = node[0]
    $P1 = tree.'get'('post', $P0)
    .return ($P1)
}


transform post (Perl6::PAST::Op) :language('PIR') {
    .local string opname, pasttype
    .local pmc optable, optok
    opname = node.'name'()
    optable = find_global 'Perl6::Grammar', '$optable'
    optok = optable[opname]
    pasttype = optok['pasttype']
    if pasttype > '' goto dispatch_post
    pasttype = 'simple'
  dispatch_post:
    .return tree.'get'(pasttype, node)
}


transform postname (Perl6::PAST::Op) :language('PIR') {
    ##   return the name to be used for this op in POST
    ##   as given by the "post" trait or the operator
    ##   name.
    .local pmc optable, optok
    .local string opname, postname
    optable = find_global 'Perl6::Grammar', '$optable'
    opname = node.'name'()
    optok = optable[opname]
    postname = optok['post']
    if postname > '' goto end
    postname = concat "'", opname
    postname = concat postname, "'"
  end:
    .return (postname)
}
    

transform simple (Perl6::PAST::Op) :language('PIR') {
    ##   create our return past node
    .local pmc ops
    ops = new 'Perl6::POST::Ops'
    ops.'init'('node'=>node)

    .local string opname, postname
    opname = node.'name'()
    postname = tree.'get'('postname', node)

  op_children:
    .local pmc iter, arglist
    iter = node.'child_iter'()
    arglist = new .ResizablePMCArray
  iter_loop:
    unless iter goto iter_end
    .local pmc cpast, cpost
    cpast = shift iter
    $I0 = defined cpast
    if $I0 == 0 goto iter_loop
    cpost = tree.'get'('post', cpast)
    ops.'add_child'(cpost)
    push arglist, cpost
    goto iter_loop
  iter_end:
    ##   Add the post node(s) for this operation.  If we have
    ##   a direct post op, we need a temporary for the result.
    ##   Use the type given by the 'returns' trait, otherwise
    ##   use .Undef .  XXX: For now, we're using the %!parrotclass
    ##   hash workaround to map Perl6 class names to parrot classes.
    .local pmc optable, optok
    .local string opreturn
    optable = find_global 'Perl6::Grammar', '$optable'
    optok = optable[opname]
    opreturn = optok['returns']
    $P0 = find_global 'Perl6', '%!parrotclass'
    opreturn = $P0[opreturn]
    if opreturn > '' goto with_opreturn
    opreturn = '.Undef'
  with_opreturn:
    ops.'add_child_new'('Perl6::POST::Op', ops, opreturn, 'name'=>'new')
  end:
    ops.'add_child_new'('Perl6::POST::Op', ops, arglist :flat, 'name'=>postname)
    .return (ops)
}


transform call (Perl6::PAST::Op) :language('PIR') {
    ##   This rule handles sub calls (e.g., postcircumfix:( ))
    .local pmc ops
    ops = new 'Perl6::POST::Ops'
    ops.'init'('node'=>node)

    ##   get the post for the subroutine itself
    .local pmc iter, arglist, spast, spost
    arglist = new .ResizablePMCArray
    iter = node.'child_iter'()
    spast = shift iter

    ##   if the spost is a &var, then use it directly
    ##   as the name of the sub to be called.
    $I0 = isa spast, 'Perl6::PAST::Var'
    if $I0 == 0 goto spast_expr
    $S0 = spast.'name'()
    $S1 = substr $S0, 0, 1
    if $S1 != '&' goto spast_expr
    substr $S0, 0, 1, "'"
    $S0 = concat $S0, "'"
    spost = new .String
    spost = $S0
    goto with_spost
  spast_expr:
    spost = tree.'get'('post', spast)
    ops.'add_child'(spost)
  with_spost:

    ##   See if the argument is an infix:, list.  If so, elevate
    ##   its children to be the children (arguments) to the call
    ##   by iterating over its children.
    $P0 = node[1]
    $I0 = isa $P0, 'Perl6::PAST::Op'
    if $I0 == 0 goto iter_loop
    $S0 = $P0.'name'()
    if $S0 != 'infix:,' goto iter_loop
    iter = $P0.'child_iter'()

  iter_loop:
    unless iter goto iter_end
    .local pmc cpast, cpost
    cpast = shift iter
    $I0 = defined cpast
    if $I0 == 0 goto iter_loop
    cpost = tree.'get'('post', cpast)
    ops.'add_child'(cpost)
    push arglist, cpost
    goto iter_loop
  iter_end:
    ##   Now add the sub call itself.
    ops.'add_child_new'('Perl6::POST::Op', ops, arglist :flat, 'name'=>spost)
    .return (ops)
}


transform assign (Perl6::PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'Perl6::POST::Ops'
    ops.'init'('node'=>node)

    .local pmc iter, lpast, rpast
    iter = node.'child_iter'()
    lpast = shift iter
    rpast = shift iter
    .local pmc lpost, rpost
    lpost = tree.'get'('post', lpast)
    lpost.'islvalue'(1)
    rpost = tree.'get'('post', rpast)
    ops.'add_child'(lpost)
    ops.'add_child'(rpost)
    ops.'add_child_new'('Perl6::POST::Assign', lpost, rpost, 'name'=>'assign')
    .local string value
    value = rpost.'value'()
    ops.'value'(value)
    .return (ops)
}


transform cond (Perl6::PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'Perl6::POST::Ops'
    ops.'init'('node'=>node)

    .local pmc exprpast, thenpast, elsepast
    .local pmc exprpost, thenpost, elsepost
    exprpast = node[0]
    thenpast = node[1]
    elsepast = node[2]

    .local pmc thenlabel, endlabel
    thenlabel = ops.'new'('Perl6::POST::Label', 'name'=>'if_then')
    endlabel = ops.'new'('Perl6::POST::Label', 'name'=>'if_end')

    exprpost = tree.'get'('post', exprpast)
    ops.'add_child'(exprpost)
    ops.'add_child_new'('Perl6::POST::Op', exprpost, thenlabel, 'name'=>'if')
    elsepost = exprpost
    $I0 = defined elsepast
    if $I0 == 0 goto cond_no_else
    elsepost = tree.'get'('post', elsepast)
    ops.'add_child'(elsepost)
  cond_no_else:
    ops.'add_child_new'('Perl6::POST::Op', ops, elsepost, 'name'=>'set')
    ops.'add_child_new'('Perl6::POST::Op', endlabel, 'name'=>'goto')
    ops.'add_child'(thenlabel)
    thenpost = exprpost
    $I0 = defined thenpast
    if $I0 == 0 goto cond_no_then
    thenpost = tree.'get'('post', thenpast)
    ops.'add_child'(thenpost)
  cond_no_then:
    ops.'add_child_new'('Perl6::POST::Op', ops, thenpost, 'name'=>'set')
    ops.'add_child'(endlabel)
    .return (ops)
}


transform xor (Perl6::PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'Perl6::POST::Ops'
    ops.'init'('node'=>node)

    .local pmc endlabel, falselabel
    falselabel = ops.'new'('Perl6::POST::Label', 'name'=>'xor_false')
    endlabel = ops.'new'('Perl6::POST::Label', 'name'=>'xor_end')

    .local pmc iter, apast, apost, i, t, u
    i = ops.unique('$I')
    t = ops.unique('$I')
    u = ops.unique('$I')
    iter = node.'child_iter'()
    apast = shift iter
    apost = tree.'get'('post', apast)
    ops.'add_child'(apost)
    ops.'add_child_new'('Perl6::POST::Op', ops, apost, 'name'=>'set')
    ops.'add_child_new'('Perl6::POST::Op', t, apost, 'name'=>'istrue')
  inner_child:
    .local pmc bpast, bpost
    bpast = shift iter
    bpost = tree.'get'('post', bpast)
    ops.'add_child'(bpost)
    ops.'add_child_new'('Perl6::POST::Op', u, bpost, 'name'=>'istrue')
    ops.'add_child_new'('Perl6::POST::Op', i, t, u, 'name'=>'and')
    ops.'add_child_new'('Perl6::POST::Op', i, falselabel, 'name'=>'if')
    unless iter goto last_child
    .local pmc s
    s = ops.'new'('Perl6::POST::Label', 'name'=>'xor_skip')
    ops.'add_child_new'('Perl6::POST::Op', t, s, 'name'=>'if')
    ops.'add_child_new'('Perl6::POST::Op', ops, bpost, 'name'=>'set')
    ops.'add_child_new'('Perl6::POST::Op', t, u, 'name'=>'set')
    ops.'add_child'(s)
    goto inner_child
  last_child:
    ops.'add_child_new'('Perl6::POST::Op', t, endlabel, 'name'=>'if')
    ops.'add_child_new'('Perl6::POST::Op', ops, bpost, 'name'=>'set')
    ops.'add_child_new'('Perl6::POST::Op', endlabel, 'name'=>'goto')
    ops.'add_child'(falselabel)
    ops.'add_child_new'('Perl6::POST::Op', ops, '.Undef', 'name'=>'new')
    ops.'add_child'(endlabel)
    .return (ops)
}


transform chain (Perl6::PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'Perl6::POST::Ops'
    ops.'init'('node'=>node)

    .local string opname, pasttype
    .local pmc optable, optok
    optable = find_global 'Perl6::Grammar', '$optable'

    .local pmc clist
    clist = new .ResizablePMCArray
  chain_loop:
    $I0 = isa node, 'Perl6::PAST::Op'
    if $I0 == 0 goto chain_end
    opname = node.'name'()
    optok = optable[opname]
    pasttype = optok['pasttype']
    if pasttype != 'chain' goto chain_end
    push clist, node
    node = node[0]
    goto chain_loop
  chain_end:

    .local pmc endlabel, apast, apost
    node = pop clist
    endlabel = ops.'new'('Perl6::POST::Label', 'name'=>'chain_end')
    apast = node[0]
    apost = tree.'get'('post', apast)
    ops.'add_child'(apost)

  clist_loop:
    .local pmc bpast, bpost
    .local string postname
    bpast = node[1]
    bpost = tree.'get'('post', bpast)
    postname = tree.'get'('postname', node)
    ops.'add_child'(bpost)
    ops.'add_child_new'('Perl6::POST::Op', ops, apost, bpost, 'name'=>postname)
    unless clist goto clist_end
    ops.'add_child_new'('Perl6::POST::Op', ops, endlabel, 'name'=>'unless')
    apost = bpost
    node = pop clist
    goto clist_loop
  clist_end:
    ops.'add_child'(endlabel)
    .return (ops)
}



transform post (Perl6::PAST::Val) :language('PIR') {
    .local string val, valtype, objtype
    val = node.'name'()
    valtype = node.'valtype'()
    objtype = '.Undef'
    if valtype != 'str' goto with_val
    objtype = '.Perl6Str'
    val = escape val
    val = concat '"', val
    val = concat val, '"'
    $I0 = index val, '\x'
    if $I0 >= 0 goto val_unicode
    $I0 = index val, '\u'
    if $I0 < 0 goto with_val
  val_unicode:
    val = concat 'unicode:', val
  with_val:
    .local pmc ops
    ops = new 'Perl6::POST::Ops'
    ops.'init'('node'=>node)
    ops.'add_child_new'('Perl6::POST::Op', ops, objtype, 'name'=>'new')
    $P0 = ops.'new'('Perl6::POST::Val', 'valtype'=>valtype, 'value'=>val)
    ops.'add_child_new'('Perl6::POST::Op', ops, $P0, 'name'=>'assign')
    .return (ops)
}
    

transform post (Perl6::PAST::Var) :language('PIR') {
    .local string name, scope
    .local pmc post
    name = node.'name'()
    scope = node.'scope'()

    if scope == 'package' goto with_scope
    if scope == 'lexical' goto with_scope
    if scope == 'parameter' goto with_scope
    .local pmc outer
    outer = find_global 'Perl6::PAST', '$?BLOCK'
  outer_loop:
    $I0 = isa outer, 'Perl6::PAST::Block'
    if $I0 == 0 goto with_scope
    $P0 = outer.'vardecl'(name)
    $I0 = isa $P0, 'Perl6::PAST::Var'
    if $I0 == 0 goto outer_next
    $S0 = $P0.'scope'()
    if $S0 != 'outer' goto outer_end
  outer_next:
    outer = outer.'outer'()
    goto outer_loop
  outer_end:
    scope .= $S0
  with_scope:
    $S0 = substr name, 0, 1
    if $S0 != '&' goto with_name
    name = substr name, 1
  with_name:
    post = new 'Perl6::POST::Var'
    post.'init'('node'=>node, 'name'=>name, 'scope'=>scope)
    .return (post)
}
