=head1 B<P6C::IMCC>

IMCC.pm is still a "ball of mud" at the moment, but context
propagation has been moved to Context.pm.  Next for refactoring is
symbol handling.

Context should not be propagated during code generation, as the
context propagation pass handles this.  This rule is broken for
hyper-operators, since I can't think of a good way to handle them
using context.

Code is generated by a depth-first recursive traversal of the op tree.
Each node type should define a C<val> function to be called by its
parent node.  This function should gather values from child nodes (by
calling their C<val> functions), then emit the code for the node's
operation (using C<P6C::Compiler::code>).  Code is appended to the
current function in the order in which it is generated, so subnodes
must be evaluated in the proper order.

C<val> should return one of the following:

=over

=item * undef if the node has no rvalue.

=item * a reference to an array of registers if called in tuple
context.

=item * the name of a PMC register holding the rvalue otherwise.

=back

Node types that can act as lvalues should define an C<assign> function
that takes an unevaluated rvalue tree and a context structure.  This
function should return a PMC register or array ref (like C<val>) if
(like an assignment) it serves as both an lvalue and an rvalue.

=head2 External interface

If C<P6C::IMCC> is imported with the ":external" flag, it will define
the following interface, used by the driver:

=over

=item B<init()>

Initialize or reset compiler state.  This should be called before
generating any code.  C<init> destroys all functions and globals,
resets the current function, and reinitializes builtins.

=item B<compile($top)>

Compile a tree based at $top, but do not emit any code.

=item B<emit()>

Emit IMCC code on standard output, including a header that calls
C<main>, and the code for any builtin functions (see
C<P6C::Builtins>).  C<emit> will fail if you have not defined C<main>.

=back

=cut

package P6C::IMCC;
use strict;
use P6C::Builtins;
use P6C::Util;
use P6C::Context;

# Map Perl types to IMCC parameter types:
my %paramtype = (int => 'int',
		 str => 'string',
		 num => 'float');
# Map Perl types to Parrot register types:
my %regtype   = (int => 'I',
		 str => 'S',
		 num => 'N');
sub regtype(*) {
    $regtype{$_[0]} || 'P';
}

sub paramtype(*) {
    $paramtype{$_[0]} || $_[0];
}

sub import {
    my ($class, $type) = @_;
    my @syms = qw(globalvar localvar paramvar findvar
		  add_localvar add_globalvar
		  push_scope pop_scope
		  gentmp genlabel newtmp mangled_name
		  code
		  add_function set_function exists_function_def
		  exists_function_decl set_function_params
		  gen_counted_loop do_scalar_to_array do_flatten_array);
    my @external = qw(init compile emit);
    my $caller = caller;
    no strict 'refs';
    if ($type eq ':all') {
	foreach (@syms) {
	    *{$caller . '::' . $_} = \&$_;
	}
    } elsif ($type eq ':external') {
	foreach (@external) {
	    *{$caller . '::' . $_} = \&$_;
	}
    } else {
	foreach (@_) {
	    *{$caller . '::' . $_} = \&$_;
	}
    }
    1;
}

our $curfunc;			# currently compiling function
our %funcs;			# all known functions
our %globals;			# global variables

sub init {			# reset state
    %funcs = ();
    %globals = ();
    undef $curfunc;
    P6C::Builtins::declare(\%funcs);
}

sub compile {			# compile input (don't emit)
    my $x = shift;
    my $ctx = new P6C::Context type => 'void';
    use P6C::Addcontext;
    if (ref $x eq 'ARRAY') {
	# propagate context:
	foreach my $stmt (@$x) {
	    $stmt->ctx_right($ctx);
	}
	# generate code:
	foreach my $stmt (@$x) {
	    $stmt->val;
	}
    } else {
	# probably single stmt.
	$x->ctx_right($ctx);
	$x->val;
    }
}

sub emit {			# emit all code
    die "Must define main" unless $funcs{main};
    print <<'END';
.sub __main
	call __setup
	call _main
	end
	ret
END
    P6C::Builtins::add_code(\%funcs);
    while (my ($name, $sub) = each %funcs) {
	unless($sub->code) {
	    diag "Function $name has no code.  Builtin?";
	    next;
	}
	$name = mangled_name($name);
	print ".sub $name\n";
	$sub->emit;
    }
    P6C::Builtins::emit;
}

=head2 Internals

If C<P6C::IMCC> is imported with the ":all" flag, it exports an
internal interface.

The compiler maintains a "current function" (could be generalized to
"current scope") in which code is emitted, locals are declared, and
symbol lookups begin.  The following functions manipulate the current
function context.

=over

=item B<code($x)>

Append IMCC code C<$x> to the current function.

=item B<add_function($name)>

Create a new function stub for C<$name>.  If C<$name> exists, it will
be overwritten.

=item B<exists_function_def($name)>

Return true if function C<$name> is defined (i.e. not just "declared").

=item B<exists_function_decl($name)>

Return true if a stub exists for C<$name>, even if it has no code.

=item B<$oldfunc = set_function($name)>

Set the code insertion point to the end of function C<$name>,
returning the name of the previously active function.  Function
C<$name> should exist before this is called.

=item B<set_function_params(@params)>

Set the parameter list for the current function.  The arguments should
be a list of C<P6C::param> objects.  XXX: there is currently no way to
handle variable parameter lists.  This is a limitation of the current
parameter-passing scheme, not just this interface.

=back

=cut

sub code {			# add code to current function
    die "Code must live within a function" unless defined $curfunc;
    $funcs{$curfunc}->code .= join "\n", @_;
}

sub add_function($) {
    my $f = shift;
    if (exists $funcs{$f}) {
	diag "Redefining function $f";
    }
    $funcs{$f} = new P6C::IMCC::Sub;
    # NOTE: top-level closure will push a scope.
    return 1;
}

sub exists_function_def($) {
    my $f = $funcs{+shift};
    return $f && $f->code;
}

sub exists_function_decl($) {
    return $funcs{+shift} ? 1 : 0;
}

sub set_function($) {	       # switch to function, returning old one
    my $func = shift;
    my $ofunc = $curfunc;
    $curfunc = $func;
    return $ofunc;
}

sub set_function_params {
    my $params = $funcs{$curfunc}->args;
    for my $p (@_) {
	push @$params, [$p->var->type, $p->var->name];
    }
}

=head2 Name lookup

This is a primitive symbol table.  Which is okay, since Parrot doesn't
have stashes yet.  Hopefully the interface will be useful when things
get more complicated.

=over

=item B<$name = findvar($var)>

=item B<($name, $isglobal) = findvar($var)>

Find variable C<$var>, a C<P6C::variable>, returning a PMC register
containing its value.  Currently C<findvar> looks at the active
function's parameters, then locals, then globals (which don't exist,
so it won't find anything there).  Returns undef if the variable is
not found.  C<$isglobal> is currently unused.

=item B<$name = globalvar($var)>

Lookup a global variable.

=item B<$name = localvar($var)>

Find local variable C<$var>, returning its IMCC name.

=item B<$name = paramvar($var)>

Find parameter C<$var>.

=item B<add_localvar($var, $type)>

Declare local variable C<$var> of type C<$type>.  Warns if C<$var> is
already defined.  If C<$type> is a PMC type, C<$var> will
automatically be initialized.

=item B<add_globalvar($var [, $type])>

Declare global variable C<$var>.  Warns if C<$var> is already defined.
C<$var> will be initialized to a new PMC of type C<$type> (or
C<PerlUndef> if type is not given) before C<main> is called.

=item B<push_scope()>

Push a scope within the current function.

=item B<pop_scope()>

Pop a scope from the current function.

=back

=item B<mangled_name($thing)>

Mangle any kind of variable, function, or operator name.

=back

=cut

sub globalvar($) {
    my $name = shift;
    if (!exists $globals{$name}) {
	if ($P6C::o{strict}) {
	    use P6C::Util 'error';
	    error "Reference to undeclared global $name";
	}
	add_globalvar($name);
    }
    return 'global "'.mangled_name($name).'"';
}

sub add_globalvar($;$) {
    my $name = shift;
    if (exists $globals{$name}) {
	use P6C::Util 'warning';
	warning "Re-adding global $name";
    }
    $globals{$name} = shift || 'PerlUndef';
    return 'global "'.mangled_name($name).'"';
}

sub localvar($) {
    my $var = shift;
    
    die "Local variable outside function" unless defined $curfunc;
    return $funcs{$curfunc}->localvar($var);
}

sub add_localvar {
    return $funcs{$curfunc}->add_localvar(@_);
}

sub paramvar($) {
    my $var = shift;
    my $mname = mangled_name($var);
    return $mname if grep {
	$_->[1] eq $var;
    } @{$funcs{$curfunc}->args};
    return undef;
}

sub findvar($) {
    my ($var) = @_;
    my $name;
    my $isglobal;
    if ($name = paramvar($var) || localvar($var)) {
	$isglobal = 0;
    } else {
	$name = globalvar($var);
	$isglobal = 1;
    }
    return wantarray ? ($name, $isglobal) : $name;
}

sub push_scope {
    use Carp 'confess';
    confess $curfunc unless $curfunc && $funcs{$curfunc};
    $funcs{$curfunc}->push_scope;
}

sub pop_scope {
    $funcs{$curfunc}->pop_scope;
}

sub mangled_name($) {
    my $name = shift;
    my %mangle = (qw(! _BANG_
		     ^ IMPL_
		     $ SV_
		     @ AV_
		     % HV_
		     & CV_));
    $name =~ s/([\!\$\@\%\&\^])/$mangle{$1}/eg;
    return '_'.$name;
}

=head2 Temporary names

=over

=item C<gensym([$str])>

Generate a unique identifier.  If C<$str> is given, include it as part
of the identifier.

=item C<genlabel([$str])>

Generate a unique label containing C<$str>.

=item C<newtmp([$type])>

Create a new temporary register to hold a value of type C<$type>,
which should be "int", "num", "str", or some PMC type.  If C<$type> is
a PMC type, the register will be initialized with a new value.  If
C<$type> is omitted, it default to C<PerlUndef>.

=item C<gentmp([$type])>

Generate an uninitialized temporary register.

=back

=cut

my $lastsym = 0;
my $lasttmp = 0;
my $lastlabel = 0;
sub gensym(;*) {
    'S'.$_[0] . ++$lastsym
} 

sub _gentmp(*) {		# uninitialized temporary (internal)
    '$' . $_[0] . ++$lasttmp
}

sub gentmp(;*) {			# uninitialized temporary
    _gentmp(regtype($_[0] || 'PerlUndef'));
}

sub genlabel(;$) {		# new label (optionally annotated)
    'L_'.$_[0]. ++$lastlabel
}

sub newtmp(;*) {			# initialized temporary
    my $type = shift || 'PerlUndef';
    my $reg = regtype $type;
    my $name;
    if ($reg eq 'S') {
 	$name = _gentmp S;
	code(<<END);
	$name = ""
END
    } elsif ($reg eq 'I' || $reg eq 'N') {
	$name = _gentmp $reg;
	code(<<END);
	$name = 0
END
    } else {
	$name = _gentmp P;
	die unless $type;
	use Carp;
	code(<<END);
	$name = new $type
END
    }
    return $name;
}

=head2 Code generation functions

=over

The following functions generate useful and common pieces of code.

=item B<gen_counted_loop($counter, $body)>

Generate a counted loop using C<$counter> as the repetition count.
The loop will iterate over values between 0 and $counter - 1,
inclusive.  C<$counter> will be used as the iteration variable, so it
can be used in indexing expressions in the loop body.

=item B<do_scalar_to_array($val)>

Emit the code to turn a scalar into a one-element array, returning the
array's name.

=item B<do_flatten_array($vals)>

Emit code to evaluate each item in C<@$vals>, which are assumed to be
in list context.  The results are concatenated into a single array,
whose name is returned.

=back

=cut

sub gen_counted_loop {
    my ($count, $body) = @_;
    my $start = genlabel;
    my $end = genlabel;
    return <<END;
$start:	if $count == 0 goto $end
	dec $count
	$body
	goto $start
$end:
END
    return undef;
}

sub do_scalar_to_array {
    my $x = shift;
    my $a = newtmp 'PerlArray';
    code(<<END);
	$a = 1
	$a\[0] = $x
END
    return $a;
}

sub do_flatten_array {
    my $vals = shift;
    my $tmp = newtmp 'PerlArray';
    my $len = gentmp 'int';
    my $offset = gentmp 'int';
    my $tmpindex = gentmp 'int';
    my $ptmp = newtmp 'PerlUndef';
    code(<<END);
# START array flattening.
	$offset = 0
END
    for my $i (0..$#{$vals}) {
	my $item = $vals->[$i]->val;
	code(<<END);
	$len = $item
END
	code(gen_counted_loop($len, <<END));
	$ptmp = $item\[$len]
	$tmpindex = $offset + $len
	$tmp\[$tmpindex] = $ptmp
END
	code(<<END);
	$len = $item
	$offset = $offset + $len
END
    }
    code("# END array flattening\n");
    return $tmp;
}

=head2 P6C::IMCC::Sub

Stores IMCC code for a subroutine.

XXX: the fact that e.g. C<P6C::prefix> relies on this for argument
information is just wrong.  This information should be retrieved from
the parse tree structures instead.

=over

=item B<code($sub)>

The code (not including C<.local> definitions, etc).  Can be appended
to like C<$func->code .= $thing>.

=item B<emit($sub)>

Emit a complete function body, minus the C<.sub> directive.

=back

=cut

package P6C::IMCC::Sub;
use Class::Struct 'P6C::IMCC::Sub'
    => { scopes => '@',		# scope stack
	 args => '@'		# arguments, in order passed
       };
#	{scopelevel}		# current scope number
#	{oldscopes}		# other closed scopes in this sub.

use P6C::Util 'diag';
use P6C::IMCC 'mangled_name';

sub localvar {
    my ($x, $var) = @_;
    for (@{$x->scopes}) {
	if (exists $_->{$var}) {
	    return $_->{$var}[0];
	}
    }
    return undef;
}

sub add_localvar {
    my ($x, $var, $type) = @_;
    my $scopename = mangled_name($var).$x->{scopelevel};
    if ($x->scopes->[0]{$var}) {
	diag "Redeclaring lexical $var in $curfunc";
    }
    $x->scopes->[0]{$var} ||= [$scopename, $type];
    return $scopename;
}

sub push_scope {
    my $x = shift;
    $x->{scopelevel}++;
    unshift @{$x->scopes}, { };
}

sub pop_scope {
    my $x = shift;
    push @{$x->{oldscopes}}, shift @{$x->scopes};
}

sub code : lvalue {
    my $x = shift;
    $x->{code};
}

sub emit {
    my $x = shift;
    print <<END;
	saveall
# Parameters:
END
    foreach (@{$x->args}) {
	my ($t, $pname) = @$_;
	my $ptype = P6C::IMCC::paramtype($t);
	$pname = P6C::IMCC::mangled_name($pname);
	print <<END;
	.param $ptype	$pname
END
    }
    print "# Named locals:\n";
    for (@{$x->scopes}, @{$x->{oldscopes}}) {
	for my $v (values %$_) {
	    my ($n, $t) = @$v;
	    print "\t.local $t $n\n";
	}
    }
    # Maybe constructors for locals:
    for (@{$x->scopes}, @{$x->{oldscopes}}) {
	for my $v (values %$_) {
	    my ($n, $t) = @$v;
	    next if $t eq '1';	# uninitialized locals
	    print "\t$n = new $t\n"
		if P6C::IMCC::regtype($t) eq 'P';
	}
    }
    print $x->code;
    print <<END;
	restoreall
	ret
END
}

######################################################################
# Node-type code generation functions

##############################
package P6C::Register;

sub val {
    shift->reg;
}

##############################
package P6C::ValueList;
use P6C::IMCC ':all';
use P6C::Util ':all';

# XXX: ValueList::val returns an array-ref in tuple context.  This is
# inconsistent with other C<val> functions, which all return single
# values.  However, if you're creating a tuple context, you should
# know what to expect.

sub val {
    my $x = shift;
    my $ctx = $x->{ctx};
    
    if ($ctx->flatten) {
	# XXX: flatten has to come first.
	# In flattening context, we have to build a new array out of
	# the values.  All the values should have been evaluated in
	# array context, so they will all be PerlArrays.
	return do_flatten_array($x->vals);

    } elsif ($ctx->is_array) {
	# In array context, the list's value is an array of all its
	# elements.
	my $tmp = newtmp 'PerlArray';
	code("\t$tmp = ".@{$x->vals}."\n");
	for my $i (0..$#{$x->vals}) {
	    my $item = $x->vals($i)->val;
	    code(<<END);
	$tmp\[$i] = $item
END
	}
	return $tmp;

    } elsif ($ctx->is_scalar || $ctx->type eq 'void') {
	# The value of a list in scalar context is its last value, but
	# we need to evaluate intermediate expressions for possible
	# side-effects.
	for (@{$x->vals}[0..$#{$x->vals} - 1]) {
	    $_->val;
	}
	return $x->vals($#{$x->vals})->val;

    } elsif ($ctx->is_tuple) {
	# In N-tuple context, the list's value is its first N elements.
	my @ret;
	my $min = @{$x->vals} < $ctx->nelem ? @{$x->vals} : $ctx->nelem;
	for my $i (0..$min - 1) {
	    $ret[$i] = $x->vals($i)->val;
	}
	for my $i ($min .. $#{$x->vals}) {
	    $x->vals($i)->val;
	}
	return [@ret];

    } else {
	use Data::Dumper;
	unimp "Can't handle context ".Dumper($ctx);
    }
}

##############################
package P6C::Binop;
use P6C::IMCC::Binop;
use P6C::IMCC ':all';
use P6C::Util ':all';
use P6C::Context;

# Create generic code for $a op $b.
sub simple_binary {
    my $x = shift;
    my $ltmp = $x->l->val;
    my $rtmp = $x->r->val;
    my $dest = newtmp 'PerlUndef';
    my $op = $x->op;
    code("\t$dest = $ltmp $op $rtmp\n");
    return $dest;
}

# '=' assignment op.
sub do_assign {
    my $x = shift;
    return $x->l->assign($x->r);
}

# Handle a comma operator sequence.  Just flattens and calls off to
# C<P6C::ValueList>.
sub do_array {
    my $x = shift;
    use Carp 'cluck';
    cluck "Should provide context to comma operator" unless $x->{ctx};
    my @things = flatten_leftop($x, ',');
    my $vallist = P6C::ValueList->new(vals => \@things);
    $vallist->{ctx} = $x->{ctx};
    return $vallist->val;
}

# Binary infix operators.
our %ops =
(
 '+'	=> \&simple_binary,
 '-'	=> \&simple_binary,
 '*'	=> \&simple_binary,
 '/'	=> \&simple_binary,
 '%'	=> \&simple_binary,
 '**'	=> \&slow_pow,

 '>>'	=> \&simple_binary,
 '<<'	=> \&simple_binary,
 '|'	=> \&simple_binary,
 '&'	=> \&simple_binary,
 '~'	=> \&simple_binary,

# '_' => \&simple_binary, # PMC concat broken.
 '_'	=> \&do_concat,
 '='	=> \&do_assign,
 '||'	=> \&do_logor,
 '&&'	=> \&do_logand,
 '~~'	=> \&simple_binary,
 '//'	=> \&do_defined,
 ','	=> \&do_array,
 'x'	=> \&do_repeat,
 '..'	=> \&do_range,
);

our %op_is_array;
BEGIN {
    my @arrayops = qw(= .. x , // ~~ && ||);
    @op_is_array{@arrayops} = (1) x @arrayops;
}

sub val {
    my $x = shift;
    if (ref($x->op) eq 'P6C::hype') {
	use P6C::IMCC::hype 'do_hyped';
	return do_hyped($x->op->op, $x->l, $x->r);
    }
    my $ret;
    if ($ops{$x->op}) {
	$ret = $ops{$x->op}->($x);
    } elsif($x->op =~ /^([^=]+)=$/ && $ops{$1}) {
	# Translate assignment operation into a binary operation.
	# XXX: Context propagation is broken for these, so we won't
	# ever do this.
	$ret = $ops{'='}->(new P6C::Binop op => '=', l => $x->l,
			   r => P6C::Binop->new(op => $1, l => $x->l,
						r => $x->r));
    } else {
	unimp $x->op;
    }

    if (!$op_is_array{$x->op} && $x->{ctx}->is_array) {
	return do_scalar_to_array($ret);
    }
    return $ret;
}

######################################################################
package P6C::incr;
use P6C::IMCC ':all';
use P6C::Util 'is_scalar';

our %inplace_op = ('++' => 'inc', '--' => 'dec');
our %outaplace_op = ('++' => '+ 1', '--' => '- 1');

sub val {
    my $x = shift;
    my $ret;

    # XXX: I'm extra-cautious here because we may be incrementing a
    # temporary, in which case we have to copy it back.  If this can
    # never happen, then the assigns can be removed here.

    # Optimize post-increment in void context to a pre-increment.
    if ($x->post && !($x->{ctx}->type eq 'void')) {
	my $op = $outaplace_op{$x->op}
	    or die $x->op().' increment not understood';
	if ($x->thing->isa('P6C::sv_literal') 
		&& is_scalar($x->thing->type)) {
	    my $val = $x->thing->val;
	    my $tmp = newtmp 'PerlUndef';
	    code(<<END);
	$tmp = $val
	$val = $val $op
END
    	    return $tmp;
	} else {
	    my $val = $x->thing->val;
	    my $tmp = newtmp 'PerlUndef';
	    my $tmp2 = newtmp 'PerlUndef';
	    code(<<END);
	$tmp = $val
	$tmp2 = $val $op
END
	    $x->thing->assign(new P6C::Register reg => $tmp2,
			      type => 'PerlUndef');
	    return $tmp;
	}
    } else {
	my $op = $inplace_op{$x->op}
	    or die $x->op().' increment not understood';
	$ret = $x->thing->val;
	code("\t$op $ret\n");
	unless ($x->thing->isa('P6C::variable')
		&& is_scalar($x->thing->type)) {
	    # Complex expression => can't just do increment.
	    $x->thing->assign(new P6C::Register reg => $ret,
			      type => $x->thing->type);
	}
	return $ret;
    }
}

######################################################################
package P6C::ternary;
use P6C::IMCC ':all';

# Ternary operator as an r-value.  Context-aware.
sub val {
    my $x = shift;
    my $tmp = newtmp 'PerlUndef';
    my ($thenlab, $endlab) = (genlabel("ternary_then"),
			      genlabel("ternary_end"));
    code(<<END);
# START TERNARY
END
    my $ifval = $x->if->val;
    code(<<END);
	if $ifval goto $thenlab
END
    my $elseval = $x->else->val;
    code(<<END);
	$tmp = $elseval
	goto $endlab
$thenlab:
END
    my $thenval = $x->then->val;
    code(<<END);
	$tmp = $thenval
$endlab:
# END TERNARY
END
    return $tmp;
}

# Ternary operator as an l-value.  Ignores incoming context.  However,
# the r-value to be assigned will be evaluated in the proper context
# for each branch.

# REMEMBER: since the two branches may have different contexts, they
# have different op-trees.

# REMEMBER: we haven't always been able to propagate context, so we
# fall back to just using the same op-tree for both sides.
sub assign {
    my ($x, $thing) = @_;
    my $tmp = newtmp 'PerlUndef';
    my ($thenlab, $endlab) = (genlabel("ternary_then"),
			      genlabel("ternary_end"));
    code(<<END);
# START TERNARY
END
    my $ifval = $x->if->val;
    code(<<END);
	if $ifval goto $thenlab
END
    my $elseval = $x->else->assign($x->{else_right} || $thing);
    code(<<END);
	$tmp = $elseval
	goto $endlab
$thenlab:
END
    my $thenval = $x->then->assign($x->{then_right} || $thing);
    code(<<END);
	$tmp = $thenval
$endlab:
# END TERNARY
END
    return $tmp;
}

######################################################################
sub P6C::sv_literal::val {
    use P6C::Util ':all';

    my $x = shift;
    return undef if $x->{ctx}->type && $x->{ctx}->type eq 'void';
    my $type = $x->type;
    my $ctx = $x->{ctx};

    # XXX: these are actually _references_.  But we don't support them
    # anyways.
    die "Don't support ".$type if $type =~ /Perl(Hash|Array)/;
    my $val = $x->lval;
    my $ret;
    if (!$ctx->type
	|| $ctx->type eq 'void'
	|| same_type($ctx->type, $type)
	|| (is_scalar($ctx->type) && is_scalar($type))) {
	warn "literal in void context" if $ctx->type eq 'void';
	$ret = newtmp 'PerlUndef';
	code(<<END);
	$ret = $val
END

    } elsif ($ctx->is_array) {
	$ret = do_scalar_to_array($val);

    } elsif ($ctx->is_tuple) {
	$ret = newtmp 'PerlUndef';
	code(<<END);
	$ret = $val
END

    } else {
 	use Data::Dumper;
 	unimp "Context ", Dumper($ctx);
	# XXX: bogus
	$ret = newtmp 'PerlUndef';
	code(<<END);
	$ret = $val
END
    }
    return $ret;
}

######################################################################
# Prefix operators (see P6C/IMCC/prefix.pm)

sub P6C::prefix::val {
    use P6C::IMCC::prefix qw(%prefix_ops gen_sub_call);

    my $x = shift;
    # XXX: temporary hack.
    if (exists_function_decl($x->name)) {
	return gen_sub_call($x, @_);
    } elsif (exists $prefix_ops{$x->name}) {
	return $prefix_ops{$x->name}->($x, @_);
    } else {
	unimp "Prefix operator ".$x->name();
    }
}

######################################################################
# Guards
package P6C::guard;
use P6C::IMCC ':all';
use P6C::Util 'unimp';
use P6C::IMCC::guard qw(guard_if guard_while);

our %guards =
(
 'if' => \&guard_if,
 'unless' => \&guard_if,
 'while' => \&guard_while,
 'until' => \&guard_while,
);

sub val {
    my $x = shift;
    # XXX: temporary hack.
    if (exists $guards{$x->name}) {
	return $guards{$x->name}->($x);
    } else {
	unimp "Guard ".$x->name();
    }
}

######################################################################
# Chained comparisons
package P6C::compare;
use P6C::IMCC ':all';

# XXX: since IMCC doesn't give us access to cmp, cmp_num, and
# cmp_string separately, we need to go through num and str temporaries
# to get the right kind of comparison.
our %type;
BEGIN {
    $type{$_} = 'num' for qw(<= == >= < > !=);
    $type{$_} = 'str' for qw(eq ne ge le lt gt);
}

# remap operator names.
our %imccop;
BEGIN {
    @imccop{qw(<= == >= < > !=)} = qw(<= == >= < > !=);
    @imccop{qw(le eq ge lt gt ne)} = qw(<= == >= < > !=);
}

# Generate one element of a comparison.  Unlike other places, $l and
# $r are already evaluated here (i.e. they may be recycled
# temporaries).  $fail is a label (defined elsewhere) to be branched
# to if the comparison fails.
sub gen_compare {
    my ($op, $l, $r, $fail) = @_;
    my $label = genlabel;
    $op = $imccop{$op};
    code(<<END);
	if $l $op $r goto $label
	goto $fail
$label:
END
}
our %ops;
BEGIN {
    for my $op (qw(<= == >= < > != le eq ge lt gt ne)) {
	$ops{$op} = \&gen_compare;
    }
}

# Evaluate a comparison sequence from left to right.  If any
# comparison fails, it will branch to the end of the sequence.  Since
# only two values are active at once, we only need two PMC
# temporaries.  For each operator, look up the operator type, and put
# the operand values in appropriate N or S temporaries.  As an
# optimization, the type of the previous comparison is kept around,
# and the PMC value of the left operand is not re-fetched if it was
# used as a right operand for the same type of operator.

# NOTE: the typing we do here duplicates what's done during the
# context pass.  Eventually these should be combined.
sub val {
    my $self = shift;
    die "Nothing to compare" if $self->size == 0;
    my $x = $self->seq;
    my $result = gentmp 'int';
    my %tmps;
    $tmps{0} = newtmp;		# PMC temporary for odd terms
    $tmps{2} = newtmp;		# PMC temporary for even terms
    my $res = newtmp;
    my $lasttype;
    my $fail = genlabel 'comparison';
    code("\t$result = 0\n");
    $tmps{0} = $x->[0]->val;
    for (my $i = 1; $i < $#{$x}; $i += 2) {
	my $op = $x->[$i];
	my $type = $type{$op} or die "No such op: $op";
	unless ($tmps{"$type 0"}) {
	    # Initialize temporaries for this type if we haven't already.
	    $tmps{"$type 0"} = gentmp $type;
	    $tmps{"$type 2"} = gentmp $type;
	}

	# Only recompute expression values if necessary
	my $ltmp = $tmps{$type.' '.(($i - 1) % 4)};
	my $rtmp = $tmps{$type.' '.(($i + 1) % 4)};
	if ($lasttype ne $type) {
	    code(<<END);
	$ltmp = $tmps{($i - 1) % 4}
END
	}
	$lasttype = $type;	# store type of right operand
	$tmps{(($i + 1) % 4)} = $x->[$i + 1]->val;
	code(<<END);
	$rtmp = $tmps{(($i + 1) % 4)}
END
	$ops{$op}->($op, $ltmp, $rtmp, $fail);
    }
    code(<<END);
	$result = 1
$fail:
    $res = $result
END
    return $res;
}

######################################################################
sub P6C::sub_def::val {
    use P6C::IMCC ':all';
    use P6C::Util 'diag';
    my $x = shift;

    if (exists_function_def($x)) {
	diag "Redefining function ".$x->name;
    }
    add_function($x->name);
    my $ofunc = set_function($x->name);
    $x->closure->val;
    set_function($ofunc);
}

######################################################################
package P6C::closure;
use P6C::Util qw(unimp map_tree);
use P6C::IMCC ':all';

# A sub with no explicit parameter list gets @_.

# NOTE: This parallels what's done in Addcontext.pm.  These things
# should be integrated.
our $default_params;
BEGIN {
    my $underscore = P6C::variable->new(name => '@_', type => 'PerlArray');
    $default_params = new P6C::params req => [], opt => [],
	rest => P6C::param->new(var => $underscore);
}

sub val {
    my $x = shift;
    my $ctx = $x->{ctx};
    my ($name, $ofunc);		# for closure return value.
    my @params;
    if ($ctx->type ne 'void') {
	# We need to create a closure.  This is disgusting.
	$name = genlabel 'closure';
	add_function($name);
	$ofunc = set_function($name);
    }

    unless ($x->params) {
	$x->params($default_params);
    }
    push_scope;
    if (!defined $x->params->max) {
	@params = $x->params->rest;
    } elsif ($x->params->min != $x->params->max) {
	# Only support variable number of params if it's zero - Inf.
	unimp "Unsupported parameter arity: ",
	    $x->params->min . ' - ' . $x->params->max;
    } else {
	@params = @{$x->params->req};
    }

    set_function_params(@params);

    if (defined($x->block)) {
	# Real definition, not just declaration.
	foreach my $stmt (@{$x->block}) {
	    $stmt->val;
	}
    }
    if ($ctx->type ne 'void') {
	# Create a closure.
	set_function($ofunc);
	my $ret = newtmp 'Sub';
	my $itmp = gentmp 'int';
	code(<<END);
	$itmp = addr _$name
	$ret = $itmp
END
	return $ret;
    }
    pop_scope;
    return undef;
}

######################################################################
package P6C::variable;
use P6C::IMCC ':all';
use P6C::Context;
use P6C::Util qw(is_scalar same_type unimp is_pmc);

# XXX: need to redo this when we get globals.
sub val {
    my $x = shift;
    my $ctx = $x->{ctx};
    use Data::Dumper;
    return undef if $ctx->type eq 'void';
    my ($v, $global) = findvar($x->name);
    if ($global) {
	my $reg = newtmp 'PerlUndef';
	code(<<END);
	$reg = $v
END
	$v = $reg;
    }

    if (!$ctx->type
	|| same_type($x->type, $ctx->type)
	|| (is_scalar($x->type) && is_scalar($ctx->type))) {
	return $v;

    } elsif (is_scalar($x->type) && $ctx->is_array) {
	return do_scalar_to_array($v);

    } elsif ($ctx->is_tuple) {
	my @ret;
	my $itmp = gentmp 'int';
	my $len = gentmp 'int';
	my $nomore = genlabel 'array_to_tuple';
	code(<<END);
	$len = $v
	$itmp = 0
END
	for (@{$ctx->type}) {
	    my $vtmp = newtmp 'PerlUndef';
	    code(<<END);
	if $itmp >= $len goto $nomore
	$vtmp = $v\[$itmp]
	inc $itmp
END
	    push @ret, $vtmp;
	}
	code(<<END);
$nomore:
END
	return [@ret];

    } elsif ($ctx->is_scalar && $x->type eq 'PerlArray') {
	return $v;

    } else {
	unimp "Variable of type ", $x->type, " in context ", $ctx->type;
    }
}

sub assign {
    my ($x, $thing) = @_;
    my ($name, $global) = findvar($x->name);
    my $tmpv = $thing->val;
    if ($global) {
	code("# ASSIGN GLOBAL ".$x->name."\n");
	code("\t$name = $tmpv\n");
	return $tmpv;		# XXX: is this okay?
    } else {
	# If we assign a PMC to a PMC (or a string to a string...), we
	# have to remember to clone it before it's modified.  Why not
	# do so here?
	code("# ASSIGN TO ".$x->name."\n");
	if (is_pmc($x->type) && $thing->can('type') && is_pmc($thing->type)
	    && $thing->type ne 'PerlArray') { # XXX: can't clone arrays.
	    code("\t$name = clone $tmpv\n");
	} else {
	    code("\t$name = $tmpv\n");
	}
	return $name;
    }
}

######################################################################
# Variable declarations, which may have initializers
package P6C::decl;
use P6C::IMCC ':all';
use P6C::Util 'unimp';
use P6C::Context;

sub val {
    my $x = shift;
    if ($x->qual && $x->qual->scope ne 'my') {
	unimp 'global variables';
    }
    if (@{$x->props}) {
	unimp 'variable properties';
    }
    if (ref $x->vars eq 'ARRAY') {
	add_localvar($_->name, $_->type) for @{$x->vars};
    } else {
	add_localvar($x->vars->name, $x->vars->type);
    }
}

# A declaration with initializers shows up as assigning to a decl.
#
# XXX: The shenanigans with temporaries should go away, as they are
# the Wrong Way to make sure that the declared variable is not defined
# within its own initializer.
sub assign {
    my ($x, $thing) = @_;

    my $tmpv = $thing->val;

    if (ref $x->vars ne 'ARRAY') {
	if (ref($tmpv) eq 'ARRAY') {
	    use Carp 'cluck';
	    cluck "shouldn't return tuple in scalar context\n";
	    $tmpv = $tmpv->[-1];
	}
	add_localvar($x->vars->name, $x->vars->type);
	$x->vars->assign(new P6C::Register reg => $tmpv,
			 type => $x->vars->type);
    } else {
	# If we are evaluating an expression in tuple context, the val
	# function must return an array ref.
	if (ref $tmpv ne 'ARRAY') {
	    use Carp 'cluck';
	    cluck "Shouldn't pass single item to tuple\n";
	    $tmpv = [$tmpv];
	}
	my @vars = @{$x->vars};
	my $min = @$tmpv < @vars ? @$tmpv : @vars;
	for my $i (0.. $min - 1) {
	    add_localvar($vars[$i]->name, $vars[$i]->type);
	    $vars[$i]->assign(new P6C::Register reg => $tmpv->[$i]);
	}

	# In case we had more variables than values (tuple rvalues can
	# do this), declare the rest of the variables.
	for my $i ($min .. $#vars) {
	    add_localvar($vars[$i]->name, $vars[$i]->type);
	}
	return undef;
    }
}

######################################################################

sub P6C::indices::val {
    my $x = shift;
    my $ctx = $x->{ctx};
    return $x->indices->val;
}

##############################
package P6C::subscript_exp;
use P6C::Util 'unimp';
use P6C::IMCC ':all';

# Temporary types for different slices:
our %temptype = qw(PerlArray int PerlHash str);

sub call_closure {
    my ($thing, $args) = @_;
    my $argval = $args ? $args->val : newtmp('PerlArray');
    my $func = $thing->val;
    code(<<END);
	.arg	$argval
	.arg	$func
	call	__CALL_CLOSURE
END
    return undef;		# XXX: return values not implemented.
}

# Slice value.  Probably doesn't handle every single case, but it
# should handle most.
sub val {
    my ($x) = @_;
    if (@{$x->subscripts} > 1) {
	# XXX: shouldn't be too hard -- just evaluate subscripts
	# recursively on temporaries.  Not sure how context would work.
	unimp "multi-level subscripting";
    }
    if ($x->subscripts(0)->type eq 'Sub') {
	# Function call
	call_closure($x->thing, $x->subscripts(0)->indices);
	return undef;
    }
    code("# Base for indexing\n");
    my $thing = $x->thing->val;
    my $type = $x->subscripts(0)->type;
    code("# done; result in $thing\n");

    code("# Indexing expression\n");
    my $indexval = $x->subscripts(0)->val;
    code("# done; result in $indexval\n");

    my $ret;
    my $ctx = $x->{ctx};
    if ($ctx->is_scalar) {
	# Scalar context or single item => return last/only item.
	$ret = newtmp 'PerlUndef';
	my $itmp = gentmp $temptype{$type};
	$indexval = $indexval->[-1] if ref $indexval;
	code(<<END);
	$itmp = $indexval
	$ret = $thing\[$itmp]
END

    } elsif ($ctx->is_array || $ctx->flatten) {
	# Slice in array context.
	$ret = newtmp 'PerlArray';
	my $tmp = gentmp;
	my $itmp = gentmp $temptype{$type};
	my $ptmp = newtmp 'PerlUndef';
	my $ret_index = gentmp 'int';
	code(<<END);
	$ret_index = $indexval
	$ret = $ret_index
END
	code(gen_counted_loop($ret_index, <<END));
	$itmp = $indexval\[$ret_index]
	$ptmp = $thing\[$itmp]
	$ret\[$ret_index] = $ptmp
END

    } elsif ($ctx->is_tuple) {
	my $itmp = gentmp $temptype{$type};
	my @ret;
	die unless ref $indexval eq 'ARRAY';

	for (@$indexval) {
	    my $rettmp = newtmp 'PerlUndef';
	    push @ret, $rettmp;
	    code(<<END);
	$itmp = $_
	$rettmp = $thing\[$itmp]
END
	}
	$ret = [@ret];

    } else {
	use Data::Dumper;
	confess "slice in unsupported context ".Dumper($ctx);
    }
    return $ret;
}

sub assign {
    my ($x, $thing) = @_;
    if (@{$x->subscripts} > 1) {
	unimp "multi-level subscripting";
    }
    my $indexval = $x->subscripts(0)->val;
    my $type = $x->subscripts(0)->type;
    my $rhs = $thing->val;
    my $lhs = $x->thing->val;
    my $lctx = $thing->{ctx};

    if ($lctx->is_scalar) {
	# XXX: This isn't quite right, since we're taking lhs's
	# C<val>.  But it works for simple @arrays.
	my $itmp = gentmp $temptype{$type};
	$indexval = $indexval->[-1] if ref $indexval;
	code(<<END);
	$itmp = $indexval
	$lhs\[$itmp] = $rhs
END
	return $rhs;	# XXX: should return $lhs[$itmp] ?

    } elsif ($lctx->is_tuple) {
	my $itmp = gentmp $temptype{$type};
	for my $i (0..$#{$indexval}) {
	    code(<<END);
	$itmp = $indexval->[$i]
	$lhs\[$itmp] = $rhs->[$i]
END
	}

    } elsif ($lctx->is_array) {
	my $index = gentmp $temptype{$type};
	my $iter = gentmp 'int';
	my $long = gentmp 'int';
	my $short = gentmp 'int';
	my $ptmp = newtmp;
	my $start = genlabel 'slice_assign';
	my $start2 = genlabel 'cleanup';
	my $end2 = genlabel 'cleanup';
	# Figure out how many values to assign:
	code(<<END);
	$short = $indexval
	$long = $rhs
	if $short < $long goto $start
	$iter = $short
	$short = $long
	$long = $iter
$start:
	$iter = $short
END
	# Assign them:
	code(gen_counted_loop($iter, <<END));
	$index = $indexval\[$iter]
	$ptmp = $rhs\[$iter]
	$lhs\[$index] = $ptmp
END
	# If we have more values, assign undef to the rest of them:
	code(<<END);
	$ptmp = new PerlUndef
	goto $end2
$start2:
	$index = $indexval\[$short]
	$lhs\[$index] = $ptmp
	inc $short
$end2:
	if $short < $long goto $start2
END
    } else {
	use Data::Dumper;
	unimp 'Assignment to multi-element slice: '.Dumper($lctx);
    }
}

######################################################################
sub P6C::loop::val {
    my ($x) = @_;
    my $start = genlabel 'loop';
    my $end = genlabel 'loop';

    push_scope;
    $x->init->val if $x->init;
    code(<<END);
	goto $end
$start:
END
    $_->val for @{$x->block};
    $x->incr->val if $x->incr;
    code(<<END);
$end:
END
    my $test = $x->test->val if $x->test;
    code(<<END);
	if $test goto $start
END
    pop_scope;
    return undef;
}

1;
