## $Id$

Perl6::PAST::Sub: pir(.) = {
   .local pmc pir, lex_hash
   lex_hash = new .Hash
   # XXX
   # this shouldn't be a global, but an attribute of
   # the PAST::Sub node
   #
   store_global "_Perl6_LexHash", lex_hash
    pir = new 'PGE::CodeString'
    pir.emit(".sub 'anon' :anon")
    $P0 = node['statement_list']
    $P1 = tree.'get'('pir', $P0)
    pir .= $P1
    $P2 = $P0['ret']
    node['ret'] = $P2
    pir.emit(".end")
    .return (pir)
}


Perl6::PAST::Stmts: pir(.) = {
    .local pmc pir
    pir = new 'PGE::CodeString'
    $P0 = node['children']
    unless $P0 goto end

    .local pmc iter
    iter = new .Iterator, $P0
    iter = 0
  iter_loop:
    unless iter goto iter_end
    $P0 = shift iter
    $P1 = tree.'get'('pir', $P0)
    pir .= $P1
    goto iter_loop
  iter_end:
    $P2 = $P0['ret']
    node['ret'] = $P2
  end:
    .return (pir)
}


Perl6::PAST::Stmt: pir(.) = {
    $P0 = node['statement']
    $P1 = tree.'get'('pir', $P0)
    $P2 = $P0['ret']
    node['ret'] = $P2
    .return ($P1)
}


Perl6::PAST::Exp: pir(.) = {
    $P0 = node['expression']
    $P1 = tree.'get'('pir', $P0)
    $P2 = $P0['ret']
    node['ret'] = $P2
    .return ($P1)
}


Perl6::PAST::Op: pir(.) = {
    .local pmc pir, op, optable
    .local string opname, subname, ret, fmt, id
    .local pmc children
    children = node['children']
    opname = node['opname']
    $S0 = node['pasttype']
    if $S0 == 'cond' goto op_cond

    subname = node['subname']
    optable = find_global "Perl6::Grammar", "$optable"
    op = optable[opname]
    fmt = op['pir']
    if fmt goto op_dispatch
    fmt = "    %r = '%f'(%,)"

  op_dispatch:
    if $S0 != 'chain' goto op_normal
    $P0 = children[0]
    $S0 = $P0['pasttype']
    if $S0 == 'chain' goto op_chain

  op_normal:
    .local pmc arglist
    arglist = new .ResizablePMCArray
    pir = new 'PGE::CodeString'
    unless children goto iter_end
    if opname != 'prelist:' goto op_children
    $P0 = children[0]
    $S0 = $P0['opname']
    if $S0 != 'infix:,' goto op_children
    children = $P0['children']
  op_children:
    unless children goto op_fmt_t
    .local pmc iter
    iter = new .Iterator, children
    iter = 0
  iter_loop:
    unless iter goto iter_end
    $P0 = shift iter
    $P1 = tree.'get'('pir', $P0)
    pir .= $P1
    $P2 = $P0['ret']
    push arglist, $P2
    goto iter_loop
  iter_end:
    ret = arglist[0]
  op_fmt_t:
    .local string treg
    treg = ''
    $I0 = index fmt, '%t'
    if $I0 < 0 goto op_fmt_r
    node['temp'] = 1
    $P0 = children[0]
    unless $P0 goto op_fmt_t1
    $I0 = $P0['temp']
    unless $I0 goto op_fmt_t1
    treg = $P0['ret']
    ret = treg
    goto op_fmt_r
  op_fmt_t1:
    treg = pir.unique('$P')
    pir.emit('    %0 = new .Undef', treg)
    ret = treg
  op_fmt_r:
    .local string rreg
    rreg = ''
    $I0 = index fmt, '%r'
    if $I0 < 0 goto op_fmt_ret
    rreg = pir.unique('$P')
    ret = rreg
  op_fmt_ret:
    if ret > '' goto op_emit
    ret = pir.unique('$P')
  op_emit:
    pir.emit(fmt, arglist :flat, 'r'=>rreg, 't'=>treg, 'f'=>subname)
    goto end

  op_chain:
    $P0 = children[0]
    pir = tree.'get'('pir', $P0)
    id = pir.unique()
    ret = $P0['ret']
    pir.'emit'("    unless %0 goto chain_%1_end", ret, id)
    $P2 = $P0['children';1;'ret']
    $P0 = children[1]
    $P1 = tree.'get'('pir', $P0)
    pir .= $P1
    $P3 = $P0['ret']
    pir.'emit'(fmt, $P2, $P3, 'r'=>ret, 'f'=>subname, 't'=>ret)
    pir.'emit'("  chain_%0_end:", id)
    goto end

  op_cond:
    .local pmc expr, then, else
    .local string childret
    expr = children[0]
    then = children[1]
    else = children[2]
    pir = tree.'get'('pir', expr)
    id = pir.unique()
    ret = concat '$P', id
    childret = expr['ret']
    pir.'emit'("    if %0 goto cond_%1_true", childret, id)
    $I0 = defined else
    unless $I0 goto op_cond_1
    $P1 = tree.'get'('pir', else)
    pir .= $P1
    childret = else['ret']
  op_cond_1:
    pir.'emit'("    %0 = %1", ret, childret)
    pir.'emit'("    goto cond_%0_end\n  cond_%0_true:", id)
    childret = expr['ret']
    $I0 = defined then
    unless $I0 goto op_cond_2
    $P1 = tree.'get'('pir', then)
    pir .= $P1
    childret = then['ret']
  op_cond_2:
    pir.'emit'("    %0 = %1", ret, childret)
    pir.'emit'("  cond_%0_end:", id)
    goto end

  end:
    node['ret'] = ret
    .return (pir)
}


Perl6::PAST::Val: pir(.) = {
    .local pmc pir
    .local string ret
    .local string value
    pir = new "PGE::CodeString"
    ret = pir.unique('$P')
    pir.emit('    %r = new .Undef', 0, 'r' => ret)
    value = node['value']
    $S0 = node['returns']
    if $S0 == 'int' goto emit_pir
    if $S0 == 'num' goto emit_pir

  string:
    $S1 = substr value, 0, 1
    value = substr value, 1
    chopn value, 1
    value = escape value
    if $S1 != '"' goto slash_end
    # remove any '\\' sequences for double-quoted strings
    $I0 = 0
  slash_loop:
    $I0 = index value, "\\\\", $I0
    if $I0 < 0 goto slash_end
    substr value, $I0, 2, "\\"
    goto slash_loop
  slash_end:
    # add quotes for pir
    value = concat '"', value
    value = concat value, '"'
    $I0 = index value, "\\x"
    if $I0 >= 0 goto unicode
    $I0 = index value, "\\u"
    if $I0 >= 0 goto unicode
    goto emit_pir
  unicode:
    value = concat 'unicode:', value

  emit_pir:
    pir.emit('    assign %r, %0', value, 'r' => ret)
    node['ret'] = ret
    node['temp'] = 1
    .return (pir)
}


Perl6::PAST::Var: pir(.) = {
    .local pmc pir
    .local string ret
    .local pmc pir, lex_hash
    .local string ret
    pir = new 'PGE::CodeString'
    $S0 = node['variable']
    lex_hash = find_global "_Perl6_LexHash"
    $I0 = exists lex_hash[$S0]
    if $I0 goto lex
    ret = pir.unique('$P')
    pir.emit('    %0 = find_name "%1"', ret, $S0)
    node['ret'] = ret
    goto ex
lex:
    $S1 = lex_hash[$S0]
    node['ret'] = $S1
ex:
    .return (pir)
}


Perl6::PAST::Lex: pir(.) = {
    .local pmc pir, lex_hash
    .local string ret
    pir = new 'PGE::CodeString'
    ret = pir.unique('$P')
    $S0 = node['variable']
    pir.emit('    .lex "%0", %1', $S0, ret)
    pir.emit('    %0 = new .Undef', ret)
    node['ret'] = ret
    lex_hash = find_global "_Perl6_LexHash"
    lex_hash[$S0] = ret
    .return (pir)
}

## vim: expandtab sw=4
