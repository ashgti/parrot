# $Id$

grammar Perl6::Grammar;


## terms
proto 'term:' is precedence('22=')
    is parsed(&term)
    is pastrule('past_term') { ... }

proto 'prelist:' is equiv('term:')
    is prec_close('05=')
    is nullterm
    is parsed(&listop) { ... }

proto 'circumfix:( )' is equiv('term:')
    is pir("        # circumfix op") { ... }

## dot comment in postfix position
proto 'postfix:.' is precedence('21=')
    is parsed(&dot_comment)
    is nows 
    is pir("        # dot comment") { ... }

## method postfix
proto 'infix:.' is equiv('postfix:.') is nows { ... }
proto 'postcircumfix:.+' is equiv('postfix:.') is nows { ... }
proto 'postcircumfix:.?' is equiv('postfix:.') is nows { ... }
proto 'postcircumfix:.*' is equiv('postfix:.') is nows { ... }
proto 'postcircumfix:.< >' is equiv('postfix:.') is nows { ... }
proto 'postcircumfix:.<< >>' is equiv('postfix:.') is nows { ... }
proto 'postcircumfix:.( )' is equiv('postfix:.') is nows { ... }
proto 'postcircumfix:.[ ]' is equiv('postfix:.') is nows { ... }
proto 'postcircumfix:.{ }' is equiv('postfix:.') is nows { ... }
proto 'postcircumfix:< >' is equiv('postfix:.') is nows { ... }
proto 'postcircumfix:<< >>' is equiv('postfix:.') is nows { ... }
proto 'postcircumfix:( )' is equiv('postfix:.') is nows { ... }
proto 'postcircumfix:[ ]' is equiv('postfix:.') is nows { ... }
proto 'postcircumfix:{ }' is equiv('postfix:.') is nows { ... }

## autoincrement
proto 'postfix:++' is precedence('20=')
    is pir("    %r = clone %0\n    inc %0") { ... }

proto 'postfix:--' is equiv('postfix:++')
    is pir("    %r = clone %0\n    dec %0") { ... }

proto 'prefix:++' is equiv('postfix:++')
    is pir("    inc %0")
    { ... }

proto 'prefix:--' is equiv('postfix:++')
    is pir("    dec %0")
    { ... }


## exponentiation
proto 'infix:**' is precedence('19=')
    is pir("    %t = %0 ** %1")
    { ... }

## symbolic unary
proto 'prefix:!' is precedence('18=')
    is pir("    $I0 = isfalse %0\n    %t = $I0")
    { ... }

proto 'prefix:+' is equiv('prefix:!')
    is pir("    %t = %0 + 0")
    { ... }

proto 'prefix:-' is equiv('prefix:!')
    is pir("    %t = neg %0")
    { ... }

proto 'prefix:~' is equiv('prefix:!')
    is pir("    %t = concat %0, ''")
    { ... }

proto 'prefix:?' is equiv('prefix:!')
    is pir("    $I0 = istrue %0\n    %t = $I0")
    { ... }

# waiting for term: rules
# sub 'prefix:$' is equiv('prefix:!') { ... }
# sub 'prefix:@' is equiv('prefix:!') { ... }
# sub 'prefix:%' is equiv('prefix:!') { ... }
# sub 'prefix:&' is equiv('prefix:!') { ... }
proto 'prefix:*' is equiv('prefix:!') { ... }
proto 'prefix:**' is equiv('prefix:!') { ... }
proto 'prefix:+^' is equiv('prefix:!') { ... }
proto 'prefix:~^' is equiv('prefix:!') { ... }

proto 'prefix:?^' is equiv('prefix:!')
    is pir("    $I0 = isfalse %0\n    %t = $I0")
    { ... }

proto 'prefix:\' is equiv('prefix:!') { ... } #'
proto 'prefix:^' is equiv('prefix:!') { ... }


## multiplicative
proto 'infix:*' is precedence('17=')
    is pir("    %t = %0 * %1")
    { ... }

proto 'infix:/' is equiv('infix:*')
    is pir("    %t = %0 / %1")
    { ... }

proto 'infix:%' is equiv('infix:*')
    is pir("    %t = mod %0, %1")
    { ... }

proto 'infix:x' is equiv('infix:*')
    is pir("    %t = repeat %0, %1")
    { ... }

proto 'infix:xx' is equiv('infix:*') { ... }

proto 'infix:+&' is equiv('infix:*')
    is pir("    %r = band %0, %1")
    { ... }

proto 'infix:+<' is equiv('infix:*')
    is pir("    %r = shl %0, %1")
    { ... }

proto 'infix:+>' is equiv('infix:*')
    is pir("    %r = shr %0, %1")
    { ... }

proto 'infix:~&' is equiv('infix:*')
    is pir("    %r = bands %0, %1")
    { ... }

proto 'infix:~<' is equiv('infix:*') { ... }
proto 'infix:~>' is equiv('infix:*') { ... }


## additive
proto 'infix:+' is precedence('16=')
    is pir("    %r = %0 + %1")
    { ... }

proto 'infix:-' is equiv('infix:+')
    is pir("    %r = %0 - %1")
    { ... }

proto 'infix:~' is equiv('infix:+')
    is pir("    %r = concat %0, %1")
    { ... }

proto 'infix:+|' is equiv('infix:+')
    is pir("    %r = %0 | %1")
    { ... }

proto 'infix:+^' is equiv('infix:+')
    is pir("    %r = bxor %0, %1")
    { ... }

proto 'infix:~|' is equiv('infix:+')
    is pir("    %r = bors %0, %1")
    { ... }

proto 'infix:~^' is equiv('infix:+')
    is pir("    %r = bxors %0, %1")
    { ... }

proto 'infix:?|' is equiv('infix:+')
    is pir("    %r = %0 | %1\n    %r = istrue %r")
    { ... }

proto 'infix:?^' is equiv('infix:+')
    is pir("    %r = bxor %0, %1\n    %r = istrue %r")
    { ... }


## junctive and (all)
proto 'infix:&' is precedence('15=') { ... }


## junctive or (any)
proto 'infix:|' is precedence('14=') { ... }
proto 'infix:^' is equiv('infix:|') { ... }


## named unary
proto 'prefix:rand' is precedence('13=')
    is nullterm
    { ... }

proto 'prefix:sleep' is equiv('rand')
    is nullterm
    is pir("    $N0 = %0\n    sleep $N0")
    { ... }

proto 'prefix:abs' is equiv('rand')
    is nullterm
    is pir("    %r = abs %0")
    { ... }


## nonchaining binary
proto 'infix:<=>' is precedence('12=') is assoc('non')
    is pir("    %r = cmp_num %0, %1")
    { ... }

proto 'infix:cmp' is equiv('infix:<=>')
    is pir("    %r = cmp_str %0, %1")
    { ... }

proto 'infix:is' is equiv('infix:<=>')
    { ... }

proto 'infix:but' is equiv('infix:<=>')
    { ... }

proto 'infix:does' is equiv('infix:<=>')
    { ... }

proto 'infix:..' is equiv('infix:<=>')
    { ... }

proto 'infix:^..' is equiv('infix:<=>')
    { ... }

proto 'infix:..^' is equiv('infix:<=>')
    { ... }

proto 'infix:^..^' is equiv('infix:<=>')
    { ... }

proto 'infix:ff' is equiv('infix:<=>')
    { ... }

proto 'infix:^ff' is equiv('infix:<=>')
    { ... }

proto 'infix:ff^' is equiv('infix:<=>')
    { ... }

proto 'infix:^ff^' is equiv('infix:<=>')
    { ... }

proto 'infix:fff' is equiv('infix:<=>')
    { ... }

proto 'infix:^fff' is equiv('infix:<=>')
    { ... }

proto 'infix:fff^' is equiv('infix:<=>')
    { ... }

proto 'infix:^fff^' is equiv('infix:<=>')
    { ... }

proto 'prefix:...' is equiv('infix:<=>')
    { ... }


## chaining binary
proto 'infix:==' is precedence('11=') is assoc('chain')
    is pir("    $I0 = cmp_num %0, %1\n    $I0 = iseq $I0, 0\n    %t = $I0")
    { ... }

proto 'infix:!=' is equiv('infix:==')
    is pir("    $I0 = cmp_num %0, %1\n    $I0 = isne $I0, 0\n    %t = $I0")
    { ... }

proto 'infix:<' is equiv('infix:==')
    is pir("    $I0 = cmp_num %0, %1\n    $I0 = islt $I0, 0\n    %t = $I0")
    { ... }

proto 'infix:<=' is equiv('infix:==')
    is pir("    $I0 = cmp_num %0, %1\n    $I0 = isle $I0, 0\n    %t = $I0")
    { ... }

proto 'infix:>' is equiv('infix:==')
    is pir("    $I0 = cmp_num %0, %1\n    $I0 = isgt $I0, 0\n    %t = $I0")
    { ... }

proto 'infix:>=' is equiv('infix:==')
    is pir("    $I0 = cmp_num %0, %1\n    $I0 = isge $I0, 0\n    %t = $I0")
    { ... }

proto 'infix:~~' is equiv('infix:==')
    { ... }

proto 'infix:!~' is equiv('infix:==')
    { ... }

proto 'infix:=~' is equiv('infix:==')
    is pir<"    'die'('brain-o. use ~~ or ~= instead.')">
    { ... }

proto 'infix:eq' is equiv('infix:==')
    is pir("    $I0 = cmp_str %0, %1\n    $I0 = iseq $I0, 0\n    %t = $I0")
    { ... }

proto 'infix:ne' is equiv('infix:==')
    is pir("    $I0 = cmp_str %0, %1\n    $I0 = isne $I0, 0\n    %t = $I0")
    { ... }

proto 'infix:lt' is equiv('infix:==')
    is pir("    $I0 = cmp_str %0, %1\n    $I0 = islt $I0, 0\n    %t = $I0")
    { ... }

proto 'infix:le' is equiv('infix:==')
    is pir("    $I0 = cmp_str %0, %1\n    $I0 = isle $I0, 0\n    %t = $I0")
    { ... }

proto 'infix:gt' is equiv('infix:==')
    is pir("    $I0 = cmp_str %0, %1\n    $I0 = isgt $I0, 0\n    %t = $I0")
    { ... }

proto 'infix:ge' is equiv('infix:==')
    is pir("    $I0 = cmp_str %0, %1\n    $I0 = isge $I0, 0\n    %t = $I0")
    { ... }

proto 'infix:=:=' is equiv('infix:==')
    { ... }

proto 'infix:===' is equiv('infix:==')
    is pir("    $I0 = issame %0, %1")
    { ... }


## tight and
proto 'infix:&&' is precedence('10=')
    is pasttype('cond') { ... }


## tight or
proto 'infix:||' is precedence('09=')
    is pasttype('cond') { ... }

proto 'infix:^^' is equiv('infix:||')
    is pasttype('cond') { ... }

proto 'infix://' is equiv('infix:||')
    is pasttype('cond') { ... }


## ternary
proto 'ternary:?? !!' is precedence('08=') is assoc('right')
    is pasttype('cond') { ... }


## assignment
proto 'infix:=' is precedence('07=') is assoc('right')
    is pir("    assign %0, %1") { ... }

proto 'infix::=' is equiv('infix:=') { ... }

proto 'infix:::=' is equiv('infix:=') { ... }

proto 'infix:.=' is equiv('infix:=') { ... }

proto 'infix:~=' is equiv('infix:=') { ... }

proto 'infix:+=' is equiv('infix:=')
    is pir("    %0 += %1") { ... }

proto 'infix:-=' is equiv('infix:=')
    is pir("    %0 -= %1") { ... }

proto 'infix:*=' is equiv('infix:=')
    is pir("    %0 *= %1") { ... }

proto 'infix:/=' is equiv('infix:=')
    is pir("    %0 /= %1") { ... }

proto 'infix:%=' is equiv('infix:=')
    is pir("    %0 %= %1") { ... }

proto 'infix:x=' is equiv('infix:=')
    is pir("    repeat %0,  %1") { ... }

proto 'infix:Y=' is equiv('infix:=') { ... }

proto 'infix:**=' is equiv('infix:=')
    is pir("    pow %0, %1") { ... }

proto 'infix:xx=' is equiv('infix:=') { ... }
proto 'infix:||=' is equiv('infix:=') { ... }
proto 'infix:&&=' is equiv('infix:=') { ... }
proto 'infix://=' is equiv('infix:=') { ... }
proto 'infix:^^=' is equiv('infix:=') { ... }

proto 'infix:+<=' is equiv('infix:=')
    is pir("    %0 <<= %1") { ... }

proto 'infix:+>=' is equiv('infix:=')
    is pir("    %0 >>= %1") { ... }

proto 'infix:+|=' is equiv('infix:=')
    is pir("    %0 |= %1") { ... }

proto 'infix:+&=' is equiv('infix:=')
    is pir("    %0 &= %1") { ... }

proto 'infix:+^=' is equiv('infix:=')
    is pir("    %0 = bxor %1") { ... }

proto 'infix:~|=' is equiv('infix:=')
    is pir("    %0 = bors %1") { ... }

proto 'infix:~&=' is equiv('infix:=')
    is pir("    %0 = bands %1") { ... }

proto 'infix:~^=' is equiv('infix:=')
    is pir("    %0 = bxors %1") { ... }

proto 'infix:?|=' is equiv('infix:=')
    is pir("    %0 = bor %1\n    %0 = istrue %0") { ... }

proto 'infix:?&=' is equiv('infix:=')
    is pir("    %0 = band %1\n    %0 = istrue %0") { ... }

proto 'infix:?^=' is equiv('infix:=')
    is pir("    %0 = bxor %1\n    %0 = istrue %0") { ... }

proto 'infix:|=' is equiv('infix:=') { ... }
proto 'infix:&=' is equiv('infix:=') { ... }
proto 'infix:^=' is equiv('infix:=') { ... }


## list item separator
proto 'infix:,' is precedence('06=') is assoc('list')
   is nullterm
   is pir<"    %r = list()">
   { ... }
## TODO zip


## listop
proto 'infix:<==' is precedence('05=') is assoc('right') { ... }

proto 'prefix:true' is equiv('infix:<==')
    is pir("    $I0 = istrue %0\n    %t = $I0") { ... }

proto 'prefix:not' is equiv('infix:<==')
    is pir("    $I0 = isfalse %0\n    %t = $I0") { ... }
## TODO print push any all XXX: do these really belong here? ~particle


## pipe forward
proto 'infix:==>' is precedence('04=') { ... }


## loose and
proto 'infix:and' is precedence('03=')
    is pasttype('cond') { ... }


## loose or
proto 'infix:or' is precedence('02=')
    is pasttype('cond') { ... }

proto 'infix:xor' is equiv('infix:or')
    is pasttype('cond') { ... }

proto 'infix:err' is equiv('infix:or')
    is pasttype('cond') { ... }


## expression terminator
proto 'infix:;' is precedence('01=') is assoc('list')
    is nullterm
    is pir("    #")
    { ... }


## statement control
proto 'statement_control:if' is pasttype('cond') { ... }


## vim: expandtab sw=4
