## $Id$

ROOT: past(.) = {
    .local pmc past
    $P0 = node['statement_list']
    $P1 = tree.'get'('past', $P0, 'Perl6::Grammar::statement_list')
    past = new 'Perl6::PAST::Sub'
    past.'init'($P1, 'node'=>node)
    .return (past)
}


Perl6::Grammar::statement_list:  past(.) = {
    .local pmc past
    .local pmc iter

    past = new 'Perl6::PAST::Stmts'
    past.'init'('node'=>node)

    $P0 = node['statement']
    iter = new .Iterator, $P0
    iter = 0
  iter_loop:
    unless iter goto iter_end
    $P1 = shift iter
    $P2 = tree.'get'('past', $P1, 'Perl6::Grammar::statement')
    if null $P2 goto iter_loop
    past.'add_child'($P2)
    goto iter_loop
  iter_end:
    .return (past)
}


Perl6::Grammar::statement: past(.) = {
    $P0 = node['statement_control']
    if $P0 goto statement_control

  expression:
    .local pmc stmt
    $P0 = node['expression']
    stmt = tree.'get'('past', $P0, 'Perl6::Grammar::expression')
    $P0 = node['statement_modifier']
    unless $P0 goto expression_1
  stmt_modifier:
    # handle if/unless modifier
    .local pmc modifier, exprpast, thenpast, elsepast
    modifier = $P0[0]
    thenpast = stmt
    null elsepast
    $S0 = modifier['KEY']
    if $S0 != 'unless' goto stmt_modifier_1
    exchange thenpast, elsepast
  stmt_modifier_1:
    $P0 = modifier['expression']
    exprpast = tree.'get'('past', $P0, 'Perl6::Grammar::expression')
    stmt = new 'Perl6::PAST::Op'
    stmt.'init'(exprpast, thenpast, elsepast, 'op'=>'statement_control:if', 'node'=>modifier)

  expression_1:
    .local pmc past
    past = new 'Perl6::PAST::Stmt'
    past.'init'(stmt, 'node'=>node)
    .return (past)

  statement_control:
    $P1 = tree.'get'('past', $P0, 'Perl6::Grammar::statement_control')
    past = new 'Perl6::PAST::Stmt'
    past.'init'($P1, 'node'=>node)
    .return (past)
}


Perl6::Grammar::statement_control: past(.) = {
    .local pmc key, exprlist, blocklist
    key = node['KEY']
    exprlist = node['expression']
    blocklist = node['block']

    ##   do we have an else clause?
    .local pmc exprpast, thenpast, elsepast
    .local int exprc, blockc
    null elsepast
  else_block:
    exprc = elements exprlist
    blockc = elements blocklist
    if blockc <= exprc goto expr_block_pair
    dec blockc
    $P0 = blocklist[blockc]
    elsepast = tree.'get'('past', $P0, 'Perl6::Grammar::block')

  expr_block_pair:
    ##   each remaining block is paired with an "if" (or "elsif")
    ##   expression, except the first which could be "unless".
    dec exprc
    dec blockc
    $P0 = exprlist[exprc]
    exprpast = tree.'get'('past', $P0, 'Perl6::Grammar::expression')
    $P0 = blocklist[blockc]
    thenpast = tree.'get'('past', $P0, 'Perl6::Grammar::block')
    if exprc > 0 goto if_op
    if key != 'unless' goto if_op
    exchange thenpast, elsepast

  if_op:
    .local pmc past
    past = new "Perl6::PAST::Op"
    past.init(exprpast, thenpast, elsepast, 'node'=>node, 'op'=>'statement_control:if')
    elsepast = past
    if exprc > 0 goto expr_block_pair
    .return (past)
}
    

Perl6::Grammar::expression: past(.) = {
    .local pmc past

    $P0 = node['expr']
    $P1 = tree.'get'('past', $P0, 'Perl6::Grammar::expr')
    past = new 'Perl6::PAST::Exp'
    past.'init'($P1, 'node'=>node)
    .return (past)
}


Perl6::Grammar::expr: past(.) = {
    .local string type
    type = node['type']
    if type != "" goto pastrule
    null $P0
    .return ($P0)

  pastrule:
    .local pmc optable, optok
    optable = find_global 'Perl6::Grammar', '$optable'
    optok = optable[type]
    $S0 = optok['pastrule']
    unless $S0 goto set_subname
    .return tree.'get'($S0, node, 'Perl6::Grammar::expr')

  set_subname:
    .local string subname
    subname = optok['post']
    if subname > '' goto set_subname_end
    subname = node['ident']
    if subname > '' goto set_subname_quote
    subname = type
  set_subname_quote:
    subname = concat "'", subname
    subname = concat subname, "'"
  set_subname_end:
    
    .local pmc past, children, iter
    past = new 'Perl6::PAST::Op'
    past.'init'('node'=>node, 'op'=>type, 'name'=>subname)
    $P0 = node.'get_array'()
    if null $P0 goto iter_end
    iter = new .Iterator, $P0
    iter = 0
  iter_loop:
    unless iter goto iter_end
    $P0 = shift iter
    $S0 = $P0
    if $S0 == "" goto iter_loop
    $P1 = tree.'get'('past', $P0, 'Perl6::Grammar::expr')
    if null $P1 goto iter_loop
    past.'add_child'($P1)
    goto iter_loop
  iter_end:
    if type == 'infix:or' goto infix_or
    if type != 'infix:||' goto end
  infix_or:
    ##   We cheat a bit here, moving the "then" portion of an 'or'
    ##   node to the 'else' portion.
    $P0 = past[1]
    past[2] = $P0
    null $P0
    past[1] = $P0
  end:
    .return (past)
}


Perl6::Grammar::expr: past_term(.) = {
    .local pmc iter
    $P0 = node.'get_hash'()
    iter = new .Iterator, $P0
    iter = 0
  iter_loop:
    unless iter goto term_error
    $S0 = shift iter
    $P0 = iter[$S0]
    $S1 = concat 'Perl6::Grammar::', $S0
    $P1 = tree.'get'('past', $P0, $S1)
    if null $P1 goto iter_loop
    .return ($P1)

  term_error:
    print "error: 'term' node has incorrect structure.\n"
    end
}


Perl6::Grammar::type: past(.) = {
    null $P0
    .return ($P0)
}


Perl6::Grammar::variable: past(.) = {
    .local pmc past
    .local string scope

    past = new 'Perl6::PAST::Var'
    past.set_node(node)
    past['returns'] = 'var'
    $S0 = node
    past['variable'] = $S0
    .return (past)
}


Perl6::Grammar::integer: past(.) = {
    .local pmc past
    $I0 = node
    past = new 'Perl6::PAST::Val'
    past.'init'('node'=>node, 'valtype'=>'int', 'val'=>$I0)
    .return (past)
}


Perl6::Grammar::number: past(.) = {
    .local pmc past
    $N0 = node
    past = new 'Perl6::PAST::Val'
    past.'init'('node'=>node, 'valtype'=>'num', 'val'=>$N0)
    .return (past)
}


Perl6::Grammar::string_literal: past(.) = {
    .local pmc past
    $S0 = node
    past = new 'Perl6::PAST::Val'
    past.'init'('node'=>node, 'valtype'=>'str', 'val'=>$S0)
    .return (past)
}


Perl6::Grammar::version: past(.) = {
    $S0 = node
    $S0 = concat "'", $S0
    $S0 = concat $S0, "'"
    .local pmc past
    past = new 'Perl6::PAST::Val'
    past.'init'('node'=>node, 'valtype'=>'str', 'val'=>$S0)
    .return (past)
}


Perl6::Grammar::block: past(.) = {
    $P0 = node['simple_block']
    .return tree.'get'('past', $P0, 'Perl6::Grammar::simple_block')
}


Perl6::Grammar::simple_block: past(.) = {
    $P0 = node['statement_list']
    .return tree.'get'('past', $P0, 'Perl6::Grammar::statement_list')
}


## vim: expandtab sw=4
