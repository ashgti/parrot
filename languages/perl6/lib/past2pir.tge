Perl6::PAST::Sub: pir(.) = {
    .local pmc pir
    pir = new 'PGE::CodeString'
    pir.emit(".sub 'anon' :anon")
    $P0 = node['statement_list']
    $P1 = tree.'get'('pir', $P0)
    pir .= $P1
    $P2 = $P0['ret']
    node['ret'] = $P2
    pir.emit(".end")
    .return (pir)
}


Perl6::PAST::Stmts: pir(.) = {
    .local pmc pir
    pir = new 'PGE::CodeString'
    $P0 = node['children']
    unless $P0 goto end

    .local pmc iter
    iter = new .Iterator, $P0
    iter = 0
  iter_loop:
    unless iter goto iter_end
    $P0 = shift iter
    $P1 = tree.'get'('pir', $P0)
    pir .= $P1
    goto iter_loop
  iter_end:
    $P2 = $P0['ret']
    node['ret'] = $P2
  end:
    .return (pir)
}


Perl6::PAST::Stmt: pir(.) = {
    $P0 = node['statement']
    $P1 = tree.'get'('pir', $P0)
    $P2 = $P0['ret']
    node['ret'] = $P2
    .return ($P1)
}


Perl6::PAST::Exp: pir(.) = {
    $P0 = node['expression']
    $P1 = tree.'get'('pir', $P0)
    $P2 = $P0['ret']
    node['ret'] = $P2
    .return ($P1)
}


Perl6::PAST::Op: pir(.) = {
    $S0 = node['op']
    if $S0 == 'statement_control:if' goto cond_op

    .local pmc pir
    pir = new 'PGE::CodeString'

    .local pmc op, optable
    optable = find_global "Perl6::Grammar", "$optable"
    op = optable[$S0]

    .local pmc childret
    childret = new .ResizablePMCArray
    $P0 = node['children']
    unless $P0 goto end
    if $S0 != 'prelist:' goto childops
    $P1 = $P0[0]
    $S0 = $P1['op']
    if $S0 != 'infix:,' goto childops
    $P0 = $P1['children']
    unless $P0 goto end

  childops:
    .local pmc iter
    iter = new .Iterator, $P0
    iter = 0
  iter_loop:
    unless iter goto iter_end
    $P0 = shift iter
    $P1 = tree.'get'('pir', $P0)
    pir .= $P1
    $P2 = $P0['ret']
    push childret, $P2
    goto iter_loop
  iter_end:
  end:
    .local string ret, fmt
    ret = childret[0]
    $S0 = node['subname']
    fmt = op['pircode']
    if fmt goto emit_pir
    ret = pir.unique('$P')
    fmt = "    %r = '%f'(%,)"
  emit_pir:
    node['ret'] = ret
    pir.emit(fmt, childret :flat, 'r'=>ret, 'f'=>$S0)
    .return (pir)

  cond_op:
    .return tree.'get'('pir_cond', node)
}


Perl6::PAST::Op: pir_cond(.) = {
    .local pmc pir
    .local string id, ret
    .local string ret, childret

    .local pmc expr
    expr = node['expr']
    pir = tree.'get'('pir', expr)
    id = pir.unique()
    ret = concat '$P', id
    childret = expr['ret']
    pir.emit('    if %0 goto cond_%1_true', childret, id)

    .local pmc else
    else = node['else']
    if null else goto no_else
    $P0 = tree.'get'('pir', else)
    pir .= $P0
    childret = else['ret']
  no_else:
    pir.emit('    %0 = %1', ret, childret)
    pir.emit('    goto cond_%0_end', id)

    .local pmc then
    pir.emit('  cond_%0_true:', id)
    childret = expr['ret']
    then = node['then']
    if null then goto no_then
    $P0 = tree.'get'('pir', then)
    pir .= $P0
    childret = then['ret']
  no_then:
    pir.emit('    %0 = %1', ret, childret)
    pir.emit('  cond_%0_end:', id)
    node['ret'] = ret
    .return (pir)
}


Perl6::PAST::Val: pir(.) = {
    .local pmc pir
    .local string ret
    .local string value
    pir = new "PGE::CodeString"
    ret = pir.unique('$P')
    pir.emit('    %r = new .Undef', 0, 'r' => ret)
    value = node['value']
    $S0 = node['returns']
    if $S0 == 'int' goto emit_pir
    if $S0 == 'num' goto emit_pir
  
  string:
    $S1 = substr value, 0, 1
    value = substr value, 1
    chopn value, 1
    value = escape value
    if $S1 != '"' goto slash_end
    # remove any '\\' sequences for double-quoted strings
    $I0 = 0
  slash_loop:
    $I0 = index value, "\\\\", $I0
    if $I0 < 0 goto slash_end
    substr value, $I0, 2, "\\"
    goto slash_loop
  slash_end:
    # add quotes for pir
    value = concat '"', value
    value = concat value, '"'
    $I0 = index value, "\\x"
    if $I0 >= 0 goto unicode
    $I0 = index value, "\\u"
    if $I0 >= 0 goto unicode
    goto emit_pir
  unicode:
    value = concat 'unicode:', value

  emit_pir:
    pir.emit('    assign %r, %0', value, 'r' => ret)
    node['ret'] = ret
    .return (pir)
}
