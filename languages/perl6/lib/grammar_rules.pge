## TITLE
##     The Perl 6 grammar
##
## DESCRIPTION
##
## These are the rules used to compile Perl 6 programs.
## This is just a first draft of a grammar for parsing
## Perl 6 programs, undoubtedly more rules will be added
## soon.  Much of the work is hidden in the <opparse>
## rule, which is defined in L<Perl6/parse.pir>
## and handles most expressions using a bottom-up
## parsing algorithm.  

grammar Perl6::Grammar ;


## These rules handle whitespace between comments and tokens

## 
rule ws {
    [ \# \N+
    | \s+
    | <?dot_comment> 
    | ^^ <?pod_comment> 
    ]* :::
}

rule dot_comment { \. [ \s <-[.]>*: | \# <?PGE::Text::bracketed: <({[> }

rule pod_comment {
    ^^ = [ [ cut \h*: | end [\h\N*]? ]
         | for [ \h\N+: ] \n [ \N+\n ]*: 
         | \w\N*: \n .*? \n = [ cut \h*: | end [\h\N*:]? ]
         ] 
         [\n|$]
}


rule program { ^ <statement_list> <?ws> [ $ | <?syntax_error> ] }


rule statement_list { <statement> [ <?statement_end> <statement> ]* }


rule statement_end {
    <after ;> ::
    | <after \}> :: <before \s*? [ \n | \# ]>
}


## XXX: <statement_control> will likely become <%statement_control>.
## Since PGE doesn't support hashes in rules yet, we're just using
## an alternation for now.

rule statement { 
    <statement_control>
    | <expression> 
}


rule statement_control {
    <?ws>: 
    ([if|unless]) <expression> <block> 
        [ <?ws>: elsif <expression> <block> ]*
        [ <?ws>: else <block> ]?
}


rule block { <simple_block> | <pointy_sub> }


## A <simple_block> is just a statement_list inside of a pair of braces.

rule simple_block { 
    <?ws>:
    \{ 
        <?ws>: <statement_list> <?ws>: 
    [ \} | <?syntax_error> ] 
}


## XXX: This isn't the real <pointy_sub> rule -- it doesn't know
## how to parse arguments yet.  It's just here as a placeholder
## for now.

rule pointy_sub { --\> <simple_block> }


## We handle Perl 6 expressions using PGE's operator 
## precedence parser.  The tokens and sub for this are 
## defined in L<Perl6/parser.pir>.  If written as a p6rule,
## it would look something like:
##     rule expression($stop) { { $opparse.parse($/, $stop) } }

## However, we do need a special "whitespace" rule for capturing
## whitespace in expressions, because dot_comments are special.

rule expression_ws { [ \s | \# \N*:\n ] <?ws> }


## The <term> rule gets called from the operator precedence
## parser whenever it needs a term.

rule term {
    <scoped_variables>
    | <variable>
    | <block>
    | <number>
    | <integer>
    | <string_literal>
    | <version>
}


## XXX: The <scope_declarator> rule will likely become <%scope_declarator>.

rule scoped_variables {
    <scope_declarator> <?ws> <variable>
}
rule scope_declarator { [ my | our ] \b }


## The <listop> rule gets called from the operator precedence
## parser whenever it's looking for a term.  At the moment
## it primarily grabs bareword terms.
## XXX: <reserved_word> may become @reserved_word.

rule listop { <reserved_word> ::: <fail> | <ident> }

rule reserved_word { [ if | unless | while | until | for | loop ] \b }


## XXX: These are just placeholder rules for demonstration,
## they certainly need to be expanded to be more complete.

rule variable { <sigil> <name> }
rule sigil { <[$@%^]> }
rule integer { \d+ }
rule number {:i \d+ \. \d+ [ e <[+\-]>? \d+ ]? }
rule string_literal { <PGE::Text::bracketed: '"> }
rule version { v\d+ }


## The <syntax_error> rule generates a simple syntax
## error message, and displays the line number and context
## of the error.

rule syntax_error { <?die: Syntax error> }

