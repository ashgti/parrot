=head1 NAME

PIR.pod - The Grammar of languages/PIR

=head1 DESCRIPTION

This document provides a more readable grammar of languages/PIR. The actual specification
for PIR is a bit more complex. This grammar for humans does not contain error
handling and some other issues unimportant for this PIR reference.


=head1 STATUS

For a bugs and issues, see the section KNOWN ISSUES AND BUGS.

The grammar includes some constructs that *are* in the IMCC parser,
but are not implemented. An example of this is the ".global" directive.


=head1 VERSION

Version: Sunday Feb. 4th 2007.
(not a version number yet, as many improvements are to be expected at this point).


=head1 LEXICAL CONVENTIONS


=head2 PIR Directives

PIR has a number of directives. All directives start with a dot. Macro identifiers
(when using a macro, on expansion) also start with a dot (see below). Therefore,
it is important not to use any of the PIR directives as a macro identifier. The
PIR directives are:

  .arg            .invocant          .pcc_call
  .const          .lex               .pcc_end_return
  .emit           .line              .pcc_end_yield
  .end            .loadlib           .pcc_end
  .endnamespace   .local             .pcc_sub
  .eom            .meth_call         .pragma
  .get_results    .namespace         .return
  .global         .nci_call          .result
  .HLL_map        .param             .sub
  .HLL            .pcc_begin_return  .sym
  .immediate      .pcc_begin_yield   .yield
  .include        .pcc_begin


=head2 Registers

PIR has two types of registers: real registers and virtual or temporary registers.
Real registers are actual registers in the Parrot VM, and are written like:

  [S|N|I|P]n, where n is a number between 0 to, but not including, 100.

Virtual, or temporary registers are written like:

  $[S|N|I|P]n, where n is a positive integer.

Virtual registers can be thought of local variable identifiers that don't need a declaration.
This prevents you from writing C<.local> directives if you're in a hurry. Of course, it would
make the code more self-documenting if C<.local>s would be used.

=head2 Constants

An integer constant is a string of one or more digits.
Examples: 0, 42.

A floatin-point constant is a string of one or more digits, followed by a dot
and one or more digits. Examples: 1.1, 42.567.

A string constant is a single or double quoted series of characters.
Examples: 'hello world', "Parrot".

TODO: PMC constants.

=head2 Identifiers

An identifier starts with a character from [_a-zA-Z], followed by
a character from [_a-zA-Z0-9].

Examples: x, x1, _foo.


=head2 Labels

A label is an identifier with a colon attached to it.

Examples: LABEL:


=head2 Macro identifiers

A macro identifier is an identifier prefixed with an dot. A macro
identifier is used when I<expanding> the macro (on usage), not in
the macro definition.

Examples:  .Macro



=head1 GRAMMAR RULES

=head2 Compilation Units

A PIR program consists of one or more compilation units. A compilation unit
is a global, sub, constant or macro definition, or a pragma or emit block.
PIR is a line oriented language, which means that each statement ends in a
newline (indicated as "nl"). Moreover, compilation units are always separated
by a newline. Each of the different compilation units are discussed in this
document.


  program:
    compilation_unit [ nl compilation_unit ]*

  compilation_unit:
      global_def
    | sub_def
    | const_def
    | macro_def
    | pragma
    | emit

=head2 Subroutine definitions


  sub_def:
    [ ".sub" | ".pcc_sub" ] sub_id sub_pragmas nl body

  sub_id:
    identifier | string_constant

  sub_pragmas:
    sub_pragma [ ","? sub_pragma ]*


  sub_pragma:
      ":load"
    | ":init"
    | ":immediate"
    | ":main"
    | ":anon"
    | ":lex"
    | wrap_pragma
    | vtable_pragma
    | multi_pragma
    | outer_pragma

  wrap_pragma:
    ":wrap" parenthesized_string

  vtable_pragma:
    ":vtable" parenthesized_string?

  parenthesized_string:
    "(" string_constant ")"

  multi_pragma:
    ":multi" "(" multi_types? ")"

  outer_pragma:
    ":outer" "(" sub_id ")"

  multi_tyes:
    multi_type [ "," multi_type ]*

  multi_type:
      type
    | "_"
    | keylist
    | identifier
    | string_constant

  body:
    param_decl*
    labeled_pir_instr*
    ".end"

  param_decl:
    ".param"  [ [ type identifier ] | register ] get_flags? nl

  get_flags:
    [ ":slurpy"
    | ":optional"
    | ":opt_flag"
    | named_flag
    ]+

  named_flag:
    ":named" parenthesized_string?

=head3 Examples subroutine

The simplest example for a subroutine definition looks like:

	.sub foo
	# PIR instructions go here
	.end

The body of the subroutine can contain PIR instructions. The subroutine can be given
one or more flags, indicating the sub should behave in a special way. Below is a list of these
flags and their meaning:

TODO: complete this

=over 4

=item *

 :load

Indicates the sub being defined

=item *

 :init

Indicates the sub being defined

=item *

 :immediate

Indicates the sub being defined

=item *

 :main

Indicates that the sub being defined is the entry point of the program. It can be compared to the main function in C.

=item *

 :method

Indicates the sub being defined is an instance method. The method belongs to the class whose namespace is
currently active. (so, to define a method for a class 'Foo', the 'Foo' namespace should be currently active).

=item *

 :vtable or vtable('x')

Indicates the sub being defined replaces a vtable entry. This flag can only be used when defining a method.

=item *

 :multi(int, string, num, _, pmc)

Indicates the sub being defined

=item *

 :outer('bar')

Indicates the sub being defined is lexically nested within the subroutine 'bar'.

=item *

 :anon

Indicates the sub being defined is anonymous; no symbol entry is stored into the global symbol table

=item *

 :lex

Indicates the sub being defined needs to store lexical variables. This flag is not necessary if any lexical
declarations are done (see below), the PIR compiler will figure this out by itself.

=item *

 :wrap('bar')

This flag is not (yet?) implemented in IMCC. It would indicate that this sub is I<wrapping> the sub "bar". That means
that when "bar" is invoked, this sub is called I<before> and I<after>. It is undecided yet whether this flag will
be implemented. If so, its syntax may change.

=back

The sub flags are listed after the sub name. They may be separated by a comma, but this is
not necessary. The subroutine name can also be a string instead of a bareword, as is shown in this
example:

	.sub 'foo' :load, :init :anon
	# PIR body
	.end

Parameter definitions have the following syntax:

	.sub main
	  .param int argc
	  .param pmc argv
	  .param num nParam
	  .param string sParam
	  .param $P0
	  # body
	.end

Parameter definitions may take flags as well. These flags are listed here:

=over 4

=item *

 :slurpy

=item *

 :named('x')

=item *

 :optional

Indicates the parameter being defined is optional.

=item *

 :opt_flag

This flag can be given to a parameter defined I<after> an optional parameter. During runtime,
the parameter is automatically given a value, and is I<not> passed by the caller. The value
of this parameter indicates whether the previous (optional) parameter was present.

=back

The correct order of the parameters depends on the flag they have.

=head2 PIR instructions

  labeled_pir_instr:
    label? instr nl

  labeled_pasm_instr:
    label? pasm_instr nl

  instr:
    pir_instr | pasm_instr

NOTE: the rule 'pasm_instr' is not included in this reference grammar. pasm_instr
defines the syntax for pure PASM instructions.

  pir_instr:
      local_decl
    | lexical_decl
    | const_def
    | conditional_stat
    | assignment_stat
    | open_namespace
    | close_namespace
    | return_stat
    | sub_invocation
    | macro_invocation
    | jump_stat
    | source_info



=head2 Local declarations

  local_decl:
    [ ".local" | ".sym" ] type local_id_list

  local_id_list:
    local_id [ "," local_id ]*

  local_id:
    identifier ":unique_reg"?


=head3 Examples local declarations

Local temporary variables can be declared by the directives C<.local> or C<.sym>. There is no
difference between these directives, except within macro definitions. (See Macros).

	.local int i
	.local num a, b, c
	.sym string s1, s2
	.sym pmc obj

The C<:unique_reg> flag indicates ... TODO.

=head2 Lexical declarations

  lexical_decl:
    ".lex" string_constant "," target

=head3 Example lexical declarations

The declaration

	.lex 'i', $P0

indicates that the value in $P0 is stored as a lexical variable, named by 'i'. Instead of a register,
one can also specify a local variable, like so:

	.local pmc p
	.lex 'i', p

=head2 Global definitions

  global_def:
    ".global" identifier

=head3 Example global declarations

This syntax is defined in the parser of IMCC, but its functionality is not implemented. The goal is
to allow for global definitions outside of subroutines. That way, the variable can be accessed by
all subroutines without doing a global lookup. It is unclear whether this feature will be implemented.

An example is:

	.global my_global_var


=head2 Constant definitions

  const_def:
    ".const" type identifier "=" constant_expr

=head3 Example constant definitions

	.const int answer = 42

defines an integer constant by name 'answer', giving it a value of 42.

=head2 Conditional statements

  conditional_stat:
      [ "if" | "unless" ]
    [ [ "null" target "goto" identifier ]
    | [ simple_expr [ relational_op simple_expr ]? ]
    ] "goto" identifier


=head3 Examples conditional statements

The syntax for C<if> and C<unless> statements is the same, except for the keyword itself.
Therefore the examples will use either.

	if null $P0 goto L1

Checks whether $P0 is C<null>, if it is, flow of control jumps to label L1

	unless $P0 goto L2
	unless x   goto L2
	unless 1.1 goto L2

Unless $P0, x or 1.1 are 'true', flow of control jumps to L2. When the argument is a PMC (like
the first example), true-ness depends on the PMC itself. For instance, in some languages, the number
0 is defined as 'true', in others it is considered 'false' (like C).

	if x < y goto L1
	if y != z  goto L1

are examples that check for the logical expression after C<if>. Any of the I<relational> operators may
be used here.


=head2 Branching statements

  jump_stat:
    "goto" identifier

=head3 Examples branching statements

	goto MyLabel

The program will continue running at label 'MyLabel:'.


=head2 Operators

  relational_op:
      "=="
    | "!="
    | "<="
    | "<"
    | <"="
    | <""

  binary_op:
      "+"
    | "-"
    | "/"
    | "**"
    | "*"
    | "%"
    | "<<"
    | <">>"
    | <">"
    | "&&"
    | "||"
    | "~~"
    | "|"
    | "&"
    | "~"
    | "."


  assign_op:
      "+="
    | "-="
    | "/="
    | "%="
    | "*="
    | ".="
    | "&="
    | "|="
    | "~="
    | "<<="
    | <">="
    | <">>="

  unary_op:
      "!"
    | "-"
    | "~"

=head2 Expressions

  expression:
      simple_expr
    | simple_expr binary_op simple_expr
    | unary_op simple_expr

  simple_expr:
      float_constant
    | int_constant
    | string_constant
    | target

=head3 Example expressions

	42
	42 + x
	1.1 / 0.1
	"hello" . "world"
	str1 . str2
	-100
	~obj
	!isSomething

Arithmetic operators are only allowed on floating-point numbers and integer values (or variables of that type).
Likewise, string concatenation (".") is only allowed on strings. These checks are B<not> done by the PIR parser.

=head2 Assignments


  assignment_stat:
      target "=" short_sub_call
    | target "=" target keylist
    | target "=" expression
    | target "=" "new" [ int_constant | string_constant | macro_id ]
    | target "=" "new" keylist
    | target "=" "find_type" [ string_constant | string_reg | id ]
    | target "=" heredoc
    | target "=" "global" <string_constant
    | target assign_op simple_expr
    | target keylist "=" simple_expr
    | "global" string_constant "=" target
    | result_var_list "=" short_sub_call

  keylist:
    "[" keys "]"

  keys:
    key [ sep key ]*

  sep:
    "," | ";"

  key:
      simple_expr
    | simple_expr ".."
    | ".." simple_expr
    | simple_expr ".." simple_expr


=head3 Examples assignment statements

	$P0 = foo()
	$I0 = $P0[1]
	$I0 = $P0[12.34]
	$I0 = $P0["Hello"]
	$P0 = new 42 # but this is really not very clear, better use identifiers

	$S0 = <<'HELLO'
	...
	HELLO

	$P0 = global "X"
	global "X" = $P0

	.local int a, b, c
	(a, b, c) = foo()

=head2 Heredoc

NOTE: the heredoc rules are not complete or tested. Some work is required here.

  heredoc:
    "<<" string_constant nl
    heredoc_string
    heredoc_label

  heredoc_label:
    ^^ identifier

  heredoc_string:
    [ \N | \n ]*


=head3 Example Heredoc

	.local string str
	str = <<'ENDOFSTRING'
	  this text
	       is stored in the
	             variable
	    named 'str'. Whitespace and newlines
	  are                  stored as well.
	ENDOFSTRING

Note that the Heredoc identifier should be at the beginning of the line, no
whitespace in front of it is allowed. Printing C<str> would print:

    this text
	       is stored in the
	             variable
	    named 'str'. Whitespace and newlines
	  are                  stored as well.


=head2 Invoking subroutines and methods

  sub_invocation:
    long_sub_call | short_sub_call

  long_sub_call:
    ".pcc_begin" nl
    arguments
    [ method_call | non_method_call] target nl
    [ local_decl nl ]*
    result_values
    ".pcc_end"

  non_method_call:
    ".pcc_call" | ".nci_call"

  method_call:
    ".invocant" target nl
    ".meth_call"

  parenthesized_args:
    "(" args ")"

  args:
    arg [ "," arg ]

  arg:
    [ float_constant
    | int_constant
    | string_constant [ "=>" target ]?
    | target
    ]
    set_flags?


  arguments:
    [ ".arg" simple_expr set_flags? nl ]*

  result_values:
    [ ".result" target get_flags? nl ]*

  set_flags:
    [ ":flat"
    | named_flag
    ]+


=head3 Example long subroutine call

The long subroutine call syntax is very suitable to be generated by a language compiler
targeting Parrot. Its syntax is rather verbose, but easy to read. The minimal invocation
looks like this:

	.pcc_begin
	.pcc_call $P0
	.pcc_end

Invoking instance methods is a simple variation:

	.pcc_begin
	.invocant $P0
	.meth_call $P1
	.pcc_end

Passing parameters and retrieving return values is done like this:

	.pcc_begin
	.arg 42
	.pcc_call $P0
	.local int res
	.result res
	.pcc_end

Parameters can take flags:

The Native Calling Interface (NCI) allows for calling C routines, in order to talk to the world
outside of Parrot. Its syntax is a slight variation:

	.pcc_begin
	.nci_call $P0
	.pcc_end


=head2 Short subroutine invocation

  short_sub_call:
    invocant? [ target | string_constant ] parenthesized_args

  invocant:
    [ target"." | target "->" ]


=head3 Example short subroutine call

The short subroutine call syntax is useful when manually writing PIR code.
Its simplest form is:

	foo()

Or a method call:

	obj.'toString'() # call the method 'toString'
	obj.x() # call the method whose name is stored in C<x>

IMCC also allows the "->" instead of a dot, to make it readable for C++ programmers:

	obj->'toString'()


=head2 Return values from subroutines

  result_var_list:
    "(" result_vars ")"

  result_vars:
    result_var [ "," result_var ]*

  result_var:
    target get_flags?

  return_stat:
      long_return_stat
    | short_return_stat
    | long_yield_stat
    | short_yield_stat
    | tail_call

  long_return_stat:
    ".pcc_begin_return" nl
    return_directive*
    ".pcc_end_return"

  return_directive:
    ".return" simple_expr set_flags? nl

=head3 Example long return statement

	.pcc_begin_return
	.return 42
	.return $P0 :flat
	.pcc_end_return

=head2 Short return statement

  short_return_stat:
    ".return" parenthesized_args

=head3 Example short return statement

	.return(myVar, "hello", 2.76, 3.14);


=head2 Long yield statements

  long_yield_stat:
    ".pcc_begin_yield" nl
    return_directive*
    ".pcc_end_yield"

=head3 Example long yield statement

	.sub foo
	  .pcc_begin_yield
	  .return 42
	  .pcc_end_yield

	  # and later in the sub, one could return another value:

	  .pcc_begin_yield
	  .return 43
	  .pcc_end_yield
	.end

	# when invoking twice:
	foo() # returns 42
	foo() # returns 43


=head2 Short yield statements

  short_yield_stat:
    ".yield" parenthesized_args

=head3 Example short yield statement

	.yield("hello", 42)

=head2 Tail calls

  tail_call:
    ".return" short_sub_call

=head3 Example tail call

	.return foo()

Returns the return values from C<foo>. This is implemented by a tail call, which is more efficient than:

	.local pmc results = foo()
	.return(results)

=head2 Symbol namespaces

  open_namespace:
    ".namespace" identifier

  close_namespace:
    ".endnamespace" identifier


=head3 Example open/close namespaces

	.sub main
	  .local int x
	  x = 42
	  say x
	  .namespace NESTED
	  .local int x
	  x = 43
	  say x
	  .endnamespace NESTED
	  say x
	.end

Will print:

	42
	43
	42

=head2 Emit blocks

  emit:
    ".emit" nl
    labeled_pasm_instr*
    ".eom"

=head3 Example Emit block

An emit block only allows PASM instructions,
not PIR instructions.


=head2 Macros

  macro_def:
    ".macro" identifier macro_parameters? nl
    macro_body

  macro_parameters:
    "(" id_list? ")"

  macro_body:
    .*?
    ".endm" nl

  macro_invocation:
    macro_id parenthesized_args?

=head3 Example Macros

NOTE: the macro definition is not complete, and untested.
This should be fixed. For now, all characters up to but not
including ".endm" are 'matched'.

=head2 PIR Pragmas

  pragma:
      include
    | new_operators
    | loadlib
    | namespace
    | hll_mapping
    | hll_specifier
    | source_info


  include:
    ".include" string_constant

  new_operators:
    ".pragma" "n_operators" int_constant

  loadlib:
    ".loadlib" string_constant

  namespace:
    ".namespace" [ "[" namespace_id "]" ]?

  hll_specifier:
    ".HLL" string_constant "," string_constant

  hll_mapping:
    ".HLL_map" int_constant "," int_constant

  namespace_id:
    string_constant [ ";" string_constant ]*

  source_info:
    ".line" int_constant [ "," string_constant ]?

  id_list:
    identifier [ "," identifier ]*

=head3 Examples pragmas

	.include "myLib.pir"

includes the source from the file "myLib.pir" at the point of this directive.

	.pragma n_operators 1

makes Parrot automatically create new PMCs when using arithmetic operators, like:

	$P1 = new .Integer
	$P2 = new .Integer
	$P1 = 42
	$P2 = 43
	$P0 = $P1 * $P2
	# now, $P0 is automatically assigned a newly created PMC.


	.line 100
	.line 100, "myfile.pir"

NOTE: currently, the line directive is implemented in IMCC as #line.
See the PROPOSALS document for more information on this.


	.namespace ['Foo'] # namespace Foo
	.namespace ['Object';'Foo'] # nested namespace
	
	.namespace # no [ id ] means the root namespace is activated

opens the namespace 'Foo'. When doing Object Oriented programming, this would indicate
that sub or method definitions belong to the class 'Foo'. Of course, you can also define
namespaces without doing OO-programming.

Please note that this C<.namespace> directive is I<different> from the C<.namespace> directive
that is used within subroutines.

	.HLL "Lua", "lua_group"
	
is an example of specifying the High Level Language (HLL) for which the PIR is being generated.
It is a shortcut for setting the namespace to 'Lua', and for loading the PMCs in the lua_group library.

	.HLL_map .Integer, .LuaNumber
	
is a way of telling Parrot, that whenever an Integer is created somewhere in the system (C code), instead
a LuaNumber object is created.

	.loadlib "myLib"
	
is a shortcut for telling Parrot that the library "myLib" should be loaded when running the program. In fact,
it is a shortcut for:

	.sub _load :load :anon
		loadlib "myLib"
	.end
	
TODO: check flags and syntax for this.

=head2 Tokens, types and targets

  string_constant:
    charset_specifier?  quoted_string

  charset_specifier:
      "ascii:"
    | "binary:"
    | "unicode:"
    | "iso-8859-1:"

  type:
      "int"
    | "num"
    | "pmc"
    | "object"
    | "string"
    | "Array"
    | "Hash"

  target:
    identifier | register

=head3 Notes on Tokens, types and targets

A string constant can be written like:

	"Hello world"

but if desirable, the character set can be specified:

	unicode:"Hello world"

TODO: is it "unicode"? or is it UTF8 or something?

IMCC currently allows identifiers to be used as types. During the parse, the identifier
is checked whether it is a defined class. The built-in types int, num, pmc and string are
always available.

A C<target> is something that can be assigned to, it is an L-value (but of course may be read just like
an R-value). It is either an identifier or a register.


=head1 AUTHOR

Klaas-Jan Stol [parrotcode@gmail.com]

=head1 KNOWN ISSUES AND BUGS

Some work should be done on:

=over 4

=item *

Macro parsing

=item *

Heredoc parsing

=item *

The rule 'type' does currently not include custom types (user defined).
Probably it needs an alternative "identifier". Not sure yet at this point.

=item *

Clean up grammar, remove never-used features.

=item *

Test. A lot.

Bugs or improvements may be sent to the author, and of course greatly
appreciated. Moreover, if you find any missing constructs that are in
IMCC, indications of these would be appreciated as well.

=back

=cut

