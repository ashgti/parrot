
grammar ASTGrammar is TGE::Grammar;


# past (ROOT)
#
# Transform the 'program' rule into a PAST::Block.
#
transform past (ROOT) :language('PIR') { 
    .local pmc past
		past = new 'PAST::Block'
		past.'init'('node'=>node, 'name'=>'anon')            
        
    .local pmc childnode, childpast
    childnode = node['program']
    childpast = tree.'get'('past', childnode, 'PIRGrammar::program')
		past.'push'(childpast)    
    .return (past)  
}

# past (PIRGrammar::program)
#
# Store each of the compilation units into a PAST::Stmts node.
#
transform past (PIRGrammar::program) :language('PIR') {
    .local pmc past
    past = new 'PAST::Stmts'
    past.'init'('node'=>node)

    .local pmc iter
    $P0 = node['compilation_unit']
    if null $P0 goto iter_end
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'PIRGrammar::compilation_unit')
    past.'push'(cpast)
    goto iter_loop
  iter_end:
    .return (past)
}

# past (PIRGrammar::compilation_unit)
#
# Call the appropiate transform rule depending on the type of compilation unit.
#
transform past (PIRGrammar::compilation_unit) :language('PIR') {
  global_def:
    $P0 = node['global_def']
    if null $P0 goto sub_def
    .return tree.'get'('past', $P0, 'PIRGrammar::global_def')
  sub_def:
    $P0 = node['sub_def']
    if null $P0 goto const_def
    .return tree.'get'('past', $P0, 'PIRGrammar::sub_def')
  const_def:
    $P0 = node['const_def']
    if null $P0 goto macro_def
    .return tree.'get'('past', $P0, 'PIRGrammar::const_def')
  macro_def:
    $P0 = node['macro_def']
    if null $P0 goto pragma
    .return tree.'get'('past', $P0, 'PIRGrammar::macro_def')
  pragma:
  	$P0 = node['pragma']
    if null $P0 goto emit
    .return tree.'get'('past', $P0, 'PIRGrammar::pragma')
  emit:  
    $P0 = node['emit']
    if null $P0 goto const_def
    .return tree.'get'('past', $P0, 'PIRGrammar::emit') 
}

transform past (PIRGrammar::global_def) :language('PIR') {

}

# past (PIRGrammar::sub_def)
#
# Transform a sub_def into a PAST::Block node.
#
transform past (PIRGrammar::sub_def) :language('PIR') {		
		printerr "subdef\n"
		.local pmc result
  	result = new 'PAST::Block'
  	.local string name
    name = node['sub_id']
    result.'init'('node'=>node, 'name'=> name, 'blocktype'=>'sub')
    .local pmc child
    
    # TODO: parameters
    
    $P1 = node['body']
    child = tree.'get'('past', $P1, 'PIRGrammar::body')
    result.'push'(child)
    .return(result)
}

transform past (PIRGrammar::const_def) :language('PIR') {
	.local pmc past
	past = new 'PASM::Op'
	# FIX:
	past.'init'('node'=>node, 'pasttype'=>'pirop', 'pirop'=>'const')	
	.return (past)
}

transform past (PIRGrammar::macro_def) :language('PIR') {

}

transform past (PIRGrammar::pragma_def) :language('PIR') {
	.local pmc past
	past = new 'PASM::Op'	
	past.'init'('node'=>node, 'pasttype'=>'pirop', 'pirop'=>'.pragma')	
	.return (past)
}

transform past (PIRGrammar::emit) :language('PIR') {
	
}

#transform past (PIRGrammar::param) :language('PIR') {
#	
#}

# past (PIRGrammar::body)
#
# Store each of the instructions in a body node in a PAST::Stmts node.
#
transform past (PIRGrammar::body) :language('PIR') {
		printerr "body\n"
    .local pmc past
    past = new 'PAST::Stmts'
    past.'init'('node'=>node)		
		
    .local pmc iter
    $P0 = node['labeled_pir_instr']
    if null $P0 goto iter_end
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'PIRGrammar::labeled_pir_instr')
    past.'push'(cpast)
    goto iter_loop
  iter_end:
    .return (past)	
}


  
transform past (PIRGrammar::local_decl) :language('PIR') {
	
}

transform past (PIRGrammar::lexical_decl) :language('PIR') {
	
}

transform past (PIRGrammar::const_def) :language('PIR') {
	
}

transform past (PIRGrammar::assignment_stat) :language('PIR') {
		
}

transform past (PIRGrammar::open_namespace) :language('PIR') {
	.local pmc past
	past = new 'PASM::Op'	
	past.'init'('node'=>node, 'pasttype'=>'pirop', 'pirop'=>'.namespace')	
	.return (past)
}

transform past (PIRGrammar::close_namespace) :language('PIR') {
	.local pmc past
	past = new 'PASM::Op'
	past.'init'('node'=>node, 'pasttype'=>'pirop', 'pirop'=>'.endnamespace')	
	.return (past)
}
  
transform past (PIRGrammar::return_stat) :language('PIR') {
	
}

transform past (PIRGrammar::sub_invocation) :language('PIR') {
	
}

transform past (PIRGrammar::macro_invocation) :language('PIR') {
	
}

transform past (PIRGrammar::jump_stat) :language('PIR') {
	.local pmc past
	past = new 'PASM::Op'
	past.'init'('node'=>node, 'pasttype'=>'pirop', 'pirop'=>'goto')	
	.return (past)
}

transform past (PIRGrammar::source_info) :language('PIR') {
	
}


transform past (PIRGrammar::instr) :language('PIR') {
		printerr "instr\n"
		$P0 = node['pir_instr']
		if null $P0 goto pasm_instr
	pir_instr:
		.return tree.'get'('past', $P0, 'PIRGrammar::pir_instr')
	pasm_instr:	
		$P0 = node['pasm_instr']
		.return tree.'get'('past', $P0, 'PIRGrammar::pasm_instr')
}

transform past (PIRGrammar::labeled_pir_instr) :language('PIR') {
		$P0 = node['instr']
		if null $P0 goto end
		.return tree.'get'('past', $P0, 'PIRGrammar::instr')
	end:
}


# past (PIRGrammar::pir_instr)
#
# Return the transformed tree of a PIR instruction.
#
transform past (PIRGrammar::pir_instr) :language('PIR') {
	local_decl:
		$P0 = node['local_decl']
		if null $P0 goto lexical_decl
		.return tree.'get'('past', $P0, 'PIRGrammar::local_decl')
	lexical_decl:
		$P0 = node['local_decl']
		if null $P0 goto const_def
		.return tree.'get'('past', $P0, 'PIRGrammar::lexical_decl')
	const_def:
		$P0 = node['const_def']
		if null $P0 goto assignment_stat
		.return tree.'get'('past', $P0, 'PIRGrammar::const_def')		
	assignment_stat:
		$P0 = node['assignment_stat']
		if null $P0 goto open_namespace
		.return tree.'get'('past', $P0, 'PIRGrammar::assignment_stat')
	open_namespace:
		$P0 = node['open_namespace']
		if null $P0 goto close_namespace
		.return tree.'get'('past', $P0, 'PIRGrammar::open_namespace')
	close_namespace:
		$P0 = node['close_namespace']
		if null $P0 goto return_stat
		.return tree.'get'('past', $P0, 'PIRGrammar::close_namespace')	
	return_stat:
		$P0 = node['return_stat']
		if null $P0 goto sub_invocation
		.return tree.'get'('past', $P0, 'PIRGrammar::return_stat')		
	sub_invocation:
		$P0 = node['sub_invocation']
		if null $P0 goto macro_invocation
		.return tree.'get'('past', $P0, 'PIRGrammar::sub_invocation')
	macro_invocation:
		$P0 = node['assignment_stat']
		if null $P0 goto lexical_decl
		.return tree.'get'('past', $P0, 'PIRGrammar::macro_invocation')
}


# past (PIRGrammar::pasm_instr)
#
# Create a PAST::Op node that represents the PASM instruction
#
transform past (PIRGrammar::pasm_instr) :language('PIR') {
	.local pmc past	
	past = new 'PAST::Op'
	# FIX: set the correct pirop
	past.'init'('node'=>node, 'pasttype'=>'pirop', 'pirop'=>'XX')
	.return (past)
}



transform past (PIRGrammar::simple_expr) :language('PIR') {   
		.local pmc past
  int_constant:
   	$P0 = node['int_constant']
    if null $P0 goto float_constant
    past = new 'PAST::Val'
    past.'init'('node'=>node, 'vtype'=>'.Integer', 'name'=>node, 'ctype'=>'i+')
    .return (past)
  float_constant:
  	$P0 = node['float_constant']
    if null $P0 goto string_constant
    past = new 'PAST::Val'
    past.'init'('node'=>node, 'vtype'=>'.Float', 'name'=>node, 'ctype'=>'n+')
    .return (past)    
  string_constant:
  	$P0 = node['string_constant']
    if null $P0 goto target
		.return tree.'get'('past', $P0, 'PIRGrammar::string_constant')
  target:    
    $P0 = node['target']
    .return tree.'get'('past', $P0, 'PIRGrammar::target')     
}

transform past (PIRGrammar::target) :language('PIR') {

}


transform past (PIRGrammar::string_constant) :language('PIR') {
	stringsingle:
		$P0 = node['stringsingle']
		if null $P0 goto stringdouble
		.return tree.'get'('past', $P0, 'PIRGrammar::stringsingle')
 	stringdouble:
 		$P0 = node['stringsingle']		
		.return tree.'get'('past', $P0, 'PIRGrammar::stringsingle')
}

transform past (PIRGrammar::stringdouble) :language('PIR') {
    .local pmc result
    result = new 'PAST::Val'
    
    .local string value
    # Check if this is a string match
    $I0 = defined node["PGE::Text::bracketed"]
    if $I0 goto bracketed_value
    value = node
    goto no_bracketed_value
  bracketed_value:
    value = node["PGE::Text::bracketed"]
  no_bracketed_value:

    # NOTE: Will have to come back and handle interpolation properly.
    # Currently have no way to distinguish between single quoted and
    # double quoted strings.
    result.'init'('node'=>node, 'vtype'=>'.String', 'name'=>value)
    .return (result)
}

transform past (PIRGrammar::stringsingle) :language('PIR') {
    .local pmc result
    result = new 'PAST::Val'

    .local string value
    # Check if this is a string match
    $I0 = defined node["PGE::Text::bracketed"]
    if $I0 goto bracketed_value
    value = node
    goto no_bracketed_value
  bracketed_value:
    value = node["PGE::Text::bracketed"]
  no_bracketed_value:

    result.'init'('node'=>node, 'vtype'=>'.String', 'name'=>value)
    .return (result)
}
