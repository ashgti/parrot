=head1 NAME

pir.pg - A PIR grammar for PGE.

TODO:

 1. fix Heredocs parsing
 2. Test and fix things

=cut


grammar PIR::Grammar;


token TOP {
    ^ <program> [ $ | <syntax_error: end of file expected> ]
}

rule program {
    <?NL>*
    <compilation_unit>
    [ <?NL> <compilation_unit> ]*
    [ <?NL> | <warning: no newline at end of file> ]
}

token compilation_unit {
    | <expansion>
    | <sub_def>
    | <const_def>
    | <pragma>
    | <emit>
}


=head2 Sub defs, sub pragmas, sub body and parameters

=cut

rule sub_def {
    <'.sub'>
    <sub_id>
    <sub_pragmas>?
    <?nl>
    <param_decl>*
    <labeled_pir_instr>*
    [ <'.end'> | <syntax_error: '.end' expected to close method/sub body> ]
}

rule sub_id {
    | <IDENT> 
    | <STRING_CONST>
    | <syntax_error: subroutine identifier expected>
}

=head3 sub_pragmas

=cut

rule sub_pragmas {
    <sub_pragma>*
}

rule sub_pragma {
    | <':load'>
    | <':init'>
    | <':immediate'>
    | <':postcomp'>
    | <':main'>
    | <':anon'>
    | <':lex'>
    | <vtable_pragma>
    | <multi_pragma>
    | <outer_pragma>
}

rule vtable_pragma {
    <':vtable'> <parenthesized_string>?
}

rule parenthesized_string {
    <'('>
    <string_constant>
    <?right_paren>
}

rule multi_pragma {
    <':multi'>
    <?left_paren>
    <multi_types>?
    <?right_paren>
}

rule left_paren {
    <'('> | <syntax_error: '(' expected>
}

rule right_paren {
    <')'> | <syntax_error: ')' expected>
}

rule outer_pragma {
    <':outer'>
    <?left_paren>
    <sub_id>
    <?right_paren>
}

rule multi_types {
    <multi_type> [ <','> <multi_type> ]*
}

rule multi_type {
    | <type>
    | <'_'>
    | <keylist>
    | <IDENT>
    | <STRING_CONST>
}

rule param_decl {
    <'.param'>
    [ [ <type> <id> ]
    | <REGISTER>
    | <syntax_error: parameter type or register expected>
    ]
    [ <get_flags> | <':unique_reg'> ]*
    <?nl>
}





=head2 PIR instructions

=cut

rule labeled_pir_instr {
    [ <label> <instr>?
    | <instr>
    ]
    <?nl>
}

rule labeled_pasm_instr {
    [ <label> <pasm_instr>?
    | <pasm_instr>
    ]
    <?nl>
}

rule instr {
    | <pir_instr> 
    | <pasm_instr>
}

token pir_instr {
    | <local_decl>
    | <lexical_decl>
    | <const_def>
    | <globalconst_def>
    | <conditional_stat>
    | <assignment_stat>
    | <open_namespace>
    | <close_namespace>
    | <return_stat>
    | <sub_invocation>
    | <macro_invocation>
    | <goto_stat>
    | <source_info>
}

rule macro_invocation {
    <macro_id> <parenthesized_args>?
}


=head2 Local declarations

Local declarations can be done using C<.local> in normal context.
TODO: how to declare locals in a macro? this needs to be fixed.

=cut

rule local_decl {
    <'.local'>
    [ <type> | <syntax_error: type for local symbol expected> ]
    <local_id_list>
}

rule local_id_list {
    <local_id> [ <','> <local_id> ]*
}

rule local_id {
    <id> <local_flag>?
}

token local_flag {
    <':unique_reg'>
}

rule lexical_decl {
    <'.lex'>
    <string_constant>
    <?comma>
    <target1>
}

rule comma {
    <','> | <syntax_error: ',' expected>
}


rule target1 {
    <target> | <syntax_error: register or identifier expected>
}

=head2 Const definition

Const definitions, a check is done for the constant type and the type of the constant value.

=cut

rule const_def {
    <'.const'> <const_def_tail>
}

rule globalconst_def {
    <'.globalconst'> <const_def_tail>
}

rule const_def_tail {
    | <'int'>    <const_assign> <int_constant>
    | <'num'>    <const_assign> <float_constant>
    | <'pmc'>    <const_assign> <string_constant> 
    | <'string'> <const_assign> <string_constant> 
    | <syntax_error: type expected for constant>
}

rule const_assign {
    <id>
    <?assign_token>
}

rule assign_token {
    <'='> | <syntax_error: '=' expected>
}

rule conditional_stat {
    [ <'if'> 
    | <'unless'> 
    ]
    <conditional_expr>
    <goto_stat>
}

token label_identifier {
    | <IDENT>
    | <pasm_instr>
}

rule conditional_expr {
    | <'null'> <target>
    | <simple_expr> [ <relational_operator> <simple_expr> ]?
}

rule goto_stat {
    <'goto'> [ <label_identifier> | <syntax_error: label expected after 'goto'> ]
}


token relational_operator {
    <'=='> | <'!='> | <'<='> | <'<'> | <'>='> | <'>'>
}

token binary_operator {
    | <'+'>  | <'-'>  | <'/'>  | <'**'> | <'*'> | <'%'> | <'<<'> | <'>>>'>
    | <'>>'> | <'&&'> | <'||'> | <'~~'> | <'|'> | <'&'> | <'~'>  | <'.'>
}

token assign_operator {
    | <'+='> | <'-='> | <'/='> | <'%='>  | <'*='>  | <'.='>
    | <'&='> | <'|='> | <'~='> | <'<<='> | <'>>='> | <'>>>='>
}

token unary_operator {
    <'!'> | <'-'> | <'~'>
}

rule expression {
    | <simple_expr> [ <binary_operator> <simple_expr> ]?
    | <unary_operator> <simple_expr>
}

token simple_expr {
    | <constant>
    | <target>
}


rule keylist {
    <'['>
    <key> [ <separator> <key> ]*
    <right_bracket>
}

token separator {
    | <','>
    | <';'>
}

rule key { 
    | <simple_expr> <'..'> <simple_expr>
    | <simple_expr> <'..'> 
    | <simple_expr>
    | <'..'> <simple_expr>
}

#rule assignment_stat {
#    | <target> <'='> <short_sub_call>
#    | <target> <'='> <target> <keylist>
#    | <target> <'='> <expression>
#    | <target> <'='> <pasm_instruction> \N*
#    #| <target> <'='> <pasm_op_1> <simple_expr>
#    #| <target> <'='> <pasm_op_2> <simple_expr> \, <simple_expr>
#    | <target> <'='> <'new'> <string_constant>
#    | <target> <'='> <'new'> <keylist>
#    | <target> <'='> <'find_type'> [ <string_constant> | <string_reg> | <IDENT> ]
#    | <target> <'='> <heredoc>
#    | <target> <assign_operator> <simple_expr>
#    | <target> <keylist> <'='> <simple_expr>
#    | <result_var_list>
#      [ <'='> | <syntax_error: '=' expected> ]
#      <short_sub_call>
#}


rule assignment_stat {
    | <target> <'='> <rhs>
    | <target> <assign_operator> <simple_expr>
    | <target> <keylist> <'='> <simple_expr>
    | <result_var_list> <'='> <short_sub_call>
}

rule rhs {
    | <short_sub_call>
    | <target> <keylist>
    | <expression>
    | <pasm_instruction> \N*
    | <heredoc>
    | <'new'> [ <STRING_CONST> | <keylist> ]
}



# pasm ops that take 1 argument
#
#rule pasm_op_1 {
#    clone
#  | compreg
#  | defined
#  | assign
#  | addr
#  | istrue
#  | isfalse
#  | isnull
#  #| others
#}
#
## pasm ops that take 2 arguments
##
#rule pasm_op_2 {
#    issame
#  | isntsame
#}
#

rule heredoc {
    <'<<'>
    <string_constant>
    <?nl>
    <heredoc_string>
    [ <heredoc_label> | <syntax_error: heredoc label expected> ]
}

token heredoc_label {
    [ ^^ | <syntax_error: no whitespace allowed in front of a heredoc label> ]
    <IDENT>
    [ $$ | <syntax_error: no whitespace allowed after a heredoc> ]
}

# fix this:
rule heredoc_string {
    [ \N | \n ]*
}

rule long_sub_call {
    <'.pcc_begin'>
    <?nl>
    <arguments>
    [ 
      [ <'.pcc_call'> 
      | <'.nci_call'> 
      ]
    | [ <invocant> <'.meth_call'> ]
    ]
    [ <target> | <syntax_error: IDENT or register expected that holds the sub object> ]
    <?nl>
    [ <local_decl> <?nl> ]*
    <result_values>
    [ <'.pcc_end'>  | <syntax_error: '.pcc_end' expected> ]
}

rule invocant {
    <'.invocant'> <target> <?nl>
}

#
# in case of a method call, these options are allowed:
# - foo.bar()
# - foo. bar()
# - foo .bar()
#
# where the method ('bar') can also be a quoted string.
# it's important to recognize that the dot can NOT be written as
# a separate token, it must be glued to either the invocant or the method.
# otherwise it's recognized as a concatentation.
#
rule short_sub_call {
    [
      [ <target>\.]?                   # optional invocant
      [ <target> | <STRING_CONST> ] # method or sub name/IDENT
    |
      <target> <method>
    ]
    <parenthesized_args>             # sub args
    <process_heredocs>               # process the list of heredoc labels, if any
    <clear_heredocs>
}

token method {
    | \.<target>
    | \.<STRING_CONST>
}

rule sub_invocation {
    | <long_sub_call> 
    | <short_sub_call>
}

rule result_var_list {
    <'('>
    [ 
      <result_var>
      [ <','> 
        [ <result_var> | <syntax_error: target to store result expected after ','> ]
      ]*
    ]?
    <right_paren>
}

rule result_var {
    <target> <get_flags>?
}

rule parenthesized_args {
    <'('>
    [
      <arg>
      [ <','>
        [ <arg> | <syntax_error: argument expected after ','> ]
      ]*
    ]?
    <right_paren>
}

rule arg {
    [ <FLOAT_CONST>
    | <INT_CONST>
    | <STRING_CONST>
      [ <'=>'>
        [ <target> | <syntax_error: target for named argument expected> ]
      ]?
    | <target>
    | <heredoc_id>
    ] <set_flags>?
}

token heredoc_id {
    <'<<'> <string_constant> <store_heredoc_label: $1>
}

rule heredoc_label {
    .* ^^ <ident> $$
}

rule arguments {
    [ <'.arg'>
      [ <simple_expr> | <syntax_error: argument expression expected> ]
      <set_flags>?
      <?nl>
    ]*
}

rule result_values {
    [ <'.result'>
      [ <target> | <syntax_error: target expected to hold the result> ]
      <get_flags>?
      <?nl>
    ]*
}

rule set_flags {
    [ <':flat'> | <named_flag> ]+
}

rule get_flags {
    [ <':slurpy'>
    | <':optional'>
    | <':opt_flag'>
    | <named_flag>
    ]+
}

rule named_flag {
    <':named'> <parenthesized_string>?
}

token return_stat {
    | <long_return_stat>
    | <short_return_stat>
    | <long_yield_stat>
    | <short_yield_stat>
    | <tail_call>
}

rule long_return_stat {
    <'.pcc_begin_return'> <?nl>
    [ <'.return'> <return_value> ]*
    [ <'.pcc_end_return'> | <syntax_error: '.pcc_end_return' expected> ]
}

rule short_return_stat {
    <'.return'> <parenthesized_args>
}

rule long_yield_stat {
    <'.pcc_begin_yield'> <?nl>
    [ <'.yield'> <return_value> ]*
    [ <'.pcc_end_yield'> | <syntax_error: '.pcc_end_yield' expected> ]
}


rule return_value {
    [ <simple_expr> | <syntax_error: simple expression expected> ]
    <set_flags>?
    <?nl>
}

rule short_yield_stat {
    <'.yield'> <parenthesized_args>
}

rule tail_call {
    <'.return'> <short_sub_call>
}

rule open_namespace {
    <'.namespace'> <id>
}

rule close_namespace {
    <'.endnamespace'> <id>
}

rule emit {
    <'.emit'>
    <?nl>
    <labeled_pasm_instr>*
    [ <'.eom'>     | <syntax_error: '.eom' expected> ]
}

rule macro_def {
    <'.macro'>
    <id>
    <macro_parameters>?
    <?nl>
    <macro_body>
}

rule macro_parameters {
    <'('>
    <id_list>?
    <?right_paren>
}

=head2 Macro body

In order to be able to parse macro identifiers, before
the macro body is parsed, some rules are redefined.
After parsing the macro body, they are restored.

=cut

regex macro_body {
    <init_macro_rules>
    <labeled_pir_instr>*
    <'.endm'>
    <close_macro_rules>
}

token expansion {
    | <macro_def>
    | <include>
    | <pasm_constant>
}

rule pasm_constant {
    <'.constant'> <IDENT> 
    [ <pasm_register> 
    | <constant> 
    ]
}

token constant {
    | <FLOAT_CONST>
    | <INT_CONST>
    | <STRING_CONST>
}


# only a PASM register is allowed for pasm_constant
#
token pasm_register {
    [P|I|N|S]\d\d?
}

=head2 Pragmas

=cut

token pragma {
    | <new_operators>
    | <loadlib>
    | <namespace>
    | <hll_mapping>
    | <hll_specifier>
    | <source_info>
}

rule include {
    <'.include'> <string_constant>
}

rule new_operators {
    <'.pragma'> <'n_operators'> <int_constant>
}

rule loadlib {
    <'.loadlib'> <string_constant>
}

rule namespace {
    <'.namespace'>
    [ <'['>
      [ <namespace_id>    | <syntax_error: namespace identifier expected> ]
      <right_bracket>
    ]?
}

rule right_bracket {
    <']'> | <syntax_error: ']' expected>
}

rule hll_specifier {
    <'.HLL'>
    <string_constant>
    <?comma>
    <string_constant>
}

rule hll_mapping {
    <'.HLL_map'>
    <string_constant>
    <?comma>
    <string_constant>
}

rule namespace_id {
    <STRING_CONST>
    [ <';'>
      <string_constant>
    ]*
}

rule source_info {
    <'.line'> <int_constant> [ <','> <string_constant> ]?
}

rule id_list {
    <IDENT>
    [
      <','>
      <id>
    ]*
}



=head2 Tokens

=head3 normal_label

this is a token, because no spaces are allowed between the IDENT and the colon.

=cut

token normal_label {
    <IDENT> <':'>
}

rule macro_label {
    <MACRO_LABEL> | <syntax_error: $LABEL: expected>
}

token MACRO_LABEL {
    <'$'> <IDENT> <':'>
}

rule macro_label_decl {
    | <'.label'> <macro_label>
    | <normal_label>
}

rule int_constant {
    <INT_CONST> | <syntax_error: int constant expected>
}

token INT_CONST {
    | 0b\d+
    | 0x\d+
    | [-]? \d+
}

rule float_constant {
    <FLOAT_CONST> | <syntax_error: float constant expected>
}

token FLOAT_CONST {
    [-]? \d+\.\d+
}

rule string_constant {
    <STRING_CONST> | <syntax_error: string constant expected>
}

rule STRING_CONST { 
    [ <encoding_specifier>? <charset_specifier> ]?
    [ <stringdouble> | <stringsingle> ]
}

token encoding_specifier {
    <'utf8:'>
}

token charset_specifier {
    | <'ascii:'> 
    | <'binary:'> 
    | <'unicode:'> 
    | <'iso-8859-1:'>
}

regex stringdouble { <PGE::Text::bracketed: "> }
regex stringsingle { <PGE::Text::bracketed: '> }

token type {
    | <pir_type>
    | <macro_id>
}

token pir_type {
    | <'int'>
    | <'num'>
    | <'pmc'>
    | <'string'>
}

token normal_target {
    | <IDENT> 
    | <REGISTER>
}

=head2 Macro_target

In a macro, a target can also be a macro_id

=cut

token macro_target {
    | <IDENT> 
    | <REGISTER> 
    | <macro_id>
}

token id {
    <IDENT> | <syntax_error: identifier expected> 
}

token IDENT {
    <!keyword> \w+
}

token macro_id {
    <!keyword> \.\w+
}


rule register {
    <REGISTER> | <syntax_error: register expected>
}

token REGISTER {
    | <INT_REG>
    | <NUM_REG>
    | <PMC_REG>
    | <STRING_REG>
}

token INT_REG {
    | I\d<[\d]>?  # match I0 to I99
    | \$I\d+      # match $I0 to infinity
}

token STRING_REG {
    | S\d<[\d]>?
    | \$S\d+
}

token PMC_REG {
    | P\d<[\d]>?
    | \$P\d+
}

token NUM_REG {
    | N\d<[\d]>?
    | \$N\d+
}

token ws {
    [ [ \s & \N ]+
    | \# \N*
    | ^^ <?pod_comment>
    ]*
}


=head2 Newlines

match the set of a newline and possible indention space 1 or more times
this is necessary to be able to skip fully white lines (with some spaces/tabs in it).
However, therefore it is also necessary to put the comments skipping here as well.

=cut

token NL {
    [ \n <?ws> ]+
}

token nl {
    <NL> | <syntax_error: newline expected>
}

regex pod_comment {
    ^^ = [ [ cut \h*: | end [\h\N*]? ]
         | for [ \h\N+: ] \n [ \N+\n ]*:
         | \w\N*: \n .*? \n = [ cut \h*: | end [\h\N*:]? ]
         ]
         [\n|$]
}

=head2 Keywords

PIR directives, PASM instructions and
the Parrot datatypes (int, string, num, pmc)
are keywords, and must not be used as
identifiers.

=cut

token keyword {
    | <pir_type>
    | <pir_directive>
    | <pir_keyword>
    | <pasm_instruction> # pasm instructions may be identifiers in IMCC
}


# TODO: find out if we need to do this: I think so..
token pir_keyword {
    <'goto'>
}

=head2 PIR directives

TODO: put this in <%pir_directive> PIR directives

=cut

token pir_directive {
    | <'.arg'>
    | <'.const'>
    | <'.constant'>
    | <'.emit'>
    | <'.end'>
    | <'.endnamespace'>
    | <'.eom'>
    | <'.get_results'>
    | <'.globalconst'>
    | <'.HLL_map'>
    | <'.HLL'>
    | <'.include'>
    | <'.invocant'>
    | <'.label'>
    | <'.lex'>
    | <'.line'>
    | <'.loadlib'>
    | <'.local'>
    | <'.meth_call'>
    | <'.namespace'>
    | <'.nci_call'>
    | <'.param'>
    | <'.pcc_begin_return'>
    | <'.pcc_begin_yield'>
    | <'.pcc_begin'>
    | <'.pcc_call'>
    | <'.pcc_end_return'>
    | <'.pcc_end_yield'>
    | <'.pcc_end'>
    | <'.pcc_sub'>
    | <'.pragma'>
    | <'.return'>
    | <'.sub'>
    | <'.result'>
    | <'.yield'>
}
