/* TclArray.pmc
 *  Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the TclArray base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *     Please remove unneeded entries.
 *  References:

=head1 NAME

dynclasses/tclarray.pmc - Tcl Array PMC

=head1 DESCRIPTION

This is the Array PMC for the Tcl implementation.

=head2 Functions

=over 4

=cut

 */

#include "parrot/parrot.h"

static INTVAL dynclass_TclInt;

/*

=item C<static STRING* make_hash_key(Interp *interpreter, PMC *key)>

Returns a Parrot string for C<*key>.

=cut

*/

static STRING* make_hash_key(Interp* interpreter, PMC * key)
{
    if (key == NULL) {
        internal_exception(OUT_OF_BOUNDS,
        "Cannot use NULL key for TclArray!");
        return NULL;
    }
    return key_string(interpreter, key);
}


pmclass TclArray extends ResizablePMCArray need_ext does hash dynpmc group tcl_group {

/*

=item C<void class_init()>

Initializes variables needed by the class.

=cut

*/

    void class_init () {
        if (pass) {
            dynclass_TclInt = Parrot_PMC_typenum(INTERP,"TclInt");
        }
    }

/*

=item C<void init()>

Initializes the instance.

=cut

*/

    void init () {
        PMC_struct_val(SELF) = NULL;
        PObj_custom_mark_SET(SELF);
        new_pmc_hash(INTERP, SELF);
    }

/*

=item C<void mark()>

Marks the hash as live.

=cut

*/
    void mark () {
        if (PMC_struct_val(SELF))
            mark_hash(INTERP, PMC_struct_val(SELF));
    }

/*

=item C<INTVAL get_integer()>

Returns the size of the hash.

=cut

*/

    INTVAL get_integer () {
        return hash_size(INTERP, PMC_struct_val(SELF));
    }

/*

=item C<INTVAL get_integer_keyed(PMC *key)>

Returns the integer value for the element at C<*key>.

=cut

*/

    INTVAL get_integer_keyed (PMC* key) {
        PMC* valpmc;
        STRING* keystr = make_hash_key(INTERP, key);
        HashBucket *b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF),
                                        keystr);
        PMC* nextkey;
        if (b == NULL) {
            return 0;
        }
        nextkey = key_next(INTERP, key);
        valpmc = b->value;
        if (!nextkey)
            return VTABLE_get_integer(INTERP, valpmc);
        return VTABLE_get_integer_keyed(INTERP, valpmc, nextkey);
    }

/*

=item C<PMC *get_pmc_keyed(PMC *key)>

Returns the PMC value for the element at C<*key>.

=cut

*/

    PMC* get_pmc_keyed (PMC* key) {
        STRING* keystr = make_hash_key(INTERP, key);
        HashBucket *b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF),
                                        keystr);
        PMC* nextkey;
        if (b == NULL) {
            return NULL;
        }
        nextkey = key_next(INTERP, key);
        if (!nextkey)
            return b->value;
        return VTABLE_get_pmc_keyed(INTERP, (PMC*)b->value, nextkey);
    }

/*

=item C<void set_integer_keyed(PMC *key, INTVAL value)>

=cut

*/

    void set_integer_keyed (PMC* key, INTVAL value) {
        STRING* keystr;
        PMC* nextkey;
        PMC* box;
        PMC* val;

        if (!key) return;
        keystr = make_hash_key(INTERP, key);
        nextkey = key_next(INTERP, key);
        if (nextkey == NULL) {
            val = pmc_new(INTERP, dynclass_TclInt);
            VTABLE_set_integer_native(INTERP, val, value);
            hash_put(INTERP, PMC_struct_val(SELF), keystr, val);
            return;
        }
        box = SELF.get_pmc_keyed_str(keystr);
        if (box == NULL) {
            /* autovivify an Hash */
            box = pmc_new(INTERP, DYNSELF.type());
        }
        VTABLE_set_integer_keyed(INTERP, box, nextkey, value);
    }

/*

=item C<void set_pmc_keyed(PMC *dest_key, PMC *value)>

=cut

*/


    void set_pmc_keyed (PMC* key, PMC* value) {
        STRING* keystr;
        PMC* nextkey;
        PMC* box;

        if (!key) return;
        keystr = make_hash_key(INTERP, key);
        nextkey = key_next(INTERP, key);
        if (nextkey == NULL) {
            hash_put(INTERP, PMC_struct_val(SELF), keystr, value);
            return;
        }
        box = SELF.get_pmc_keyed_str(keystr);
        if (box == NULL) {
            /* autovivify an TclArray */
            box = pmc_new(INTERP, DYNSELF.type());
        }
        VTABLE_set_pmc_keyed(INTERP, box, nextkey, value);
    }

}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
