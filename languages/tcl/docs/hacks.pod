=head1 hacks.pod

Prodding by Matt Diephouse to generate documentation for two things:

=over 4

=item 1

Things that partcl has done that might be considered hacks - 
things that will likely impair our ability in the distant future to 
cleanly do language interoperability.

=item 2

Things that partcl hasn't done yet at all because parrot makes them
hard.

=back 

It is, of course, quite likely that said feature already exists with
a nice interface, and
was just not found by the partcl developers - If you find something
along these lines, let them know.

=head1 WORKAROUNDS

=over 4

=item subroutine meta information.

Tcl provides the ability to query subroutines about their arguments
and their code. For example:

 % proc sum {{a 2} {b 3}} {
 return [expr $a + $b]
 }
 % sum 
 5
 % info args sum
 a b
 % info body sum

  return [expr $a + $b]

 % info default sum a the_argument
 1
 % puts $the_argument
 2
 %

Right now, partcl is using globals to store the argument list and the the body information.
It would seem that we'd want to have a builtin mechanism for querying the subs directly
rather than storing this information separately.

=item user defined subs; parameter handling.

Tcl provides nice exceptions for dealing with argument handling - to continue
our example:

 % sum a b c
 wrong # args: should be "sum ?a? ?b?"

Right now, this is handled I<inside> the function definition - it is defined to take
an arbitary number of args, and then is checked for correctness internally. It would
be nice to have invoke() automatically figure this out and generate an exception
that Tcl can use. (This also starts to drag in "how to do Tcl exceptions cleanly from
parrot")

=head1 [error], [catch], [break], continue...

Tcl kind of conflates normal returns and exceptional returns, and uses the same
mechanism for [break]ing and [continue]'ing  out of loops. 

Right now, this is being handled by returning *two* values from each publicly exposed
function. (And from several internal ones, as well.) The first is the code, that is, 
an integer, which is a faked up enum of:

 TCL_OK, TCL_ERROR, TCL_BREAK, TCL_CONTINUE, TCL_RETURN

Then, the actual I<interesting> value is returned as as a PMC. How do we tie in the
two happy return cases, the two cases that interact with loops, and the error case
into parrot's normal return/exception handler in a way that works for tcl and will
allow interoperability

=head1 stack depth

Cheating and keeping a global around right now, so we can figure out if we should
be using a global or a lexical (and if so, how far down or up).

=cut
