grammar TclExpr::Grammar;

# RT#40688: This began as an [expr] only grammar, and has since grown to
# encompass the language itself. Either rename the whole thing, or,
# preferentially, split out the non-expr specific bits into another
# grammar that this one can then refer to.

token ws { \h* }

token program {
   | <[;\n\r\t\ ]>* <command> [ <?ws> <[\n;]> <?ws> <command>? ]*
   | $<empty>:=[^\s*$]
}

token command {
    | \# \N*
    | [ $<word>:=( <quoted_word> [<before [<[;\n\r\t\ ]>|$]> | <error: extra characters after close-quote> ]
                 | <braced_word> [<before [<[;\n\r\t\ ]>|$]> | <error: extra characters after close-brace> ]
                 | $<chunk>:=( <substitution> | \$ | <-[[$\\;\n\r\t\ ]>+ )+
                 ) \h*
      ]+
}

token substitution {
    | <command_substitution>
    | <variable_substitution>
    | <backslash_substitution>
}

token quoted_word {
    " $<chunk>:=( <substitution> | \$ | <-[[$\\"]>+ )* "
}

token braced_word { <PGE::Text::bracketed: {}> }

token command_substitution {
    \[ \]
  | \[ <[;\n\r\t\ ]>* <subcommand> [ <?ws> <[\n;]> <?ws> <subcommand>? ]* [ \] | <error: missing close-bracket> ]
}

token subcommand {
    | \# \N*
    | [ $<word>:=( <quoted_word> [<before [<[\];\n\r\t\ ]>|$]> | <error: extra characters after close-quote> ]
                 | <braced_word> [<before [<[\];\n\r\t\ ]>|$]> | <error: extra characters after close-brace> ]
                 | $<chunk>:=( <substitution> | \$ | <-[[$\]\\;\n\r\t\ ]>+ )+
                 ) \h*
      ]+
}

token variable_substitution {
    \$ [ \{  ( <-[}]>+ )  \}
       | ([\:\:]?<?name>) [ \( $<index>:=( <substitution> | \$ | <-[[$\\)]>+ )+ \) ]?
       ]
}

token backslash_substitution {
    \\ [ x <[0..9a..fA..F]>+
       | u <[0..9a..fA..F]>**{1..4}
       | <[0..7]>**{1..3}
       | .
       ]
}

# Actual [expr] items

token term {
      <substitution>
    | <quoted_word>
    | <braced_word>
    | <number>
    | <mathfunc>
    | <nested>
    | <boolean>
    | <[a..zA..Z]> <syntax_error_variable_or_function>
}

## used by term

rule boolean { (:i true | false ) <?wb> }

rule nested { \( <expression> \) }

token number { <scientific> | <float> | <integer> }

token float  { (<[+\-]>)? [ <[0..9]>+\.<[0..9]>* | \.<[0..9]>+ ] }

token scientific { (<float> | <integer>) e (<[+\-]>? <[0..9]>+) }

token decimal { [<[1..9]><[0..9]>*] }

token binary  { 0<[bB]> ( <[01]>+ ) }
token octal   { 0 [ <[0..7]> | <[89]><[0..9]>* <invalid_octal> ]* }
token hex     { 0<[xX]> ( <[0..9A..Fa..f]>) + }
token integer { (<[+\-]>)? [ <decimal> | <binary> | <hex> | <octal> ] }

token nullary_function { rand }

token unary_function { 
 abs    | acos   | asin      | atan   | ceil   | cosh?  | double | exp    |
 floor  | int    | log[10]?  | round  | sinh?  | sqrt   | srand  | tanh?  |
 wide
}

token binary_function { atan2 | fmod | hypot | pow }

token mathfunc {
  [ <binary_function> | <unary_function> | <nullary_function> 
  | ( <[a..zA..Z]>\w* )  \(  <unknown_math_function>  ]
        \( [<expression> [, <expression>]*]? \)
}

rule 'expression' is optable {...}

proto 'term:' is precedence('16=')
    is parsed(&term) {...}
 
proto 'prefix:-' is precedence('15=') {...}
proto 'prefix:+' is precedence('15=') {...}
proto 'prefix:~' is precedence('15=') {...}
proto 'prefix:!' is precedence('15=') {...}

proto 'infix:**' is precedence('14=') {...}

proto 'infix:*'  is precedence('13=') {...}
proto 'infix:/'  is precedence('13=') {...}
proto 'infix:%'  is precedence('13=') {...}

proto 'infix:+'  is precedence('12=') {...}
proto 'infix:-'  is precedence('12=') {...}

proto 'infix:<<' is precedence('11=') {...}
proto 'infix:>>' is precedence('11=') {...}

proto 'infix:<'  is precedence('10=') {...}
proto 'infix:>'  is precedence('10=') {...}
proto 'infix:<=' is precedence('10=') {...}
proto 'infix:>=' is precedence('10=') {...}

proto 'infix:==' is precedence('09=') {...}
proto 'infix:!=' is precedence('09=') {...}

proto 'infix:eq' is precedence('08=') {...}
proto 'infix:ne' is precedence('08=') {...}

proto 'infix:in' is precedence('07=') {...}
proto 'infix:ni' is precedence('07=') {...}

proto 'infix:&'  is precedence('06=') {...}

proto 'infix:^'  is precedence('05=') {...}

proto 'infix:|'  is precedence('04=') {...}

proto 'infix:&&' is precedence('03=') {...}

proto 'infix:||' is precedence('02=') {...}

proto 'ternary:? :' is precedence('01=') {...}
