grammar TclExpr::Grammar;

# The expression token is the top level expression - it is defined in 
# XXX-NAME-OF-SUB in XXX-NAME-OF-FILE, which in turn invokes the
# opcode parser from src/tcl_expr_optok.pg.

# XXX Some of the items here actually belong in the language grammar. 
# (like command, quoted, etc.) Move them there when we use PGE for everything.

token tclcommand {
    | \# \N*
    | [ $<word>:=( <quoted_word>
                 | <braced_word>
                 | ( <substitution> | \$ | <-[[$\\;\n\r\t ]>+ )+
                 ) \h*
      ]+
}

token substitution {
    | <command_substitution>
    | <variable_substitution>
    | <backslash_substitution>
}

token quoted_word {
    " $<chunk>:=( <substitution> | \$ | <-[[$\\"]>+ )* "
}

token braced_word { <PGE::Text::bracketed: {}> }

token command_substitution {
    \[ <subcommand> [ <[\n;]> <subcommand> ]* \]
}

token subcommand {
    | \# \N*
    | [ $<word>:=( <quoted_word>
                 | <braced_word>
                 | $<chunk>:=( <substitution> | \$ | <-[[$\]\\\n\r\t ]>+ )+
                 ) \h*
      ]*
}

token variable_substitution {
    \$ [ \{  ( <-[}]> )  \}
       | (<?name>) [ \( $<index>:=( <substitution> | \$ | <-[[$\\)]>+ )+ \) ]?
       ]
}

token backslash_substitution {
    \\ [ x <[0..9a..fA..F]>+
       | o <[0..7]>**{1..3}
       | u <[0..9a..fA..F]>+
       | .
       ]
}

# Actual [expr] items

token term {
      <substitution>
    | <quoted_word>
    | <braced_word>
    | <number>
    | <function>
    | <nested>
    | <boolean>
    | <[a..zA..Z]> <syntax_error_variable_or_function>
}

## used by term

rule boolean { (:i true | false ) <?wb> }

rule nested { \( <expression> \) }

token number { <scientific> | <float> | <integer> }

token float  { (<[+\-]>)? [ <[0..9]>+\.<[0..9]>* | \.<[0..9]>+ ] }

token scientific { (<float> | <integer>) e (<[+\-]>? <[0..9]>+) }

token decimal { [<[1..9]><[0..9]>*] }

# XXX squawk about invalid looking octal.

token octal   { 0 [ <[0..7]> | <[89]><[0..9]>* <invalid_octal> ]* }
token hex     { 0<[xX]> ( <[0..9A..Fa..f]>) + }
token integer { (<[+\-]>)? [ <decimal> | <hex> | <octal> ] }

token nullary_function { rand }

token unary_function { 
 abs    | acos   | asin      | atan   | ceil   | cosh?  | double | exp    |
 floor  | int    | log[10]?  | round  | sinh?  | sqrt   | srand  | tanh?  |
 wide
}

token binary_function { atan2 | fmod | hypot | pow }

token function {
  [ <binary_function> | <unary_function> | <nullary_function> 
  | ( <[a..zA..Z]>\w* )  \(  <unknown_math_function>  ]
        \( [<expression> [, <expression>]*]? \)
}

rule 'expression' is optable {...}

proto 'term:' is precedence('16=')
    is parsed(&term) {...}
 
proto 'prefix:-' is precedence('15=') {...}
proto 'prefix:+' is precedence('15=') {...}
proto 'prefix:~' is precedence('15=') {...}
proto 'prefix:!' is precedence('15=') {...}

proto 'infix:**' is precedence('14=') {...}

proto 'infix:*'  is precedence('13=') {...}
proto 'infix:/'  is precedence('13=') {...}
proto 'infix:%'  is precedence('13=') {...}

proto 'infix:+'  is precedence('12=') {...}
proto 'infix:-'  is precedence('12=') {...}

proto 'infix:<<' is precedence('11=') {...}
proto 'infix:>>' is precedence('11=') {...}

proto 'infix:<'  is precedence('10=') {...}
proto 'infix:>'  is precedence('10=') {...}
proto 'infix:<=' is precedence('10=') {...}
proto 'infix:>=' is precedence('10=') {...}

proto 'infix:==' is precedence('09=') {...}
proto 'infix:!=' is precedence('09=') {...}

proto 'infix:eq' is precedence('08=') {...}
proto 'infix:ne' is precedence('08=') {...}

proto 'infix:in' is precedence('07=') {...}
proto 'infix:ni' is precedence('07=') {...}

proto 'infix:&'  is precedence('06=') {...}

proto 'infix:^'  is precedence('05=') {...}

proto 'infix:|'  is precedence('04=') {...}

proto 'infix:&&' is precedence('03=') {...}

proto 'infix:||' is precedence('02=') {...}

proto 'ternary:? :' is precedence('01=') {...}
