/* TclString.pmc
 *  Copyright (C) 2001-2003, The Perl Foundation.
 *  SVN Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the TclString base class
 */

#include "parrot/parrot.h"
#include "parrot/cclass.h"
#include <stdio.h>

pmclass TclString
    dynpmc
    extends String
    does    string
    group   tcl_group
    hll     Tcl
    maps    String
{

    METHOD PMC* get_list (STRING* str) {
        PMC*   retval = pmc_new(INTERP, pmc_type(INTERP, string_from_literal(INTERP,"TclList")));
        INTVAL pos = -1; /* we're going to increment before we use it... */
        INTVAL len;
        INTVAL I0, I1, depth;
        PMC* P0;
        STRING* S0;

        if (! str) return(SELF);

        len = string_length(INTERP, str);

      eat_space:
        while (Parrot_string_is_cclass(INTERP, enum_cclass_whitespace, str, ++pos));

      loop:
        if (pos >= len) goto done;

        I0 = string_ord(INTERP,str,pos);
        if (I0 == '{') {
            depth = 1;
            I1 = pos;
          find_close_bracket:
            I1++;
            if (I1 >= len)
                real_exception(INTERP, NULL, 1, "unmatched open brace in list");

            I0 = string_ord(INTERP,str,I1);
            if (I0 == '{') {
                depth++;
                goto find_close_bracket;
            }
            else if (I0 == '}')  {
                if (--depth) goto find_close_bracket;

                I0 = I1 + 1;
                if (I0 >= len) goto found_close_bracket;
                if (!Parrot_string_is_cclass(INTERP, enum_cclass_whitespace, str, I0)) {
                    I1++;
                    I0 = len - I1;
                    I0 = CHARSET_FIND_CCLASS(INTERP, enum_cclass_whitespace, str, I1, I0);
                    I0 = I0 - I1;
                    S0 = string_substr(INTERP, str, I1, I0, &S0, 0);
                    real_exception(INTERP, NULL, 1, "list element in braces followed by \"%s\" instead of space", string_to_cstring(INTERP, S0 ));
                }

              found_close_bracket:
                /* length -- if we have "{ }", pos and $I0 should both be 1 */
                I0 = I1 - pos++ - 1;
                S0 = string_substr(INTERP, str, pos, I0, &S0, 0);
                pos = pos + I0 + 1;

                /* Now add that list as another element*/
                retval->vtable->push_string(INTERP, retval, S0);
                goto eat_space;
            }
            else if (I0 == '\\') {
                I1++;
                goto find_close_bracket;
            }
            else
              goto find_close_bracket;
            }
        else if (I0 == '"') {
            /* find the closing '"'*/
            I1 = ++pos;
          quote_loop:
            if (I1 >= len)
                real_exception(INTERP, NULL, 1, "unmatched open quote in list");
            I0 = string_ord(INTERP,str,I1);
            if (I0 == '\\') {
                I1 += 2;
                goto quote_loop;
            }
            else if (I0 == '"') goto found_quote;
            I1++;
            goto quote_loop;
        }
        I0 = pos;

        while (I0 < len) {
            if ('\\' == string_ord(INTERP,str,I0)) {
                I0 += 2;
                continue;
            }
            if (Parrot_string_is_cclass(INTERP, enum_cclass_whitespace, str, I0))
                break;

            I0++;
        }

      extract:
        /*  extract the element */
        I1 = I0 - pos;
        S0 = string_substr(INTERP, str, pos, I1, &S0, 0);

        /* add it to the list*/
        P0 = pmc_new(INTERP, pmc_type(INTERP, string_from_literal(INTERP,"TclConst")));
        VTABLE_set_string_native(INTERP, P0, S0);
        retval->vtable->push_pmc(INTERP, retval, P0);

        /* find the next pos */
        pos = I0;
        goto eat_space;

      found_quote:
        I0 = I1 + 1;
        if (I0 >= len) {
            I0 = I1 - pos;
            S0 = string_substr(INTERP, str, pos, I0, &S0, 0);

            P0 = pmc_new(INTERP, pmc_type(INTERP, string_from_literal(INTERP,"TclConst")));
            VTABLE_set_string_native(INTERP, P0, S0);
            retval->vtable->push_pmc(INTERP, retval, P0);

            pos = I1 + 1;
            goto eat_space;
        }

        if (!Parrot_string_is_cclass(INTERP, enum_cclass_whitespace, str, I0)) {
            I1++;
            I0 = len - I1;
            I0 = CHARSET_FIND_CCLASS(INTERP, enum_cclass_whitespace, str, I1, I0);
            I0 = I0 - I1;
            S0 = string_substr(INTERP, str, I1, I0, &S0, 0);
            real_exception(INTERP, NULL, 1, "list element in quotes followed by \"%s\" instead of space", string_to_cstring(INTERP, S0 ));
        }


      done:
        return(retval);
    }
}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
