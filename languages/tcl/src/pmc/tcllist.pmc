/*
Copyright (C) 2001-2003, The Perl Foundation.
$Id$

=head1 NAME

pmc/tcllist.pmc - Tcl List

=head1 DESCRIPTION

These are the vtable functions for the TclList base class

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

/* cache of classes referenced */

pmclass TclList
    dynpmc
    need_ext
    extends ResizablePMCArray
    does    array
    group   tcl_group
    hll     Tcl
    maps    Array
{

/*

=item C<STRING *get_string()>

Returns the list as a string

=cut

*/

    STRING* get_string() {
        STRING* retval = string_from_literal(INTERP,"");
        INTVAL elems = VTABLE_get_integer(INTERP, SELF);
        INTVAL i;
        STRING* str;
        PMC* P0;
        INTVAL count;
        INTVAL str_len;
        INTVAL pos;

        for (i=0; i < elems; i++) {
            str = VTABLE_get_string_keyed_int(INTERP, SELF, i);

            str_len = string_length(INTERP, str);
            if (str_len == 0) {
                /* empty element */
                str = string_from_literal(INTERP, "{}");
                goto append_elem;
            }
            count = pos = 0;
            while (pos < str_len) {
                switch (string_ord(INTERP, str, pos)) {
                    case '{':
                        count++;
                        break;
                    case '}':
                        if (--count < 0) goto escape;
                        break;
                }
                pos++;
            }

            if (count != 0) goto escape;

            if (-1 != string_str_index(INTERP,  str, string_from_literal(INTERP,"["), 0))
                 goto quote;

            /* only check hashes on first elem.*/
            if (i==0 && -1 != string_str_index(INTERP, str, string_from_literal(INTERP,"#"), 0))
                goto quote;

            if (-1 != string_str_index(INTERP, str, string_from_literal(INTERP,"$"), 0))
                goto quote;

            if (-1 != string_str_index(INTERP, str, string_from_literal(INTERP,";"), 0))
                goto quote;

            /* \'d constructs */
            if (-1 != string_str_index(INTERP, str, string_from_literal(INTERP,"]"), 0))
                goto escape;

            if (-1 != string_str_index(INTERP, str, string_from_literal(INTERP,"\\"), 0))
                goto escape;

            /* {}'d constructs */
            if (str_len != CHARSET_FIND_CCLASS(INTERP, enum_cclass_whitespace, str, 0, str_len))
                goto quote;

            goto append_elem;

          escape:
            P0 = pmc_new(INTERP, enum_class_String);
            VTABLE_set_string_native(INTERP, P0, str);

            Parrot_String_nci_replace(INTERP, P0, string_from_literal(INTERP,"\\"), string_from_literal(INTERP,"\\\\"));
            Parrot_String_nci_replace(INTERP, P0, string_from_literal(INTERP,"\t"), string_from_literal(INTERP,"\\t"));
            Parrot_String_nci_replace(INTERP, P0, string_from_literal(INTERP,"\f"), string_from_literal(INTERP,"\\f"));
            Parrot_String_nci_replace(INTERP, P0, string_from_literal(INTERP,"\n"), string_from_literal(INTERP,"\\n"));
            Parrot_String_nci_replace(INTERP, P0, string_from_literal(INTERP,"\r"), string_from_literal(INTERP,"\\r"));
            Parrot_String_nci_replace(INTERP, P0, string_from_literal(INTERP,"\v"), string_from_literal(INTERP,"\\v"));
            Parrot_String_nci_replace(INTERP, P0, string_from_literal(INTERP,";"), string_from_literal(INTERP,"\\;"));
            Parrot_String_nci_replace(INTERP, P0, string_from_literal(INTERP,"$"), string_from_literal(INTERP,"\\$"));
            Parrot_String_nci_replace(INTERP, P0, string_from_literal(INTERP,"}"), string_from_literal(INTERP,"\\}"));
            Parrot_String_nci_replace(INTERP, P0, string_from_literal(INTERP,"{"), string_from_literal(INTERP,"\\{"));
            Parrot_String_nci_replace(INTERP, P0, string_from_literal(INTERP," "), string_from_literal(INTERP,"\\ "));
            Parrot_String_nci_replace(INTERP, P0, string_from_literal(INTERP,"["), string_from_literal(INTERP,"\\["));
            Parrot_String_nci_replace(INTERP, P0, string_from_literal(INTERP,"]"), string_from_literal(INTERP,"\\]"));
            Parrot_String_nci_replace(INTERP, P0, string_from_literal(INTERP,"\""), string_from_literal(INTERP,"\\\""));

            str = VTABLE_get_string(INTERP, P0);
            goto append_elem;

          quote:
            str = string_append(INTERP, string_from_literal(INTERP, "{"), str);
            str = string_append(INTERP, str, string_from_literal(INTERP, "}"));

          append_elem:
            retval = string_append(INTERP, retval, str);
            retval = string_append(INTERP, retval, string_from_literal(INTERP, " "));
        }

        /* remove the extra space at the end, if necessary*/
        if (string_length(INTERP, retval))
            string_chopn_inplace(INTERP, retval, 1);

        return retval;
    }

/*

=item C<void set_pmc(PMC *other)>

An alias to assign_pmc to make other things happy before set_pmc is removed.

=cut

*/

    void set_pmc(PMC *other) {
        VTABLE_assign_pmc(INTERP, SELF, other);
    }

/*

=item C<void assign_pmc(PMC *other)>

Copy the contents of other to self.

=back

=cut

*/

    void assign_pmc(PMC *other) {
        STRING *array  = string_from_cstring(INTERP, "array", 5);
        STRING *string = string_from_cstring(INTERP, "String", 6);
        STRING *undef  = string_from_cstring(INTERP, "Undef", 5);

        if (VTABLE_does(INTERP, other, array))
        {
            INTVAL size;
            INTVAL i;

            size = VTABLE_elements(INTERP,other);
            DYNSELF.set_integer_native(size);
            for (i = 0; i < size; i++) {
                PMC* elem = VTABLE_get_pmc_keyed_int(INTERP, other, i);
                DYNSELF.set_pmc_keyed_int(i, elem);
            }
        }
        else if (VTABLE_isa(INTERP, other, string))
        {
            STRING *v = VTABLE_get_string(INTERP, other);
            pmc_reuse(INTERP, SELF, other->vtable->base_type, 0);
            DYNSELF.set_string_native(v);
        }
        else if (VTABLE_isa(INTERP, other, undef))
        {
            pmc_reuse(INTERP, SELF, other->vtable->base_type, 0);
        }
        else
        {
            real_exception(INTERP, NULL, E_TypeError,
                           "unable to assign self to this type");
        }
    }

}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
