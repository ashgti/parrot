=head2 [proc]

Create a PIR sub on the fly for this user defined proc.

=cut

.namespace [ "Tcl" ]

.sub _proc
  .param pmc name_p
  .param pmc args_p
  .param pmc body_p

  if I3 != 3 goto error

  .local int return_type
  .local pmc retval
  retval = new PerlString 
  return_type = TCL_OK
  retval = ""

  .local pmc parse
  .local pmc string2list
  parse = find_global "_Tcl", "__parse"
  string2list = find_global "_Tcl", "__stringToList"

  .local string name
  .local string args
  .local string body

  name = name_p
  args = args_p
  body = body_p

  .local pmc arg_list
  arg_list = string2list(args)

  # Save the parsed body.
  .local pmc parsed_body
  parsed_body = parse(body,0,0)

  # XXX these need to go away - for now, we'll just escape
  # the code portion and put it, escaped, into the proc 
  # definition. The arg list will be used to generate the proc's
  # indvidual argument handling code.
 
  # Now, shove the parsed routine into the global hash...
  $P0 = find_global "_Tcl", "proc_body"
  
  $P0[name] = parsed_body
  #$P2[name] = arg_list

  .local pmc escaper
  escaper = find_global "Data::Escape", "String"
  .local string esc_name
  esc_name = escaper(name)

  .local string proc_body
  proc_body  = ".namespace [\"Tcl\"]\n.sub _"
  proc_body .= name
  proc_body .= "\n.param pmc args\nargs = foldup\nnew_pad 1\n"
  .local int arg_count 
  arg_count = arg_list
  .local int ii
  ii = 0
arg_loop:
  if ii == arg_count goto arg_loop_done
  $S1 = ii
  proc_body .= "$P1 = args["
  proc_body .= $S1
  proc_body .= "]\nstore_lex -1,\""
  # XXX This should be Escape'd
  $S1 = arg_list[ii]
  proc_body .= $S1
  proc_body .= "\", $P1\n"
  ii = ii + 1
  goto arg_loop
arg_loop_done:

  proc_body .= ".local pmc interpret\ninterpret = find_global \"_Tcl\", \"__interpret\"\n.local pmc proc_body\n$P0 = find_global \"_Tcl\", \"proc_body\"\nproc_body=$P0[\""
  proc_body .= esc_name
  proc_body .= "\"]\nif I3 == "
  $S1 = arg_count
  proc_body .= $S1
  proc_body .= " goto args_ok\nbad_args:\n.pcc_begin_return\n.return 1\n.return \"wrong # args: should be \\\""
  proc_body .= name
  proc_body .= " "
  proc_body .= args
  proc_body .= "\\\"\"\n.pcc_end_return\nargs_ok:\n"

  # XXX Is the pop_pad necessary, or would it be  handled as a side
  #  effect of the .pcc_return?
 
  # a TCL_RETURN (2) from a sub body should be transformed into a TCL_OK (0)
  # to stop propagation outward.  XXX Should use the real constants here

  proc_body .= "($I0,$P0) = interpret(proc_body)\nif $I0 != 2 goto done\n$I0 = 0\ndone:\npop_pad\n.pcc_begin_return\n.return $I0\n.return $P0\n.pcc_end_return\n.end\n"

  #print "PROC_BODY=\n"
  #print proc_body
  #print "\n--\n"
  
  .local pmc pir_compiler
  pir_compiler = compreg "PIR"
  $P0 = compile pir_compiler, proc_body 
 
  goto done
 
error:
  return_type = TCL_ERROR
  retval = "wrong # args: should be \"proc name args body\"\n"

done:
  .pcc_begin_return
    .return return_type
    .return retval
  .pcc_end_return
.end
