.sub __parse
  .param string buffer
  # buffer contains the string we are working on.

  .include "languages/tcl/lib/macros/debug.imc"
  .const int debug = 0

  .debug("Called with buffer of {")
  .debug(buffer)
  .debug("}\n")
  
  # Keep track of the position of the current word
  .local int start_word
  .local int word_length
  .local int word_trailing_length
  start_word = 0

  # Keep track of the position of the current command
  .local int start_command
  .local int command_length
  start_command = 0

  # Keep track of a particular character
  .local int character
  .local int last_character

  # Should the word be over?
  .local int end_of_word

  # An array of commands, the current command
  .local PerlArray commands
  commands = new PerlArray
  .local PerlArray command

  # Define any macros we use.
  .include "languages/tcl/lib/macros/is_space.imc"
  .include "languages/tcl/lib/macros/debug.imc"

  .debug("Backslash newline substitution\n")

  buffer = __backslash_newline_subst(buffer)

  # (Do this after the newline_subst since this could change the size of the buffer.)

  # don't fall off the end
  .local int buffer_length
  length buffer_length, buffer

BEGIN_COMMAND:
  .debug("BEGIN COMMAND:\n")
  .debug("start_word=")
  .debug(start_word)
  .debug("\n")

  command = new PerlArray

BEGIN_WORD:
  .debug("BEGIN WORD:\n")

  end_of_word = 0
  # Skip any leading whitespace.

space_loop:
  .debug("space_loop:\n")
  .debug("start word='")
  .debug(start_word)
  .debug("'\n")

  if start_word >= buffer_length goto END_SCOPE

space_loop_cont:
  ord $I0, buffer, start_word
  .is_space($I0,$I1)
  if $I1 == 0 goto space_loop_end
  inc start_word
  goto space_loop

space_loop_end:
  .debug("space_loop_end:\n")
  # at this point, we know start_word is correct. Now to figure out where
  # the word ends.

  # If the first character is special, then DTRT
  ord character, buffer, start_word

  # {block}
  if character == 123 goto block_begin
  
  # "string"
  if character == 34 goto block_begin

  # #comment
  if character != 35 goto pre_middle
  if command == 0 goto handle_comment

pre_middle:
  word_length = 0
  word_trailing_length = 0
  last_character = -1

MIDDLE_WORD:
  .debug("MIDDLE_WORD:\n")

  $I0 = start_word + word_length
  if $I0 != buffer_length goto middle_word_0
  .debug("premature end of word, stopping...\n")
  goto END_COMMAND

middle_word_0:
  .debug("checking character at: ")
  .debug($I0)
  .debug("\n")

  ord character, buffer, $I0

  .is_space(character,$I0)
  if $I0 == 1 goto END_WORD

  # if this isn't a newline, skip
  if character != 10 goto middle_word_2

middle_word_1:
  .debug("middle_word_1:\n")
  word_trailing_length=1 
  goto END_COMMAND

middle_word_2:
  .debug("middle_word_2:\n")
  # wait, this was a semicolon - go back and deal with it.
  if character == 59 goto middle_word_1

  # If we've gotten this far and we're in a "" or {} block, barf.
  if end_of_word == 1 goto invalid_word

  if character == 91 goto handle_command_block
  
  if character != 123 goto middle_continue
  if character == 36 goto handle_variable_block

middle_continue:
  .debug("middle_continue:\n")
  last_character = character
  inc word_length
  goto MIDDLE_WORD

END_WORD:
  .debug("END_WORD:\n")

  # XXX from start_word to end_word is a word.
  # save the word and put it into the command array
  substr $S0, buffer, start_word, word_length
  push command, $S0
  #_dumper("command after END_WORD is",command)

  .debug("END_WORD='")
  .debug($S0)
  .debug("'\n")

  start_word = start_word + word_length
  start_word = start_word + word_trailing_length
  inc start_word
  .debug("start_word=")
  .debug(start_word)
  .debug("\n")

  goto BEGIN_WORD  

handle_comment:
  .debug("handle_comment:\n")
  index $I0, buffer, "\n", start_word
  if $I0 == -1 goto comment_remainder

  start_word = $I0 + 1
  goto BEGIN_COMMAND
  
comment_remainer:
  .debug("comment_remainder:\n")
  # There's nothing left to process, the comment ends the string.
  goto END_COMMAND

END_COMMAND:
  .debug("END_COMMAND:\n")
  .debug("word_length = '")
  .debug(word_length)
  .debug("'\n")
  .debug("word_trailing_length = '")
  .debug(word_trailing_length)
  .debug("'\n")
  .debug("start_word = '")
  .debug(start_word)
  .debug("'\n")

  # If this was an empty line, we'll have a 0 word length but
  # a trailing length of 1. skip the newline
  if word_length == 0 goto end_command_1
 
  #$I0 = command
  #if $I0 == 0 goto end_command_3
  #goto end_command_2

  substr $S0, buffer, start_word, word_length
  .debug("salvaged word='")
  .debug($S0)
  .debug("'\n") 
  push command, $S0



  .debug("END_COMMAND_WORD='")
  .debug($S0)
  .debug("'\n")

end_command_1:
  .debug("end_command_1:\n")
  # go to the next word

  $I0 = command
  if $I0 == 0 goto end_command_2
  push commands, command

end_command_2:
  .debug("end_command_2:\n")
  
  #_dumper("I have a command of",command)
  #_dumper("but my commands are",commands)

  start_word = start_word + word_length
  start_word = start_word + word_trailing_length
  goto BEGIN_COMMAND

block_begin:
  # This handles both { and " style blocks.

  word_length = __match_close(buffer,start_word)

  .debug("word_length = ")
  .debug(word_length)
  .debug("\n")

  if word_length < 0 goto bad_block
  end_of_word = 1 
  goto MIDDLE_WORD

handle_variable_block:
  # All this needs to do is find the ending } and goto
  # MIDDLE Word to keep accumulating word fragments...
  .debug("XXX - handle_variable_block\n")    
  goto END
handle_command_block:     
  # All this needs to do is find the ending ] and goto
  # MIDDLE Word to keep accumulating word fragments...
  # XXX this can probably be combined with block_begin...
  .debug("handle_command_block:\n")

  word_length = __match_close(buffer,start_word)

  .debug("word_length = ")
  .debug(word_length)
  .debug("\n")
  if word_length < 0 goto bad_block

  goto MIDDLE_WORD

END_SCOPE:
  .debug("END_SCOPE:\n")

  # If we have a command in progress, save it!
  $I0 = command
  if $I0 == 0 goto end_scope_2
  #if command == 0 goto end_scope_2
  push commands, command
  #_dumper("commands is now(END_SCOPE)",commands)
  # At this point, we have parsed the string into an array of commands.
  # return it.

end_scope_2:
  .debug("there were ")
  $I12= commands
  .debug($I12)
  .debug(" commands in this parsed block.\n")

  #_dumper("parse generated commands of ",commands)

  .pcc_begin_return
  .return commands
  .pcc_end_return
  ret


END:
  end

 # XXX these really should generate compile-time tcl errors.
 # (perhaps even compile to code that generates an [error]?)
bad_block:
  print "XXX - invalid word, no closing <mumble> found\n"
  goto END
invalid_word:
  print "XXX - invalid word, should have ended after block\n"
  goto END

.end
