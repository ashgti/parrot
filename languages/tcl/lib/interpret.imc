=head1

Given a pre-parsed chunk of Tcl, interpret it.

=cut

.sub __interpret
  .param pmc commands

  #_dumper("INTERPRETING",commands)

  # our running return value, type
  .local int return_type
  return_type = TCL_OK
  .local string retval
  retval = ""

  # Which command are we processing?
  .local int command_num
  command_num = -1
  .local int num_commands
  num_commands = commands
  .local pmc command
  .local string proc
  .local pmc args
  .local pmc my_cmd
  .local pmc parsed_body
  .local pmc argument_list

  # global variables....
  .local pmc proc_body
  proc_body = global "proc_body" 
  .local pmc proc_args
  proc_args = global "proc_args" 
  .local pmc global_cmds
  global_cmds = global "commands"

 
end_scope:
  inc command_num
  if command_num == num_commands goto done
  if return_type != TCL_OK goto done

  command = commands[command_num] 

  # this should stringify the tclword object, which performs
  # all necessary substitutions.
  $P0 = command[0]
  #_dumper("Command word",$P0)
  (return_type,retval) = $P0.__get_string()
  #print "COMMAND='"
  #print retval
  #print "'\n"
  if return_type != TCL_OK goto done
  proc = retval 

  # XXX Can probably ditch PerlArray here.
  args = new PerlArray
  .local int num_args 
  num_args = command
  .local int arg_num
  arg_num = 1

loop:
  if arg_num == num_args goto loop_done
  $I0 = arg_num - 1
  $P0 = command[arg_num]
  #_dumper("arg",$P0)
  (return_type,retval) = $P0.__get_string()
  #print "ARG_NUM='"
  #print arg_num
  #print "'\n"
  #print "RETVAL IS '"
  #print retval
  #print "'\n"
  #print "RETURN_TYPE='"
  #print return_type
  #print "'\n"
  if return_type != TCL_OK goto done
  args[$I0] = retval
  inc arg_num
  goto loop

loop_done: 
 
  # get the sub we need..
  my_cmd = global_cmds[proc]

  # XXX Switch back to isnull when we switch to Tcl*
  typeof $I0, my_cmd
  if .PerlUndef == $I0 goto user_command
  #isnull my_cmd, user_command
  (return_type,retval) = my_cmd(args)
  
cooked2:
  goto end_scope

user_command:
  #print "USER_COMMAND:\n"
  parsed_body   = proc_body[proc]
  #_dumper("PARSED BODY",parsed_body)
  argument_list = proc_args[proc]
  #_dumper("ARGULIST",argument_list)

  # XXX Switch back to isnull when we switch to Tcl*
  typeof $I0, parsed_body
  if .PerlUndef == $I0 goto no_command
  #isnull parsed_body, no_command
  dec num_args # We inc'd the command, above.
  #print "NUM_ARGS='"
  #print num_args
  #print "'\n"
  $I3 = argument_list
  #print "CALLED_WITH_ARGS='"
  #print $I3
  #print "'\n"

  if num_args != $I3 goto bad_user_args

  new_pad 1
 
  .local int arg_loop_var
  .local string arg_var_name
  .local pmc arg_var_value
  arg_loop_var = 0
arg_loop:
  if arg_loop_var >= num_args goto args_done
 
  arg_var_name  =  argument_list[arg_loop_var]
  #print "SETTING ARG_VAR_NAME='"
  #print arg_var_name
  #print "'\n"
  arg_var_value =  args[arg_loop_var]
  #print "SETTING ARG_VAR_VALUE'"
  #print arg_var_value
  #print "'\n"
    
  .local pmc copied_var
  clone copied_var, arg_var_value

  store_lex -1, arg_var_name, copied_var
  inc arg_loop_var
  goto arg_loop

args_done:
  #_dumper("ABOUT TO CALL PARSED BODY",parsed_body)
  (return_type,retval) = __interpret(parsed_body)
  # Getting a TCL_RETURN or a TCL_OK here is fine - both indicate
  # that we returned from the user's proc properly.
  # we'll cheat for now and morph a return from a proc into an OK.
  if return_type != TCL_RETURN goto donemorph
  return_type = TCL_OK
donemorph:
  if return_type != TCL_OK goto bad_sub_command
  pop_pad

  goto end_scope

bad_user_args:
  # XXX This needs to be smart enough to say:
  # called "foo" with too many arguments
  # vs.
  # no value given for parameter "i" to "foo"
  return_type = TCL_ERROR
  retval ="called \""
  retval = retval . $S0
  retval = retval . "\" with wrong # of arguments\n"
  goto end_scope

bad_sub_command:
  retval = $S0
  return_type = $I0
  goto done

no_command:
  return_type = TCL_ERROR
  retval = "invalid command name \""
  retval = retval . $S0
  retval = retval . "\"\n"

done:
 # print "DONE with interpreter...\n"
  .pcc_begin_return
    .return return_type
    .return retval
  .pcc_end_return
.end
