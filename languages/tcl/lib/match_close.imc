#
# match_close
#
# given a string and a starting position,
# return the position at which the leading { or " 
# closes, including the last character.

.sub __match_close
  .param string buffer
  .param int start_pos

  .include "languages/tcl/lib/macros/debug.imc"
  .const int debug = 0

  #_dumper(buffer,"match_close_buffer")

  .local int opener
  .local int closer
  .local int peekchar

  .local int count
  .local int state
  .local int position
  .local int bufferlen
  .local int position
  .local int hierarchical

  hierarchical = 0 

  position = start_pos

  .debug("position=")
  .debug(position)
  .debug("\n")

  length bufferlen, buffer
  .debug("buffer={")
  .debug(buffer)
  .debug("}\n")
  .debug("bufferlen=")
  .debug(bufferlen)
  .debug("\n")
  ord opener, buffer, start_pos
  .debug("opener=")
  .debug(opener)
  .debug("\n")
  closer = -1

  # {}
  if opener != 123 goto trycommand
  hierarchical = 1
  closer = 125
  goto gotcloser 

  # []
trycommand:
  .debug("match_close:trycommand:\n")
  if opener != 91 goto tryquote
  closer = 93
  goto gotcloser 

  # ""
tryquote: 
  .debug("match_close:tryquote:\n")
  if opener != 34 goto tryparen
  closer = 34

tryparen: 
  .debug("match_close:tryparen:\n")
  if opener != 40 goto gotcloser
  hierarchical = 1
  closer = 41

gotcloser: 
  .debug("match_close:gotcloser:\n")
  if closer == -1 goto die1 
  .debug("closer='")
  .debug(closer)
  .debug("'\n")

  count = 1
  state = 1
  # 1 == normal, 2 == saw a \

outer:
  .debug("match_close:outer:\n")

  if count == 0 goto outer_done

  inc position 

  .debug("position=")
  .debug(position)
  .debug("\n")

  if position == bufferlen goto die2

  ord peekchar,buffer,position

  .debug("peekchar =")
  .debug(peekchar)
  .debug("\n")

  if state==2 goto state2

  if peekchar == closer goto decr
  if peekchar == opener goto incr

  # backslash
  if peekchar != 92 goto outer

  state = 2
  goto outer

# a \ is only special the first time...
state2:
  .debug("match_close:state2:\n")
  state = 1
  goto outer

# found a closer
decr:
  .debug("match_close:decr:\n")
  if opener == closer goto outer_done 
  count = count - 1
  goto outer

# found another opener
incr:
  .debug("match_close:incr:\n")
  if hierarchical == 0 goto outer
  count = count + 1
  goto outer

outer_done:
  .debug("match_close:outer_done:\n")
  .debug("position='")
  .debug(position)
  .debug("'\n")
  .debug("start_pos='")
  .debug(start_pos)
  .debug("'\n")

  $I1 = position - start_pos
  # off by two?
  inc $I1
  .debug("length='")
  .debug($I1)
  .debug("'\n") 
  goto done

die1:
  .debug("match_close:die1\n")
  # invalid opening match char
  $I1 = -1
  goto done

die2:
  .debug("match_close:die2\n")
  # no closing char found
  $I1 = -2

done:
  .debug("match_close:done\n")
  .pcc_begin_return
  .return $I1
  .pcc_end_return
.end
