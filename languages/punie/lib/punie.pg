# Copyright (C) 2005-2008, The Perl Foundation.
# $Id$

grammar Punie::Grammar is PCT::Grammar;

token TOP    {
    <lineseq> [ $ || <panic: parse error> ] {*}
}

token ws {
    || \v+
    || \h+
    || '#' \N*
}

token block { \{ <lineseq> \} {*} }

rule lineseq {
    <line>*
    {*}
}

token line {
    | <loop> {*}                                   #= loop
    | <label>
      [ <cond> {*}                                 #= cond
      | <subroutine> {*}                           #= subroutine
      | <sideff> ';' {*}                           #= sideff
      ] \s*

}

rule sideff {
    <expr> [$<modifier>=<condmod>|<loopmod>]?
    {*}
}

rule condmod {
    $<sym>=[if|unless] <expr>
    {*}
}

rule loopmod {
    $<sym>=[while|until] <expr>
    {*}
}

rule label { [<word>\:]? {*} }

token word { [\w|_][\w|\d|_]* }

rule subroutine { sub <word> <block> {*} }

rule cond {
    $<sym>=[if|unless]
    \( <expr> \) <block>
    [ 'elsif' \( <expr> \) <block> ]*
    [ 'else' $<else>=<block> ]?
    {*}
}

rule loop {
    <label>
    [ <while_loop> {*}                          #= while_loop
    | <until_loop> {*}                          #= until_loop
    | <for_loop> {*}                            #= for_loop
    ]
}

rule while_loop {
    while \( <texpr> \) <block>
    {*}
}

rule until_loop {
    until \( <expr> \) <block>
    {*}
}

rule for_loop {
    for \( [$<init>=<sideff>]? ';' <texpr> ';' [$<step>=<sideff>]? \)
    <block>
    {*}
}

rule texpr {
    <expr>? {*}
}

rule expr    {
    | <gprint> {*}                               #= gprint
    | <oexpr> {*}                                #= oexpr
}

rule gprint  { (print) <expr> {*} }

rule 'oexpr' is optable { ... }


token term {
    | <list> {*}                                  #= list
    | \( <expr> \) {*}                           #= expr
    | <number> {*}                               #= number
    | <integer> {*}                              #= integer
    | <stringdouble> {*}                         #= stringdouble
    | <stringsingle> {*}                         #= stringsingle
    | <stringbacktick> {*}                       #= stringbacktick
    | do <.ws> <block> {*}                       #= block
    | <opcall> {*}                               #= subcall
    | <subcall> {*}                              #= subcall
    | <do_chop> {*}                              #= do_chop
    | <variable> {*}                             #= variable

    #| <split> {*}                                #= split
    #| <join> {*}                                 #= join
}


rule list {
    \( \)
    {*}
}

## XXX add "pattern" to lexical rules.
##rule split {
##    split [\( <variable> [',' <variable> [',' <expr>]? ]? \)]?
##}

## XXX complete this and implement
##rule join {
##    join [\( <oexpr> ',' <expr> \)]?
##}

rule do_chop {
    'chop' [\( <expr> \)]?
    {*}
}


rule variable {
    | <sigil>? <word> <key>? {*}
    | <special_variable> <key>? {*}
}

token special_variable { '$_' | '$#' | '$ ' '_' }

token sigil { '$#' | <[$@%]> {*} }
token key {
    | $<KEY>=[\[] <?ws> <expr> <?ws> $<KEY_CLOSE>=[\]]
    | $<KEY>=[\{] <?ws> <expr> <?ws> $<KEY_CLOSE>=[\}]
    {*}
}
token integer { \d+ {*} }
token number { \d+\.\d+ {*} }
token stringdouble { '"' <string_literal: "> '"' {*} }
token stringsingle { \' <string_literal: '> \' {*} }
token stringbacktick { \` <string_literal: `> \` {*} }
rule subcall { do $<sym>=<word> \( <expr>? \) {*} }
rule opcall  { $<sym>=<op> \( <expr>? \) {*} }

token op {
    | open
    | die
}

token ws {
    [ \s+
    | \# \N*
    ]*
    {*}
}



proto infix:<+> is assoc('left') is precedence('=')
    is pirop('n_add')
    {...}

proto infix:<-> is assoc('left') is equiv(infix:<+>)
    is pirop('n_sub')
    {...}

proto infix:<.> is assoc('left')  is equiv(infix:<+>)
    is pirop('n_concat')
    {...}

proto infix:<*> is assoc('left') is tighter(infix:<+>)
    is pirop('n_mul')
    {...}

proto infix:</> is assoc('left') is equiv(infix:<*>)
    is pirop('n_div')
    {...}

proto infix:<%> is assoc('left') is equiv(infix:<*>)
    is pirop('n_mod')
    {...}

proto infix:<x> is assoc('left') is equiv(infix:<*>)
    {...}

proto prefix:<-> is tighter(infix:<*>) is assoc('right') { ... }
proto prefix:<~> is equiv(prefix:<->) is assoc('right') { ... }
proto prefix:<!> is equiv(prefix:<->) is assoc('right') { ... }

proto postfix:<++> is tighter(prefix:<->) is assoc('non') is lvalue(1) { ... }
proto postfix:<--> is equiv(postfix:<++>)is assoc('non') is lvalue(1) { ... }
proto prefix:<++> is equiv(postfix:<++>) is assoc('non') is lvalue(1) { ... }
proto prefix:<--> is equiv(postfix:<++>) is assoc('non') is lvalue(1) { ... }


proto infix:«<<» is looser(infix:<+>) is assoc('left')
#    is pirop('shl') # XXX pirop()s with non PREG destinations don't work yet
    {...}

proto infix:«>>» is equiv(infix:«<<») is assoc('left')
#    is pirop('shr') # XXX pirop()s with non PREG destinations don't work yet
    {...}

proto infix:«<»  is looser(infix:«<<») is assoc('non') {...}
proto infix:«>»  is equiv(infix:«<»)   is assoc('non') {...}
proto infix:«<=» is equiv(infix:«<»)   is assoc('non') {...}
proto infix:«>=» is equiv(infix:«<»)   is assoc('non') {...}
proto infix:<lt> is equiv(infix:«<»)   is assoc('non') {...}
proto infix:<gt> is equiv(infix:«<»)   is assoc('non') {...}
proto infix:<le> is equiv(infix:«<»)   is assoc('non') {...}
proto infix:<ge> is equiv(infix:«<»)   is assoc('non') {...}

proto infix:<==> is looser(infix:«<») is assoc('non') {...}
proto infix:<!=> is equiv(infix:<==>) is assoc('non') {...}

proto infix:<eq> is equiv(infix:<==>) is assoc('non')
    {...}
proto infix:<ne> is equiv(infix:<==>) is assoc('non')
    {...}

proto infix:<&> is looser(infix:<==>) is assoc('left')
#    is pirop('band') # XXX pirop()s with non PREG destinations don't work yet
    {...}

proto infix:<|> is looser(infix:<&>) is assoc('left')
#    is pirop('bor') # XXX pirop()s with non PREG destinations don't work yet
    {...}

proto infix:<^> is equiv(infix:<|>)   is assoc('left')
#    is pirop('bxor') # XXX pirop()s with non PREG destinations don't work yet
    {...}

proto infix:<&&> is looser(infix:<|>)  is assoc('left')
    is pasttype('if')
    {...}
proto infix:<||> is looser(infix:<&&>) is assoc('left')
    is pasttype('unless')
    {...}

proto infix:<..> is looser(infix:<||>) is assoc('non')
    {...}

proto ternary:<? :> is looser(infix:<..>) is assoc('right')
    is pasttype('if')
    {...}

proto infix:<=> is looser(ternary:<? :>)
    is pirop('assign')
    is lvalue(1)
    {...}

proto infix:<,> is looser(infix:<=>) is assoc('list')
    { ... }

proto term: is tighter(infix:<+>) is parsed(&term) { ... }




