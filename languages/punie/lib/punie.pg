grammar Punie::Grammar is PCT::Grammar;

token TOP    {
    <lineseq> [ $ || <panic: parse error> ] {*}
}

token ws {
    || \v+
    || \h+
    || '#' \N*
}

token block { \{ <lineseq> \} {*} }

rule lineseq {
    <line>*
    {*}
}

token line {
    <label>
    [ <cond> {*}                                 #= cond
    | <subroutine> {*}                           #= subroutine
    | <expr> ';' {*}                             #= expr
    ] \s*
}

rule label { [<word>\:]? {*} }

token word { [\w|_][\w|\d|_]* }

rule subroutine { sub <word> <block> {*} }

rule cond {
    $<sym>=[if|unless]
    \( <expr> \) <block>
    [ 'elsif' \( <expr> \) <block> ]*
    [ 'else' $<else>=<block> ]?
    {*}
}

rule expr    {
    | <gprint> {*}                               #= gprint
    | <oexpr> {*}                                #= oexpr
}

rule gprint  { (print) $<handle>=<word>? <expr> {*} }

rule 'oexpr' is optable { ... }

token term {
    | \( <expr> \) {*}                           #= expr
    | <number> {*}                               #= number
    | <integer> {*}                              #= integer
    | <stringdouble> {*}                         #= stringdouble
    | <stringsingle> {*}                         #= stringsingle
    | <stringbacktick> {*}                       #= stringbacktick
    | <regex> {*}                                #= regex
    | do <.ws> <block> {*}                       #= block
    | <opcall> {*}                               #= subcall
    | <subcall> {*}                              #= subcall
    | <variable> {*}                             #= variable
}
rule variable {
    | <sigil>? <word> <key>? {*}
    | <special_variable> <key>? {*}
}

token special_variable { '$_' | '$#' | '$ ' '_' }

token sigil { '$#' | <[$@%]> {*} }
token key {
    | $<KEY>=[\[] <?ws> <expr> <?ws> $<KEY_CLOSE>=[\]]
    | $<KEY>=[\{] <?ws> <expr> <?ws> $<KEY_CLOSE>=[\}]
    {*}
}
token integer { \d+ {*} }
token number  { \d+\.\d+ {*} }
token stringdouble   { '"' <string_literal: "> '"' {*} }
token stringsingle   { \' <string_literal: '> \' {*} }
token stringbacktick { \` <string_literal: `> \` {*} }
token regex          { \/ <string_literal: \/> \/ {*} }
rule subcall  { do $<sym>=<word> \( <expr>? \) {*} }
rule opcall   { $<sym>=<op> \( <expr>? \) {*} }

token op {
    | open
    | die
    | shift
}

token ws {
    [ \s+
    | \# \N*
    ]*
    {*}
}

proto prefix:<!> is precedence('=') {...}

proto infix:<+> is looser(prefix:<!>)
    is pirop('n_add')
    {...}

proto infix:<-> is equiv(infix:<+>)
    is pirop('n_sub')
    {...}

proto infix:<.> is equiv(infix:<+>)
    is pirop('n_concat')
    {...}

proto infix:<*> is tighter(infix:<+>)
    is pirop('n_mul')
    {...}

proto infix:</> is equiv(infix:<*>)
    is pirop('n_div')
    {...}

proto infix:<%> is equiv(infix:<*>)
    is pirop('n_mod')
    {...}

proto infix:<x> is equiv(infix:<*>)
    {...}

proto infix:«<<» is looser(infix:<+>)
#    is pirop('shl') # XXX pirop()s with non PREG destinations don't work yet
    {...}

proto infix:«>>» is equiv(infix:«<<»)
#    is pirop('shr') # XXX pirop()s with non PREG destinations don't work yet
    {...}

proto infix:«<»  is looser(infix:«<<») is assoc('non') {...}
proto infix:«>»  is equiv(infix:«<»)   is assoc('non') {...}
proto infix:«<=» is equiv(infix:«<»)   is assoc('non') {...}
proto infix:«>=» is equiv(infix:«<»)   is assoc('non') {...}
proto infix:<lt> is equiv(infix:«<»)   is assoc('non') {...}
proto infix:<gt> is equiv(infix:«<»)   is assoc('non') {...}
proto infix:<le> is equiv(infix:«<»)   is assoc('non') {...}
proto infix:<ge> is equiv(infix:«<»)   is assoc('non') {...}
proto infix:<=~> is equiv(infix:«<»)   is assoc('non') {...}

proto infix:<==> is looser(infix:«<») is assoc('non') {...}
proto infix:<!=> is equiv(infix:<==>) is assoc('non') {...}

proto infix:<eq> is equiv(infix:<==>) is assoc('non')
    {...}
proto infix:<ne> is equiv(infix:<==>) is assoc('non')
    {...}

proto infix:<&> is looser(infix:<==>) is assoc('left')
#    is pirop('band') # XXX pirop()s with non PREG destinations don't work yet
    {...}

proto infix:<|> is looser(infix:<&>) is assoc('left')
#    is pirop('bor') # XXX pirop()s with non PREG destinations don't work yet
    {...}

proto infix:<^> is equiv(infix:<|>)   is assoc('left')
#    is pirop('bxor') # XXX pirop()s with non PREG destinations don't work yet
    {...}

proto infix:<&&> is looser(infix:<|>)  is assoc('left')
    is pasttype('if')
    {...}
proto infix:<||> is looser(infix:<&&>) is assoc('left')
    is pasttype('unless')
    {...}

proto infix:<=> is looser(infix:<||>)
    is pirop('assign')
    is lvalue(1)
    {...}

proto infix:<,> is looser(infix:<=>) is assoc('list')
    { ... }

proto term: is tighter(infix:<+>) is parsed(&term) { ... }
