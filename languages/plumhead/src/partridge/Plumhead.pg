# Copyright (C) 2006-2007, The Perl Foundation.
# $Id$

# PHP grammar for Plumhead partrige

# The starting rule is TOP

grammar Plumhead::Grammar;

token TOP                     { <program> }

regex SEA                     { .*? <?before: \<> }
token CODE_START              { <'<?php'> }
token CODE_END                { <'?>'> <' '>* \n? }
token DOUBLEQUOTE_STRING      { " <-["]>* " }
token SINGLEQUOTE_STRING      { ' <-[']>* ' }
token ECHO                    { <'echo'> }
token VAR_DUMP                { <'var_dump'> }
token PAREN_OPEN              { \( }
token PAREN_CLOSE             { \) }

token IDENT                   { ( <[a..z]> | <[A..Z]> | <'_'> )( <[a..z]> | <[A..Z]> | <'_'> )* }
token VAR_NAME                {  <'$'> <IDENT> }

token INTEGER                 { \d+ }
token NUMBER                  { ( \d+ )? <'.'> \d+ }

token UNARY_MINUS             { \- }
token UNARY_PLUS              { \+ }
token ADD_OP                  { \+ | \- }
token MUL_OP                  { \* | / | % }
token BITWISE_OP              { <'|'>  | <'&'> | <'^'> }
token ASSIGN_OP               { <'='> }
token REL_OP                  { <'=='> | <'<='> | <'>='> | <'!='> | <'<'>  | <'>'> }

token IF                      { <'if'> }
token ELSE                    { <'else'> }
token program                 { ^ <SEA> <code> }

rule  code                    { <?CODE_START> <statement>* <?CODE_END>? }

rule relational_expression    { <expression> <rel_op_clause>? }

rule statement                {
    <ECHO> <expression> ;
  | <VAR_DUMP> <?PAREN_OPEN>  <expression> <?PAREN_CLOSE> ;
  | <IF> <?PAREN_OPEN> <relational_expression> <?PAREN_CLOSE> \{ <statement>* \} <else_clause>? 
  | <inline_sea> 
  | <scalar_assign>
  | <array_assign>
                              }

rule else_clause              { <?ELSE> \{ <statement>* \} }
# TODO: rel_op_clause is not a nice name
rule  rel_op_clause           { <REL_OP> <expression> }
rule  else_clause             { <?ELSE> \{ <statement>* \} }
token inline_sea              { <?CODE_END> <SEA> <?CODE_START> }
rule  scalar_assign           { <var> <ASSIGN_OP> <expression> ; }
rule  array_assign            { <array_elem> <ASSIGN_OP> <expression> ; }

token expression              {   <DOUBLEQUOTE_STRING>
                                | <SINGLEQUOTE_STRING>
                                | <bitwise_expression>
                                | <array_elem>
                                | <var>
                              }

rule  array_elem              { <VAR_NAME> <'['> <array_key> <']'> }
rule  array_key               { <expression>  }
rule  var                     { <VAR_NAME> }

rule bitwise_expression       { <adding_expression> <bitwise_tail>? }

rule bitwise_tail             { <BITWISE_OP> <adding_expression> }

# BUG: this gets precedence  wrong
rule adding_expression        { <multiplying_expression> <adding_tail>* }

rule adding_tail              { <ADD_OP> <multiplying_expression> }

# TODO: this gets precedence  wrong
rule multiplying_expression   { <unary_expression> <multiplicand>? }

rule multiplicand             { <MUL_OP> <multiplying_expression> }

rule unary_expression         { <UNARY_MINUS>? <postfix_expression> }

rule postfix_expression       { <NUMBER> | <INTEGER> | <?PAREN_OPEN> <expression> <?PAREN_CLOSE> }

