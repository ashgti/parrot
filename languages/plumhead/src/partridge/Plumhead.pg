# Copyright (C) 2006-2007, The Perl Foundation.
# $Id$

# PHP grammar for Plumhead partrige

# The starting rule is TOP

grammar Plumhead::Grammar;

token TOP                     { <program> }

regex SEA                     { .*? <?before: \<> }
token CODE_START              { <'<?php'> }
token CODE_END                { <'?>'> <' '>* \n? }
token DOUBLEQUOTE_STRING      { " <-["]>* " }
token SINGLEQUOTE_STRING      { ' <-[']>* ' }
token ECHO                    { <'echo'> }
token PAREN_OPEN              { \( }
token PAREN_CLOSE             { \) }

token NUMBER                  { \d+ ( . \d+ )? | . \d+ }

token UNARY_MINUS             { \- }
token UNARY_PLUS              { \+ }
token ADD_OP                  { \+ | \- }
token MUL_OP                  { \* | / | % }
token REL_OP                  { <'=='> | <'<='> | <'>='> | <'!='> | <'<'>  | <'>'> }

token IF                      { <'if'> }
token ELSE                    { <'else'> }
token program                 { ^ <SEA> <code> }

rule  code                    { <?CODE_START> <statement>* <?CODE_END> }

rule relational_expression    { <expression> <rel_op_clause>? }

rule statement                { <ECHO> <expression> ;
                              | <IF> <?PAREN_OPEN> <relational_expression> <?PAREN_CLOSE> \{ <statement>* \} <else_clause>? 
                              | <inline_sea> 
                              }

rule else_clause              { <?ELSE> \{ <statement>* \} }
# TODO: rel_op_clause is not a nice name
rule rel_op_clause            { <REL_OP> <expression> }
rule else_clause              { <?ELSE> \{ <statement>* \} }
token inline_sea              { <?CODE_END> <SEA> <?CODE_START> }

token expression              { <DOUBLEQUOTE_STRING> | <SINGLEQUOTE_STRING> | <adding_expression> }

# TODO: this gets precedence  wrong
rule adding_expression        { <multiplying_expression> <summand>? }

rule summand                  { <ADD_OP> <adding_expression> }

# TODO: this gets precedence  wrong
rule multiplying_expression   { <unary_expression> <multiplicand>? }

rule multiplicand             { <MUL_OP> <multiplying_expression> }

rule unary_expression         { <UNARY_MINUS>? <postfix_expression> }

rule postfix_expression       { <NUMBER> | <?PAREN_OPEN> <expression> <?PAREN_CLOSE> }

