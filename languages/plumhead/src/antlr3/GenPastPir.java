// $ANTLR 3.0 src/antlr3/GenPastPir.g 2007-05-19 15:26:59

  import java.util.regex.*;


import org.antlr.runtime.*;
import org.antlr.runtime.tree.*;import java.util.Stack;
import java.util.List;
import java.util.ArrayList;

public class GenPastPir extends TreeParser {
    public static final String[] tokenNames = new String[] {
        "<invalid>", "<EOR>", "<DOWN>", "<UP>", "PROGRAM", "NOQUOTE_STRING", "STMTS", "SCALAR", "ARRAY", "FUNCTION", "PREFIX", "SEA", "CODE_START", "CODE_END", "WS", "DOUBLEQUOTE_STRING", "SINGLEQUOTE_STRING", "ECHO", "VAR_DUMP", "PAREN_OPEN", "PAREN_CLOSE", "IDENT", "VAR_NAME", "DIGITS", "INTEGER", "NUMBER", "MINUS", "PLUS", "MUL_OP", "BITWISE_OP", "ASSIGN_OP", "REL_OP", "IF", "ELSE", "';'", "'{'", "'}'", "'['", "']'"
    };
    public static final int CODE_START=12;
    public static final int MINUS=26;
    public static final int VAR_NAME=22;
    public static final int DIGITS=23;
    public static final int IDENT=21;
    public static final int ARRAY=8;
    public static final int BITWISE_OP=29;
    public static final int NUMBER=25;
    public static final int WS=14;
    public static final int SINGLEQUOTE_STRING=16;
    public static final int MUL_OP=28;
    public static final int SEA=11;
    public static final int CODE_END=13;
    public static final int STMTS=6;
    public static final int PROGRAM=4;
    public static final int PAREN_OPEN=19;
    public static final int PREFIX=10;
    public static final int INTEGER=24;
    public static final int ASSIGN_OP=30;
    public static final int DOUBLEQUOTE_STRING=15;
    public static final int PAREN_CLOSE=20;
    public static final int ECHO=17;
    public static final int FUNCTION=9;
    public static final int ELSE=33;
    public static final int IF=32;
    public static final int EOF=-1;
    public static final int VAR_DUMP=18;
    public static final int REL_OP=31;
    public static final int PLUS=27;
    public static final int NOQUOTE_STRING=5;
    public static final int SCALAR=7;

        public GenPastPir(TreeNodeStream input) {
            super(input);
        }
        

    public String[] getTokenNames() { return tokenNames; }
    public String getGrammarFileName() { return "src/antlr3/GenPastPir.g"; }


      // used for generating unique register names
      public static int reg_num = 200;



    // $ANTLR start gen_pir_past
    // src/antlr3/GenPastPir.g:28:1: gen_pir_past : ^( PROGRAM ( node[\"past_stmts\"] )* ) ;
    public final void gen_pir_past() throws RecognitionException {
        try {
            // src/antlr3/GenPastPir.g:29:5: ( ^( PROGRAM ( node[\"past_stmts\"] )* ) )
            // src/antlr3/GenPastPir.g:29:5: ^( PROGRAM ( node[\"past_stmts\"] )* )
            {

                  System.out.println( 
                      "#!/usr/bin/env parrot                                             \n"
                    + "                                                                  \n"
                    + "# Do not edit this file.                                          \n"
                    + "# This file has been generated by GenPastPir.xsl                  \n"
                    + "                                                                  \n"
                    + ".sub 'php_init' :load :init                                       \n"
                    + "                                                                  \n"
                    + "  load_bytecode 'languages/plumhead/src/common/plumheadlib.pbc'   \n"
                    + "  load_bytecode 'PAST-pm.pbc'                                     \n"
                    + "  load_bytecode 'Parrot/HLLCompiler.pbc'                          \n"
                    + "  load_bytecode 'MIME/Base64.pbc'                                 \n"
                    + "  load_bytecode 'dumper.pbc'                                      \n"
                    + "  load_bytecode 'PGE.pbc'                                         \n"
                    + "  load_bytecode 'CGI/QueryHash.pbc'                               \n"
                    + "                                                                  \n"
                    + ".end                                                              \n"
                    + "                                                                  \n"
                    + ".sub plumhead :main                                               \n"
                    + "                                                                  \n"
                    + "    # look for subs in other namespaces                           \n"
                    + "    .local pmc parse_get_sub, parse_post_sub   \n"
                    + "    parse_get_sub  = get_global [ 'CGI'; 'QueryHash' ], 'parse_get'         \n"
                    + "    parse_post_sub = get_global [ 'CGI'; 'QueryHash' ], 'parse_post'        \n"
                    + "                                                                  \n"
                    + "    # the superglobals                                            \n"
                    + "    .local pmc superglobal_GET                                    \n"
                    + "    ( superglobal_GET ) = parse_get_sub()                         \n"
                    + "    set_global '$_GET', superglobal_GET                            \n"
                    + "                                                                  \n"
                    + "    .local pmc superglobal_POST                                   \n"
                    + "    ( superglobal_POST ) = parse_post_sub()                       \n"
                    + "    set_global '$_POST', superglobal_POST                          \n"
                    + "                                                                  \n"
                    + "    # The root node of PAST.                                      \n"
                    + "    .local pmc past_root                                          \n"
                    + "    past_root  = new 'PAST::Block'                                \n"
                    + "    past_root.init('name' => 'plumhead_main')                     \n"
                    + "                                                                  \n"
                    + "    .local pmc past_stmts                                         \n"
                    + "    past_stmts = new 'PAST::Stmts'                                \n"
                    + "                                                                  \n"
                    + "    .sym pmc past_temp                                            \n"
                    + "    .sym pmc past_name                                            \n"
                    + "    .sym pmc past_if_op                                           \n"
                    + "                                                                  \n"
                  );
                
            match(input,PROGRAM,FOLLOW_PROGRAM_in_gen_pir_past75); 

            if ( input.LA(1)==Token.DOWN ) {
                match(input, Token.DOWN, null); 
                // src/antlr3/GenPastPir.g:78:16: ( node[\"past_stmts\"] )*
                loop1:
                do {
                    int alt1=2;
                    int LA1_0 = input.LA(1);

                    if ( ((LA1_0>=NOQUOTE_STRING && LA1_0<=ARRAY)||LA1_0==PREFIX||(LA1_0>=DOUBLEQUOTE_STRING && LA1_0<=VAR_DUMP)||(LA1_0>=INTEGER && LA1_0<=IF)) ) {
                        alt1=1;
                    }


                    switch (alt1) {
                	case 1 :
                	    // src/antlr3/GenPastPir.g:78:16: node[\"past_stmts\"]
                	    {
                	    pushFollow(FOLLOW_node_in_gen_pir_past77);
                	    node("past_stmts");
                	    _fsp--;


                	    }
                	    break;

                	default :
                	    break loop1;
                    }
                } while (true);


                match(input, Token.UP, null); 
            }

                  System.out.println( 
                      "                                                                  \n"
                    + "                                                                  \n"
                    + "  past_root.'push'( past_stmts )                                  \n"
                    + "                                                                  \n"
                    + "    #'_dumper'(past_root, 'past')                                \n"
                    + "    # '_dumper'(superglobal_POST , 'superglobal_POST')            \n"
                    + "    # '_dumper'(superglobal_GET , 'superglobal_GET')              \n"
                    + "                                                                  \n"
                    + "    # .local pmc post                                             \n"
                    + "    # post = past_root.'compile'( 'target' => 'post' )            \n"
                    + "    # '_dumper'(post, 'post')                                     \n"
                    + "                                                                  \n"
                    + "    # .local pmc pir                                              \n"
                    + "    # pir = past_root.'compile'( 'target' => 'pir' )              \n"
                    + "    # print pir                                                   \n"
                    + "                                                                  \n"
                    + "    .local pmc pastcompiler, eval_past                            \n"
                    + "    pastcompiler = new 'HLLCompiler'                              \n"
                    + "    pastcompiler.'removestage'('parse')                           \n"
                    + "    pastcompiler.'removestage'('past')                            \n"
                    + "    eval_past = pastcompiler.'compile'(past_root)                 \n"
                    + "    eval_past()                                                   \n"
                    + "                                                                  \n"
                    + ".end                                                              \n"
                    + "                                                                  \n"
                  );
                

            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end gen_pir_past


    // $ANTLR start node
    // src/antlr3/GenPastPir.g:110:1: node[String reg_mother] : ( ^( ECHO node[\"past_echo\"] ) | ^( VAR_DUMP node[\"past_var_dump\"] ) | NOQUOTE_STRING | SINGLEQUOTE_STRING | DOUBLEQUOTE_STRING | NUMBER | INTEGER | ^(infix= ( PLUS | MINUS | MUL_OP | BITWISE_OP ) node[reg] node[reg] ) | ^(prefix= PREFIX node[reg] ) | ^( REL_OP node[reg] node[reg] ) | ^( IF node[\"past_if_op\"] node[\"past_if_op\"] ( node[\"past_if_op\"] )? ) | ^( STMTS ( node[reg_stmts] )* ) | ^( ASSIGN_OP node[reg_assign] node[reg_assign] ) | SCALAR | ^( ARRAY node[reg_array] ) );
    public final void node(String reg_mother) throws RecognitionException {
        CommonTree infix=null;
        CommonTree prefix=null;
        CommonTree NOQUOTE_STRING1=null;
        CommonTree SINGLEQUOTE_STRING2=null;
        CommonTree DOUBLEQUOTE_STRING3=null;
        CommonTree NUMBER4=null;
        CommonTree INTEGER5=null;
        CommonTree REL_OP6=null;
        CommonTree SCALAR7=null;
        CommonTree ARRAY8=null;

        try {
            // src/antlr3/GenPastPir.g:111:5: ( ^( ECHO node[\"past_echo\"] ) | ^( VAR_DUMP node[\"past_var_dump\"] ) | NOQUOTE_STRING | SINGLEQUOTE_STRING | DOUBLEQUOTE_STRING | NUMBER | INTEGER | ^(infix= ( PLUS | MINUS | MUL_OP | BITWISE_OP ) node[reg] node[reg] ) | ^(prefix= PREFIX node[reg] ) | ^( REL_OP node[reg] node[reg] ) | ^( IF node[\"past_if_op\"] node[\"past_if_op\"] ( node[\"past_if_op\"] )? ) | ^( STMTS ( node[reg_stmts] )* ) | ^( ASSIGN_OP node[reg_assign] node[reg_assign] ) | SCALAR | ^( ARRAY node[reg_array] ) )
            int alt4=15;
            switch ( input.LA(1) ) {
            case ECHO:
                {
                alt4=1;
                }
                break;
            case VAR_DUMP:
                {
                alt4=2;
                }
                break;
            case NOQUOTE_STRING:
                {
                alt4=3;
                }
                break;
            case SINGLEQUOTE_STRING:
                {
                alt4=4;
                }
                break;
            case DOUBLEQUOTE_STRING:
                {
                alt4=5;
                }
                break;
            case NUMBER:
                {
                alt4=6;
                }
                break;
            case INTEGER:
                {
                alt4=7;
                }
                break;
            case MINUS:
            case PLUS:
            case MUL_OP:
            case BITWISE_OP:
                {
                alt4=8;
                }
                break;
            case PREFIX:
                {
                alt4=9;
                }
                break;
            case REL_OP:
                {
                alt4=10;
                }
                break;
            case IF:
                {
                alt4=11;
                }
                break;
            case STMTS:
                {
                alt4=12;
                }
                break;
            case ASSIGN_OP:
                {
                alt4=13;
                }
                break;
            case SCALAR:
                {
                alt4=14;
                }
                break;
            case ARRAY:
                {
                alt4=15;
                }
                break;
            default:
                NoViableAltException nvae =
                    new NoViableAltException("110:1: node[String reg_mother] : ( ^( ECHO node[\"past_echo\"] ) | ^( VAR_DUMP node[\"past_var_dump\"] ) | NOQUOTE_STRING | SINGLEQUOTE_STRING | DOUBLEQUOTE_STRING | NUMBER | INTEGER | ^(infix= ( PLUS | MINUS | MUL_OP | BITWISE_OP ) node[reg] node[reg] ) | ^(prefix= PREFIX node[reg] ) | ^( REL_OP node[reg] node[reg] ) | ^( IF node[\"past_if_op\"] node[\"past_if_op\"] ( node[\"past_if_op\"] )? ) | ^( STMTS ( node[reg_stmts] )* ) | ^( ASSIGN_OP node[reg_assign] node[reg_assign] ) | SCALAR | ^( ARRAY node[reg_array] ) );", 4, 0, input);

                throw nvae;
            }

            switch (alt4) {
                case 1 :
                    // src/antlr3/GenPastPir.g:111:5: ^( ECHO node[\"past_echo\"] )
                    {

                          System.out.println( 
                              "                                                                  \n"
                            + "  # start of ECHO node                                            \n"
                            + "  .local pmc past_echo                                            \n"
                            + "  past_echo = new 'PAST::Op'                                      \n"
                          );
                        
                    match(input,ECHO,FOLLOW_ECHO_in_node109); 

                    match(input, Token.DOWN, null); 
                    pushFollow(FOLLOW_node_in_node111);
                    node("past_echo");
                    _fsp--;


                    match(input, Token.UP, null); 

                          System.out.println( 
                              "                                                                  \n"
                            + "  past_echo.'attr'( 'name', 'echo', 1 )                           \n"
                            + "  " + reg_mother + ".'push'( past_echo )                    \n"
                            + "  # end of ECHO node                                              \n"
                          );
                        

                    }
                    break;
                case 2 :
                    // src/antlr3/GenPastPir.g:128:5: ^( VAR_DUMP node[\"past_var_dump\"] )
                    {

                          System.out.println( 
                              "                                                                  \n"
                            + "  # start of VAR_DUMP node                                        \n"
                            + "  .local pmc past_var_dump                                        \n"
                            + "  past_var_dump = new 'PAST::Op'                                  \n"
                          );
                        
                    match(input,VAR_DUMP,FOLLOW_VAR_DUMP_in_node134); 

                    match(input, Token.DOWN, null); 
                    pushFollow(FOLLOW_node_in_node136);
                    node("past_var_dump");
                    _fsp--;


                    match(input, Token.UP, null); 

                          System.out.println( 
                              "                                                                  \n"
                            + "  past_var_dump.'attr'( 'name', 'var_dump', 1 )                   \n"
                            + "  " + reg_mother + ".'push'( past_var_dump )                \n"
                            + "  # end of VAR_DUMP node                                          \n"
                          );
                        

                    }
                    break;
                case 3 :
                    // src/antlr3/GenPastPir.g:145:5: NOQUOTE_STRING
                    {
                    NOQUOTE_STRING1=(CommonTree)input.LT(1);
                    match(input,NOQUOTE_STRING,FOLLOW_NOQUOTE_STRING_in_node151); 

                          String noquote = NOQUOTE_STRING1.getText();
                          noquote = noquote.replace( "\n", "\\n" );
                          System.out.println( 
                              "                                                                  \n"
                            + "  # start of NOQUOTE_STRING                                       \n"
                            + "  .local string val                                               \n"
                            + "  val = \"" + noquote + "\"                                       \n"
                            + "  past_temp = new 'PAST::Val'                                     \n"
                            + "  .local pmc code_string                                          \n"
                            + "  code_string = new 'PGE::CodeString'                             \n"
                            + "  ( val ) = code_string.'escape'( val )                           \n"
                            + "      past_temp.'init'( 'name' => val, 'vtype' => '.Undef' )      \n"
                            + "  " + reg_mother + ".'push'( past_temp )                    \n"
                            + "  # end of NOQUOTE_STRING                                         \n"
                            + "                                                                  \n"
                          );
                        

                    }
                    break;
                case 4 :
                    // src/antlr3/GenPastPir.g:164:5: SINGLEQUOTE_STRING
                    {
                    SINGLEQUOTE_STRING2=(CommonTree)input.LT(1);
                    match(input,SINGLEQUOTE_STRING,FOLLOW_SINGLEQUOTE_STRING_in_node163); 

                          String singlequote = SINGLEQUOTE_STRING2.getText();
                          singlequote = singlequote.replace( "\n", "\\n" );
                          System.out.println( 
                              "                                                                  \n"
                            + "  # start of SINGLEQUOTE_STRING                                   \n"
                            + "  .local string val                                               \n"
                            + "  val = " + singlequote + "                                       \n"
                            + "  past_temp = new 'PAST::Val'                                     \n"
                            + "  .local pmc code_string                                          \n"
                            + "  code_string = new 'PGE::CodeString'                             \n"
                            + "  ( val ) = code_string.'escape'( val )                           \n"
                            + "      past_temp.'init'( 'name' => val, 'vtype' => '.Undef' )      \n"
                            + "  " + reg_mother + ".'push'( past_temp )                    \n"
                            + "  # end of SINGLEQUOTE_STRING                                                 \n"
                            + "                                                                  \n"
                          );
                        

                    }
                    break;
                case 5 :
                    // src/antlr3/GenPastPir.g:183:5: DOUBLEQUOTE_STRING
                    {
                    DOUBLEQUOTE_STRING3=(CommonTree)input.LT(1);
                    match(input,DOUBLEQUOTE_STRING,FOLLOW_DOUBLEQUOTE_STRING_in_node175); 

                          String doublequote = DOUBLEQUOTE_STRING3.getText();
                          doublequote = doublequote.replace( "\n", "\\n" );
                          System.out.println( 
                              "                                                                  \n"
                            + "  # start of DOUBLEQUOTE_STRING                                   \n"
                            + "  .local string val                                               \n"
                            + "  val = " + doublequote + "                                      \n"
                            + "  past_temp = new 'PAST::Val'                                     \n"
                            + "  .local pmc code_string                                          \n"
                            + "  code_string = new 'PGE::CodeString'                             \n"
                            + "  ( val ) = code_string.'escape'( val )                           \n"
                            + "      past_temp.'init'( 'name' => val, 'vtype' => '.Undef' )      \n"
                            + "  " + reg_mother + ".'push'( past_temp )                    \n"
                            + "  # end of DOUBLEQUOTE_STRING                                                 \n"
                            + "                                                                  \n"
                          );
                        

                    }
                    break;
                case 6 :
                    // src/antlr3/GenPastPir.g:202:5: NUMBER
                    {
                    NUMBER4=(CommonTree)input.LT(1);
                    match(input,NUMBER,FOLLOW_NUMBER_in_node187); 

                          System.out.println( 
                              "                                                                  \n"
                            + "  # start of NUMBER                                               \n"
                            + "  past_temp = new 'PAST::Val'                                     \n"
                            + "      past_temp.'attr'( 'name', '" + NUMBER4.getText() + "', 1 )       \n"
                            + "      past_temp.'attr'( 'ctype', 'n+', 1 )                        \n"
                            + "      past_temp.'attr'( 'vtype', '.Float', 1 )                    \n"
                            + "  " + reg_mother + ".'push'( past_temp )                    \n"
                            + "  # end of NUMBER                                                 \n"
                          );
                        

                    }
                    break;
                case 7 :
                    // src/antlr3/GenPastPir.g:215:5: INTEGER
                    {
                    INTEGER5=(CommonTree)input.LT(1);
                    match(input,INTEGER,FOLLOW_INTEGER_in_node199); 

                          System.out.println( 
                              "                                                                  \n"
                            + "  # start of INTEGER                                              \n"
                            + "  past_temp = new 'PAST::Val'                                     \n"
                            + "      past_temp.'attr'( 'name', '" + INTEGER5.getText() + "', 1 )      \n"
                            + "      past_temp.'attr'( 'ctype', 'i+', 1 )                        \n"
                            + "      past_temp.'attr'( 'vtype', '.Integer', 1 )                  \n"
                            + "  " + reg_mother + ".'push'( past_temp )                    \n"
                            + "  # end of INTEGER                                                \n"
                          );
                        

                    }
                    break;
                case 8 :
                    // src/antlr3/GenPastPir.g:228:5: ^(infix= ( PLUS | MINUS | MUL_OP | BITWISE_OP ) node[reg] node[reg] )
                    {

                          reg_num++;
                          String reg = "reg_" + reg_num;
                          System.out.print( 
                              "                                                                   \n"
                            + "    # entering PLUS | MINUS | MUL_OP | BITWISE_OP                  \n"
                            + "      .sym pmc " + reg + "                                         \n"
                            + "      " + reg + " = new 'PAST::Op'                                 \n"
                          );
                        
                    infix=(CommonTree)input.LT(1);
                    if ( (input.LA(1)>=MINUS && input.LA(1)<=BITWISE_OP) ) {
                        input.consume();
                        errorRecovery=false;
                    }
                    else {
                        MismatchedSetException mse =
                            new MismatchedSetException(null,input);
                        recoverFromMismatchedSet(input,mse,FOLLOW_set_in_node221);    throw mse;
                    }


                    match(input, Token.DOWN, null); 
                    pushFollow(FOLLOW_node_in_node239);
                    node(reg);
                    _fsp--;

                    pushFollow(FOLLOW_node_in_node242);
                    node(reg);
                    _fsp--;


                    match(input, Token.UP, null); 

                          // Todo. This is not nice, handle pirops in Plumhead.g
                          String op = infix.getText();
                          String pirop = "";
                          if      ( op.equals( "+" ) )  { pirop = "n_add"; }
                          else if ( op.equals( "-" ) )  { pirop = "n_sub"; }
                          else if ( op.equals( "/" ) )  { pirop = "n_div"; }
                          else if ( op.equals( "*" ) )  { pirop = "n_mul"; }
                          else if ( op.equals( "%" ) ) { pirop = "n_mod"; }
                          
                          String name = op;
                          if      ( op.equals( "&" ) )  { name = "+&"; }
                          else if ( op.equals( "|" ) )  { name = "+|"; }
                          else if ( op.equals( "^" ) )  { name = "+^"; }
                          name = "infix:" + name;

                          System.out.print( 
                              "  " + reg + ".'attr'( 'pirop', '" + pirop + "', 1 )                \n"
                            + "  " + reg + ".'attr'( 'name',  '" + name + "' , 1 )                \n"
                            + "  " + reg + ".'attr'( 'islvalue',  0 , 1 )                \n"
                            + "  " + reg_mother + ".'push'( " + reg + " )                   \n"
                            + "    # leaving PLUS | MINUS | MUL_OP | BITWISE_OP                   \n"
                          );
                        

                    }
                    break;
                case 9 :
                    // src/antlr3/GenPastPir.g:263:5: ^(prefix= PREFIX node[reg] )
                    {

                          reg_num++;
                          String reg = "reg_" + reg_num;
                          System.out.print( 
                              "                                                                   \n"
                            + "    # entering PREFIX                                              \n"
                            + "      .sym pmc " + reg + "                                         \n"
                            + "      " + reg + " = new 'PAST::Op'                                 \n"
                          );
                        
                    prefix=(CommonTree)input.LT(1);
                    match(input,PREFIX,FOLLOW_PREFIX_in_node267); 

                    match(input, Token.DOWN, null); 
                    pushFollow(FOLLOW_node_in_node269);
                    node(reg);
                    _fsp--;


                    match(input, Token.UP, null); 

                          // Todo. This is not nice, handle pirops in Plumhead.g
                          String op = prefix.getText();
                          
                          String name = op;
                          name = "prefix:" + name;

                          System.out.print( 
                              "  " + reg + ".'attr'( 'name',  '" + name + "' , 1 )                \n"
                            + "  " + reg_mother + ".'push'( " + reg + " )                   \n"
                            + "    # leaving PREFIX                                               \n"
                          );
                        

                    }
                    break;
                case 10 :
                    // src/antlr3/GenPastPir.g:287:5: ^( REL_OP node[reg] node[reg] )
                    {

                          reg_num++;
                          String reg = "reg_" + reg_num;
                          System.out.print( 
                              "                                                                   \n"
                            + "    # entering REL_OP                                              \n"
                            + "      .sym pmc " + reg + "                                         \n"
                            + "      " + reg + " = new 'PAST::Op'                                 \n"
                          );
                        
                    REL_OP6=(CommonTree)input.LT(1);
                    match(input,REL_OP,FOLLOW_REL_OP_in_node292); 

                    match(input, Token.DOWN, null); 
                    pushFollow(FOLLOW_node_in_node294);
                    node(reg);
                    _fsp--;

                    pushFollow(FOLLOW_node_in_node297);
                    node(reg);
                    _fsp--;


                    match(input, Token.UP, null); 

                          // Todo. This is not nice, handle pirops in Plumhead.g
                          String name = REL_OP6.getText();
                          if      ( name.equals( "==" ) )  { name = "eq"; }
                          else if ( name.equals( "!=" ) )  { name = "ne"; }
                          name = "infix:" + name;
                          
                          System.out.print( 
                              "  " + reg + ".'attr'( 'name', '" + name + "' , 1 )               \n"
                            + "  " + reg_mother + ".'push'( " + reg + " )                 \n"
                            + "    # leaving REL_OL                                              \n"
                          );
                        

                    }
                    break;
                case 11 :
                    // src/antlr3/GenPastPir.g:311:5: ^( IF node[\"past_if_op\"] node[\"past_if_op\"] ( node[\"past_if_op\"] )? )
                    {

                          reg_num++;
                          String reg_exp   = "reg_expression_" + reg_num;
                          System.out.print( 
                              "                                                                   \n"
                            + "  # entering IF                                                    \n"
                            + "      past_if_op = new 'PAST::Op'                                  \n"
                            + "      past_if_op.'attr'( 'pasttype', 'if' , 1 )                    \n"
                            + "        .sym pmc " + reg_exp + "                                   \n"
                            + "        " + reg_exp + " = new 'PAST::Block'                        \n"
                            + "                                                                   \n"
                          );
                        
                    match(input,IF,FOLLOW_IF_in_node320); 

                    match(input, Token.DOWN, null); 
                    pushFollow(FOLLOW_node_in_node322);
                    node("past_if_op");
                    _fsp--;

                    pushFollow(FOLLOW_node_in_node325);
                    node("past_if_op");
                    _fsp--;

                    // src/antlr3/GenPastPir.g:324:49: ( node[\"past_if_op\"] )?
                    int alt2=2;
                    int LA2_0 = input.LA(1);

                    if ( ((LA2_0>=NOQUOTE_STRING && LA2_0<=ARRAY)||LA2_0==PREFIX||(LA2_0>=DOUBLEQUOTE_STRING && LA2_0<=VAR_DUMP)||(LA2_0>=INTEGER && LA2_0<=IF)) ) {
                        alt2=1;
                    }
                    switch (alt2) {
                        case 1 :
                            // src/antlr3/GenPastPir.g:324:49: node[\"past_if_op\"]
                            {
                            pushFollow(FOLLOW_node_in_node328);
                            node("past_if_op");
                            _fsp--;


                            }
                            break;

                    }


                    match(input, Token.UP, null); 

                          System.out.print( 
                              "                                                                   \n"
                            + "  " + reg_mother + ".'push'( past_if_op )                     \n"
                            + "  # leaving IF                                                     \n"
                          );
                        

                    }
                    break;
                case 12 :
                    // src/antlr3/GenPastPir.g:332:5: ^( STMTS ( node[reg_stmts] )* )
                    {

                          reg_num++;
                          String reg_stmts = "reg_stmts_" + reg_num;
                          System.out.print( 
                              "                                                                   \n"
                            + "    # entering STMTS                                               \n"
                            + "        .sym pmc " + reg_stmts + "                                 \n"
                            + "        " + reg_stmts + " = new 'PAST::Stmts'                      \n"
                          );
                        
                    match(input,STMTS,FOLLOW_STMTS_in_node352); 

                    if ( input.LA(1)==Token.DOWN ) {
                        match(input, Token.DOWN, null); 
                        // src/antlr3/GenPastPir.g:342:14: ( node[reg_stmts] )*
                        loop3:
                        do {
                            int alt3=2;
                            int LA3_0 = input.LA(1);

                            if ( ((LA3_0>=NOQUOTE_STRING && LA3_0<=ARRAY)||LA3_0==PREFIX||(LA3_0>=DOUBLEQUOTE_STRING && LA3_0<=VAR_DUMP)||(LA3_0>=INTEGER && LA3_0<=IF)) ) {
                                alt3=1;
                            }


                            switch (alt3) {
                        	case 1 :
                        	    // src/antlr3/GenPastPir.g:342:14: node[reg_stmts]
                        	    {
                        	    pushFollow(FOLLOW_node_in_node354);
                        	    node(reg_stmts);
                        	    _fsp--;


                        	    }
                        	    break;

                        	default :
                        	    break loop3;
                            }
                        } while (true);


                        match(input, Token.UP, null); 
                    }

                          System.out.print( 
                              "  " + reg_mother + ".'push'( " + reg_stmts + " )             \n"
                            + "  # leaving 'STMTS node*'                                          \n"
                          );
                        

                    }
                    break;
                case 13 :
                    // src/antlr3/GenPastPir.g:349:5: ^( ASSIGN_OP node[reg_assign] node[reg_assign] )
                    {

                          reg_num++;
                          String reg_assign = "reg_assign_" + reg_num;
                          System.out.print( 
                              "                                                                   \n"
                            + "    # entering ASSIGN_OP                                           \n"
                            + "    .sym pmc " + reg_assign + "                                    \n"
                            + "    " + reg_assign + " = new 'PAST::Op'                            \n"
                            + "    " + reg_assign + ".init( 'name' => 'infix:=', 'pasttype' => 'assign' ) \n"
                          );
                        
                    match(input,ASSIGN_OP,FOLLOW_ASSIGN_OP_in_node378); 

                    match(input, Token.DOWN, null); 
                    pushFollow(FOLLOW_node_in_node380);
                    node(reg_assign);
                    _fsp--;

                    pushFollow(FOLLOW_node_in_node383);
                    node(reg_assign);
                    _fsp--;


                    match(input, Token.UP, null); 

                          System.out.print( 
                              "  " + reg_mother + ".'push'( " + reg_assign + " )            \n"
                            + "  # leaving ASSIGN_OP                                              \n"
                          );
                        

                    }
                    break;
                case 14 :
                    // src/antlr3/GenPastPir.g:367:5: SCALAR
                    {
                    SCALAR7=(CommonTree)input.LT(1);
                    match(input,SCALAR,FOLLOW_SCALAR_in_node398); 

                          System.out.println( 
                              "                                                                  \n"
                            + "  # entering SCALAR                                               \n"
                            + "  past_temp = new 'PAST::Var'                                     \n"
                            + "      past_temp.'init'( 'name' => '" + SCALAR7.getText() + "', 'viviself' => '.Undef', 'islvalue' => 1 )      \n"
                            + "  " + reg_mother + ".'push'( past_temp )                    \n"
                            + "  # leaving SCALAR                                                \n"
                          );
                        

                    }
                    break;
                case 15 :
                    // src/antlr3/GenPastPir.g:378:5: ^( ARRAY node[reg_array] )
                    {

                          reg_num++;
                          String reg_array = "reg_array_" + reg_num;
                          System.out.print( 
                              "                                                                  \n"
                            + "    # entering ARRAY                                              \n"
                            + "    .sym pmc " + reg_array + "                                    \n"
                            + "    " + reg_array + " = new 'PAST::Var'                           \n"
                            + "    " + reg_array + ".init( 'scope' => 'keyed', 'viviself' => '.Undef', 'islvalue' => 1 ) \n"
                          );
                        
                    ARRAY8=(CommonTree)input.LT(1);
                    match(input,ARRAY,FOLLOW_ARRAY_in_node418); 

                    match(input, Token.DOWN, null); 
                    pushFollow(FOLLOW_node_in_node420);
                    node(reg_array);
                    _fsp--;


                    match(input, Token.UP, null); 

                          System.out.println( 
                              "                                                                  \n"
                            + "  past_name = new 'PAST::Var'                                     \n"
                            + "  past_name.'init'( 'name' => '" + ARRAY8.getText() + "', 'viviself' => '.Hash', 'islvalue' => 1 )      \n"
                            + "  # PAST-pm has no unshift yet                                    \n"
                            + "  $P0 = " + reg_array + ".'get_array'()                          \n"
                            + "  unshift $P0, past_name                                         \n"
                            + "  " + reg_mother + ".'push'( " + reg_array + " )            \n"
                            + "  # leaving ARRAY                                                 \n"
                          );
                        

                    }
                    break;

            }
        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {
        }
        return ;
    }
    // $ANTLR end node


 

    public static final BitSet FOLLOW_PROGRAM_in_gen_pir_past75 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_node_in_gen_pir_past77 = new BitSet(new long[]{0x00000001FF0785E8L});
    public static final BitSet FOLLOW_ECHO_in_node109 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_node_in_node111 = new BitSet(new long[]{0x0000000000000008L});
    public static final BitSet FOLLOW_VAR_DUMP_in_node134 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_node_in_node136 = new BitSet(new long[]{0x0000000000000008L});
    public static final BitSet FOLLOW_NOQUOTE_STRING_in_node151 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_SINGLEQUOTE_STRING_in_node163 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_DOUBLEQUOTE_STRING_in_node175 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_NUMBER_in_node187 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_INTEGER_in_node199 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_set_in_node221 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_node_in_node239 = new BitSet(new long[]{0x00000001FF0785E0L});
    public static final BitSet FOLLOW_node_in_node242 = new BitSet(new long[]{0x0000000000000008L});
    public static final BitSet FOLLOW_PREFIX_in_node267 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_node_in_node269 = new BitSet(new long[]{0x0000000000000008L});
    public static final BitSet FOLLOW_REL_OP_in_node292 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_node_in_node294 = new BitSet(new long[]{0x00000001FF0785E0L});
    public static final BitSet FOLLOW_node_in_node297 = new BitSet(new long[]{0x0000000000000008L});
    public static final BitSet FOLLOW_IF_in_node320 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_node_in_node322 = new BitSet(new long[]{0x00000001FF0785E0L});
    public static final BitSet FOLLOW_node_in_node325 = new BitSet(new long[]{0x00000001FF0785E8L});
    public static final BitSet FOLLOW_node_in_node328 = new BitSet(new long[]{0x0000000000000008L});
    public static final BitSet FOLLOW_STMTS_in_node352 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_node_in_node354 = new BitSet(new long[]{0x00000001FF0785E8L});
    public static final BitSet FOLLOW_ASSIGN_OP_in_node378 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_node_in_node380 = new BitSet(new long[]{0x00000001FF0785E0L});
    public static final BitSet FOLLOW_node_in_node383 = new BitSet(new long[]{0x0000000000000008L});
    public static final BitSet FOLLOW_SCALAR_in_node398 = new BitSet(new long[]{0x0000000000000002L});
    public static final BitSet FOLLOW_ARRAY_in_node418 = new BitSet(new long[]{0x0000000000000004L});
    public static final BitSet FOLLOW_node_in_node420 = new BitSet(new long[]{0x0000000000000008L});

}