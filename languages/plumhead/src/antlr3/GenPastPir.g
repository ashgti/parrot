// Copyright (C) 2006, The Perl Foundation.
// $Id$

// Transform ANTLR PAST to PIR that sets up a PAST data structure
// let the Parrot Compiler Tools handle the execution.

tree grammar GenPastPir;

options
{
  ASTLabelType = CommonTree;
  tokenVocab   = Plumhead;      // Token file is found because of '-lib' option
}


@header 
{
  import java.util.regex.*;
}

@members
{
  // used for generating unique register names
  public static int reg_num = 100;
}

gen_pir_past 
  : {
      System.out.println( 
          "#!/usr/bin/env parrot                                             \n"
        + "                                                                  \n"
        + "# Do not edit this file.                                          \n"
        + "# This file has been generated by GenPastPir.xsl                  \n"
        + "                                                                  \n"
        + ".sub 'php_init' :load :init                                       \n"
        + "                                                                  \n"
        + "  load_bytecode 'languages/plumhead/plumheadlib.pbc'              \n"
        + "  load_bytecode 'PAST-pm.pbc'                                     \n"
        + "  load_bytecode 'MIME/Base64.pbc'                                 \n"
        + "  load_bytecode 'dumper.pbc'                                      \n"
        + "  load_bytecode 'CGI/QueryHash.pbc'                               \n"
        + "                                                                  \n"
        + ".end                                                              \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + ".sub plumhead :main                                               \n"
        + "                                                                  \n"
        + "    # look for subs in other namespaces                           \n"
        + "    .local pmc decode_base64_sub, parse_get_sub, parse_post_sub   \n"
        + "    decode_base64_sub = get_global [ 'MIME'; 'Base64' ], 'decode_base64'    \n"
        + "    parse_get_sub  = get_global [ 'CGI'; 'QueryHash' ], 'parse_get'         \n"
        + "    parse_post_sub = get_global [ 'CGI'; 'QueryHash' ], 'parse_post'        \n"
        + "                                                                  \n"
        + "    # the superglobals                                            \n"
        + "    .local pmc superglobal_GET                                    \n"
        + "    ( superglobal_GET ) = parse_get_sub()                         \n"
        + "    set_global '_GET', superglobal_GET                            \n"
        + "                                                                  \n"
        + "    .local pmc superglobal_POST                                   \n"
        + "    ( superglobal_POST ) = parse_post_sub()                       \n"
        + "    set_global '_POST', superglobal_POST                          \n"
        + "                                                                  \n"
        + "    # The root node of PAST.                                      \n"
        + "    .local pmc past_node_id2244466                                \n"
        + "    past_node_id2244466  = new 'PAST::Block'                      \n"
        + "    past_node_id2244466.init('name' => 'plumhead_main')           \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + "  # start of generic node                                         \n"
        + "  .local pmc past_node_id2244469                                  \n"
        + "  past_node_id2244469 = new 'PAST::Stmts'                         \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + "  # start of generic node                                         \n"
        + "  .local pmc past_node_id2244476                                  \n"
        + "  past_node_id2244476 = new 'PAST::Op'                            \n"
        + "                                                                  \n"
        + "      past_node_id2244476.'attr'( 'name', 'echo', 1 )             \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + "  # start of past:Val                                             \n"
        + "  .local pmc past_node_id2244480                                  \n"
        + "  past_node_id2244480 = new 'PAST::Val'                           \n"
        + "                                                                  \n"
        + "      .local string decoded                                       \n"
        + "      decoded = decode_base64_sub( 'SGVsbG8sIFdvcmxkIQo=' )       \n"
        + "      past_node_id2244480.'attr'( 'name', decoded, 1 )            \n"
        + "      null decoded                                                \n"
        + "                                                                  \n"
        + "  past_node_id2244480.'attr'( 'ctype', 's~', 1 )                  \n"
        + "                                                                  \n"
        + "  past_node_id2244480.'attr'( 'vtype', '.String', 1 )             \n"
        + "                                                                  \n"
        + "  past_node_id2244476.'push'( past_node_id2244480 )               \n"
        + "  # end of past:Val                                               \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + "  past_node_id2244469.'push'( past_node_id2244476 )               \n"
        + "  null past_node_id2244476                                        \n"
        + "  # end of generic node                                           \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + "  past_node_id2244466.'push'( past_node_id2244469 )               \n"
        + "  null past_node_id2244469                                        \n"
        + "  # end of generic node                                           \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + "                                                                  \n"
        + "    # '_dumper'(past_node_id2244466, 'past')                      \n"
        + "    # '_dumper'(superglobal_POST , 'superglobal_POST')            \n"
        + "    # '_dumper'(superglobal_GET , 'superglobal_GET')              \n"
        + "                                                                  \n"
        + "    # .local pmc post                                             \n"
        + "    # post = past_node_id2244466.'compile'( 'target' => 'post' )  \n"
        + "    # '_dumper'(post, 'post')                                     \n"
        + "                                                                  \n"
        + "    # .local pmc pir                                              \n"
        + "    # pir = past_node_id2244466.'compile'( 'target' => 'pir' )    \n"
        + "    # print pir                                                   \n"
        + "                                                                  \n"
        + "    .local pmc eval_past                                          \n"
        + "    eval_past = past_node_id2244466.'compile'( )                  \n"
        + "    eval_past()                                                   \n"
        + "    # '_dumper'(eval, 'eval')                                     \n"
        + "                                                                  \n"
        + ".end                                                              \n"
        + "                                                                  \n"
        + "                                                                  \n"
      );
    }
    START_PHP
  ;

node[String reg_mother]
  : {
      System.out.print( 
          "                                                                  \n"
        + "  # entering 'PRINT node'                                         \n"
        + "    reg_expression_stmt = new 'PAST::Stmt'                        \n"
        + "      reg_expression_topexp = new 'PAST::Exp'                     \n"
        + "        reg_print_op = new 'PAST::Op'                             \n"
        + "        reg_print_op.'op'( 'print' )                              \n"
        + "          reg_expression_exp = new 'PAST::Exp'                    \n"
      );
    }
    ^( PRINT node["reg_expression_exp"] )
    { 
      System.out.print( 
          "                                                                   \n"
        + "      reg_print_op.'add_child'( reg_expression_exp )               \n"
        + "      reg_expression_topexp.'add_child'( reg_print_op      )       \n"
        + "    reg_expression_stmt.'add_child'( reg_expression_topexp )       \n"
        + "  " + $node.reg_mother + ".'add_child'( reg_expression_stmt )      \n"
        + "  # leaving 'PRINT node'                                           \n"
      );
    }
  | ^( FUNCTION LETTER )
    {
      // do nothing for now
    }
  | {
      System.out.print( 
          "                                                                   \n"
        + "  # entering 'assign'                                              \n"
        + "    reg_assign_lhs = new 'PAST::Exp'                               \n"
      );
    }
    ^( ASSIGN_OP ^(VAR LETTER) node["reg_assign_lhs"] )
    {
      // TODO: strip String
      System.out.print(     
          "                                                                   \n"
        + "    # entering 'ASSIGN_OP ^(VAR LETTER) node'                      \n"
        + "      .sym pmc past_op                                             \n"
        + "      past_op = new 'PAST::Op'                                     \n"
        + "      past_op.'op'( 'infix:=' )                                    \n"
        + "        .sym pmc past_var                                          \n"
        + "        past_var = new 'PAST::Var'                                 \n"
        + "        past_var.'varname'( '" + $LETTER.text + "' )               \n"
        + "        past_var.'vartype'( 'scalar' )                             \n"
        + "        past_var.'scope'( 'global' )                               \n"
        + "      past_op.'add_child'( past_var )                              \n"
        + "      past_op.'add_child'( reg_assign_lhs )                        \n"
        + "    " + $node.reg_mother + ".'add_child'( past_op )                \n"
        + "    # leaving  'ASSIGN_OP named_expression NUMBER'                 \n"
      );
    }
  | NUMBER
    {
      System.out.print(     
          "                                                                  \n"
        + "# entering 'NUMBER'                                               \n"
        + "reg_temp = new 'PAST::Val'                                        \n"
        + "reg_temp.value( " + $NUMBER.text + " )                            \n"
        + "reg_temp.valtype( 'num' )                                         \n"
        + $node.reg_mother + ".'add_child'( reg_temp )                       \n"
        + "null reg_temp                                                     \n"
        + "# leaving 'NUMBER'                                                \n"
      );
    }
  | {
      reg_num++;
      String reg = "reg_" + reg_num;
      System.out.print( 
          "                                                                   \n"
        + "    # entering '( PLUS | MINUS | MUL_OP | REL_OP ) node node'               \n"
        + "      .sym pmc " + reg + "                                         \n"
        + "      " + reg + " = new 'PAST::Op'                                 \n"
      );
    }
    ^( infix=( PLUS | MINUS | MUL_OP | REL_OP ) node[reg] node[reg] )
    {
      System.out.print( 
          "      " + reg + ".'op'( 'infix:" + $infix.text + "' )              \n"
        + "    reg_temp = new 'PAST::Exp'                                     \n"
        + "    reg_temp.'add_child'( " + reg + " )                            \n"
        + "      null " + reg + "                                             \n"
        + "  " + $node.reg_mother + ".'add_child'( reg_temp )                 \n"
        + "    null reg_temp                                                  \n"
        + "    # leaving '( PLUS | MINUS | MUL | DIV ) node node'             \n"
      );
    }
  | ^( VAR LETTER )
    {
      System.out.print( 
          "                                                                   \n"
        + " # entering '( VAR LETTER )                                        \n"
        + "    reg_temp = new 'PAST::Var'                                     \n"
        + "    reg_temp.'varname'( '" + $LETTER.text + "' )                   \n"
        + "    reg_temp.'vartype'( 'scalar' )                                 \n"
        + "    reg_temp.'scope'( 'global' )                                   \n"
        + "  " + $node.reg_mother + ".'add_child'( reg_temp )                 \n"
        + "    null reg_temp                                                  \n"
        + "  # leaving '(VAR LETTER)'                                         \n"
      );
    }
  | NEWLINE
    { 
      System.out.print(     
          "                                                                   \n"
        + "# entering 'NEWLINE'                                               \n"
        + "            reg_temp = new 'PAST::Val'                             \n"
        + "            reg_temp.value( '\\n' )                                \n"
        + "            reg_temp.valtype( 'strqq' )                            \n"
        + "          " + $node.reg_mother + ".'add_child'( reg_temp )         \n"
        + "          null reg_temp                                            \n"
        + "# leaving 'NEWLINE'                                                \n"
      );
    }
  | STRING
    {
      // In bc backslash has on special meaning, so s!/!//!
      // Write newlines as '\n', in to not break PIR. s!\n!\\n!
      String escaped = $STRING.text.replaceAll( "\\\\", "\\\\\\\\\\\\\\\\" ).replaceAll( "\\n", "\\\\\\\\n" );
      System.out.print(     
          "                                                                   \n"
        + "# entering 'STRING'                                                \n"
        + "            reg_temp = new 'PAST::Val'                             \n"
        + "            reg_temp.value( " + escaped + " )                      \n"
        + "            reg_temp.valtype( 'strqq' )                            \n"
        + "          " + $node.reg_mother + ".'add_child'( reg_temp )         \n"
        + "          null reg_temp                                            \n"
        + "# leaving 'STRING'                                                 \n"
      );
    }
  | {
      reg_num++;
      String reg_exp   = "reg_expression_" + reg_num;
      System.out.print( 
          "  # entering 'If node node                                         \n"
        + "      reg_if_op = new 'PAST::Op'                                   \n"
        + "      reg_if_op.'op'( 'if' )                                       \n"
        + "        .sym pmc " + reg_exp + "                                   \n"
        + "        " + reg_exp + " = new 'PAST::Exp'                          \n"
        + "                                                                   \n"
      );
    }
    ^( If node["reg_if_op"] node["reg_if_op"] )
    {
       // Create a node for If
      System.out.print( 
          "  # entering 'STMTS node*'                                         \n"
        + "  " + $node.reg_mother + ".'add_child'( reg_if_op )                \n"
        + "  # leaving 'If node node                                          \n"
      );
    }
  | {
      reg_num++;
      String reg_stmts = "reg_stmts_" + reg_num;
      System.out.print( 
          "        .sym pmc " + reg_stmts + "                                 \n"
        + "        " + reg_stmts + " = new 'PAST::Stmts'                      \n"
      );
    }
    ^( STMTS node[reg_stmts]* )
    {
       // Create a node for If
      System.out.print( 
          "  " + $node.reg_mother + ".'add_child'( " + reg_stmts + " )        \n"
        + "  # leaving 'STMTS node*'                                          \n"
      );
    }
  ;
