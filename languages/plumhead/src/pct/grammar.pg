# Copyright (C) 2006-2008, The Perl Foundation.
# $Id$

# PHP grammar for Plumhead PCT

grammar Plumhead::Grammar is PCT::Grammar;

token TOP                     { ^ <sea_or_code>+ {*} }
token sea_or_code             { <SEA>    {*}   #= SEA
                              | <code>   {*}   #= code
                              }
regex SEA                     { <-[<]>+? ( <before \<> | $ ) {*} } 
rule  code                    { <.CODE_START> <statements>  <.CODE_END>? {*} }
token CODE_START              { '<?php' }
token CODE_END                { '?>' \n? }

rule  statements              { <statement>*           {*} }
rule  statement               { <echo_statement>       {*} <statement_delimiter>  #= echo_statement
                              | <expression>           {*} <statement_delimiter>  #= expression
                              | <if_statement>         {*}                        #= if_statement
                              | <inline_sea>           {*}                        #= inline_sea
                              | <scalar_assign>        {*} <statement_delimiter>  #= scalar_assign
                              | <array_assign>         {*} <statement_delimiter>  #= array_assign
                              }
rule  statement_delimiter     { ';' | <before \? > | $ }
rule  echo_statement          { <ECHO>
                                <expression>
                                {*}
                              }
rule  function_call           { <FUNCTION_NAME> <.PAREN_OPEN> <arguments> <.PAREN_CLOSE> {*} }
rule  arguments               { <expression>*  {*} }
rule  if_statement            { <IF> <.PAREN_OPEN> <relational_expression> <.PAREN_CLOSE>
                                \{ <statements> \}
                                <else_clause>?
                                {*}
                              }
token inline_sea              { <.CODE_END> <SEA_empty_allowed> <.CODE_START> {*} }
rule  scalar_assign           { <var> <ASSIGN_OP> <expression>        {*} }
rule  array_assign            { <array_elem> <ASSIGN_OP> <expression> {*} }

token ECHO                    { 'echo' }
token FUNCTION_NAME           { <IDENT> }
token PAREN_OPEN              { \( }
token PAREN_CLOSE             { \) }

token IDENT                   { <[a..zA..Z_]>+ <[a..zA..Z_0..9]>* }
token VAR_NAME                {  '$' <IDENT> {*} }

token DOUBLEQUOTE_STRING      { '"' <string_literal: '"'> '"'  {*} }
token SINGLEQUOTE_STRING      { \'  <string_literal: '\''> \'  {*} }
token INTEGER                 { \d+              {*} }
token NUMBER                  { ( \d+ )? '.' \d+ {*} }

token UNARY_MINUS             { \- }
token UNARY_PLUS              { \+ }
token CONCAT_OP               { \. }
token ADD_OP                  { \+ | \- }
token MUL_OP                  { '*' | '/' | '%' }
token BITWISE_OP              { '|' | '&' | '^' }
token ASSIGN_OP               { '=' }
token REL_OP                  { '==' | '<=' | '>=' | '!=' | '<'  | '>' }

token IF                      { 'if' }
token ELSE                    { 'else' }

rule  relational_expression   { <expression> <rel_op_clause>? {*} }

rule  else_clause             { <.ELSE> \{ <statements> \} {*} }
rule  rel_op_clause           { <REL_OP> <expression> }
regex SEA_empty_allowed       { <-[<]>*? <before \<> }  # everthing till the next '<'

token expression              { <concat_expression>       {*}  #= concat_expression
                              | <bitwise_expression>      {*}  #= bitwise_expression
                              | <function_call>           {*}  #= function_call
                              }

rule  array_elem              { <VAR_NAME> '[' <array_key> ']' {*} }
rule  array_key               { <expression> {*} }
rule  var                     { <VAR_NAME> {*} }
rule  concat_expression       { <string> <concat_tail>* {*} }
rule  string                  { <DOUBLEQUOTE_STRING> {*}   #= DOUBLEQUOTE_STRING
                              | <SINGLEQUOTE_STRING> {*}   #= SINGLEQUOTE_STRING
                              }
rule  concat_tail             { <CONCAT_OP> <string> }

rule  bitwise_expression      { <adding_expression> <bitwise_tail>? {*} }

rule  bitwise_tail            { <BITWISE_OP> <adding_expression> }

# BUG: this gets precedence  wrong
rule  adding_expression       { <multiplying_expression> <adding_tail>* {*} }

rule  adding_tail             { <ADD_OP> <multiplying_expression> }

# TODO: this gets precedence wrong, see adding_expression
rule  multiplying_expression  { <unary_expression> <multiplicand>? {*} }

rule  multiplicand            { <MUL_OP> <multiplying_expression> }

rule  unary_expression        { <UNARY_MINUS>? <postfix_expression> {*} }

rule  postfix_expression      { <NUMBER>                                   {*}    #= NUMBER
                              | <INTEGER>                                  {*}    #= INTEGER
                              | <.PAREN_OPEN> <expression> <.PAREN_CLOSE>  {*}    #= expression
                              | <array_elem>                               {*}    #= array_elem
                              | <var>                                      {*}    #= var
                              }
