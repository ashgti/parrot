# $Id$

=begin overview

This is the grammar for cardinal written as a sequence of Perl 6 rules.

Currently taken (partly) from:
http://www.math.hokudai.ac.jp/~gotoken/ruby/man/yacc.html

=end overview

grammar cardinal::Grammar is PCT::Grammar;

rule TOP {
    <comp_stmt>
    [ $ || <panic: Syntax error> ]
    {*}
}

token comp_stmt {
    <stmt> [ <.term> <expr> ]* <.term>?
    {*}
}

token term {
    | \n+   ## it's perfectly fine to have multiple whitelines
    | ';'
}

rule stmt {
    <basic_stmt> {*}
}

rule basic_stmt {
    | <expr> {*}            #= expr
}

rule expr {
    | <assignment> {*}      #= assignment
    | <arg> {*}             #= arg
}

rule assignment {
    <mlhs> '=' <mrhs>
    {*}
}

rule mlhs {
    <mlhs_item>
    {*}
}

rule mlhs_item {
    | <lhs> {*}               #= lhs
    | '(' <mlhs> ')' {*}      #= mlhs
}

rule lhs {
    <variable>
    {*}
}

rule variable {
    <varname> {*}
}

rule varname {
    <!reserved_word> <identifier> {*}
}

rule mrhs {
    <args> {*}
}

rule args {
    <arg> [',' <arg>]*
    {*}
}

rule 'arg' is optable { ... }

proto 'infix:=' is precedence('1')      { ... }

proto 'infix:+' is tighter('infix:=')   { ... }

proto 'term:'   is tighter('infix:+')
                is parsed(&primary)     { ... }


rule primary {
    | <literal> {*}        #= literal
    | <variable> {*}       #= variable
    | <functiondef> {*}    #= functiondef
    | <if_stmt> {*}        #= if_stmt
}

rule if_stmt {
    'if' <expr> 'then' <.nl>
    <comp_stmt>
    ['elsif' <expr> 'then' <.nl>
    <comp_stmt>]*
    ['else' <.nl> $<else>=<comp_stmt>]?
    'end'
    {*}
}

rule functiondef {
    'def' <fname> <argdecl> <.nl>
    <comp_stmt>
    'end'
    {*}
}

token nl {
    \n+
}

rule argdecl {
    '(' ')'
}

rule fname {
    | <identifier> {*}          #= identifier
}

token identifier {
    <ident> {*}
}

token literal {
    | <numeric> {*}        #= numeric
    | <string> {*}         #= string
}

token numeric {
    \d+ {*}
}

token string {
    [ \' <string_literal: '> \' | \" <string_literal: "> \" ]
    {*}
}

token reserved_word {
    [alias|and|BEGIN|begin|break|case
    |class|def|defined|do|else|elsif
    |END|end|ensure|false|for|if
    |in|module|next|nil|not|or
    |redo|rescue|retry|return|self|super
    |then|true|undef|unless|until|when
    |while|yield]>>
}

token ws {
    | <after '='> \n
    | <after '+'> \n
    | \h* ['#' \N* \n*]?
}
