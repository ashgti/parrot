=head1 NAME

OSTGrammar -- A grammar for transforming an abstract syntax tree to an
opcode syntax tree.

=head1 SYNOPSYS

  .sub _main :main
      load_bytecode 'OSTGrammar.pir'
      .local pmc grammar
       grammar = new 'OSTGrammar'

      # Construct the "OST"
      load_bytecode "languages/cardinal/src/POST.pir"
      .local pmc ostbuilder
      ostbuilder = grammar.apply(match)
      .local pmc ost
      ost = ostbuilder.get('result')

      end
  .end

=head1 DESCRIPTION


=cut

grammar Cardinal::OSTGrammar is TGE::Grammar;

transform root (ROOT) :language('PIR') {
    $P0 = new .Undef
    store_global 'Cardinal::POST', '$?BLOCK', $P0
    store_global 'Cardinal::PAST', '$?BLOCK', $P0
    #tree.'outerpastblock'($P0)
    #tree.'outerpostblock'($P0)
    .return tree.'get'('post', node)
}

transform post (Cardinal::PAST::Block) :language('PIR') {
    .local string name, blocktype
    name = node.'name'()
    blocktype = node.'blocktype'()
    if name > '' goto with_name
    name = concat '_', blocktype
    name = node.'unique'(name)
  with_name:
    .local pmc outerpost, outerpast

    outerpost = find_global 'Cardinal::POST', '$?BLOCK'
    outerpast = find_global 'Cardinal::PAST', '$?BLOCK'

    .local pmc post
    post = new 'Cardinal::POST::Sub'
    post.'init'('node'=>node, 'name'=>name, 'outer'=>outerpost, 'subtype'=>blocktype)
    store_global 'Cardinal::POST', '$?BLOCK', post
    store_global 'Cardinal::PAST', '$?BLOCK', node

    .local pmc iter
    iter = node.'child_iter'()
  iter_loop:
    unless iter goto iter_end
    .local pmc cpast, cpost
    cpast = shift iter
    cpost = tree.'get'('post', cpast)
    post.'add_child'(cpost)
    goto iter_loop
  iter_end:

    .local pmc value
    value = cpost.'value'()
    value = clone value
    post.'value'(value)

    store_global 'Cardinal::POST', '$?BLOCK', outerpost
    store_global 'Cardinal::PAST', '$?BLOCK', outerpast
    
    ##   For immediate blocks, generate code to execute the block.
    $S0 = node.'blocktype'()
    if $S0 != 'immediate' goto end
    $P0 = post
    post = post.'new'('Cardinal::POST::Ops', $P0, 'node'=>node)
    post.'add_child_new'('Cardinal::POST::Op', post, 'name'=>$P0, 'node'=>node)
  end:
    .return (post)
}

transform post (Cardinal::PAST::Stmts) :language('PIR') {
    .local pmc ops
    ops = new 'Cardinal::POST::Ops'
    ops.'init'('node'=>node)

    .local pmc iter
    iter = node.'child_iter'()
  iter_loop:
    unless iter, iter_end         # while (entries) ...
    $P0 = shift iter
    $P1 = tree.get('post', $P0)
    ops.'add_child'($P1)
    goto iter_loop
  iter_end:
    $P1 = $P1.'value'()
    ops.'value'($P1)
    .return (ops)
}

transform post (Cardinal::PAST::Stmt) :language('PIR') {
    .local pmc past
    .local pmc post
    past = node[0]
    post = tree.get('post', past)
    .return (post)
}

transform post (Cardinal::PAST::Exp) :language('PIR') {
    .local pmc past
    .local pmc post
    past = node[0]
    post = tree.get('post', past)
    .return (post)
}

transform post (Cardinal::PAST::Op) :language('PIR') {
    .local string opname
    .local string pasttype
    .local pmc optable
    .local pmc optoken
    
    opname = node.'name'()
    #optable = get_hll_global [ 'Cardinal'; 'Grammar' ], '$optable'
    optable = get_root_global [ 'parrot'; 'Cardinal::Grammar' ], '$optable'
    optoken = optable[opname]
    unless optoken goto no_optoken
    pasttype = optoken['pasttype']
  no_optoken:
    if pasttype > '' goto dispatch_post
    pasttype = 'simple'
  dispatch_post:
    .return tree.get(pasttype, node)
}

transform postname (Cardinal::PAST::Op) :language('PIR') {
    .local string opname
    .local string postname
    .local pmc optable
    .local pmc optoken
    
    opname = node.'name'()
    #optable = get_hll_global [ 'Cardinal'; 'Grammar' ], '$optable'
    optable = get_root_global [ 'parrot'; 'Cardinal::Grammar' ], '$optable'
    optoken = optable[opname]
  
    unless optoken goto no_optoken
    postname = optoken['post']
  no_optoken:
    if postname > '' goto end
    postname = concat "'", opname 
    postname .= "'"
  end:
    .return (postname)
}

transform simple (Cardinal::PAST::Op) :language('PIR') {
    .local pmc ops
    .local string opname
    .local string postname
    ops = new 'Cardinal::POST::Ops'
    ops.'init'('node'=>node)
    opname = node.'name'()
    postname = tree.'get'('postname', node)

    .local pmc iter
    .local pmc arglist
    iter = node.'child_iter'()
    arglist = new .ResizablePMCArray

  iter_loop:
    unless iter goto iter_end
    .local pmc past
    .local pmc post
    past = shift iter
    $I0 = defined past
    unless $I0 goto iter_loop
    post = tree.'get'('post', past)
    ops.'add_child'(post)
    push arglist, post
    goto iter_loop

  iter_end:

    .local pmc optable
    .local pmc optoken
    .local string opreturn

    #optable = get_hll_global [ 'Cardinal'; 'Grammar' ], '$optable'
    optable = get_root_global [ 'parrot'; 'Cardinal::Grammar' ], '$optable'
    optoken = optable[opname]
    unless optoken goto without_opreturn
    opreturn = optoken['returns']

    #$P0 = get_hll_global ['Cardinal'], 'CardinalParrotClassMap'
    $P0 = get_root_global ['parrot'; 'Cardinal'], 'CardinalParrotClassMap'
    unless $P0 goto without_opreturn
    opreturn = $P0[opreturn]
    unless opreturn goto without_opreturn
  without_opreturn:
    opreturn = '.Undef'
  with_opreturn:
    ops.'add_child_new'('Cardinal::POST::Op', ops, opreturn, 'name'=>'new')
    ops.'add_child_new'('Cardinal::POST::Op', ops, arglist :flat, 'name'=>postname)
    .return (ops)
}

transform assign (Cardinal::PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'Cardinal::POST::Ops'
    ops.'init'('node'=>node)

    .local pmc iter, lpast, rpast
    .local pmc lpost, rpost

    iter = node.'child_iter'()
    lpast = shift iter
    rpast = shift iter
    lpost = tree.'get'('post', lpast)
    lpost.'islvalue'(1)
    rpost = tree.'get'('post', rpast)
    ops.'add_child'(lpost)
    ops.'add_child'(rpost)
    ops.'add_child_new'('Cardinal::POST::Assign', lpost, rpost, 'name'=>'assign')

    #return value 
    .local string value
    value = rpost.'value'()
    ops.'value'(value)
    .return (ops)
}

transform cond (Cardinal::PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'Cardinal::POST::Ops'
    ops.'init'('node'=>node)

    .local pmc exprpast, thenpast, elsepast
    .local pmc exprpost, thenpost, elsepost
    exprpast = node[0]
    thenpast = node[1]
    elsepast = node[2]

    .local pmc thenlabel, endlabel
    thenlabel = ops.'new'('Cardinal::POST::Label', 'name'=>'if_then')
    endlabel = ops.'new'('Cardinal::POST::Label', 'name'=>'if_end')

    exprpost = tree.'get'('post', exprpast)
    ops.'add_child'(exprpost)
    ops.'add_child_new'('Cardinal::POST::Op', exprpost, thenlabel, 'name'=>'if')
    
    elsepost = exprpost
    $I0 = defined elsepast
    unless $I0 goto cond_no_else
    elsepost = tree.'get'('post', elsepast)
    ops.'add_child'(elsepost)
  cond_no_else:
    ops.'add_child_new'('Cardinal::POST::Op', ops, elsepost, 'name'=>'set')
    ops.'add_child_new'('Cardinal::POST::Op', endlabel, 'name'=>'goto')
    ops.'add_child'(thenlabel)

    thenpost = exprpost
    $I0 = defined thenpast
    unless $I0 goto cond_no_then
    thenpost = tree.'get'('post', thenpast)
    ops.'add_child'(thenpost)
  cond_no_then:
    ops.'add_child_new'('Cardinal::POST::Op', ops, thenpost, 'name'=>'set')
    ops.'add_child'(endlabel)
    .return (ops)
}


transform xor (Perl6::PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'Perl6::POST::Ops'
    ops.'init'('node'=>node)

    .local pmc endlabel, falselabel
    falselabel = ops.'new'('Perl6::POST::Label', 'name'=>'xor_false')
    endlabel = ops.'new'('Perl6::POST::Label', 'name'=>'xor_end')

    .local pmc iter, apast, apost, i, t, u
    i = ops.unique('$I')
    t = ops.unique('$I')
    u = ops.unique('$I')
    iter = node.'child_iter'()
    apast = shift iter
    apost = tree.'get'('post', apast)
    ops.'add_child'(apost)
    ops.'add_child_new'('Perl6::POST::Op', ops, apost, 'name'=>'set')
    ops.'add_child_new'('Perl6::POST::Op', t, apost, 'name'=>'istrue')
  inner_child:
    .local pmc bpast, bpost
    bpast = shift iter
    bpost = tree.'get'('post', bpast)
    ops.'add_child'(bpost)
    ops.'add_child_new'('Perl6::POST::Op', u, bpost, 'name'=>'istrue')
    ops.'add_child_new'('Perl6::POST::Op', i, t, u, 'name'=>'and')
    ops.'add_child_new'('Perl6::POST::Op', i, falselabel, 'name'=>'if')
    unless iter goto last_child
    .local pmc s
    s = ops.'new'('Perl6::POST::Label', 'name'=>'xor_skip')
    ops.'add_child_new'('Perl6::POST::Op', t, s, 'name'=>'if')
    ops.'add_child_new'('Perl6::POST::Op', ops, bpost, 'name'=>'set')
    ops.'add_child_new'('Perl6::POST::Op', t, u, 'name'=>'set')
    ops.'add_child'(s)
    goto inner_child
  last_child:
    ops.'add_child_new'('Perl6::POST::Op', t, endlabel, 'name'=>'if')
    ops.'add_child_new'('Perl6::POST::Op', ops, bpost, 'name'=>'set')
    ops.'add_child_new'('Perl6::POST::Op', endlabel, 'name'=>'goto')
    ops.'add_child'(falselabel)
    ops.'add_child_new'('Perl6::POST::Op', ops, '.Undef', 'name'=>'new')
    ops.'add_child'(endlabel)
    .return (ops)
}


transform chain (Perl6::PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'Perl6::POST::Ops'
    ops.'init'('node'=>node)

    .local string opname, pasttype
    .local pmc optable, optok
    #optable = get_hll_global [ 'Cardinal'; 'Grammar' ], '$optable'
    optable = get_root_global [ 'parrot'; 'Cardinal::Grammar' ], '$optable'

    .local pmc childrenlist
    childrenlist = new .ResizablePMCArray
  chain_loop:
    $I0 = isa node, 'Perl6::PAST::Op'
    if $I0 == 0 goto chain_end
    opname = node.'name'()
    optok = optable[opname]
    pasttype = optok['pasttype']
    if pasttype != 'chain' goto chain_end
    push childrenlist, node
    node = node[0]
    goto chain_loop
  chain_end:

    .local pmc endlabel, apast, apost
    node = pop childrenlist
    endlabel = ops.'new'('Perl6::POST::Label', 'name'=>'chain_end')
    apast = node[0]
    apost = tree.'get'('post', apast)
    ops.'add_child'(apost)

  childrenlist_loop:
    .local pmc bpast, bpost
    .local string postname
    bpast = node[1]
    bpost = tree.'get'('post', bpast)
    postname = tree.'get'('postname', node)
    ops.'add_child'(bpost)
    ops.'add_child_new'('Perl6::POST::Op', ops, apost, bpost, 'name'=>postname)
    unless childrenlist goto childrenlist_end
    ops.'add_child_new'('Perl6::POST::Op', ops, endlabel, 'name'=>'unless')
    apost = bpost
    node = pop childrenlist
    goto childrenlist_loop
  childrenlist_end:
    ops.'add_child'(endlabel)
    .return (ops)
}


transform post (Cardinal::PAST::Val) :language('PIR') {
    .local string val
    .local string valtype
    .local string objtype
    val = node.'name'()
    valtype = node.'valtype'()
    unless valtype == 'string' goto n1
    #objtype = '.RubyString'
    objtype = '.String'
    goto with_objtype
    n1:
    unless valtype == 'Integer' goto n2
    #objtype = '.RubyInteger'
    objtype = '.Integer'
    goto with_val
    n2:
    unless valtype == 'float' goto n3
    #objtype = '.RubyFloat'
    objtype = '.Float'
    goto with_val
    n3:
    objtype = '.Undef'

  with_objtype:
    val = escape val
    val = concat '"', val
    val = concat val, '"'

    #unicode check    
    $I0 = index val, '\x'
    unless $I0 > 0 goto with_val
    val = concat 'unicode:', val

  with_val:
    .local pmc ops
    ops = new 'Cardinal::POST::Ops'
    ops.'init'('node'=>node)
    ops.'add_child_new'('Cardinal::POST::Op', ops, objtype, 'name'=>'new')
    $P0 = ops.'new'('Cardinal::POST::Val', 'valtype'=>valtype, 'value'=>val)
    ops.'add_child_new'('Cardinal::POST::Op', ops, $P0, 'name'=>'assign')
    .return (ops)
}

transform post (Cardinal::PAST::Var) :language('PIR') {
    .local string name
    .local string scope
    .local pmc post
    name = node.'name'()
    scope = node.'scope'()

    if scope == 'package' goto with_name
    if scope == 'lecical' goto with_name
    if scope == 'parameter' goto with_name

    .local pmc outer
    #outer = tree.'outer_block'()
    outer = find_global 'Cardinal::PAST', '$?BLOCK'

  outer_loop:
    $I0 = isa outer, 'Cardinal::PAST::BLOCK'
    unless $I0 goto with_name
    $P0 = outer.'vardecl'(name)
    $I0 = isa outer, 'Cardinal::PAST::Var'
    unless $I0 goto outer_next
    $S0 = $P0.'scope'()
    ne $S0, 'outer', outer_end
  outer_next:
    outer = outer.'outer'()
    goto outer_loop

  outer_end:
    scope .= $S0

  with_name:
    post = new 'Cardinal::POST::Var'
    post.'init'('node'=>node, 'name'=>name, 'scope'=>scope)
    .return (post)
}

=head1 LICENSE

Copyright (C) 2006, The Perl Foundation.

This is free software; you may redistribute it and/or modify
it under the same terms as Parrot.

=head1 AUTHOR

Kevin Tew <tewk@tewk.com>

=cut
