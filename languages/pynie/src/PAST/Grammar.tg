grammar Pynie::PAST::Grammar is TGE::Grammar;

transform past (ROOT) :language('PIR') {
    node = node['file_input']
    .local pmc past
    past = new 'PAST::Block'
    past.'init'('node'=>node, 'name'=>'anon')
    .local pmc iter
    $P0 = node['statement']
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'Pynie::Grammar::statement')
    past.'push'(cpast)
    goto iter_loop
  iter_end:
    .return (past)
}


transform past (Pynie::Grammar::statement) :language('PIR') {
  stmt_list:
    $P0 = node['stmt_list']
    if null $P0 goto compound_stmt
    .return tree.'get'('past', $P0, 'Pynie::Grammar::stmt_list')

  compound_stmt:
    $P0 = node['compound_stmt']
  if_stmt:
    $P1 = $P0['if_stmt']
    if null $P1 goto while_stmt
    .return tree.'get'('past', $P1, 'Pynie::Grammar::if_stmt')
  while_stmt:
    $P1 = $P0['while_stmt']
    if null $P1 goto for_stmt
    .return tree.'get'('past', $P1, 'Pynie::Grammar::while_stmt')
  for_stmt:
    $P1 = $P0['for_stmt']
    if null $P1 goto try_stmt
    .return tree.'get'('past', $P1, 'Pynie::Grammar::for_stmt')
  try_stmt:
    $P1 = $P0['try_stmt']
    if null $P1 goto with_stmt
    .return tree.'get'('past', $P1, 'Pynie::Grammar::try_stmt')
  with_stmt:
    $P1 = $P0['with_stmt']
    if null $P1 goto funcdef
    .return tree.'get'('past', $P1, 'Pynie::Grammar::with_stmt')
  funcdef:
    $P1 = $P0['funcdef']
    if null $P1 goto classdef
    .return tree.'get'('past', $P1, 'Pynie::Grammar::funcdef')
  classdef:
    $P1 = $P0['classdef']
    .return tree.'get'('past', $P1, 'Pynie::Grammar::classdef')
}


transform past (Pynie::Grammar::stmt_list) :language('PIR') {
    .local pmc past
    past = new 'PAST::Stmts'
    past.'init'('node'=>node)

    .local pmc iter
    $P0 = node['simple_stmt']
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'Pynie::Grammar::simple_stmt')
    past.'push'(cpast)
    goto iter_loop
  iter_end:
    .return (past)
}


transform past (Pynie::Grammar::simple_stmt) :language('PIR') {
    .local pmc hash, iter, cnode
    .local string key
    hash = node.'get_hash'()
    iter = new .Iterator, hash
    key = shift iter
    cnode = hash[key]
    key = concat 'Pynie::Grammar::', key
    ##printerr "past::simple_stmt; invoking "
    ##printerr key
    ##printerr "\n"
    .return tree.'get'('past', cnode, key)
}

transform past (Pynie::Grammar::assert_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'

## From http://docs.python.org/ref/assert.html
##    The simple form, "assert expression", is equivalent to
##
##if __debug__:
##   if not expression: raise AssertionError
##
##The extended form, "assert expression1, expression2", is equivalent to
##
##if __debug__:
##   if not expression1: raise AssertionError, expression2
##
    #past.'init'('node'=>node, 'pasttype'=>'if')
    #$P0 = node['expression']


    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# assert_stmt not implemented')
    .return (past)

}

transform past (Pynie::Grammar::augmented_assignment_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# augmented assignment stmt not implemented')
    .return (past)
}

transform past (Pynie::Grammar::expression_stmt) :language('PIR') {
    $P0 = node['expression_list']
    .return tree.'get'('past', $P0, 'Pynie::Grammar::expression_list')
}

transform past (Pynie::Grammar::del_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# del stmt not implemented')
    .return (past)
}

# Handle "pass" statement; only emit a comment
# Alternative would be to _not_ create a PAST node, but then
# extra logic would be necessary in both stmt_list() and simple_stmt().
#
transform past (Pynie::Grammar::pass_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# pass')
    .return (past)
}

transform past (Pynie::Grammar::return_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'pirop', 'pirop'=>'return')
    $P0 = node['expression_list']

## FIX:
## Returning something does not work; 'method 'from' not found...
    if null $P0 goto skip_expression_list
    .local pmc expr_list_past
    expr_list_past = tree.'get'('past', $P0, 'Pynie::Grammar::expression_list')
    past.'push'(expr_list_past)
  skip_expression_list:
    .return (past)
}

## FIX:
## generated code is nonsense for yield_stmt
transform past (Pynie::Grammar::yield_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'pirop', 'pirop'=>'yield')
    $P0 = node['expression_list']
    .local pmc expr_list_past
    expr_list_past = tree.'get'('past', $P0, 'Pynie::Grammar::expression_list')
    past.'push'(expr_list_past)
    .return (past)
}

transform past (Pynie::Grammar::break_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# break not implemented')
    .return (past)
}

transform past (Pynie::Grammar::continue_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# continue not implemented')
    .return (past)
}

transform past (Pynie::Grammar::print_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'name'=>'print')

    ###printerr "expression\n"
 #   $P0 = node[0]
 #   $S0 = $P0[0]
 #   if $S0 == ',' goto skip_nl
 #   past.'name'('printnl')
  skip_nl:

    ###printerr "get print expression\n"
    .local pmc iter
    $P0 = node['expression']
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'Pynie::Grammar::expression')
    past.'push'(cpast)
    goto iter_loop
  iter_end:
    .return (past)
}

transform past (Pynie::Grammar::import_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# import stmt not implemented')
    .return (past)
}

transform past (Pynie::Grammar::raise_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# raise stmt not implemented')
    .return (past)
}

transform past (Pynie::Grammar::global_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# global stmt not implemented')
    .return (past)
}



transform past (Pynie::Grammar::expression) :language('PIR') {
    $P0 = node['or_test']
    $P0 = $P0[0] # this is a hack, 'rule expression' has 1 or more <or_test>s, so it stores them in an array. Handle $P0[1] later.
    #printerr "pynie::grammar::expression\n"
    .return tree.'get'('past', $P0, 'Pynie::Grammar::or_test')
}

transform past (Pynie::Grammar::or_test) :language('PIR') {
    $P0 = node['and_test']
    $P0 = $P0[0] # this is a hack, 'rule expression' has 1 or more <or_test>s, so it stores them in an array. Handle $P0[1] later.
    #printerr "pynie::grammar::or_test\n"
    .return tree.'get'('past', $P0, 'Pynie::Grammar::and_test')
}

transform past (Pynie::Grammar::and_test) :language('PIR') {
    $P0 = node['not_test']
    $P0 = $P0[0] # this is a hack, 'rule expression' has 1 or more <or_test>s, so it stores them in an array. Handle $P0[1] later.
    #printerr "pynie::grammar::and_test\n"
    .return tree.'get'('past', $P0, 'Pynie::Grammar::not_test')
}

transform past (Pynie::Grammar::not_test) :language('PIR') {
    $P0 = node['not_in_test']
    #printerr "pynie::grammar::not_test\n"
    .return tree.'get'('past', $P0, 'Pynie::Grammar::not_in_test')
}

transform past (Pynie::Grammar::not_in_test) :language('PIR') {
    $P0 = node['is_not_test']
    $P0 = $P0[0] # this is a hack, 'rule expression' has 1 or more <or_test>s, so it stores them in an array. Handle $P0[1] later.
    #printerr "pynie::grammar::not_in_test\n"
    .return tree.'get'('past', $P0, 'Pynie::Grammar::is_not_test')
}

transform past (Pynie::Grammar::is_not_test) :language('PIR') {
    $P0 = node['comparison']
    $P0 = $P0[0]
    $P0 = $P0['expr']
    #printerr "pynie::grammar::is_not_test\n"
    .return tree.'get'('past', $P0, 'Pynie::Grammar::expr')
}

transform past (Pynie::Grammar::expr) :language('PIR') {
    .local string type
    type = node['type']

    if type == 'term:' goto past_term

    .local pmc optable, optok
    .local string pasttype, pirop, returns
    .local int islvalue
    ##printerr "ok 1\n"
    optable = get_hll_global [ 'Pynie::Grammar' ], '$optable'
    optok = optable[type]
    ##printerr "ok 2\n"
    pasttype = optok['past']
    ##printerr "ok 3\n"
    pirop = optok['pirop']
    ##printerr "ok 4\n"
    returns = optok['returns']
    ##printerr "ok 5\n"
    islvalue = optok['lvalue']
    ##printerr "ok 6\n"

    .local pmc past, iter
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'name'=>type, 'pasttype'=>pasttype, 'pirop'=>pirop, 'returns'=>returns)

    $P0 = node.'get_array'()
    if null $P0 goto iter_end
    iter = new .Iterator, $P0
    unless iter goto iter_end
    $P0[0;'islvalue'] = islvalue

  iter_loop:
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'Pynie::Grammar::expr')
    if null cpast goto iter_loop
    past.'push'(cpast)
    if iter goto iter_loop
  iter_end:
    .return (past)

  past_term:
#   .return tree.'get'('past_term', node, 'Pynie::Grammar::expr')
    $P0 = node['atom']
    .return tree.'get'('past', $P0, 'Pynie::Grammar::atom')

}

transform past (Pynie::Grammar::primary) :language('PIR') {
    .local pmc atomnode, atompast
    atomnode = node['atom']
    atompast = tree.'get'('past', atomnode, 'Pynie::Grammar::atom')
    .return (atompast)
}

transform past (Pynie::Grammar::atom) :language('PIR') {
    .local pmc cnode
  identifier:
    cnode = node['identifier']
    if null cnode goto literal
    #printerr "atom::identifier\n"
    .return tree.'get'('past', cnode, 'Pynie::Grammar::identifier')
  literal:
    cnode = node['literal']
    if null cnode goto enclosure
    .return tree.'get'('past', cnode, 'Pynie::Grammar::literal')
  enclosure:
    cnode = node['enclosure']
    .return tree.'get'('past', cnode, 'Pynie::Grammar::enclosure')
}

#transform past_term (Pynie::Grammar::expr) :language('PIR') {
#    .local pmc cnode
#    cnode = node['literal']
#    if null cnode goto list_display
#    .return tree.'get'('past', cnode, 'Pynie::Grammar::literal')
#  list_display:
#    cnode = node['list_display']
#    if null cnode goto identifier
#    .return tree.'get'('past', cnode, 'Pynie::Grammar::list_display')
#  identifier:
#    cnode = node['identifier']
#    .return tree.'get'('past', cnode, 'Pynie::Grammar::identifier')
#}


transform past (Pynie::Grammar::literal) :language('PIR') {
    .local pmc past, cnode
    cnode = node['integer']
    unless null cnode goto integer
    cnode = node['stringliteral']
    unless null cnode goto stringliteral
    cnode = node['longinteger']
    unless null cnode goto longinteger
    cnode = node['floatnumber']
    unless null cnode goto floatnumber
    cnode = node['imagnumber']
    unless null cnode goto imagnumber
    #printerr "Error in past::literal\n"
    exit 1

  integer:
    past = new 'PAST::Val'
    past.'init'('node'=>cnode, 'vtype'=>'.Integer', 'name'=>node, 'ctype'=>'i+')
    .return (past)

  stringliteral:
    past = new 'PAST::Val'
    $S0 = cnode
    past.'init'('node'=>cnode, 'vtype'=>'.Undef', 'name'=>$S0)
    .return (past)

  longinteger:

  floatnumber:

  imagnumber:

}


transform past (Pynie::Grammar::list_display) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'name'=>'listmaker')

    $P0 = node['listmaker']
    unless $P0 goto end
    $P0 = $P0[0]
    $P0 = $P0['expression']
    .local pmc iter
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'Pynie::Grammar::expression')
    past.'push'(cpast)
    goto iter_loop
  iter_end:
  end:
    .return (past)
}


transform past (Pynie::Grammar::identifier) :language('PIR') {
    .local pmc past
    $P0 = new .Iterator, node
    #printerr "'"
    #printerr node
    #printerr "'\n"
   L1:
    unless $P0 goto L2
    $P1 = shift $P0
    #printerr $P1
    #printerr "\n"
    goto L1
   L2:

    $S0 = node['identifier']
    past = new 'PAST::Var'
    past.'init'('node'=>node, 'name'=>$S0, 'scope'=>'package')
    .return (past)
}


transform past (Pynie::Grammar::assignment_stmt) :language('PIR') {
    .local pmc tnode, tpast, enode, epast, past
    $P0 = node['target_list']
    tnode = $P0[0]
    tpast = tree.'get'('past', tnode, 'Pynie::Grammar::target_list')
    enode = node['expression_list']
    epast = tree.'get'('past', enode, 'Pynie::Grammar::expression_list')
    past = epast.'new'('PAST::Op', tpast, epast, 'pasttype'=>'bind', 'node'=>node)
    .return (past)
}


transform past (Pynie::Grammar::target_list) :language('PIR') {
    .local pmc past
    past = new 'PAST::VarList'
    past.'init'('node'=>node)

    .local pmc targetiter
    $P0 = node['target']
    targetiter = new .Iterator, $P0
  iter_loop:
    unless targetiter goto iter_end
    .local pmc targetnode, targetpast
    targetnode = shift targetiter
    targetpast = tree.'get'('past', targetnode, 'Pynie::Grammar::identifier')
    $S0 = targetpast['name']
    past.'push_new'('PAST::Var', 'name'=>$S0, 'islvalue'=>1, 'scope'=>'package')
    goto iter_loop
  iter_end:
    .return (past)
}


transform past (Pynie::Grammar::expression_list) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'name'=>'listmaker')
    .local pmc expriter
    $P0 = node['expression']
    expriter = new .Iterator, $P0
  iter_loop:
    unless expriter goto iter_end
    .local pmc enode, epast
    enode = shift expriter
    epast = tree.'get'('past', enode, 'Pynie::Grammar::expression')
    past.'push'(epast)
    goto iter_loop
  iter_end:
    .return (past)
}


transform past (Pynie::Grammar::if_stmt) :language('PIR') {
    .local pmc exprlist, suitelist
    exprlist = node['expression']
    suitelist = node['suite']

    ##   do we have an else clause?
    .local pmc elsenode, elsepast
    .local int exprc, suitec
    null elsepast
  else_suite:
    exprc = elements exprlist
    suitec = elements suitelist
    if suitec <= exprc goto expr_suite_pair
    dec suitec
    elsenode = suitelist[suitec]
    elsepast = tree.'get'('past', elsenode, 'Pynie::Grammar::suite')
    elsepast.'suitetype'('immediate')

  expr_suite_pair:
    ##   each remaining suite is paired with an "if" (or "elsif")
    ##   expression, except the first which could be "unless".
    .local pmc exprnode, exprpast, thennode, thenpast
    dec exprc
    exprnode = exprlist[exprc]
    exprpast = tree.'get'('past', exprnode, 'Pynie::Grammar::expression')
    thennode = suitelist[exprc]
    thenpast = tree.'get'('past', thennode, 'Pynie::Grammar::suite')
    .local pmc past
    past = new 'PAST::Op'
    past.'init'(exprpast, thenpast, elsepast, 'node'=>node, 'pasttype'=>'if')
    elsepast = past
    if exprc > 0 goto expr_suite_pair
    past.'pasttype'('if')
    .return (past)
}


transform past (Pynie::Grammar::while_stmt) :language('PIR') {
   # .local pmc past
   # past = new 'PAST::Op'
   # past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# while stmt not implemented')
   # .return (past)

    .local pmc exprnode, stmtnode
    exprnode = node['expression']
    stmtnode = node['suite']
    stmtnode = stmtnode[0]

    .local pmc past, exprpast, stmtpast
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'while')
    exprpast = tree.'get'('past', exprnode, 'Pynie::Grammar::expression')
    past.'push'(exprpast)
    stmtpast = tree.'get'('past', stmtnode, 'Pynie::Grammar::suite')
    past.'push'(stmtpast)
    .return (past)
}

## FIX: complete this
transform past (Pynie::Grammar::for_stmt) :language('PIR') {

    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# for stmt not implemented')
    .return (past)

#   .local pmc tlistnode, elistnode, suitenode
#   tlistnode = node['target_list']
#   elistnode = node['expression_list']
#   suitenode = node['suite']
#
#   .local pmc past, tlistpast, elistpast, suitepast
#   past = new 'PAST::Op'
#   past.'init'('node'=>node, 'pasttype'=>'while')
#
#   tlistpast = tree.'get'('past', tlistnode, 'Pynie::Grammar::target_list')
#   #past.'push'(tlistpast)
#
#   elistpast = tree.'get'('past', elistnode, 'Pynie::Grammar::expression_list')
#   past.'push'(elistpast)
#
#   suitepast = tree.'get'('past', suitenode, 'Pynie::Grammar::suite')
#   past.'push'(suitepast)
#
#   .return (past)
}

transform past (Pynie::Grammar::try_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# try stmt not implemented')
    .return (past)
}

transform past (Pynie::Grammar::with_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# with stmt not implemented')
    .return (past)
}

transform past (Pynie::Grammar::funcdef) :language('PIR') {

    .local pmc past
    past = new 'PAST::Block'

    .local pmc decnode, fnamenode, plistnode, suitenode
#   decnode   = node['decorators']
    fnamenode = node['funcname']
#   plistnode = node['parameter_list']
#   suitenode = node['suite']
#
#   .local pmc past
#   past = new 'PAST::Block'
#
#   if null decnode goto skip_decorators
#   # handle decorators
#   #printerr "Function decorators not implemented!\n"
#   exit 1
#
# skip_decorators:
    .local pmc fnamepast
    fnamepast = tree.'get'('past', fnamenode, 'Pynie::Grammar::funcname')
#
#   if null plistnode goto skip_parameter_list
#   #.local plistpast
#   #plistpast = tree.'get'('past', plistnode, 'Pynie::Grammar::parameter_list')
#   #printerr "Parameters not implemented!\n"
#   exit 1
#
# skip_parameter_list:
#   .local pmc stmtpast
#   stmtpast = tree.'get'('past', suitenode, 'Pynie::Grammar::suite')
#
#   # FIX
#   past.'init'('node'=>node, 'name'=>fnamepast)
#   .local pmc past
#
    past.'init'('node'=>node, 'name'=>fnamepast)
    .return (past)
}

transform past (Pynie::Grammar::funcname) :language('PIR') {
    $P0 = node['identifier']
    .return tree.'get'('past', $P0, 'Pynie::Grammar::identifier')
}


## FIX: fix this, not sure about how to handle instructions such
## as subclass etc.
##
transform past (Pynie::Grammar::classdef) :language('PIR') {

    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# classdef stmt not implemented')
    .return (past)

#   .local pmc past
#   past = new 'PAST::Stmts'
#   past.'init'('node'=>node)
#
#   .local pmc instr
#   instr = new 'PAST::Op'
#
#   $P0 = node['inheritance']
#   if null $P0 goto skip_inheritance
#   instr.'init'('node'=>node, 'pasttype'=>'pirop', 'pirop'=>'subclass')
#   # inheritancenot implemented right now
#   goto handle_class_body
#
# skip_inheritance:
#   instr.'init'('node'=>node, 'pasttype'=>'pirop', 'pirop'=>'newclass')
#   $P0 = node['classname']
#   $P1 = tree.'get'('past', $P0, 'Pynie::Grammar::classname')
#   instr.'push'($P1)
#
# handle_class_body:
#   # add newclass or subclass instruction to Stmts node
#   past.'push'(instr)
#
#   # add a .namespace[ <class_id> ] instruction to add methods?
#   $P0 = node['suite']
#   $P1 = tree.'get'('past', $P0, 'Pynie::Grammar::suite')
#   past.'push'($P1)
#
#
# done:
#   .return (past)
}

## FIX: Return class name as a string, not using "get_global" as in identifier.
transform past (Pynie::Grammar::classname) :language('PIR') {
    $P0 = node['identifier']
    .return tree.'get'('past', $P0, 'Pynie::Grammar::identifier')
}

transform past (Pynie::Grammar::inheritance) :language('PIR') {
    $P0 = node['expression_list']
    .return tree.'get'('past', $P0, 'Pynie::Grammar::expression_list')
}

transform past (Pynie::Grammar::suite) :language('PIR') {
    $P0 = node['stmt_list']
    if null $P0 goto statements
    .return tree.'get'('past', $P0, 'Pynie::Grammar::stmt_list')

  statements:
    .local pmc past, iter
    past = new 'PAST::Stmts'
    past.'init'('node'=>node)
    $P0 = node['statement']
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'Pynie::Grammar::statement')
    past.'push'(cpast)
    goto iter_loop
  iter_end:
    .return (past)
}

