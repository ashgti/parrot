grammar Pynie::PAST::Grammar is TGE::Grammar;

transform past (ROOT) :language('PIR') {
    node = node['file_input']
    .local pmc past
    past = new 'PAST::Block'
    past.'init'('node'=>node, 'name'=>'anon')
    .local pmc iter
    $P0 = node['statement']
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'Pynie::Grammar::statement')
    past.'push'(cpast)
    goto iter_loop
  iter_end:
    .return (past)
}


transform past (Pynie::Grammar::statement) :language('PIR') {
  stmt_list:
    $S0 = node.'find_key'()
    $P0 = node[$S0]
    $S0 = concat 'Pynie::Grammar::', $S0
    .return tree.'get'('past', $P0, $S0)
}

transform past (Pynie::Grammar::compound_stmt) :language('PIR') {
    $S0 = node.'find_key'()
    $P0 = node[$S0]
    $S0 = concat 'Pynie::Grammar::', $S0
    .return tree.'get'('past', $P0, $S0)
}


transform past (Pynie::Grammar::stmt_list) :language('PIR') {
    .local pmc past
    past = new 'PAST::Stmts'
    past.'init'('node'=>node)

    .local pmc iter
    $P0 = node['simple_stmt']
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'Pynie::Grammar::simple_stmt')
    past.'push'(cpast)
    goto iter_loop
  iter_end:
    .return (past)
}


transform past (Pynie::Grammar::simple_stmt) :language('PIR') {
    .local string key
    .local pmc cnode
    key = node.'find_key'()
    cnode = node[key]
    key = concat 'Pynie::Grammar::', key
    .return tree.'get'('past', cnode, key)
}

transform past (Pynie::Grammar::assert_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'

## From http://docs.python.org/ref/assert.html
##    The simple form, "assert expression", is equivalent to
##
##if __debug__:
##   if not expression: raise AssertionError
##
##The extended form, "assert expression1, expression2", is equivalent to
##
##if __debug__:
##   if not expression1: raise AssertionError, expression2
##
    #past.'init'('node'=>node, 'pasttype'=>'if')
    #$P0 = node['expression']


    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# assert_stmt not implemented')
    .return (past)

}

transform past (Pynie::Grammar::augmented_assignment_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# augmented assignment stmt not implemented')
    .return (past)
}

transform past (Pynie::Grammar::expression_stmt) :language('PIR') {
    $P0 = node['expression_list']
    .return tree.'get'('past', $P0, 'Pynie::Grammar::expression_list')
}

transform past (Pynie::Grammar::del_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# del stmt not implemented')
    .return (past)
}

# Handle "pass" statement; only emit a comment
# Alternative would be to _not_ create a PAST node, but then
# extra logic would be necessary in both stmt_list() and simple_stmt().
#
transform past (Pynie::Grammar::pass_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# pass')
    .return (past)
}

transform past (Pynie::Grammar::return_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'pirop', 'pirop'=>'return')
    $P0 = node['expression_list']

## FIX:
## Returning something does not work; 'method 'from' not found...
    if null $P0 goto skip_expression_list
    .local pmc expr_list_past
    expr_list_past = tree.'get'('past', $P0, 'Pynie::Grammar::expression_list')
    past.'push'(expr_list_past)
  skip_expression_list:
    .return (past)
}

## FIX:
## generated code is nonsense for yield_stmt
transform past (Pynie::Grammar::yield_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'pirop', 'pirop'=>'yield')
    $P0 = node['expression_list']
    .local pmc expr_list_past
    expr_list_past = tree.'get'('past', $P0, 'Pynie::Grammar::expression_list')
    past.'push'(expr_list_past)
    .return (past)
}

transform past (Pynie::Grammar::break_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# break not implemented')
    .return (past)
}

transform past (Pynie::Grammar::continue_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# continue not implemented')
    .return (past)
}

transform past (Pynie::Grammar::print_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'name'=>'print')

    $P0 = node[0]
    $S0 = $P0[0]
    if $S0 == ',' goto skip_nl
    past.'name'('printnl')
  skip_nl:

    .local pmc iter
    $P0 = node['expression']
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'Pynie::Grammar::expression')
    past.'push'(cpast)
    goto iter_loop
  iter_end:
    .return (past)
}

transform past (Pynie::Grammar::import_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# import stmt not implemented')
    .return (past)
}

transform past (Pynie::Grammar::raise_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# raise stmt not implemented')
    .return (past)
}

transform past (Pynie::Grammar::global_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# global stmt not implemented')
    .return (past)
}


transform past (Pynie::Grammar::expression) :language('PIR') {
    $P0 = node['or_test']
    $P0 = $P0[0] # this is a hack, 'rule expression' has 1 or more <or_test>s, so it stores them in an array. Handle $P0[1] later.
    #printerr "pynie::grammar::expression\n"
    .return tree.'get'('past', $P0, 'Pynie::Grammar::or_test')
}

transform past (Pynie::Grammar::or_test) :language('PIR') {
    .local pmc past, iter, clist, cnode
    clist = node['and_test']
    clist = clone clist
    cnode = pop clist
    past = tree.'get'('past', cnode, 'Pynie::Grammar::and_test')
    unless clist goto end
  clist_loop:
    cnode = pop clist
    $P0 = tree.'get'('past', cnode, 'Pynie::Grammar::and_test')
    past = past.'new'('PAST::Op', $P0, past, 'node'=>node, 'pasttype'=>'unless')
    if clist goto clist_loop
  end:
    .return (past)
}

transform past (Pynie::Grammar::and_test) :language('PIR') {
  .local pmc past, iter, clist, cnode
    clist = node['not_test']
    clist = clone clist
    cnode = pop clist
    past = tree.'get'('past', cnode, 'Pynie::Grammar::not_test')
    unless clist goto end
  clist_loop:
    cnode = pop clist
    $P0 = tree.'get'('past', cnode, 'Pynie::Grammar::not_test')
    past = past.'new'('PAST::Op', $P0, past, 'node'=>node, 'pasttype'=>'if')
    if clist goto clist_loop
  end:
    .return (past)
}

transform past (Pynie::Grammar::not_test) :language('PIR') {
    .local string key, fullkey
    .local pmc cnode, past, notpast

    cnode = node['not_test']
    if null cnode goto do_in_test
    notpast = tree.'get'('past', cnode, 'Pynie::Grammar::not_test')

    past = new 'PAST::Op'
    past.'init'('node'=>cnode, 'pasttype'=>'pirop', 'pirop'=>'not')
    past.'push'(notpast)

    .return (past)

  do_in_test:
    cnode = node['in_test']
    past = tree.'get'('past', cnode, 'Pynie::Grammar::in_test')
    .return (past)
}

transform past (Pynie::Grammar::in_test) :language('PIR') {
    .local pmc past, iter, clist, cnode
    clist = node['is_test']
    clist = clone clist
    cnode = pop clist
    past = tree.'get'('past', cnode, 'Pynie::Grammar::is_test')
    unless clist goto end
  clist_loop:
    cnode = pop clist
    $P0 = tree.'get'('past', cnode, 'Pynie::Grammar::is_test')
    #
    # FIX THIS; also check for "not"
    #
    past = past.'new'('PAST::Op', $P0, past, 'node'=>node, 'pasttype'=>'pirop', 'pirop'=>'IN (FIX)')
    if clist goto clist_loop
  end:
    .return (past)
}

transform past (Pynie::Grammar::is_test) :language('PIR') {
    .local pmc past, iter, clist, cnode
    .local int hasnot

    hasnot = 1
    # HACK:
    # TODO: figure out how presence of "not" can be checked.
    # then set flag for each iteration.

    clist = node['comparison']
    clist = clone clist

    cnode = pop clist
    past = tree.'get'('past', cnode, 'Pynie::Grammar::comparison')
    unless clist goto end

  clist_loop:
    cnode = pop clist
    $P0 = tree.'get'('past', cnode, 'Pynie::Grammar::comparison')
  if hasnot == 0 goto do_issame
    $S0 = "isntsame"
    goto done
  do_issame:
    $S0 = "issame"
  done:
    past = past.'new'('PAST::Op', $P0, past, 'node'=>node, 'pasttype'=>'pirop', 'pirop'=>$S0)
    if clist goto clist_loop
  end:
    .return (past)
}


transform past (Pynie::Grammar::comparison) :language('PIR') {
    $P0 = node['expr']
    .return tree.'get'('past', $P0, 'Pynie::Grammar::expr')
}

transform past (Pynie::Grammar::expr) :language('PIR') {
    .local string type
    type = node['type']

    if type == 'term:' goto past_term

    .local pmc optable, optok
    .local string pasttype, pirop, returns
    .local int islvalue
    optable = get_hll_global [ 'Pynie::Grammar' ], '$optable'
    optok = optable[type]
    pasttype = optok['past']
    pirop = optok['pirop']
    returns = optok['returns']
    islvalue = optok['lvalue']

    .local pmc past, iter
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'name'=>type, 'pasttype'=>pasttype, 'pirop'=>pirop, 'returns'=>returns)

    $P0 = node.'get_array'()
    if null $P0 goto iter_end
    iter = new .Iterator, $P0
    unless iter goto iter_end
    $P0[0;'islvalue'] = islvalue

  iter_loop:
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'Pynie::Grammar::expr')
    if null cpast goto iter_loop
    past.'push'(cpast)
    if iter goto iter_loop
  iter_end:
    .return (past)

  past_term:
    .return tree.'get'('past_primary', node, 'Pynie::Grammar::primary')
}

transform past_primary (Pynie::Grammar::primary) :language('PIR') {
    .local pmc atomnode, atompast
    atomnode = node['atom']
    atompast = tree.'get'('past', atomnode, 'Pynie::Grammar::atom')
    .return (atompast)
}

transform past (Pynie::Grammar::atom) :language('PIR') {
    .local pmc cnode
    $S0 = node.'find_key'()
    cnode = node[$S0]
    $S0 = concat 'Pynie::Grammar::', $S0
    .return tree.'get'('past', cnode, $S0)
}

transform past (Pynie::Grammar::literal) :language('PIR') {
    .local pmc cnode
    $S0 = node.'find_key'()
    cnode = node[$S0]
    $S0 = concat 'Pynie::Grammar::', $S0
    .return tree.'get'('past', cnode, $S0)
}

transform past (Pynie::Grammar::integer) :language('PIR') {
    .local pmc past
    past = new 'PAST::Val'
    past.'init'('node'=>node, 'vtype'=>'.Integer', 'name'=>node, 'ctype'=>'i+')
    .return (past)
}

transform past (Pynie::Grammar::longinteger) :language('PIR') {
    .local pmc past
    past = new 'PAST::Val'
    past.'init'('node'=>node, 'vtype'=>'.Integer', 'name'=>node, 'ctype'=>'i+')
    .return (past)
}

transform past (Pynie::Grammar::floatnumber) :language('PIR') {
    .local pmc past
    past = new 'PAST::Val'
    # FIX
    #past.'init'('node'=>node, 'vtype'=>'.Integer', 'name'=>node, 'ctype'=>'i+')
    .return (past)
}

transform past (Pynie::Grammar::imagnumber) :language('PIR') {
    .local pmc past
    past = new 'PAST::Val'
    # FIX
    #past.'init'('node'=>node, 'vtype'=>'.Integer', 'name'=>node, 'ctype'=>'i+')
    .return (past)
}

transform past (Pynie::Grammar::stringliteral) :language('PIR') {
    .local pmc past
    past = new 'PAST::Val'
    $S0 = node
    past.'init'('node'=>node, 'vtype'=>'.Undef', 'name'=>$S0)
    .return (past)
}

transform past (Pynie::Grammar::list_display) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'name'=>'listmaker')

    $P0 = node['listmaker']
    unless $P0 goto end
    $P0 = $P0[0]
    $P0 = $P0['expression']
    .local pmc iter
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'Pynie::Grammar::expression')
    past.'push'(cpast)
    goto iter_loop
  iter_end:
  end:
    .return (past)
}


transform past (Pynie::Grammar::identifier) :language('PIR') {
    .local pmc past
    $S0 = node
    past = new 'PAST::Var'
    past.'init'('node'=>node, 'name'=>$S0, 'scope'=>'package')
    .return (past)
}


transform past (Pynie::Grammar::assignment_stmt) :language('PIR') {
    .local pmc tnode, tpast, enode, epast, past
    $P0 = node['target_list']
    tnode = $P0[0]
    tpast = tree.'get'('past', tnode, 'Pynie::Grammar::target_list')
    enode = node['expression_list']
    epast = tree.'get'('past', enode, 'Pynie::Grammar::expression_list')
    past = epast.'new'('PAST::Op', tpast, epast, 'pasttype'=>'bind', 'node'=>node)
    .return (past)
}


transform past (Pynie::Grammar::target_list) :language('PIR') {
    .local pmc past
    past = new 'PAST::VarList'
    past.'init'('node'=>node)

    .local pmc targetiter
    $P0 = node['target']
    targetiter = new .Iterator, $P0
  iter_loop:
    unless targetiter goto iter_end
    .local pmc targetnode, targetpast
    targetnode = shift targetiter
    targetpast = tree.'get'('past', targetnode, 'Pynie::Grammar::target')
    past.'push'(targetpast)
    goto iter_loop
  iter_end:
    .return (past)
}


transform past (Pynie::Grammar::target) :language('PIR') {
    .local pmc cnode, cpast
    cnode = node['identifier']
    cpast = tree.'get'('past', cnode, 'Pynie::Grammar::identifier')
    cpast.'islvalue'(1)
    .return (cpast)
}


transform past (Pynie::Grammar::expression_list) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'name'=>'listmaker')
    .local pmc expriter
    $P0 = node['expression']
    expriter = new .Iterator, $P0
  iter_loop:
    unless expriter goto iter_end
    .local pmc enode, epast
    enode = shift expriter
    epast = tree.'get'('past', enode, 'Pynie::Grammar::expression')
    past.'push'(epast)
    goto iter_loop
  iter_end:
    .return (past)
}


transform past (Pynie::Grammar::if_stmt) :language('PIR') {
    .local pmc exprlist, suitelist
    exprlist = node['expression']
    suitelist = node['suite']

    ##   do we have an else clause?
    .local pmc elsenode, elsepast
    .local int exprc, suitec
    null elsepast
  else_suite:
    exprc = elements exprlist
    suitec = elements suitelist
    if suitec <= exprc goto expr_suite_pair
    dec suitec
    elsenode = suitelist[suitec]
    elsepast = tree.'get'('past', elsenode, 'Pynie::Grammar::suite')    
    # 'suitetype' does not exist...
    ##elsepast.'suitetype'('immediate')

  expr_suite_pair:
    ##   each remaining suite is paired with an "if" (or "elsif")
    ##   expression, except the first which could be "unless".
    .local pmc exprnode, exprpast, thennode, thenpast
    dec exprc
    exprnode = exprlist[exprc]
    exprpast = tree.'get'('past', exprnode, 'Pynie::Grammar::expression')
    thennode = suitelist[exprc]
    thenpast = tree.'get'('past', thennode, 'Pynie::Grammar::suite')
    .local pmc past
    past = new 'PAST::Op'
    past.'init'(exprpast, thenpast, elsepast, 'node'=>node, 'pasttype'=>'if')
    elsepast = past
    if exprc > 0 goto expr_suite_pair
    past.'pasttype'('if')
    .return (past)
}


transform past (Pynie::Grammar::while_stmt) :language('PIR') {
    .local pmc exprnode, stmtnode, suitenode
    exprnode = node['expression']
    suitenode = node['suite']
    stmtnode = suitenode[0]

    .local pmc past, whilepast, exprpast, stmtpast
    past = new 'PAST::Stmts'
    past.'init'('node'=>node)

    whilepast = new 'PAST::Op'
    whilepast.'init'('node'=>node, 'pasttype'=>'while')
    exprpast = tree.'get'('past', exprnode, 'Pynie::Grammar::expression')
    whilepast.'push'(exprpast)
    stmtpast = tree.'get'('past', stmtnode, 'Pynie::Grammar::suite')
    whilepast.'push'(stmtpast)
    past.'push'(whilepast)

    stmtnode = suitenode[1]
    if null stmtnode goto no_else
    unless stmtnode goto no_else # check for .Undef # why does that happen?
    stmtpast = tree.'get'('past', stmtnode, 'Pynie::Grammar::suite')
    past.'push'(stmtpast)

  no_else:
    .return (past)
}

## FIX: complete this
transform past (Pynie::Grammar::for_stmt) :language('PIR') {

    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# for stmt not implemented')
    .return (past)

#   .local pmc tlistnode, elistnode, suitenode
#   tlistnode = node['target_list']
#   elistnode = node['expression_list']
#   suitenode = node['suite']
#
#   .local pmc past, tlistpast, elistpast, suitepast
#   past = new 'PAST::Op'
#   past.'init'('node'=>node, 'pasttype'=>'while')
#
#   tlistpast = tree.'get'('past', tlistnode, 'Pynie::Grammar::target_list')
#   #past.'push'(tlistpast)
#
#   elistpast = tree.'get'('past', elistnode, 'Pynie::Grammar::expression_list')
#   past.'push'(elistpast)
#
#   suitepast = tree.'get'('past', suitenode, 'Pynie::Grammar::suite')
#   past.'push'(suitepast)
#
#   .return (past)
}

transform past (Pynie::Grammar::try_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# try stmt not implemented')
    .return (past)
}

transform past (Pynie::Grammar::with_stmt) :language('PIR') {
    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# with stmt not implemented')
    .return (past)
}

transform past (Pynie::Grammar::funcdef) :language('PIR') {

    .local pmc past
    past = new 'PAST::Block'

    .local pmc decnode, fnamenode, plistnode, suitenode
#   decnode   = node['decorators']
    fnamenode = node['funcname']
#   plistnode = node['parameter_list']
#   suitenode = node['suite']
#
#   .local pmc past
#   past = new 'PAST::Block'
#
#   if null decnode goto skip_decorators
#   # handle decorators
#   #printerr "Function decorators not implemented!\n"
#   exit 1
#
# skip_decorators:
    .local pmc fnamepast
    fnamepast = tree.'get'('past', fnamenode, 'Pynie::Grammar::funcname')
#
#   if null plistnode goto skip_parameter_list
#   #.local plistpast
#   #plistpast = tree.'get'('past', plistnode, 'Pynie::Grammar::parameter_list')
#   #printerr "Parameters not implemented!\n"
#   exit 1
#
# skip_parameter_list:
#   .local pmc stmtpast
#   stmtpast = tree.'get'('past', suitenode, 'Pynie::Grammar::suite')
#
#   # FIX
#   past.'init'('node'=>node, 'name'=>fnamepast)
#   .local pmc past
#
    past.'init'('node'=>node, 'name'=>fnamepast)
    .return (past)
}

transform past (Pynie::Grammar::funcname) :language('PIR') {
    $P0 = node['identifier']
    .return tree.'get'('past', $P0, 'Pynie::Grammar::identifier')
}


## FIX: fix this, not sure about how to handle instructions such
## as subclass etc.
##
transform past (Pynie::Grammar::classdef) :language('PIR') {

    .local pmc past
    past = new 'PAST::Op'
    past.'init'('node'=>node, 'pasttype'=>'inline', 'inline'=>'# classdef stmt not implemented')
    .return (past)

#   .local pmc past
#   past = new 'PAST::Stmts'
#   past.'init'('node'=>node)
#
#   .local pmc instr
#   instr = new 'PAST::Op'
#
#   $P0 = node['inheritance']
#   if null $P0 goto skip_inheritance
#   instr.'init'('node'=>node, 'pasttype'=>'pirop', 'pirop'=>'subclass')
#   # inheritancenot implemented right now
#   goto handle_class_body
#
# skip_inheritance:
#   instr.'init'('node'=>node, 'pasttype'=>'pirop', 'pirop'=>'newclass')
#   $P0 = node['classname']
#   $P1 = tree.'get'('past', $P0, 'Pynie::Grammar::classname')
#   instr.'push'($P1)
#
# handle_class_body:
#   # add newclass or subclass instruction to Stmts node
#   past.'push'(instr)
#
#   # add a .namespace[ <class_id> ] instruction to add methods?
#   $P0 = node['suite']
#   $P1 = tree.'get'('past', $P0, 'Pynie::Grammar::suite')
#   past.'push'($P1)
#
#
# done:
#   .return (past)
}

## FIX: Return class name as a string, not using "get_global" as in identifier.
transform past (Pynie::Grammar::classname) :language('PIR') {
    $P0 = node['identifier']
    .return tree.'get'('past', $P0, 'Pynie::Grammar::identifier')
}

transform past (Pynie::Grammar::inheritance) :language('PIR') {
    $P0 = node['expression_list']
    .return tree.'get'('past', $P0, 'Pynie::Grammar::expression_list')
}

transform past (Pynie::Grammar::suite) :language('PIR') {
    $P0 = node['stmt_list']
    if null $P0 goto statements
    .return tree.'get'('past', $P0, 'Pynie::Grammar::stmt_list')

  statements:
    .local pmc past, iter
    past = new 'PAST::Stmts'
    past.'init'('node'=>node)
    $P0 = node['statement']
    iter = new .Iterator, $P0
  iter_loop:
    unless iter goto iter_end
    .local pmc cnode, cpast
    cnode = shift iter
    cpast = tree.'get'('past', cnode, 'Pynie::Grammar::statement')
    past.'push'(cpast)
    goto iter_loop
  iter_end:
    .return (past)
}

