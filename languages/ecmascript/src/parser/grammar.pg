# Copyright (C) 2008, The Perl Foundation.
# $Id$

## ECMAscript grammar, based on the grammar as defined in the
## reference manual.
##
## See "ECMAScript Language Specification"
## Standard ECMA-262, 3rd edition, December 1999

grammar JS::Grammar is PCT::Grammar;

token TOP {
    <source_element>*
    [ $ || <panic: Syntax error> ]
    {*}
}

rule source_element {
    | <statement> {*}              #= statement
    | <function_declaration> {*}   #= function_declaration
}

##
## functions
##

rule function_declaration {
    'function' <identifier> <function_common>
    {*}
}

rule function_common {
    '(' <formal_parameter_list>? ')' <block>
    {*}
}

rule formal_parameter_list {
    <identifier> [',' <identifier>]*
}

##
## statements
##

rule statement {
    | <block> {*}                 #= block
    | <if_statement> {*}          #= if_statement
    | <while_statement> {*}       #= while_statement
    | <do_while_statement> {*}    #= do_while_statement
    | <empty_statement> {*}       #= empty_statement
    | <try_statement> {*}         #= try_statement
    | <throw_statement> {*}       #= throw_statement
    | <variable_statement> {*}    #= variable_statement
    | <for1_statement> {*}        #= for1_statement
    | <expression_statement> {*}  #= expression_statement
    | <return_statement> {*}      #= return_statement
    | <switch_statement> {*}      #= switch_statement
    | <with_statement> {*}        #= with_statement
}

rule block {
    '{' <statements> '}' {*}
}

rule if_statement {
    'if' '(' <expression> ')' <statement> ['else' $<else>=<statement>]?
    {*}
}

rule do_while_statement {
    'do' <statement> 'while' '(' <expression> ')' ';'
    {*}
}

rule while_statement {
    'while' '(' <expression> ')' <statement>
    {*}
}

rule for1_statement {
    'for' '(' [$<init>=<expression>]? ';' [$<cond>=<expression>]? ';' [$<step>=<expression>]? ')'
    <statement>
    {*}
}

rule try_statement {
    'try' <block>
    [ <catch> <finally>
    | <finally>
    | <catch>
    ]
    {*}
}

rule catch {
    'catch' '(' <identifier> ')' <block> {*}
}

rule finally {
    'finally' <block> {*}
}

rule throw_statement {
    'throw' \N <expression> ';' {*}
}

rule variable_statement {
    'var' <variable_declaration> [',' <variable_declaration>]* ';'
    {*}
}

rule variable_declaration {
    <identifier> ['=' <assignment_expression>]?
    {*}
}

rule empty_statement {
    ';' {*}
}

rule expression_statement {
    ##<!['{'|'function']> ## is this necessary? isn't this fixed automatically by PGE?
    <expression> ';' {*}
}

rule return_statement {
    'return' \N <expression>? ';' {*}
}

rule switch_statement {
    'switch' '(' <expression> ')' <case_block>
    {*}
}

rule case_block {
    '{'
    <case_clause>*
    [ <default_clause>
      <case_clause>*
    ]?
    '}'
}

rule case_clause {
    'case' <expression> ':' <statements>
    {*}
}

rule default_clause {
    'default' ':' <statements>
    {*}
}

rule statements {
    <statement>*
    {*}
}

rule with_statement {
    'with' '(' <expression> ')' <statement>
    {*}
}


##
## expressions
##

rule function_expression {
    'function' <identifier>? <function_common>
    {*}
}

rule arguments {
    '(' [ <assignment_expression> [',' <assignment_expression>]* ]? ')'
}

rule primary_expression {
    #| 'this' {*}                #= this
    | <literal> {*}             #= literal
    | <array_literal> {*}       #= array_literal
    | <identifier> {*}          #= identifier
    | <object_literal> {*}      #= object_literal
    | '(' <expression> ')' {*}  #= expression
}


rule array_literal {
    '['
    #[ <elision>
    #| <element_list> [',' <elision>]?
    #]
    ']'
    {*}
}

rule element_list {
    <elision> <assignment_expression> [',' <elision> <assignment_expression>]*
    #{*}
}

rule elision {
    [$<comma>=',']* {*}
}

token identifier {
    <!reserved_word>
    <alpha> [<alpha>|<digit>|_]*
    {*}
}

token literal {
    | <str_literal> {*}            #= str_literal
    | <numeric_literal> {*}        #= numeric_literal
    | <builtin_literal> {*}        #= builtin_literal
}


## TODO: handle 'true', 'false' and 'null'
##
token builtin_literal {
    $<sym>=[true|false|null]
    {*}
}

rule object_literal {
    '{' [<property> [',' <property>]* ]? '}'
    {*}
}

rule property {
    <property_name> ':' <expression>
    {*}
}

token property_name {
    | <identifier> {*}       #= identifier
    | <str_literal> {*}      #= str_literal
    | <numeric_literal> {*}  #= numeric_literal
}

token numeric_literal {
    | <decimal_literal> {*}        #= decimal_literal
    | <hex_integer_literal> {*}    #= hex_integer_literal
}

token hex_integer_literal {
    0<[xX]><hex_digits>+ {*}
}

token hex_digits { <[0..9 a..f A..F]> }

token decimal_literal {
    | <integer_number> {*}         #= integer_number
    | <floating_point_number> {*}  #= floating_point_number
}

token floating_point_number {
    [ <decimal_integer_literal> '.' <digit>+? <exponent_part>?
    | '.' <digit>+ <exponent_part>?
    ]
    {*}
}

token integer_number {
    <decimal_integer_literal> <exponent_part>?
    {*}
}

token decimal_integer_literal {
    | 0
    | <[1..9]> <digit>*
}

token exponent_part { <[eE]> <[+\-]> <digit>+ }

token str_literal {
    [ '"' <string_literal: "> '"'
    | \' <string_literal: '> \'
    ]
    {*}
}


token keyword {
    [ break | case | catch | continue | default
    | delete | do | else | finally | for | function | if
    | in | instance | new | return | switch | this | throw
    | try | typeof | var | void | while | with
    ] >>
}

token future_reserved_word {
    [ abstract | enum | int | short
    | boolean | export | interface | static
    | byte | extends | long | super
    | char | final | native | synchronized
    | class | float | package | throws
    | const | goto | private | transient
    | debugger | implements | protected | volatile
    ] >>
}

token reserved_word {
    | <keyword>
    | <future_reserved_word>
}


#### whitespace
#token ws {
#    | <.whitespace>
#    | <.newline>
#    | <.comment>
#}

#token whitespace {
#    | <[\t\v\f\ ]>
#    | \nbsp
#    | \usp #unicode sp
#}

#token newline {
#    | \r?\n
#    | \LS
#    | \PS
#}

#token comment {
#    <.singlelinecomment>
#}

##
#### comments
##rule multilinecomment {
##    <PGE::Text::Bracketed: /* */>
##}
##
token singlelinecomment {
    '//' \N* <newline>
}


## Grammar rules converted directly from the ECMA-script reference manual, 3rd edition.
## This makes converting the whole thing to an optable easier.

rule expression {
    <assignment_expression> [',' <assignment_expression>]*
    {*}
}

rule assignment_expression {
    [<lhs_expression> <assignop>]* <conditional_expression>
    {*}
}

token assignop {
    $<op>=['='|'*='|'/='|'%='|'+='|'-='|'<<='|'>>='|'>>>='|'&='|'^='|'|=']
}

rule conditional_expression {
    <logical_or_expression> ['?' <assignment_expression> ':' <assignment_expression>]?
    {*}
}

rule 'logical_or_expression' is optable { ... }

proto 'infix:||'  is precedence('1') { ... }
proto 'infix:&&'  is tighter('infix:||') { ... }
proto 'infix:|'   is tighter('infix:&&') { ... }
proto 'infix:^'   is tighter('infix:|') { ... }
proto 'infix:&'   is tighter('infix:^') { ... }
proto 'infix:=='  is tighter('infix:&') { ... }
proto 'infix:!='  is equiv('infix:==') { ... }
proto 'infix:===' is equiv('infix:==') { ... }
proto 'infix:!==' is equiv('infix:==') { ... }
proto 'infix:<'   is tighter('infix:==') { ... }
proto 'infix:>'   is equiv('infix:<') { ... }
proto 'infix:<='  is equiv('infix:<') { ... }
proto 'infix:>='  is equiv('infix:<') { ... }
proto 'infix:instanceof' is equiv('infix:<') { ... }
proto 'infix:in' is equiv('infix:<') { ... }

proto 'infix:<<' is tighter('infix:<') { ... }
proto 'infix:>>' is equiv('infix:<<') { ... }
proto 'infix:>>>' is equiv('infix:<<') { ... }

proto 'infix:+' is tighter('infix:<<') { ... }
proto 'infix:-' is equiv('infix:+') { ... }

proto 'infix:*' is tighter('infix:+') { ... }
proto 'infix:/' is equiv('infix:*') { ... }
proto 'infix:%' is equiv('infix:*') { ... }

#rule logical_or_expression {
#    <logical_and_expression> ['||' <logical_and_expression>]*
#}
#
#rule logical_and_expression {
#    <bitwise_or_expression> ['&&' <bitwise_or_expression>]*
#}
#
#rule bitwise_or_expression {
#    <bitwise_xor_expression> ['|' <bitwise_xor_expression>]*
#}
#
#rule bitwise_xor_expression {
#    <bitwise_and_expression> ['^' <bitwise_and_expression>]*
#}
#
#rule bitwise_and_expression {
#    <equality_expression> ['&' <equality_expression>]*
#}
#
#rule equality_expression {
#    <relational_expression> [<eqop> <relational_expression>]*
#}
#
#token eqop { '==' | '!=' | '===' | '!==' }
#
#rule relational_expression {
#    <shift_expression> [<relop> <shift_expression>]*
#}
#
#token relop { '<' | '>' | '<=' | '>=' | 'instanceof' }
#
#rule shift_expression {
#    <additive_expression> [<shiftop> <additive_expression>]*
#}
#
#token shiftop { '<<' | '>>' | '>>>' }
#
#rule additive_expression {
#    <multiplicative_expression> [<addop> <multiplicative_expression>]*
#}
#
#token addop { '+' | '-' }
#
#rule multiplicative_expression {
#    <unary_expression> [<mulop> <unary_expression>]*
#}
#
#token mulop { '*' | '/' | '%' }
#

rule unary_expression {
    <unop>* <postfix_expression>
    {*}
}

token unop { $<op>=['delete'|'void'|'typeof'|'++'|'--'|'+'|'-'|'~'|'!'] }

proto term: is tighter(infix:<||>) is parsed(&unary_expression) { ... }

rule postfix_expression {
    <lhs_expression> [\N <postfixop>]?
    {*}
}

token postfixop { '++' | '--' }

rule lhs_expression {
    | <new_expression> {*}  #= new_expression
    | <call_expression> {*} #= call_expression
}

rule new_expression {
    [new]* <member_expression>
    {*}
}

rule member_expression {
    [ <member>  {*}
    | 'new' <member> <arguments>
    ]
    {*}
}

rule index {
    | '[' <expression> ']'
    | '.' <identifier>
}

rule member {
    [ <primary_expression>
    | <function_expression>
    ]
    <index>*
    {*}
}

rule call_expression {
    <member_expression> <arguments> <post_call_expr>*
    {*}
}

rule post_call_expr {
    | <arguments> {*}   #= arguments
    | <index> {*}       #= index
}

