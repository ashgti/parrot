=head1 TITEL

libpcre.imc - pcre interface

=head1 SYNOPSIS

  .include "library/pcre.imc"
  .PCRE_INIT(lib)
  .PCRE_COMPILE(pattern, options, regex, error, errptr)
  .PCRE_MATCH(regex, string, nres, ovector)
  .PCRE_DOLLAR(string, ok, ovector, n, match)

=head1 DESCRIPTION

Above macros call functions in libpcre.imc.

=over 4

=item macro PCRE_INIT(var)

Intialize the pcre library. The PMC B<var> is set to the library handle
and additionally stored as global "pcre::lib".

=item macro PCRE_COMPILE((pattern, options, regex, error, errptr)

Compile the string B<pattern> with int B<options>. Returns var B<regex>
string B<error> and int B<errptr>.

=cut


.pcc_sub _pcre_compile prototyped
    .param string pat
    .param int options

    .sym pmc NULL
    .sym pmc code
    .sym string error
    .sym pmc COMPILE
    COMPILE = global "pcre::compile"
    repeat error, " ", 500	# could be enough
    .sym int errptr
    null NULL
    .pcc_begin prototyped
    .arg pat
    .arg options
    .arg error
    .arg errptr
    .arg NULL
    .nci_call COMPILE
    .result code
    .pcc_end
    $I0 = defined code
    unless $I0 goto nok
    error = ""
nok:
    .pcc_begin_return
    .return code
    .return error
    .return errptr
    .pcc_end_return
.end
=item macro PCRE_MATCH(regex, str, start, options, ok, res)

Match the var B<regex> against string B<str> from int B<start> with
int B<options>. Returns the number of matches in int B<ok> and the
ovector in var B<res>.

=cut

.pcc_sub _pcre_exec prototyped
    .param pmc regex
    .param string s
    .param int start
    .param int options
    .sym int len
    length len, s
    .sym pmc NULL
    null NULL
    .sym pmc ovector
    ovector = new ManagedStruct
    ovector = 120	# 1/(2/3) * 4  * 2 * 10 for 10 result pairs
    .sym pmc EXEC	# on 32 bit systems
    EXEC = global "pcre::exec"

    .pcc_begin prototyped
    .arg regex		# p code
    .arg NULL		# P extra
    .arg s		# t subject
    .arg len		# i length
    .arg start		# i start
    .arg options
    .arg ovector	# p ovector
    .arg 10		# i ovecsize
    .nci_call EXEC
    .local int ok
    .result ok
    .pcc_end
    .pcc_begin_return
    .return ok
    .return ovector
    .pcc_end_return
.end

=item macro PCRE_DOLLAR(str, ok, res, n, matched)

Extract from string B<str> the int B<n>th result into string B<match>.

=cut



.pcc_sub _pcre_result prototyped
    .param string s
    .param int ok
    .param pmc ovector
    .param int n

    .sym string match
    match = ""
    if ok <= 0 goto nomatch

    .local int ovecs
    .local int ovece
    .sym pmc struct
    struct = new SArray
    struct = 3
.include "datatypes.pasm"
    struct[0] = .DATATYPE_INT
    $I0 = ok * 2
    struct[1] = $I0
    struct[2] = 0
    assign ovector, struct
    $I0 = n * 2
    ovecs = ovector[0;$I0]
    inc $I0
    ovece = ovector[0;$I0]
    $I0 = ovece - ovecs
    if ovecs >= 0 goto m1
    match = ""
    goto m0
m1:
    substr match, s, ovecs, $I0
m0:
nomatch:
    .pcc_begin_return
    .return match
    .pcc_end_return
.end

=for todo
    # or use convinience function
    print "copy_substring\n"
    i = 0
    repeat match, " ", 500
loop:
    .pcc_begin prototyped
    .arg s
    .arg ovector
    .arg ok
    .arg i
    .arg match
    .arg 500
    .nci_call COPY_SUBSTRING
    .pcc_end
    if i goto subp
    print "all "
    goto all
subp:
    print "("
    print i
    print ") "
all:
    print "matched: '"
    print match
    print "'\n"
    inc i
    if i < ok goto loop
    end
.end

=back

=head1 FILES

pcre.imc, libpcre.imc

=head1 SEE ALSO

pcre(3)

=head1 AUTHOR

Leopold Toetsch


