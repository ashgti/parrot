/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/resizablepmcarray.pmc - resizable array for PMCs only

=head1 DESCRIPTION

This class, ResizablePMCArray, implements an resizable array,
which stores PMCs. It puts things into Integer, Float, or String PMCs
as appropriate.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"


pmclass ResizablePMCArray extends FixedPMCArray need_ext does array {

/*

=item C<void set_integer_native(INTVAL size)>

Resizes the array to C<size> elements.

=cut

*/

    void set_integer_native (INTVAL size) {

        if (size < 0)
            internal_exception(OUT_OF_BOUNDS,
                    "ResizablePMCArray: Can't resize!");

        if (!PMC_data(SELF)) {
            /* empty - used fixed routine */
            if (size < 8) {
                SUPER(8);
                PMC_int_val(SELF) = size;
                PMC_int_val2(SELF) = 8;
            }
            else {
                SUPER(size);
                PMC_int_val2(SELF) = size;
            }
        }
        else if (size <= PMC_int_val2(SELF)) {
            PMC_int_val(SELF) = size;
            /* we could shrink here if necessary */
            return;
        }
        else {
            INTVAL i, cur, needed;
            i = cur = PMC_int_val2(SELF);
            if (cur < 8192)
                cur = size < 2 * cur ? 2 * cur : size;
            else {
                needed = size - cur;
                cur += needed + 4096;
                cur &= ~0xfff;
            }
            PMC_data(SELF) = mem_sys_realloc(PMC_data(SELF),
                    cur * sizeof(PMC*));
            for (; i < cur; i++)
                ((PMC**)PMC_data(SELF))[i] = PMCNULL;
            PMC_int_val2(SELF) = cur;
            PMC_int_val(SELF) = size;
        }
    }
/*

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Returns the PMC value of the element at index C<key>.

=cut

*/

    PMC* get_pmc_keyed_int (INTVAL key) {
        PMC **data;

        if (key < 0)
            key += PMC_int_val(SELF);
        if (key < 0)
            internal_exception(OUT_OF_BOUNDS,
                "ResizablePMCArray: index out of bounds!");
        if (key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);
        data = PMC_data(SELF);
        if (data[key] == PMCNULL)
            data[key] = pmc_new(INTERP, enum_class_Undef);
        return data[key];
    }

/*

=item C<void set_pmc_keyed_int(INTVAL key, PMC *src)>

Sets the PMC value of the element at index C<key> to C<*src>.

=item C<void set_pmc_keyed(PMC *key, PMC *src)>

If key is a slice, do a splice as set that item.

=cut

*/

    void set_pmc_keyed_int (INTVAL key, PMC* src) {
        PMC **data;

        /*
         * TODO in python mode, only .append is allowed
         */
        if (key < 0)
            key += PMC_int_val(SELF);
        if (key < 0)
            internal_exception(OUT_OF_BOUNDS,
                "ResizablePMCArray: index out of bounds!");
        if (key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);
        data = (PMC**)PMC_data(SELF);
        DOD_WRITE_BARRIER(INTERP, SELF, data[key], src);
        data[key] = src;
    }

    void set_pmc_keyed (PMC* key, PMC* src) {
        SUPER(key, src);
    }

    void delete_keyed (PMC* key) {
        PMC **data;
        INTVAL idx = key_integer(INTERP, key);
        INTVAL i;
        INTVAL n = PMC_int_val(SELF);
        data = PMC_data(SELF);
        for (i = idx; i < n - 1; ++i)
            data[i] = data[i + 1];
        PMC_int_val(SELF)--;
    }

/*

=item C<void push_pmc (PMC* value)>

Extends the array by adding an element of value C<*value> to the end of
the array.

=cut

*/

    void push_pmc(PMC* value) {
        INTVAL size = PMC_int_val(SELF);

        /* let set_integer_native() worry about memory allocation */
        DYNSELF.set_integer_native(size + 1);
        ((PMC**)PMC_data(SELF))[size] = value;

        return;
    }

    METHOD void append(PMC* value) {
        Parrot_ResizablePMCArray_push_pmc(INTERP, SELF, value);
    }

/*

=item C<void push_integer(INTVAL value)>

=item C<void push_string(INTVAL value)>

Extends the array by adding an element of value C<*value> to the end of
the array.

=cut

*/

    void push_integer(INTVAL value) {
        PMC *val;
        INTVAL size;

        size = PMC_int_val(SELF);
        val = pmc_new(INTERP, enum_class_Integer);
        VTABLE_set_integer_native(INTERP, val, value);
        /* let set_pmc_keyed_int() worry about memory allocation */
        DYNSELF.set_pmc_keyed_int(size, val);

        return;
    }

    void push_string(STRING* value) {
        PMC *val;
        INTVAL size;

        size = PMC_int_val(SELF);
        val = pmc_new(INTERP, enum_class_String);
        VTABLE_assign_string_native(INTERP, val, value);
        /* let set_pmc_keyed_int() worry about memory allocation */
        DYNSELF.set_pmc_keyed_int(size, val);

        return;
    }
/*

=item C<void unshift_pmc (PMC* value)>

Extends the array by adding an element of value C<*value> to the begin of
the array.

=cut

*/

    void unshift_pmc(PMC* value) {
        INTVAL size = PMC_int_val(SELF);
        PMC **data;
        INTVAL i;

        /* let set_integer_native() worry about memory allocation */
        DYNSELF.set_integer_native(size + 1);
        /* make room */
        data = (PMC**)PMC_data(SELF);
        for (i = size; i; --i) {
            data[i] = data[i-1];
        }
        data[0] = value;
    }
/*

=item C<PMC *clone()>

Creates and returns a copy of the array.

=cut

*/

    PMC* clone () {
        PMC *copy = SUPER();

        PMC_int_val2(copy) = PMC_int_val(SELF);
        return copy;
    }

/*

=item C<INTVAL is_equal (PMC* value)>

The C<==> operation. Compares two array to hold equal elements.

=cut

*/

    INTVAL is_equal (PMC* value) {
        INTVAL j, n;

        if (value->vtable->base_type != enum_class_ResizablePMCArray)
            return 0;
        n = DYNSELF.elements();
        if (VTABLE_elements(INTERP, value) != n)
            return 0;
        for (j = 0; j < n; ++j) {
            PMC *item1, *item2;
            item1 = DYNSELF.get_pmc_keyed_int(j);
            item2 = VTABLE_get_pmc_keyed_int(INTERP, value, j);
            if (item1 == item2)
                continue;
            if (!mmd_dispatch_i_pp(INTERP, item1, item2, MMD_EQ))
                return 0;
        }
        return 1;
    }

}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd17_basic_types.pod>.

=head1 HISTORY

Initial version                  - Matt Fowles 2004-06-11
Changed allocator to double size - Matt Fowles 2004-06-15

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
