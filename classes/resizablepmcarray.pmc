/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/resizablepmcarray.pmc - resizable size array for PMCs only

=head1 DESCRIPTION

This class, ResizablePMCArray, implements an array of resizable size,
which stores PMCs, it puts things into Integer, Float, or String PMCs
as appropriate

TODO currently this uses PerlString instead of String PMCs.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"


pmclass ResizablePMCArray extends FixedPMCArray need_ext does array {

/*

=item C<void* invoke(void* next)>

Pythonic object constructor. SELF is a ResizeablePMCArray Class object.
Return a new C<list> object according to 2.1. Built-in Functions.

=cut

*/
    void* invoke(void* next) {
        int argcP = REG_INT(3);
        PMC *res = pmc_new(interpreter, enum_class_ResizablePMCArray);
        PMC *arg;
        if (argcP) {
            if (argcP > 1) {
                real_exception(interpreter, NULL, E_TypeError,
                        "TypeError: list expected at most 1 arguments, got %d",
                        (int)argcP);
            }
            arg = REG_PMC(5);
            Parrot_py_fill(interpreter, res, arg);
        }
        REG_PMC(5) = res;
        return next;
    }

/*

=item C<void set_integer_native(INTVAL size)>

Resizes the array to C<size> elements.

=cut

*/

    void set_integer_native (INTVAL size) {

        if (size < 0)
            internal_exception(OUT_OF_BOUNDS,
                    "ResizablePMCArray: Can't resize!\n");

        if (!PMC_data(SELF)) {
            /* empty - used fixed routine */
            if (size < 8) {
                SUPER(8);
                PMC_int_val(SELF) = size;
                PMC_int_val2(SELF) = 8;
            }
            else {
                SUPER(size);
                PMC_int_val2(SELF) = size;
            }
        }
        else if (size <= PMC_int_val2(SELF)) {
            PMC_int_val(SELF) = size;
            /* we could shrink here if necessary */
            return;
        }
        else {
            INTVAL i, cur, needed;
            i = cur = PMC_int_val2(SELF);
            if (cur < 8192)
                cur = size < 2 * cur ? 2 * cur : size;
            else {
                needed = size - cur;
                cur += needed + 4096;
                cur &= ~0xfff;
            }
            PMC_data(SELF) = mem_sys_realloc(PMC_data(SELF),
                    cur * sizeof(PMC*));
            for (; i < cur; i++)
                ((PMC**)PMC_data(SELF))[i] = PMCNULL;
            PMC_int_val2(SELF) = cur;
            PMC_int_val(SELF) = size;
        }
    }
/*

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Returns the PMC value of the element at index C<key>.

=cut

*/

    PMC* get_pmc_keyed_int (INTVAL key) {
        PMC **data;
        if (key < 0)
            key += PMC_int_val(SELF);
        if (key < 0)
            internal_exception(OUT_OF_BOUNDS,
                "ResizablePMCArray: index out of bounds!\n");
        if (key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);
        data = PMC_data(SELF);
        if (data[key] == PMCNULL)
            data[key] = pmc_new(INTERP, enum_class_Undef);
        return data[key];
    }

/*

=item C<void set_pmc_keyed_int(INTVAL key, PMC *src)>

Sets the PMC value of the element at index C<key> to C<*src>.

=item C<void set_pmc_keyed(PMC *key, PMC *src)>

If key is a slice, do a splice as set that item.

=cut

*/

    void set_pmc_keyed_int (INTVAL key, PMC* src) {
        PMC **data;
        /*
         * TODO in python mode, only .append is allowed
         */
        if (key < 0)
            key += PMC_int_val(SELF);
        if (key < 0)
            internal_exception(OUT_OF_BOUNDS,
                "ResizablePMCArray: index out of bounds!\n");
        if (key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);
        data = (PMC**)PMC_data(SELF);
        DOD_WRITE_BARRIER(INTERP, SELF, data[key], src);
        data[key] = src;
    }

    void set_pmc_keyed (PMC* key, PMC* src) {
        if (key->vtable->base_type == enum_class_Slice)
            Parrot_py_set_slice(INTERP, SELF, key, src);
        else
            SUPER(key, src);
    }

    void delete_keyed (PMC* key) {
        if (key->vtable->base_type == enum_class_Slice)
            Parrot_py_set_slice(INTERP, SELF, key, NULL);
        else
            internal_exception(OUT_OF_BOUNDS,
                "ResizablePMCArray: unimplemented delete!\n");
    }

    void push_pmc(PMC* value) {
        INTVAL cap = PMC_int_val2(SELF);
        INTVAL size = PMC_int_val(SELF);
        if (size + 1 >= cap)
            DYNSELF.set_integer_native(size + 1);
        else
            PMC_int_val(SELF) = size + 1;
        ((PMC**)PMC_data(SELF))[size] = value;
    }

    METHOD void append(PMC* value) {
        Parrot_ResizablePMCArray_push_pmc(INTERP, SELF, value);
    }

/*

=item C<PMC *clone()>

Creates and returns a copy of the array.

=cut

*/

    PMC* clone () {
        PMC *copy = SUPER();
        PMC_int_val2(copy) = PMC_int_val(SELF);
        return copy;
    }

    STRING* get_repr () {
        return SELF.get_string();
    }

    STRING* get_string () {
        if (Interp_flags_TEST(interpreter, PARROT_PYTHON_MODE)) {
            STRING *res, *s;
            INTVAL j, n;
            PMC *val;

            res = string_from_cstring(INTERP, "[", 0);
            n = VTABLE_elements(INTERP, SELF);
            for (j = 0; j < n; ++j) {
                STRING *vals;
                val = SELF.get_pmc_keyed_int(j);
                REG_INT(3) = 0;
                vals = VTABLE_get_repr(INTERP, val);
                res = string_append(INTERP, res, vals, 0);
                if (j < n - 1)
                    res = string_append(INTERP, res,
                            const_string(INTERP, ", "), 0);
            }
            res = string_append(INTERP, res,
                        const_string(INTERP, "]"), 0);
            return res;
        }

        return string_from_int(INTERP, DYNSELF.elements());
    }
/*

=item C<INTVAL is_equal (PMC* value)>

The C<==> operation. Compares two array to hold equal elements.

=cut

*/

    INTVAL is_equal (PMC* value) {
        INTVAL j, n;

        if (value->vtable->base_type != enum_class_ResizablePMCArray)
            return 0;
        n = DYNSELF.elements();
        if (VTABLE_elements(INTERP, value) != n)
            return 0;
        for (j = 0; j < n; ++j) {
            PMC *item1, *item2;
            item1 = DYNSELF.get_pmc_keyed_int(j);
            item2 = VTABLE_get_pmc_keyed_int(INTERP, value, j);
            if (item1 == item2)
                continue;
            if (!mmd_dispatch_i_pp(INTERP, item1, item2, MMD_EQ))
                return 0;
        }
        return 1;
    }
/*

=item C<void multiply_int(INTVAL value,  PMC *dest)>

Python (b6.main):

 # L = [1] * 1000000

  4           0 LOAD_CONST               1 (1)
              3 BUILD_LIST               1
              6 LOAD_CONST               2 (1000000)
              9 BINARY_MULTIPLY
             10 STORE_FAST               2 (L)

Build a list by duplicating the passed list N times. Only implemented for
list.elements == 1.

=cut

*/

    void multiply_int (INTVAL value,  PMC* dest) {
        INTVAL k = DYNSELF.elements();
        INTVAL i;
        PMC *elem;
        PMC **data;

        if (k != 1)
            internal_exception(1, "multiply_int: unimplemented list size");
        elem = VTABLE_get_pmc_keyed_int(INTERP, SELF, 0);
        pmc_reuse(INTERP, dest, enum_class_ResizablePMCArray, 0);
        VTABLE_set_integer_native(INTERP, dest, value);
        data = PMC_data(dest);
        for (i = 0; i < value; ++i)
            data[i] = elem;
    }


}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd03_calling_conventions.pod>.

=head1 HISTORY

Initial version 2004.06.11 by Matt Fowles
Changed allocator to double size - MF 2004.06.15

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
