/* SharedRef.pmc
 *  Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
 *  CVS Info
 *     $Id$
 *  Overview:
 *     The vtable functions for the SharedRef base class.
 *     This class wraps locking around PMC access.
 *  Data Structure and Algorithms:
 *  History:
 *     Initial revision by leo 2004.01.14
 *  Notes:
 *     All methods not present below get a default body autogenerated
 *     inside Pmc2c.pm.
 *
 *     Currently all access is locked. When we have a non-copying GC
 *     allocator we can relax that a bit.
 *  References:
 */

#include "parrot/parrot.h"
#include "parrot/method_util.h"

#define USE_RWLOCK 0

#if USE_RWLOCK
/* quick hack for rwlocks memory overhead - estimated only */
#define RWL 20
#undef MUTEX_INIT
#define MUTEX_INIT(m) pthread_rwlock_init(&m, NULL)
#undef LOCK
#define LOCK(m) pthread_rwlock_rdlock(&m)
#undef UNLOCK
#define UNLOCK(m) pthread_rwlock_unlock(&m)
#undef MUTEX_DESTROY
#define MUTEX_DESTROY(m) pthread_rwlock_destroy(&m)

#else
#define RWL 0
#endif

/*
 * TODO we should catch exceptions around these locks
 *      if the vtable meth throws the lock is never unlocked
 */
#define LOCK_PMC(interp, pmc) LOCK(PMC_sync(pmc)->pmc_lock);
#define UNLOCK_PMC(interp, pmc) UNLOCK(PMC_sync(pmc)->pmc_lock);

pmclass SharedRef does ref need_ext is_shared extends Ref {

    void init () {
	internal_exception(1, "SharedRef init without PMC\n");
    }

    void init_pmc(PMC* init) {
	/*
	 * XXX if the PMC we refer to is an aggregate (or has properties)
	 *     - call share() on the aggregate, which
	 *       calls share() on its contents - so
	 *       getting aggregate members only yields shared PMCs
	 *     - and unshare the aggregate itself, because we
	 *       lock on behalf of the referee
	 *
	 * A direct deref of the SharedRef is currently not enabled
	 * so we shouldn't leak unshared PMCs into different threads
	 */
	SUPER(init);
	PMC_sync(SELF) =
		mem_sys_allocate(sizeof(*SELF->synchronize) + RWL);
	PMC_sync(SELF)->owner = INTERP;
	MUTEX_INIT(PMC_sync(SELF)->pmc_lock);
	PObj_active_destroy_SET(SELF);
    }

    void init_pmc_props(PMC* init, PMC* props) {
	SUPER(init, props);
    }

    void share () {
	/* we do already sharing - so just ignore */
    }

    void mark () {
	SUPER();
    }

    void destroy() {
	PMC *ref = PMC_pmc_val(SELF);
	if (PObj_active_destroy_TEST(ref))
	    VTABLE_destroy(INTERP, ref);
	if (PMC_sync(SELF)->owner != INTERP)
	    PANIC("SharedRef destroyed by wrong interpreter");
	MUTEX_DESTROY(PMC_sync(SELF)->pmc_lock);
	mem_sys_free(PMC_sync(SELF));
    }
}
