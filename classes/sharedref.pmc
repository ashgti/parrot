/* SharedRef.pmc
 *  Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
 *  CVS Info
 *     $Id$
 *  Overview:
 *     The vtable functions for the SharedRef base class.
 *     This class wraps locking around PMC access.
 *  Data Structure and Algorithms:
 *  History:
 *     Initial revision by leo 2004.01.14
 *  Notes:
 *     All methods not present below get a default body autogenerated
 *     inside Pmc2c.pm.
 *
 *     Currently all access is locked. When we have a non-copying GC
 *     allocator we can relax that a bit.
 *  References:
 */

#include "parrot/parrot.h"
#include "parrot/method_util.h"

/*
 * TODO we should catch exceptions around these locks
 *      if the vtable meth throws the lock is never unlocked
 */
#define LOCK_PMC(interp, pmc) LOCK(pmc->synchronize->pmc_lock);
#define UNLOCK_PMC(interp, pmc) UNLOCK(pmc->synchronize->pmc_lock);

pmclass SharedRef does ref need_ext is_shared extends Ref {

    void init () {
	internal_exception(1, "SharedRef init without PMC\n");
    }

    void init_pmc(PMC* init) {
	/*
	 * XXX if the PMC we refer to is an aggregate (or has properties)
	 *     - call share() on the aggregate, which
	 *       calls share() on its contents - so
	 *       getting aggregate members only yields shared PMCs
	 *     - and unshare the aggregate itself, because we
	 *       lock on behalf of the referee
	 *
	 * A direct deref of the SharedRef is currently not enabled
	 * so we shouldn't leak unshared PMCs into different threads
	 */
	SUPER(init);
	SELF->synchronize = mem_sys_allocate(sizeof(*SELF->synchronize));
	SELF->synchronize->owner = INTERP;
	MUTEX_INIT(SELF->synchronize->pmc_lock);
	PObj_active_destroy_SET(SELF);
    }

    void init_pmc_props(PMC* init, PMC* props) {
	SUPER(init, props);
    }

    void share () {
	/* we do already sharing - so just ignore */
    }

    void mark () {
	SUPER();
    }

    void destroy() {
	PMC *ref = PMC_ptr2p(SELF);
	if (PObj_active_destroy_TEST(ref))
	    VTABLE_destroy(INTERP, ref);
	if (SELF->synchronize->owner != INTERP)
	    PANIC("SharedRef destroyed by wrong interpreter");
	MUTEX_DESTROY(SELF->synchronize->pmc_lock);
	mem_sys_free(SELF->synchronize);
    }
}
