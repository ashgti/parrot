/* Coroutine.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the Coroutine base class
 *  Data Structure and Algorithms:
 *     Initial version by Melvin on 2002/06/6
 *  History:
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"
#include "parrot/method_util.h"

pmclass Coroutine {

    INTVAL type () {
        return enum_class_Coroutine;
    }

    STRING* name () {
        return whoami;
    }

    void init () {
        INTVAL address = 0; /* XXX this was originally passed as a
                             * parameter, but that's not valid.  So
                             * this is totally broken now. */
        SELF->data = new_coroutine(INTERP, (opcode_t*)address);
        SELF->flags |= PMC_custom_mark_FLAG | PMC_active_destroy_FLAG;
    }

    void destroy () {
        mem_sys_free(SELF->data);
    }

    PMC* mark (PMC* end_of_used_list) {
        /* XXX: need to do pads as well. */
        return mark_stack(
            ((struct Parrot_Coroutine *)SELF->data)->ctx.user_stack,
            end_of_used_list
            );
    }

    void set_integer (PMC * value) {
        ((struct Parrot_Coroutine*)SELF->data)->resume
            = (opcode_t*)value->vtable->get_integer(INTERP, value);
    }

    void set_integer_native (INTVAL value) {
        ((struct Parrot_Coroutine*)SELF->data)->resume = (opcode_t*)value;
    }

    PMC* get_pmc () {
        return SELF;
    }

    INTVAL is_same (PMC* value) {
        return SELF == value;
    }

    INTVAL is_equal (PMC* value) {
        return (SELF->vtable == value->vtable
                && memcmp(value->data, SELF->data,
                          sizeof(struct Parrot_Coroutine)) == 0);
    }

    INTVAL defined () {
        return ((struct Parrot_Coroutine*)SELF->data)->resume != NULL;
    }
    
    void* invoke (void* next) {
        struct Parrot_Coroutine* co = (struct Parrot_Coroutine*)SELF->data;
        void * dest = co->resume;
        co->resume = (opcode_t *)next;
        return dest;
    } 

    PMC* clone() {
        struct Parrot_Coroutine * retc;
        PMC * ret = new_pmc_header(INTERP);
        ret->vtable = &Parrot_base_vtables[enum_class_Coroutine];
        ret->data = retc = mem_sys_allocate(sizeof(struct Parrot_Coroutine));
        memcpy(ret->data, SELF->data, sizeof(struct Parrot_Coroutine));
        stack_mark_cow(retc->ctx.user_stack);
        stack_mark_cow(retc->ctx.control_stack);
        return ret;
    }
}
