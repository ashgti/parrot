/* Coroutine.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the Coroutine base class
 *  Data Structure and Algorithms:
 *  History:
 *     Initial version by Melvin on 2002/06/6
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"
#include "parrot/method_util.h"

pmclass Coroutine {

    INTVAL type () {
        return enum_class_Coroutine;
    }

    STRING* name () {
        return whoami;
    }

    void init () {
        INTVAL address = 0; /* XXX this was originally passed as a
                             * parameter, but that's not valid.  So
                             * this is totally broken now. */
        SELF->data = new_coroutine(INTERP, (opcode_t*)address);
        PObj_custom_mark_destroy_SETALL(SELF);
    }

    void destroy () {
	/* XXX stack_destroy for deeper stacks */
	mem_sys_free(((struct Parrot_Coroutine *)SELF->data)->ctx.user_stack);
	mem_sys_free(((struct Parrot_Coroutine *)SELF->data)->ctx.control_stack);
        mem_sys_free(SELF->data);
    }

    void mark () {
        /* XXX: need to do pads as well. */
        mark_stack(
            INTERP, ((struct Parrot_Coroutine *)SELF->data)->ctx.user_stack);
    }

    void set_integer (PMC * value) {
        ((struct Parrot_Coroutine*)SELF->data)->resume
            = (opcode_t*)value->vtable->get_integer(INTERP, value);
    }

    void set_integer_native (INTVAL value) {
        ((struct Parrot_Coroutine*)SELF->data)->resume = (opcode_t*)value;
    }

    PMC* get_pmc () {
        return SELF;
    }

    INTVAL is_same (PMC* value) {
        return SELF == value;
    }

    INTVAL is_equal (PMC* value) {
        return (SELF->vtable == value->vtable
                && memcmp(value->data, SELF->data,
                          sizeof(struct Parrot_Coroutine)) == 0);
    }

    INTVAL defined () {
        return ((struct Parrot_Coroutine*)SELF->data)->resume != NULL;
    }

    void* invoke (void* next) {
        PMC * pad = ((struct Parrot_Coroutine *)SELF->data)->lex_pad;
        struct Parrot_Coroutine* co = (struct Parrot_Coroutine*)SELF->data;
        void * dest = co->resume;
        co->resume = (opcode_t *)next;

        if (pad) {
           /* put the correct pad in place */
           stack_push(INTERP, &INTERP->ctx.pad_stack, pad,
                      STACK_ENTRY_PMC, STACK_CLEANUP_NULL);
        }

        return dest;
    }

    void clone(PMC *ret) {
        struct Parrot_Coroutine * retc;
        ret->data = retc = mem_sys_allocate(sizeof(struct Parrot_Coroutine));
        PObj_custom_mark_destroy_SETALL(ret);
        memcpy(ret->data, SELF->data, sizeof(struct Parrot_Coroutine));
        stack_mark_cow(retc->ctx.user_stack);
        stack_mark_cow(retc->ctx.control_stack);
    }
}
