/* tqueue.pmc
 *  Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
 *  CVS Info
 *     $Id$
 *  Overview:
 *     Threadsafe queue class for inter thread communication
 *     If you have an unthreaded program then please
 *     use a PerlArray
 *  Data Structure and Algorithms:
 *  History:
 *     2003.12.19 leo initial rev
 *  Notes:
 *
 *     new P0, .TQueue
 *     push P0, some
 *     new P2, .ParrotThread
 *     ...
 *
 *     and in other thread (at least, when shared PMCs work :)
 *
 *     shift P1, P0
 *
 *     Note: The TQueue must always be emptied before program
 *           exit.
 *
 *  References:
 */

#include "parrot/parrot.h"
#include <assert.h>

pmclass TQueue need_ext is_shared {

    void init () {
        SELF->cache.int_val = 0;
        PMC_data(SELF) = queue_init(0);
	PObj_custom_mark_destroy_SETALL(SELF);
    }

    PMC* clone() {
        /* XXX fake a shared PMC */
        return SELF;
    }

    void mark () {
        QUEUE *queue = PMC_data(SELF);
        QUEUE_ENTRY *entry;
        PMC *val;

        queue_lock(queue);
        entry = queue->head;
        while (entry) {
            pobject_lives(INTERP, (PObj*) entry->data);
            if (entry == queue->tail)
                break;
            entry = entry->next;
        }
        queue_unlock(queue);
    }

    void destroy () {
        if (PMC_data(SELF)) {
            QUEUE *queue = PMC_data(SELF);
#if 0
            /*
             * wait til queue is empty
             * XXX implement a time wait and PANIC if queue
             * isn't empty after some TIMEOUT
             */
            while (SELF.elements()) {
                queue_lock(queue);
                queue_wait(queue);
                queue_unlock(queue);
            }
#endif
            mem_sys_free(queue);
            PMC_data(SELF) = NULL;
        }
    }

    INTVAL defined () {
        return SELF.get_integer() != 0;
    }

    INTVAL get_integer () {
        INTVAL items;
        QUEUE *queue = PMC_data(SELF);

        items = SELF->cache.int_val;
        return items;
    }

    INTVAL elements () {
        return SELF.get_integer();
    }

    void push_pmc(PMC *item) {
        QUEUE_ENTRY* entry = mem_sys_allocate(sizeof(QUEUE_ENTRY));
        QUEUE *queue = PMC_data(SELF);

        /*
         * if item isn't shared nor const, then make
         *       a shared item
         */
        if (!(item->vtable->flags &
                    (VTABLE_IS_CONST_FLAG | VTABLE_IS_SHARED_FLAG)))
            VTABLE_share(INTERP, item);

        entry->data = item;
        entry->type = QUEUE_ENTRY_TYPE_NONE;
        /* s. tsq.c:quene_push */
        queue_lock(queue);
        ++SELF->cache.int_val;
        /* Is there something in the queue? */
        if (queue->tail) {
            queue->tail->next = entry;
            queue->tail = entry;
        } else {
            queue->head = entry;
            queue->tail = entry;
        }
        queue_broadcast(queue);        /* signal all waiters */
        queue_unlock(queue);
    }

    PMC* shift_pmc() {
        QUEUE_ENTRY *entry;
        QUEUE *queue = PMC_data(SELF);
        PMC *ret;

        queue_lock(queue);
        while (queue->head == NULL) {
            queue_wait(queue);
        }
        entry = nosync_pop_entry(queue);
        --SELF->cache.int_val;
        queue_unlock(queue);
        ret = entry->data;
        mem_sys_free(entry);
        return ret;
    }


}

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
