/*
Copyright: 2004 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/slice.pmc - Slice PMC

=head1 DESCRIPTION

These are the vtable functions for the slice PMC class.

A Slice PMC isa Key PMC, holding a chain of start and/or end values
for slice ranges. Private flags define the meaning of the values:

  [ s .. e ]    s .. KEY_start_slice_FLAG; e .. KEY_end_slice_FLAG
  [ x,     ]    KEY_start_slice_FLAG | KEY_end_slice_FLAG
  [  .. e  ]    KEY_inf_slice_FLAG   | KEY_end_slice_FLAG
  [ s ..   ]    KEY_start_slice_FLAG | KEY_inf_slice_FLAG

Ranges are currently implemented for Array and PerlString only.

Run

  $ parrot -d2000 slice.pasm

to see slice constant flags.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"


/*
 * set the Slice iter state to initial, first position
 * no backwards iterations for now
 */
static void
set_slice_start(Interp *interpreter, PMC *self)
{
    PMC* range = PMC_pmc_val(self);

    /*
     * set start value in struct_val
     * Please nt that the range PMC can hold variables too
     * so that key_integer/key_string must be used to get the
     * values
     */
    if (key_type(interpreter, range) & KEY_integer_FLAG) {
        /* integer key */
        if ((PObj_get_FLAGS(range) &
                    (KEY_inf_slice_FLAG|KEY_end_slice_FLAG)) ==
                (KEY_inf_slice_FLAG|KEY_end_slice_FLAG)) {
            /*
             * first range is ".. end"
             * start at index 0
             * */
            PMC_struct_val(self) = (void *)0;
        }
        else {
            /*
             * else start at range value
             */
            PMC_struct_val(self) = (void *)key_integer(interpreter, range);
        }
    }
    else {
        if (PObj_get_FLAGS(range) & KEY_inf_slice_FLAG) {
            internal_exception(1,
                    "unlimited slice range for hash not implemented");
        }

        /*
         * string assumed
         * start at value
         */
        PMC_struct_val(self) = key_string(interpreter, range);
    }
}

/*
 * increment Slice value according to range and/or advance to
 * next range PMC in Key chain
 */
static void
set_slice_next(Interp *interpreter, PMC *self, PMC *agg)
{
    PMC* range = PMC_pmc_val(self);

    if (key_type(interpreter, range) & KEY_integer_FLAG) {
        INTVAL cur, end;

        if ((PObj_get_FLAGS(range) &
                    (KEY_start_slice_FLAG|KEY_end_slice_FLAG)) ==
                (KEY_start_slice_FLAG|KEY_end_slice_FLAG)) {
            /* start = end, single element */
            goto next_range;
        }
        if ((PObj_get_FLAGS(range) &
                    (KEY_inf_slice_FLAG|KEY_end_slice_FLAG)) ==
                (KEY_inf_slice_FLAG|KEY_end_slice_FLAG)) {
            /* first range is ".. end" */
            cur = (INTVAL)PMC_struct_val(self);
            end = key_integer(interpreter, range);
            if (agg->vtable->base_type == enum_class_Slice)
                --end;
            if (cur < end) {
                ++cur;
                PMC_struct_val(self) = (void *)cur;
                return;
            }
            goto next_range;
        }

        if ((PObj_get_FLAGS(range) &
                    (KEY_inf_slice_FLAG|KEY_start_slice_FLAG)) ==
                (KEY_inf_slice_FLAG|KEY_start_slice_FLAG)) {
            /* last range "start .." */
            cur = (INTVAL)PMC_struct_val(self);
            end = VTABLE_elements(interpreter, agg);
            if (cur < end - 1) {
                ++cur;
                PMC_struct_val(self) = (void *)cur;
                return;
            }
            goto next_range;
        }
        if (PObj_get_FLAGS(range) & KEY_start_slice_FLAG) {
            /*
             * start ... end range
             * end is in the next range in the Key chain
             */
            PMC *end_range = PMC_data(range);
            if (!end_range)
                internal_exception(1, "No end range found");
            cur = (INTVAL)PMC_struct_val(self);
            end = key_integer(interpreter, end_range);
            if (agg->vtable->base_type == enum_class_Slice)
                --end;
            if (cur < end) {
                ++cur;
                PMC_struct_val(self) = (void *)cur;
                return;
            }
            /* skip end range */
            PMC_pmc_val(self) = end_range;
            range = end_range;
            /* go on with next_range */
        }

next_range:
        range = PMC_pmc_val(self) = PMC_data(range);
        if (!range) {
            /*
             * this denotes the end of iteration
             */
            PMC_int_val(self) = -1;
        }
        else {
            /*
             * set start value
             */
            PMC_struct_val(self) = (void *)key_integer(interpreter, range);
        }
    }
    else {
        STRING *cur, *end;
        /*
         * string assumed
         */
        if ((PObj_get_FLAGS(range) &
                    (KEY_start_slice_FLAG|KEY_end_slice_FLAG)) ==
                (KEY_start_slice_FLAG|KEY_end_slice_FLAG)) {
            /*
             * only single values or limited ranges - no
             * ..end or start.. range for hash
             */
            goto next_str_range;
        }
        if (PObj_get_FLAGS(range) & KEY_inf_slice_FLAG) {
            internal_exception(1,
                    "unlimited slice range for hash not implemented");
        }
        if (PObj_get_FLAGS(range) & KEY_start_slice_FLAG) {
            /*
             * start ... end range
             * end is in the next range in the Key chain
             */
            PMC *end_range = PMC_data(range);
            if (!end_range)
                internal_exception(1, "No end range found");
            cur = (STRING *)PMC_struct_val(self);
            end = key_string(interpreter, end_range);
            if (string_compare(interpreter, cur, end) < 0) {
                cur = string_increment(interpreter, cur);
                PMC_struct_val(self) = (void *)cur;
                return;
            }
            /* skip end range */
            PMC_pmc_val(self) = end_range;
            range = end_range;
            /* go on with next_range */
        }
next_str_range:
        range = PMC_pmc_val(self) = PMC_data(range);
        if (!range)
            PMC_int_val(self) = -1;
        else
            PMC_struct_val(self) = key_string(interpreter, range);
    }
}

pmclass Slice need_ext extends Key {

    void init () {
        PMC_pmc_val(SELF) = NULL;
        SUPER();
    }

    void mark () {
        if (PMC_pmc_val(SELF))
            pobject_lives(INTERP, (PObj*)PMC_pmc_val(SELF));
        SUPER();
    }

    PMC* clone() {
        internal_exception(1, "Unimplemented");
        /*
         * TODO - Key_Clone does all - except for the slice flags
         */
        return NULL;
    }

/*

=item C<INTVAL get_integer()>

Get the next integer key from the current slice range.

=item C<STRING* get_string()>

Get the next string key from the current slice range.

=cut

*/

    INTVAL get_integer() {
        INTVAL v = (INTVAL)PMC_struct_val(SELF);
        return v;
    }

    STRING* get_string() {
        STRING *s = (STRING *)PMC_struct_val(SELF);
        return s;
    }

/*

=item C<PMC* slice(PMC *key)>

A slice can serve as its own iterator, yielding values [start .. end-1].
This is used for implementing Pythons xrange()

=cut

*/

    PMC* slice(PMC *key) {
	PMC *iter = pmc_new_init(interpreter, enum_class_Iterator, SELF);
        PMC_struct_val(iter) = key;
        return iter;
    }

    INTVAL elements () {
        /* only start .. end supported so:
         * TODO check flags somewhere
         * */
        PMC* range = PMC_pmc_val(SELF);
        PMC *end = PMC_data(range);
        INTVAL n = PMC_int_val(end) - PMC_int_val(range);
        return n;
    }

    INTVAL get_integer_keyed(PMC* key) {
        return VTABLE_get_integer(INTERP, key);
    }

    STRING* get_string_keyed(PMC* key) {
        INTVAL v = VTABLE_get_integer(INTERP, key);
        return string_from_int(INTERP, v);
    }
/*

=item C<PMC* nextkey_keyed (PMC* agg, INTVAL what)>

Prepate slice PMC SELF for iteration over the passed aggregate or
advance to next position in the range, dpending on what.

=cut

*/
    PMC* nextkey_keyed (PMC* agg, INTVAL what) {
        PMC *ret = SELF;
        if (agg->vtable->base_type == enum_class_Slice) {
            /* xrange implementation - the slice PMC
             * itself serves as the aggregate. We
             * are called with params swapped then
             */
            PMC *temp = SELF;
            SELF = ret = agg;
            agg = temp;
        }

        switch (what) {
            case ITERATE_FROM_START:
            case ITERATE_FROM_START_KEYS:    /* reset key */
                /*
                 * need a new Slice PMC that hold's the state
                 * especially PMC_data() must be zero
                 *
                 * aggregate call get_integer/get_string on this
                 * PMC, because it's marked being a Key PMC
                 */
                ret = pmc_new(INTERP, enum_class_Slice);
                PObj_get_FLAGS(ret) |= KEY_pmc_FLAG;

                PMC_data(ret) = NULL;
                /*
                 * remember slice chain in PMC_pmc_val
                 */
                PMC_pmc_val(ret) = SELF;
                /*
                 * and set start value
                 */
                set_slice_start(INTERP, ret);
                break;
                /*
                 * we are passed now the new PMC, we had created above
                 */
            case ITERATE_GET_NEXT:
                set_slice_next(INTERP, ret, agg);
                break;
            default:
                internal_exception(1, "No backward iteration on slices yet");
                break;
        }
        return ret;
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
