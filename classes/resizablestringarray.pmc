/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/resizablestringarray.pmc - resizable array for strings only

=head1 DESCRIPTION

ResizableStringArray implements a resizeable array which stores Parrot 
strings only. If other PMCs are assigned to elements of it, their 
values will automatically be stringified and assigned to String PMCs.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

typedef struct _SizeStringData {
    INTVAL size;
    STRING* data[1];
} SizeStringData;
#define NEEDED_SIZE(n) ((n-1)*sizeof(STRING*) + sizeof(SizeStringData))

pmclass ResizableStringArray extends FixedStringArray need_ext does array {
    
/*

=item C<STRING *get_string_keyed_int(INTVAL key)>

Returns the Parrot string value of the element at index C<key>.

=cut

*/

    STRING* get_string_keyed_int (INTVAL key) {
        SizeStringData *sd;
        if (key < 0)
            internal_exception(OUT_OF_BOUNDS, 
                "ResizableStringArray: index out of bounds!");
        if(key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);
        
        sd = (SizeStringData *)PMC_data(SELF);
        return sd->data[key];
    }

/*

=item C<void set_string_keyed_int(INTVAL key, STRING *value)>

Sets the Parrot string value of the element at index C<key> to C<value>.

=cut

*/

    void set_string_keyed_int (INTVAL key, STRING* value) {
        SizeStringData *sd;
        if (key < 0)
            internal_exception(OUT_OF_BOUNDS, 
                "ResizableStringArray: index out of bounds!");
        if(key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);

        sd = (SizeStringData *)PMC_data(SELF);
        sd->data[key] = value;
    }

/*

=item C<void push_string (STRING* value)>

Extends the array by adding an element of value C<*value> to the end of
the array.

=cut

*/

    void push_string (STRING* value) {
        INTVAL nextix = DYNSELF.elements();
        DYNSELF.set_string_keyed_int(nextix, value);
    }

/*

=item C<STRING* pop_string()>

Removes and returns the last element in the array.

=cut

*/

    STRING* pop_string() {
        INTVAL size;
        STRING* value;
        SizeStringData *sd;

        size = PMC_int_val(SELF);
        sd = (SizeStringData *)PMC_data(SELF);

        if (sd == NULL || size == 0) {
            internal_exception(OUT_OF_BOUNDS, 
                    "ResizableStringArray: Can't pop from an empty array!");
        }

	value = sd->data[size - 1];
        DYNSELF.set_integer_native(size - 1);

        return value;
    }

/*

=item C<void set_integer_native(INTVAL size)>

Resizes the array to C<size> elements.

=cut

*/

    void set_integer_native (INTVAL size) {
        SizeStringData *sd;

        if (size < 0)
            internal_exception(OUT_OF_BOUNDS, 
                    "ResizableStringArray: Can't resize!");

        sd = (SizeStringData *)PMC_data(SELF);
        PMC_int_val(SELF) = size;
        if(sd == NULL) {
            /* The parent class makes the assumption that NULL pointers are all
               bits zero, so we might as well too.  */
            sd = mem_sys_allocate_zeroed(NEEDED_SIZE(size));
            sd->size = size;
        } else if(size >= sd->size) {
            int i = sd->size;
            sd->size =  size < 2*sd->size ? sd->size*2 : size;
            sd = mem_sys_realloc(sd, NEEDED_SIZE(sd->size));
            for(; i < sd->size; i++)
                sd->data[i] = NULL;
        } else {
            return;
        }

        PMC_data(SELF) = sd;
        PObj_custom_mark_destroy_SETALL(SELF);
    }
    
/*

=item C<PMC *clone()>

Creates and returns a copy of the array.

=cut

*/

    PMC* clone () {
        SizeStringData *sd;
        PMC * dest = pmc_new(INTERP, SELF->vtable->base_type);
    
        if (!PMC_data(SELF))
            return dest;
        PMC_int_val(dest) = PMC_int_val(SELF);
        sd = (SizeStringData *)PMC_data(SELF);
        
        PMC_data(dest) = mem_sys_allocate(NEEDED_SIZE(sd->size));
        mem_sys_memcopy(PMC_data(dest), PMC_data(SELF), NEEDED_SIZE(sd->size));
        PObj_custom_mark_destroy_SETALL(SELF);
        return dest;
    }

/*

=item C<void mark()>

Marks the array as live.

=cut

*/

    void mark () {
        SizeStringData *sd;
        int i, end;
        STRING **data;
        if (!PMC_data(SELF))
            return;
        sd = (SizeStringData *)PMC_data(SELF);
        data = sd->data;
        end = PMC_int_val(SELF);
        for(i = 0; i < end; i++) {
            if(data[i]) {
                pobject_lives(INTERP, (PObj *) data[i]);
            }
        }
    }

}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd17_basic_types.pod>.

=head1 HISTORY

Initial version                  - Matt Fowles 2004-06-11
Changed allocator to double size - Matt Fowles 2004-06-15
Added push_string                - Bernhard Schmalhofer 2004-10-17

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
