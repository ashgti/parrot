/* default.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info $Id$
 *  Overview:
 *     These are the vtable functions for the default base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"

pmclass default noinit {

   INTVAL type () {
     return 0;
   }

   STRING* name () {
     return NULL;
   }

   void init () {
   }

   void clone (PMC* dest) {
   }

   void morph (INTVAL type) {
   }

   BOOLVAL move_to (void * destination) {
     return 0;
   }

   INTVAL real_size () {
     return 0;
   }

   void destroy () {
   }

   INTVAL get_integer () {
     return SELF->cache.int_val;
   }

   INTVAL get_integer_index (INTVAL idx) {
     return 0;
   }

   INTVAL get_integer_index_s (STRING* idx) {
     return 0;
   }

   FLOATVAL get_number () {
     return SELF->cache.num_val;
   }

   FLOATVAL get_number_index (INTVAL idx) {
     return 0.0;
   }

   FLOATVAL get_number_index_s (STRING* idx) {
     return 0.0;
   }

   STRING* get_string () {
     STRING *s = string_copy(INTERP, SELF->cache.struct_val);
     return s;
   }

   STRING* get_string_index (INTVAL idx) {
     return NULL;
   }

   STRING* get_string_index_s (STRING* idx) {
     return NULL;
   }

   BOOLVAL get_bool () {
     /*  Everything has to be false */
     if (   SELF->vtable->get_integer(INTERP, SELF) == 0 
	 && SELF->vtable->get_number(INTERP, SELF) == 0.0
	 && string_bool(SELF->vtable->get_string(INTERP, SELF)) == 0
	    )
       {
	 return 0;
       }
     return 1;
   }

   void* get_value () {
     return SELF->cache.struct_val;
   }

   BOOLVAL is_same (PMC* pmc2) {
     /* I think this should cover this correctly, is_same implies that
	same B<data> used by each, but as meaning of data is a little
	vtable reliant, I include that test as well */
     return (BOOLVAL)(SELF->vtable == pmc2->vtable && &SELF->cache == &pmc2->cache);
   }

   /* The set methods merely make the appropriate part of the cache
      be what it should be, more complex behaviour is left as an
      exercise for the inheriting class. */

   void set_integer (PMC * value) {
     SELF->cache.int_val = value->vtable->get_integer(INTERP, value);
   }

   void set_integer_native (INTVAL value) {
     SELF->cache.int_val = value;
   }

   void set_integer_bigint (BIGINT value) {
     /*SELF->vtable = &(Parrot_base_vtables[enum_class_PerlBigInt]);*/
     /* XXX: do something to copy the BigInt .. */
   }

   void set_integer_same (PMC * value) {
     SELF->cache.int_val = value->vtable->get_integer(INTERP, value);
   }

   void set_integer_index (INTVAL value, INTVAL idx) {
   }

   void set_integer_index_s (INTVAL value, STRING* idx) {
   }

   void set_number (PMC * value) {
     SELF->cache.num_val = value->vtable->get_number(INTERP, value);
   }

   void set_number_native (FLOATVAL value) {
     SELF->cache.num_val = value;
   }

   void set_number_bigfloat (BIGFLOAT value) {
     /* SELF->vtable = &(Parrot_base_vtables[enum_class_PerlBigNum]); */
     /* will want to use bignum library to copy bignum... */
   }

   void set_number_same (PMC * value) {
     SELF->cache.num_val = value->vtable->get_number(INTERP, value);
   }

   void set_number_index (FLOATVAL value, INTVAL idx) {
   }

   void set_number_index_s (FLOATVAL value, STRING* idx) {
   }

   void set_string (PMC * value) {
     SELF->cache.struct_val = value->vtable->get_string(INTERP, value);
   }

   void set_string_native (STRING * value) {
     SELF->cache.struct_val = string_copy(INTERP, value);
   }

   void set_string_unicode (STRING * value) {
     SELF->cache.struct_val = string_copy(INTERP, value);
   }

   void set_string_other (STRING * value) {
     SELF->cache.struct_val = string_copy(INTERP, value);
   }

   void set_string_same (PMC * value) {
     SELF->cache.struct_val = value->vtable->get_string(INTERP, value);
   }

   void set_string_index (STRING * string, INTVAL idx) {
   }

   void set_string_index_s (STRING * string, STRING* idx) {
   }

   void set_value (void* value) {
     SELF->cache.struct_val = value;
   }

   void add (PMC * value,  PMC* dest) {
     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             + value->vtable->get_number(INTERP, value);

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void add_int (INTVAL value,  PMC* dest) {
     /* dest = SELF + value */
     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             + value;

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void add_bigint (BIGINT value,  PMC* dest) {
     /* XXX: bigint magic */
   }

   void add_float (FLOATVAL value,  PMC* dest) {
     /* dest = SELF + value */
     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             + value;

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void add_bigfloat (BIGFLOAT value,  PMC* dest) {
     /* XXX: bigfloat magic */
   }

   void add_same (PMC * value,  PMC* dest) {
     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             + value->vtable->get_number(INTERP, value);

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void subtract (PMC * value,  PMC* dest) {
     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             - value->vtable->get_number(INTERP, value);

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void subtract_int (INTVAL value,  PMC* dest) {
     /* dest = SELF - value */
     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             - value;

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void subtract_bigint (BIGINT value,  PMC* dest) {
     /* XXX: bigint magic */
   }

   void subtract_float (FLOATVAL value,  PMC* dest) {
     /* dest = SELF - value */
     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             - value;

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void subtract_bigfloat (BIGFLOAT value,  PMC* dest) {
     /* XXX: bigfloat magic */
   }

   void subtract_same (PMC * value,  PMC* dest) {
     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             - value->vtable->get_number(INTERP, value);

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void multiply (PMC * value,  PMC* dest) {
     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             * value->vtable->get_number(INTERP, value);

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void multiply_int (INTVAL value,  PMC* dest) {
     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             * value;

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void multiply_bigint (BIGINT value,  PMC* dest) {
   }

   void multiply_float (FLOATVAL value,  PMC* dest) {
     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             * value;

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void multiply_bigfloat (BIGFLOAT value,  PMC* dest) {
     /* XXX: bigfloat magic */
   }

   void multiply_same (PMC * value,  PMC* dest) {
     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             * value->vtable->get_number(INTERP, value);

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void divide (PMC * value,  PMC* dest) {
     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             / value->vtable->get_number(INTERP, value);

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void divide_int (INTVAL value,  PMC* dest) {
     /* dest = SELF / value */

     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             / value;

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void divide_bigint (BIGINT value,  PMC* dest) {
   }

   void divide_float (FLOATVAL value,  PMC* dest) {
     /* dest = SELF / value */

     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             / value;

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void divide_bigfloat (BIGFLOAT value,  PMC* dest) {
   }

   void divide_same (PMC * value,  PMC* dest) {
     /* XXX: overflow detection, bignum promotion? */

     FLOATVAL result;

     result = SELF->vtable->get_number(INTERP, SELF)
             / value->vtable->get_number(INTERP, value);

     dest->vtable->set_number_native(INTERP, dest, result);
   }

   void modulus (PMC * value,  PMC* dest) {
     /* This does perl-like modulus */

     INTVAL result;

     result = SELF->vtable->get_integer(INTERP, SELF)
             % value->vtable->get_integer(INTERP, value);

     dest->vtable->set_integer_native(INTERP, dest, result);
   }

   void modulus_int (INTVAL value,  PMC* dest) {
     INTVAL result;

     result = SELF->vtable->get_integer(INTERP, SELF)
             % value;

     dest->vtable->set_integer_native(INTERP, dest, result);
   }

   void modulus_bigint (BIGINT value,  PMC* dest) {
     /*  lala, I can't hear you */
   }

   void modulus_float (FLOATVAL value,  PMC* dest) {
     /* XXX: makes all arguments integers...*/
     INTVAL result;

     result = SELF->vtable->get_integer(INTERP, SELF)
             % (INTVAL)value;

     dest->vtable->set_integer_native(INTERP, dest, result);
   }

   void modulus_bigfloat (BIGFLOAT value,  PMC* dest) {
     /*  Can't sleep, clown'll eat me */
   }

   void modulus_same (PMC * value,  PMC* dest) {
     /* This does perl-like modulus */
     INTVAL result;

     result = SELF->vtable->get_integer(INTERP, SELF)
             % value->vtable->get_integer(INTERP, value);

     dest->vtable->set_integer_native(INTERP, dest, result);
   }

   void concatenate (PMC * value,  PMC* dest) {
     STRING *s =
       string_concat( INTERP, SELF->vtable->get_string(INTERP, SELF),
		      value->vtable->get_string(INTERP, value), 0);

     dest->vtable->set_string_native(INTERP, dest, s);
   }

   void concatenate_native (STRING * value,  PMC* dest) {
     /* dest = SELF (concat) value */
     STRING *s =
       string_concat( INTERP, SELF->vtable->get_string(INTERP, SELF),
		      value, 0);

     dest->vtable->set_string_native(INTERP, dest, s);
   }

   void concatenate_unicode (STRING * value,  PMC* dest) {
     /* dest = SELF (concat) value */
     STRING *s =
       string_concat( INTERP, SELF->vtable->get_string(INTERP, SELF),
		      value, 0);

     dest->vtable->set_string_native(INTERP, dest, s);
   }

   void concatenate_other (STRING * value,  PMC* dest) {
     /* dest = SELF (concat) value */
     STRING *s =
       string_concat( INTERP, SELF->vtable->get_string(INTERP, SELF),
		      value, 0);

     dest->vtable->set_string_native(INTERP, dest, s);
   }

   void concatenate_same (PMC * value,  PMC* dest) {
     STRING *s =
       string_concat( INTERP, SELF->vtable->get_string(INTERP, SELF),
		      value->vtable->get_string(INTERP, value), 0);

     dest->vtable->set_string_native(INTERP, dest, s);
   }

   BOOLVAL is_equal (PMC* value) {
     /* I think we need to check everything, do the easiest first... */
     if (    SELF->vtable->get_integer(INTERP, SELF)
	  == value->vtable->get_integer(INTERP, value)
	  && SELF->vtable->get_number(INTERP, SELF)
	  == value->vtable->get_number(INTERP, value)
	  && 0 == string_compare(INTERP,
			    SELF->vtable->get_string(INTERP, SELF),
			    value->vtable->get_string(INTERP, value))
	 )
       {
	 return 1;
       }
     return 0;
   }

   void logical_or (PMC* value,  PMC* dest) {
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_bool(INTERP, SELF) ||
            value->vtable->get_bool(INTERP, value)
        );
   }

   void logical_and (PMC* value,  PMC* dest) {
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_bool(INTERP, SELF) &&
            value->vtable->get_bool(INTERP, value)
        );
   }

   void logical_not (PMC* dest) {
     dest->vtable->
       set_integer_native(INTERP, dest,
			  !SELF->vtable->get_bool(INTERP, SELF));
   }

   void match (PMC * value,  REGEX* re) {
   }

   void match_native (STRING * value,  REGEX* re) {
   }

   void match_unicode (STRING * value,  REGEX* re) {
   }

   void match_other (STRING * value,  REGEX* re) {
   }

   void match_same (PMC * value,  REGEX* re) {
   }

   void repeat (PMC * value,  PMC* dest) {
     dest->vtable->set_string_native(INTERP, dest,
	 string_repeat(INTERP, SELF->vtable->get_string(INTERP,SELF),
		       (UINTVAL)value->vtable->get_integer(INTERP, value), NULL) );
   }

   void repeat_native (STRING * value,  PMC* dest) {
     /* dest = value (repeat) SELF */
     dest->vtable->set_string_native(INTERP, dest,
	 string_repeat(INTERP, value,
		       (UINTVAL)SELF->vtable->get_integer(INTERP,SELF),
		       NULL) );
   }

   void repeat_unicode (STRING * value,  PMC* dest) {
     /* dest = value (repeat) SELF */
     dest->vtable->set_string_native(INTERP, dest,
	 string_repeat(INTERP, value,
		       (UINTVAL)SELF->vtable->get_integer(INTERP,SELF),
		       NULL) );
   }

   void repeat_other (STRING * value,  PMC* dest) {
     /* dest = value (repeat) SELF */
     dest->vtable->set_string_native(INTERP, dest,
	 string_repeat(INTERP, value,
		       (UINTVAL)SELF->vtable->get_integer(INTERP,SELF),
		       NULL) );
   }

   void repeat_same (PMC * value,  PMC* dest) {
     dest->vtable->set_string_native(INTERP, dest,
	 string_repeat(INTERP, SELF->vtable->get_string(INTERP,SELF),
		       (UINTVAL)value->vtable->get_integer(INTERP, value), NULL) );
  }

}
