/* default.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info $Id$
 *  Overview:
 *     These are the vtable functions for the default PMC class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"

pmclass default noinit {

    void init () {
    }

    void init_pmc (PMC* value) {
        SELF->vtable->init(INTERP, SELF);
    }

    void morph (INTVAL type) {
    }

    /* The end of used parameter is passed into the mark_used function of
    * the garbage collector.
    */
    PMC* mark (PMC* end_of_used_list) {
        PANIC("custom_mark flag set but no custom mark routine defined");
        return NULL;
    }

    void destroy () {
    }

    INTVAL type () {
        return SELF->vtable->base_type;
    }

    INTVAL type_keyed (KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0;
    }

    INTVAL type_keyed_int (INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->type_keyed(INTERP, SELF, &r_key);
    }

    UINTVAL subtype (INTVAL type) {
        return 0;
    }

    UINTVAL subtype_keyed (KEY* key, INTVAL type) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0;
    }

    UINTVAL subtype_keyed_int (INTVAL* key, INTVAL type) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->subtype_keyed(INTERP, SELF, &r_key, type);
    }

    STRING* name () {
        return NULL;
    }

    STRING* name_keyed (KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return NULL;
    }

    STRING* name_keyed_int (INTVAL *key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->name_keyed(INTERP, SELF, &r_key);
    }

    PMC* clone () {
        PMC* dest;
        dest = pmc_new(INTERP, SELF->vtable->base_type);
        memcpy(&dest->cache, &SELF->cache, sizeof(UnionVal));
        dest->data = SELF->data;
        return dest;
    }

    PMC* clone_keyed (KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return NULL;
    }

    PMC* clone_keyed_int (INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->clone_keyed(INTERP, SELF, &r_key);
    }

    PMC* find_method(STRING* method_name) {
        return NULL;
    }

    PMC* find_method_keyed(KEY* key, STRING* method_name) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return NULL;
    }

    PMC* find_method_keyed_int(INTVAL *key, STRING* method_name) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->find_method_keyed(INTERP, SELF, &r_key, method_name);
    }

    INTVAL get_integer () {
        return SELF->cache.int_val;
    }

    INTVAL get_integer_keyed (KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0;
    }

    INTVAL get_integer_keyed_int (INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->get_number_keyed(INTERP, SELF, &r_key);
    }

    FLOATVAL get_number () {
        return SELF->cache.num_val;
    }

    FLOATVAL get_number_keyed (KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0.0;
    }

    FLOATVAL get_number_keyed_int (INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->get_number_keyed(INTERP, SELF, &r_key);
    }

    BIGNUM* get_bignum () {
        return (BIGNUM*)SELF->cache.struct_val;
    }

    BIGNUM* get_bignum_keyed (KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return NULL;
    }

    BIGNUM* get_bignum_keyed_int (INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->get_bignum_keyed(INTERP, SELF, &r_key);
    }

    STRING* get_string () {
        STRING*s = string_copy(INTERP, SELF->cache.struct_val);
        return s;
    }

    STRING* get_string_keyed (KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return NULL;
    }

    STRING* get_string_keyed_int (INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->get_string_keyed(INTERP, SELF, &r_key);
    }

    INTVAL get_bool () {
        /*  Everything has to be 0 */
        if (   SELF->vtable->get_integer(INTERP, SELF) == 0
            && SELF->vtable->get_number(INTERP, SELF) == 0.0
            && string_bool(SELF->vtable->get_string(INTERP, SELF)) == 0
            )
        {
            return 0;
        }
        return 1;
    }

    INTVAL get_bool_keyed (KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0;
    }

    INTVAL get_bool_keyed_int (INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->get_bool_keyed(INTERP, SELF, &r_key);
    }

    INTVAL elements () {
        /* XXX maybe this should be one */
        return 0;
    }

    INTVAL elements_keyed (KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0;
    }

    INTVAL elements_keyed_int (INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->elements_keyed(INTERP, SELF, &r_key);
    }

    PMC* get_pmc () {
        return SELF;
    }

    PMC* get_pmc_keyed (KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return NULL;
    }

    PMC* get_pmc_keyed_int (INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->get_pmc_keyed(INTERP, SELF, &r_key);
    }

    INTVAL is_same (PMC* pmc2) {
        /* I think this should cover this correctly, is_same implies that
        same B<data> used by each, but as meaning of data is a little
        vtable reliant, I include that test as well */
        return (INTVAL)(SELF->vtable == pmc2->vtable && &SELF->cache == &pmc2->cache);
    }

    INTVAL is_same_keyed (KEY* key, PMC* value, KEY* value_key) {
        if (key == NULL) {
            /* pmc2_key must not be null, else why did you call me? */
            return SELF->vtable->is_same(INTERP, SELF, value->vtable->get_pmc_keyed(INTERP, value, value_key));
        }
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0;
    }

    INTVAL is_same_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key) {
        KEY r_key, r_value_key;
        if (key == NULL) {
            MAKE_KEY_INT(r_value_key, *value_key);
            return SELF->vtable->is_same_keyed(INTERP, SELF, NULL, value, &r_value_key);
        }
        MAKE_KEY_INT(r_key, *key);
        if (value_key == NULL) {
            return SELF->vtable->is_same_keyed(INTERP, SELF, &r_key, value, NULL);
        }
        MAKE_KEY_INT(r_value_key, *value_key);
        return SELF->vtable->is_same_keyed(INTERP, SELF, &r_key, value, &r_value_key);
    }

    /* The set methods merely make the appropriate part of the cache
      be what it should be, more complex behaviour is left as an
      exercise for the inheriting class. */

    void set_integer (PMC* value) {
        SELF->cache.int_val = value->vtable->get_integer(INTERP, value);
    }

    void set_integer_native (INTVAL value) {
        SELF->cache.int_val = value;
    }

    void set_integer_bignum (BIGNUM* value) {
        /* XXX: do something to copy the BigInt .. */
    }

    void set_integer_same (PMC* value) {
        SELF->cache.int_val = value->vtable->get_integer(INTERP, value);
    }

    void set_integer_keyed (KEY* key, INTVAL value) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void set_integer_keyed_int (INTVAL* key, INTVAL value) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        SELF->vtable->set_integer_keyed(INTERP, SELF, &r_key, value);
    }

    void set_number (PMC* value) {
        SELF->cache.num_val = value->vtable->get_number(INTERP, value);
    }

    void set_number_native (FLOATVAL value) {
        SELF->cache.num_val = value;
    }

    void set_number_bignum (BIGNUM* value) {
        /* XXX: will want to use bignum library to copy bignum... */
    }

    void set_number_same (PMC* value) {
        SELF->cache.num_val = value->vtable->get_number(INTERP, value);
    }

    void set_number_keyed (KEY* key, FLOATVAL value) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void set_number_keyed_int (INTVAL* key, FLOATVAL value) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        SELF->vtable->set_number_keyed(INTERP, SELF, &r_key, value);
    }

    void set_bignum (PMC* value) {
        SELF->cache.struct_val = (DPOINTER*)value->vtable->get_bignum(INTERP, value);
    }

    void set_bignum_int (INTVAL value) {
        /* XXX: bignum from int */
    }

    void set_bignum_native (BIGNUM* value) {
        SELF->cache.struct_val = (DPOINTER*)value;
    }

    void set_bignum_float (FLOATVAL value) {
        /* XXX */
    }

    void set_bignum_same (PMC* value) {
        SELF->cache.struct_val = (DPOINTER*)value->vtable->get_bignum(INTERP, value);
    }

    void set_bignum_keyed (KEY* key, BIGNUM* value) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void set_bignum_keyed_int (INTVAL* key, BIGNUM* value) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        SELF->vtable->set_bignum_keyed(INTERP, SELF, &r_key, value);
    }

    void set_string (PMC* value) {
        SELF->cache.struct_val = value->vtable->get_string(INTERP, value);
    }

    void set_string_native (STRING* value) {
        SELF->cache.struct_val = string_copy(INTERP, value);
    }

    void set_string_unicode (STRING* value) {
        SELF->cache.struct_val = string_copy(INTERP, value);
    }

    void set_string_other (STRING* value) {
        SELF->cache.struct_val = string_copy(INTERP, value);
    }

    void set_string_same (PMC* value) {
        SELF->cache.struct_val = value->vtable->get_string(INTERP, value);
    }

    void set_string_keyed (KEY* key, STRING* string) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void set_string_keyed_int (INTVAL* key, STRING* string) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        SELF->vtable->set_string_keyed(INTERP, SELF, &r_key, string);
    }

    void set_pmc (PMC* value) {
        SELF->cache.struct_val = value->vtable->get_pmc(INTERP, value);
    }

    void set_pmc_keyed (KEY* key, PMC* value, KEY* value_key) {
        /* Either key or value must NOT be NULL */
        if (key == NULL)
            SELF->vtable->set_pmc(INTERP, SELF, value->vtable->get_pmc_keyed(INTERP, value, value_key));
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void set_pmc_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key) {
        KEY r_key, r_value_key;
        if (key == NULL) {
            MAKE_KEY_INT(r_value_key, *value_key);
            SELF->vtable->set_pmc_keyed(INTERP, SELF, NULL, value, &r_value_key);
            return;
        }
        MAKE_KEY_INT(r_key, *key);
        if (value_key == NULL) {
            SELF->vtable->set_pmc_keyed(INTERP, SELF, &r_key, value, NULL);
            return;
        }
        MAKE_KEY_INT(r_value_key, *value_key);
        SELF->vtable->set_pmc_keyed(INTERP, SELF, &r_key, value, &r_value_key);
    }

    void set_same (PMC* value) {
        SELF->cache = value->cache;
    }

    void set_same_keyed (KEY* dest_key, PMC* src, KEY* src_key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void set_same_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key) {
        KEY r_key, r_value_key;
        if (key == NULL) {
            MAKE_KEY_INT(r_value_key, *value_key);
            SELF->vtable->set_same_keyed(INTERP, SELF, NULL, value, &r_value_key);
            return;
        }
        MAKE_KEY_INT(r_key, *key);
        if (value_key == NULL) {
            SELF->vtable->set_same_keyed(INTERP, SELF, &r_key, value, NULL);
            return;
        }
        MAKE_KEY_INT(r_value_key, *value_key);
        SELF->vtable->set_same_keyed(INTERP, SELF, &r_key, value, &r_value_key);
    }

    INTVAL pop_integer() {
        internal_exception(OUT_OF_BOUNDS, "Pop on something that's not an aggregate!\n");
        return 0;
    }

    INTVAL pop_integer_keyed(KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0;
    }
    
    INTVAL pop_integer_keyed_int(INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->pop_integer_keyed(INTERP, SELF, &r_key);
    }    

    FLOATVAL pop_float() {
        internal_exception(OUT_OF_BOUNDS, "Pop on something that's not an aggregate!\n");
        return 0.0;
    }

    FLOATVAL pop_float_keyed(KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0.0;
    }
    
    FLOATVAL pop_float_keyed_int(INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->pop_float_keyed(INTERP, SELF, &r_key);
    }    

    BIGNUM* pop_bignum() {
        internal_exception(OUT_OF_BOUNDS, "Pop on something that's not an aggregate!\n");
        return NULL;
    }

    BIGNUM* pop_bignum_keyed(KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return NULL;
    }
    
    BIGNUM* pop_bignum_keyed_int(INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->pop_bignum_keyed(INTERP, SELF, &r_key);
    }    

    STRING* pop_string() {
        internal_exception(OUT_OF_BOUNDS, "Pop on something that's not an aggregate!\n");
        return NULL;
    }

    STRING* pop_string_keyed(KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return NULL;
    }
    
    STRING* pop_string_keyed_int(INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->pop_string_keyed(INTERP, SELF, &r_key);
    }    

    PMC* pop_pmc() {
        internal_exception(OUT_OF_BOUNDS, "Pop on something that's not an aggregate!\n");
        return NULL;
    }

    PMC* pop_pmc_keyed(KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return NULL;
    }
    
    PMC* pop_pmc_keyed_int(INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->pop_pmc_keyed(INTERP, SELF, &r_key);
    }    

    void push_integer (INTVAL value) {
        internal_exception(OUT_OF_BOUNDS, "Push on something that's not an aggregate!\n");
    }

    void push_integer_keyed (KEY* key, INTVAL value) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }
    
    void push_integer_keyed_int (INTVAL* key, INTVAL value) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        SELF->vtable->push_integer_keyed(INTERP, SELF, &r_key, value);
    }    

    void push_float (FLOATVAL value) {
        internal_exception(OUT_OF_BOUNDS, "Push on something that's not an aggregate!\n");
    }

    void push_float_keyed (KEY* key, FLOATVAL value) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }
    
    void push_float_keyed_int (INTVAL* key, FLOATVAL value) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        SELF->vtable->push_float_keyed(INTERP, SELF, &r_key, value);
    }    

    void push_bignum (BIGNUM* value) {
        internal_exception(OUT_OF_BOUNDS, "Push on something that's not an aggregate!\n");
    }

    void push_bignum_keyed (KEY* key, BIGNUM* value) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }
    
    void push_bignum_keyed_int (INTVAL* key, BIGNUM* value) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        SELF->vtable->push_bignum_keyed(INTERP, SELF, &r_key, value);
    }    

    void push_string (STRING* value) {
        internal_exception(OUT_OF_BOUNDS, "Push on something that's not an aggregate!\n");
    }

    void push_string_keyed (KEY* key, STRING* value) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }
    
    void push_string_keyed_int (INTVAL* key, STRING* value) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        SELF->vtable->push_string_keyed(INTERP, SELF, &r_key, value);
    }    

    void push_pmc (PMC* value) {
        internal_exception(OUT_OF_BOUNDS, "Push on something that's not an aggregate!\n");
    }

    void push_pmc_keyed (KEY* key, PMC* value, KEY* value_key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }
    
    void push_pmc_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key) {
        KEY r_key, r_value_key;
        if (key == NULL) {
            MAKE_KEY_INT(r_value_key, *value_key);
            SELF->vtable->push_pmc_keyed(INTERP, SELF, NULL, value, &r_value_key);
            return;
        }
        MAKE_KEY_INT(r_key, *key);
        if (value_key == NULL) {
            SELF->vtable->push_pmc_keyed(INTERP, SELF, &r_key, value, NULL);
            return;
        }
        MAKE_KEY_INT(r_value_key, *value_key);
        SELF->vtable->push_pmc_keyed(INTERP, SELF, &r_key, value, &r_value_key);
    }    

    INTVAL shift_integer() {
        internal_exception(OUT_OF_BOUNDS, "Shift on something that's not an aggregate!\n");
        return 0;
    }

    INTVAL shift_integer_keyed(KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0;
    }
    
    INTVAL shift_integer_keyed_int(INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->shift_integer_keyed(INTERP, SELF, &r_key);
    }    

    FLOATVAL shift_float() {
        internal_exception(OUT_OF_BOUNDS, "Shift on something that's not an aggregate!\n");
        return 0.0;
    }

    FLOATVAL shift_float_keyed(KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0.0;
    }
    
    FLOATVAL shift_float_keyed_int(INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->shift_float_keyed(INTERP, SELF, &r_key);
    }    

    BIGNUM* shift_bignum() {
        internal_exception(OUT_OF_BOUNDS, "Shift on something that's not an aggregate!\n");
        return NULL;
    }

    BIGNUM* shift_bignum_keyed(KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return NULL;
    }
    
    BIGNUM* shift_bignum_keyed_int(INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->shift_bignum_keyed(INTERP, SELF, &r_key);
    }    

    STRING* shift_string() {
        internal_exception(OUT_OF_BOUNDS, "Shift on something that's not an aggregate!\n");
        return NULL;
    }

    STRING* shift_string_keyed(KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return NULL;
    }
    
    STRING* shift_string_keyed_int(INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->shift_string_keyed(INTERP, SELF, &r_key);
    }    

    PMC* shift_pmc() {
        internal_exception(OUT_OF_BOUNDS, "Shift on something that's not an aggregate!\n");
        return NULL;
    }

    PMC* shift_pmc_keyed(KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return NULL;
    }
    
    PMC* shift_pmc_keyed_int(INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->shift_pmc_keyed(INTERP, SELF, &r_key);
    }    

    void unshift_integer (INTVAL value) {
        internal_exception(OUT_OF_BOUNDS, "Unshift on something that's not an aggregate!\n");
    }

    void unshift_integer_keyed (KEY* key, INTVAL value) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }
    
    void unshift_integer_keyed_int (INTVAL* key, INTVAL value) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        SELF->vtable->unshift_integer_keyed(INTERP, SELF, &r_key, value);
    }    

    void unshift_float (FLOATVAL value) {
        internal_exception(OUT_OF_BOUNDS, "Unshift on something that's not an aggregate!\n");
    }

    void unshift_float_keyed (KEY* key, FLOATVAL value) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }
    
    void unshift_float_keyed_int (INTVAL* key, FLOATVAL value) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        SELF->vtable->unshift_float_keyed(INTERP, SELF, &r_key, value);
    }    

    void unshift_bignum (BIGNUM* value) {
        internal_exception(OUT_OF_BOUNDS, "Unshift on something that's not an aggregate!\n");
    }

    void unshift_bignum_keyed (KEY* key, BIGNUM* value) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }
    
    void unshift_bignum_keyed_int (INTVAL* key, BIGNUM* value) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        SELF->vtable->unshift_bignum_keyed(INTERP, SELF, &r_key, value);
    }    

    void unshift_string (STRING* value) {
        internal_exception(OUT_OF_BOUNDS, "Unshift on something that's not an aggregate!\n");
    }

    void unshift_string_keyed (KEY* key, STRING* value) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }
    
    void unshift_string_keyed_int (INTVAL* key, STRING* value) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        SELF->vtable->unshift_string_keyed(INTERP, SELF, &r_key, value);
    }    

    void unshift_pmc (PMC* value) {
        internal_exception(OUT_OF_BOUNDS, "Unshift on something that's not an aggregate!\n");
    }

    void unshift_pmc_keyed (KEY* key, PMC* value, KEY* value_key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }
    
    void unshift_pmc_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key) {
        KEY r_key, r_value_key;
        if (key == NULL) {
            MAKE_KEY_INT(r_value_key, *value_key);
            SELF->vtable->unshift_pmc_keyed(INTERP, SELF, NULL, value, &r_value_key);
            return;
        }
        MAKE_KEY_INT(r_key, *key);
        if (value_key == NULL) {
            SELF->vtable->unshift_pmc_keyed(INTERP, SELF, &r_key, value, NULL);
            return;
        }
        MAKE_KEY_INT(r_value_key, *value_key);
        SELF->vtable->unshift_pmc_keyed(INTERP, SELF, &r_key, value, &r_value_key);
    }    

    void add (PMC* value, PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            + value->vtable->get_number(INTERP, value);

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void add_int (INTVAL value, PMC* dest) {
        /* dest = SELF + value */
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            + value;

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void add_bignum (BIGNUM* value, PMC* dest) {
        /* XXX: bignum magic */
    }

    void add_float (FLOATVAL value, PMC* dest) {
        /* dest = SELF + value */
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            + value;

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void add_same (PMC* value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            + value->vtable->get_number(INTERP, value);

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void add_keyed (KEY* key, PMC* value, KEY* value_key,
        PMC* dest, KEY* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            FLOATVAL result;

            result = SELF->vtable->get_number(INTERP, SELF) + (
                value_key == NULL ?
                value->vtable->get_number(INTERP, value) :
                value->vtable->get_number_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                dest->vtable->set_number_native(INTERP, dest, result);
            else
                dest->vtable->set_number_keyed(INTERP, dest, dest_key, result);
        }
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void add_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {

        KEY r_key, r_value_key, r_dest_key;
        
        /* Lots of comparisons here, but any given path has a max of 3 */
        
        if (key == NULL) {
            if (value_key == NULL) {
                MAKE_KEY_INT(r_dest_key, *dest_key);
                SELF->vtable->add_keyed(INTERP, SELF, NULL, value, NULL, dest, &r_dest_key);
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                SELF->vtable->add_keyed(INTERP, SELF, NULL, value, &r_value_key, dest, NULL);
            }
        }
        else {
            MAKE_KEY_INT(r_key, *key);
            if (value_key == NULL) {
                if (dest_key == NULL)
                    SELF->vtable->add_keyed(INTERP, SELF, &r_key, value, NULL, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->add_keyed(INTERP, SELF, &r_key, value, NULL, dest, &r_dest_key);
                }
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                if (dest_key == NULL)
                    SELF->vtable->add_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->add_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, &r_dest_key);
                }
            }
        }
    }

    void subtract (PMC* value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            - value->vtable->get_number(INTERP, value);

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void subtract_int (INTVAL value,  PMC* dest) {
        /* dest = SELF - value */
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            - value;

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void subtract_bignum (BIGNUM* value,  PMC* dest) {
        /* XXX: bignum magic */
    }

    void subtract_float (FLOATVAL value,  PMC* dest) {
        /* dest = SELF - value */
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            - value;

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void subtract_same (PMC* value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            - value->vtable->get_number(INTERP, value);

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void subtract_keyed (KEY* key, PMC* value, KEY* value_key,
            PMC* dest, KEY* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            FLOATVAL result;

            result = SELF->vtable->get_number(INTERP, SELF) - (
                value_key == NULL ?
                value->vtable->get_number(INTERP, value) :
                value->vtable->get_number_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                dest->vtable->set_number_native(INTERP, dest, result);
            else
                dest->vtable->set_number_keyed(INTERP, dest, dest_key, result);
        }
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void subtract_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {

        KEY r_key, r_value_key, r_dest_key;
        
        /* Lots of comparisons here, but any given path has a max of 3 */
        
        if (key == NULL) {
            if (value_key == NULL) {
                MAKE_KEY_INT(r_dest_key, *dest_key);
                SELF->vtable->subtract_keyed(INTERP, SELF, NULL, value, NULL, dest, &r_dest_key);
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                SELF->vtable->subtract_keyed(INTERP, SELF, NULL, value, &r_value_key, dest, NULL);
            }
        }
        else {
            MAKE_KEY_INT(r_key, *key);
            if (value_key == NULL) {
                if (dest_key == NULL)
                    SELF->vtable->subtract_keyed(INTERP, SELF, &r_key, value, NULL, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->subtract_keyed(INTERP, SELF, &r_key, value, NULL, dest, &r_dest_key);
                }
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                if (dest_key == NULL)
                    SELF->vtable->subtract_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->subtract_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, &r_dest_key);
                }
            }
        }
    }

    void multiply (PMC* value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            * value->vtable->get_number(INTERP, value);

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void multiply_int (INTVAL value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            * value;

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void multiply_bignum (BIGNUM* value,  PMC* dest) {
        /* XXX: bignum magic */
    }

    void multiply_float (FLOATVAL value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            * value;

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void multiply_same (PMC* value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            * value->vtable->get_number(INTERP, value);

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void multiply_keyed (KEY* key, PMC* value, KEY* value_key,
            PMC* dest, KEY* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            FLOATVAL result;

            result = SELF->vtable->get_number(INTERP, SELF) * (
                value_key == NULL ?
                value->vtable->get_number(INTERP, value) :
                value->vtable->get_number_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                dest->vtable->set_number_native(INTERP, dest, result);
            else
                dest->vtable->set_number_keyed(INTERP, dest, dest_key, result);
        }
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void multiply_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {

        KEY r_key, r_value_key, r_dest_key;
        
        /* Lots of comparisons here, but any given path has a max of 3 */
        
        if (key == NULL) {
            if (value_key == NULL) {
                MAKE_KEY_INT(r_dest_key, *dest_key);
                SELF->vtable->multiply_keyed(INTERP, SELF, NULL, value, NULL, dest, &r_dest_key);
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                SELF->vtable->multiply_keyed(INTERP, SELF, NULL, value, &r_value_key, dest, NULL);
            }
        }
        else {
            MAKE_KEY_INT(r_key, *key);
            if (value_key == NULL) {
                if (dest_key == NULL)
                    SELF->vtable->multiply_keyed(INTERP, SELF, &r_key, value, NULL, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->multiply_keyed(INTERP, SELF, &r_key, value, NULL, dest, &r_dest_key);
                }
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                if (dest_key == NULL)
                    SELF->vtable->multiply_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->multiply_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, &r_dest_key);
                }
            }
        }
    }

    void divide (PMC* value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            / value->vtable->get_number(INTERP, value);

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void divide_int (INTVAL value,  PMC* dest) {
        /* dest = SELF / value */

        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            / value;

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void divide_bignum (BIGNUM* value,  PMC* dest) {
        /* XXX: bignum magic */
    }

    void divide_float (FLOATVAL value,  PMC* dest) {
        /* dest = SELF / value */

        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            / value;

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void divide_same (PMC* value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = SELF->vtable->get_number(INTERP, SELF)
            / value->vtable->get_number(INTERP, value);

        dest->vtable->set_number_native(INTERP, dest, result);
    }

    void divide_keyed (KEY* key, PMC* value, KEY* value_key,
            PMC* dest, KEY* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            FLOATVAL result;

            result = SELF->vtable->get_number(INTERP, SELF) / (
                value_key == NULL ?
                value->vtable->get_number(INTERP, value) :
                value->vtable->get_number_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                dest->vtable->set_number_native(INTERP, dest, result);
            else
                dest->vtable->set_number_keyed(INTERP, dest, dest_key, result);
        }
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void divide_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {

        KEY r_key, r_value_key, r_dest_key;
        
        /* Lots of comparisons here, but any given path has a max of 3 */
        
        if (key == NULL) {
            if (value_key == NULL) {
                MAKE_KEY_INT(r_dest_key, *dest_key);
                SELF->vtable->divide_keyed(INTERP, SELF, NULL, value, NULL, dest, &r_dest_key);
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                SELF->vtable->divide_keyed(INTERP, SELF, NULL, value, &r_value_key, dest, NULL);
            }
        }
        else {
            MAKE_KEY_INT(r_key, *key);
            if (value_key == NULL) {
                if (dest_key == NULL)
                    SELF->vtable->divide_keyed(INTERP, SELF, &r_key, value, NULL, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->divide_keyed(INTERP, SELF, &r_key, value, NULL, dest, &r_dest_key);
                }
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                if (dest_key == NULL)
                    SELF->vtable->divide_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->divide_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, &r_dest_key);
                }
            }
        }
    }

    void modulus (PMC* value,  PMC* dest) {
        /* This does perl-like modulus */

        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            % value->vtable->get_integer(INTERP, value);

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void modulus_int (INTVAL value,  PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            % value;

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void modulus_bignum (BIGNUM* value,  PMC* dest) {
        /* XXX: Can't sleep, clown'll eat me */
    }

    void modulus_float (FLOATVAL value,  PMC* dest) {
        /* XXX: makes all arguments integers...*/
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            % (INTVAL)value;

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void modulus_same (PMC* value,  PMC* dest) {
        /* This does perl-like modulus */
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            % value->vtable->get_integer(INTERP, value);

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void modulus_keyed (KEY* key, PMC* value, KEY* value_key,
            PMC* dest, KEY* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            INTVAL result;

            result = SELF->vtable->get_integer(INTERP, SELF) % (
                value_key == NULL ?
                value->vtable->get_integer(INTERP, value) :
                value->vtable->get_integer_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                dest->vtable->set_integer_native(INTERP, dest, result);
            else
                dest->vtable->set_integer_keyed(INTERP, dest, dest_key, result);
        }
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void modulus_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {

        KEY r_key, r_value_key, r_dest_key;
        
        /* Lots of comparisons here, but any given path has a max of 3 */
        
        if (key == NULL) {
            if (value_key == NULL) {
                MAKE_KEY_INT(r_dest_key, *dest_key);
                SELF->vtable->modulus_keyed(INTERP, SELF, NULL, value, NULL, dest, &r_dest_key);
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                SELF->vtable->modulus_keyed(INTERP, SELF, NULL, value, &r_value_key, dest, NULL);
            }
        }
        else {
            MAKE_KEY_INT(r_key, *key);
            if (value_key == NULL) {
                if (dest_key == NULL)
                    SELF->vtable->modulus_keyed(INTERP, SELF, &r_key, value, NULL, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->modulus_keyed(INTERP, SELF, &r_key, value, NULL, dest, &r_dest_key);
                }
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                if (dest_key == NULL)
                    SELF->vtable->modulus_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->modulus_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, &r_dest_key);
                }
            }
        }
    }

    void neg (PMC* dest) {
        dest->vtable->set_integer_native(INTERP, dest, -SELF->vtable->get_integer(INTERP, SELF));
    }

    void neg_keyed (KEY* key, PMC* dest, KEY* dest_key) {
        if (key == NULL)
            dest->vtable->set_integer_keyed(INTERP, dest,
                dest_key, -SELF->vtable->get_integer(INTERP, SELF));
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void neg_keyed_int (INTVAL* key, PMC* dest, INTVAL* dest_key) {
        KEY r_key, r_dest_key;
        if (key == NULL) {
            MAKE_KEY_INT(r_dest_key, *dest_key);
            SELF->vtable->neg_keyed(INTERP, SELF, NULL, dest, &r_dest_key);
            return;
        }
        MAKE_KEY_INT(r_key, *key);
        if (dest_key == NULL) {
            SELF->vtable->neg_keyed(INTERP, SELF, &r_key, dest, NULL);
            return;
        }
        MAKE_KEY_INT(r_dest_key, *dest_key);
        SELF->vtable->neg_keyed(INTERP, SELF, &r_key, dest, &r_dest_key);
    }

    void bitwise_or (PMC* value, PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            | value->vtable->get_integer(INTERP, value);

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void bitwise_or_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            | value;

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void bitwise_or_same (PMC* value, PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            | value->vtable->get_integer(INTERP, value);

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void bitwise_or_keyed (KEY* key, PMC* value, KEY* value_key,
            PMC* dest, KEY* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            INTVAL result;

            result = SELF->vtable->get_integer(INTERP, SELF) | (
                value_key == NULL ?
                value->vtable->get_integer(INTERP, value) :
                value->vtable->get_integer_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                dest->vtable->set_integer_native(INTERP, dest, result);
            else
                dest->vtable->set_integer_keyed(INTERP, dest, dest_key, result);
        }
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void bitwise_or_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {

        KEY r_key, r_value_key, r_dest_key;
        
        /* Lots of comparisons here, but any given path has a max of 3 */
        
        if (key == NULL) {
            if (value_key == NULL) {
                MAKE_KEY_INT(r_dest_key, *dest_key);
                SELF->vtable->bitwise_or_keyed(INTERP, SELF, NULL, value, NULL, dest, &r_dest_key);
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                SELF->vtable->bitwise_or_keyed(INTERP, SELF, NULL, value, &r_value_key, dest, NULL);
            }
        }
        else {
            MAKE_KEY_INT(r_key, *key);
            if (value_key == NULL) {
                if (dest_key == NULL)
                    SELF->vtable->bitwise_or_keyed(INTERP, SELF, &r_key, value, NULL, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->bitwise_or_keyed(INTERP, SELF, &r_key, value, NULL, dest, &r_dest_key);
                }
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                if (dest_key == NULL)
                    SELF->vtable->bitwise_or_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->bitwise_or_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, &r_dest_key);
                }
            }
        }
    }

    void bitwise_and (PMC* value, PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            & value->vtable->get_integer(INTERP, value);

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void bitwise_and_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            & value;

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void bitwise_and_same (PMC* value, PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            & value->vtable->get_integer(INTERP, value);

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void bitwise_and_keyed (KEY* key, PMC* value, KEY* value_key,
            PMC* dest, KEY* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            INTVAL result;

            result = SELF->vtable->get_integer(INTERP, SELF) & (
                value_key == NULL ?
                value->vtable->get_integer(INTERP, value) :
                value->vtable->get_integer_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                dest->vtable->set_integer_native(INTERP, dest, result);
            else
                dest->vtable->set_integer_keyed(INTERP, dest, dest_key, result);
        }
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void bitwise_and_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {

        KEY r_key, r_value_key, r_dest_key;
        
        /* Lots of comparisons here, but any given path has a max of 3 */
        
        if (key == NULL) {
            if (value_key == NULL) {
                MAKE_KEY_INT(r_dest_key, *dest_key);
                SELF->vtable->bitwise_and_keyed(INTERP, SELF, NULL, value, NULL, dest, &r_dest_key);
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                SELF->vtable->bitwise_and_keyed(INTERP, SELF, NULL, value, &r_value_key, dest, NULL);
            }
        }
        else {
            MAKE_KEY_INT(r_key, *key);
            if (value_key == NULL) {
                if (dest_key == NULL)
                    SELF->vtable->bitwise_and_keyed(INTERP, SELF, &r_key, value, NULL, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->bitwise_and_keyed(INTERP, SELF, &r_key, value, NULL, dest, &r_dest_key);
                }
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                if (dest_key == NULL)
                    SELF->vtable->bitwise_and_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->bitwise_and_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, &r_dest_key);
                }
            }
        }
    }

    void bitwise_xor (PMC* value, PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            ^ value->vtable->get_integer(INTERP, value);

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void bitwise_xor_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            ^ value;

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void bitwise_xor_same (PMC* value, PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            ^ value->vtable->get_integer(INTERP, value);

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void bitwise_xor_keyed (KEY* key, PMC* value, KEY* value_key,
            PMC* dest, KEY* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            INTVAL result;

            result = SELF->vtable->get_integer(INTERP, SELF) ^ (
                value_key == NULL ?
                value->vtable->get_integer(INTERP, value) :
                value->vtable->get_integer_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                dest->vtable->set_integer_native(INTERP, dest, result);
            else
                dest->vtable->set_integer_keyed(INTERP, dest, dest_key, result);
        }
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void bitwise_xor_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {

        KEY r_key, r_value_key, r_dest_key;
        
        /* Lots of comparisons here, but any given path has a max of 3 */
        
        if (key == NULL) {
            if (value_key == NULL) {
                MAKE_KEY_INT(r_dest_key, *dest_key);
                SELF->vtable->bitwise_xor_keyed(INTERP, SELF, NULL, value, NULL, dest, &r_dest_key);
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                SELF->vtable->bitwise_xor_keyed(INTERP, SELF, NULL, value, &r_value_key, dest, NULL);
            }
        }
        else {
            MAKE_KEY_INT(r_key, *key);
            if (value_key == NULL) {
                if (dest_key == NULL)
                    SELF->vtable->bitwise_xor_keyed(INTERP, SELF, &r_key, value, NULL, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->bitwise_xor_keyed(INTERP, SELF, &r_key, value, NULL, dest, &r_dest_key);
                }
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                if (dest_key == NULL)
                    SELF->vtable->bitwise_xor_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->bitwise_xor_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, &r_dest_key);
                }
            }
        }
    }

    void bitwise_not (PMC* dest) {
        dest->vtable->set_integer_native(INTERP, dest, ~SELF->vtable->get_integer(INTERP, SELF));
    }

    void bitwise_not_keyed (KEY* key, PMC* dest, KEY* dest_key) {
        if (key == NULL)
            dest->vtable->set_integer_keyed(INTERP, dest,
                dest_key, ~SELF->vtable->get_integer(INTERP, SELF));
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void bitwise_not_keyed_int (INTVAL* key, PMC* dest, INTVAL* dest_key) {
        KEY r_key, r_dest_key;
        if (key == NULL) {
            MAKE_KEY_INT(r_dest_key, *dest_key);
            SELF->vtable->bitwise_not_keyed(INTERP, SELF, NULL, dest, &r_dest_key);
            return;
        }
        MAKE_KEY_INT(r_key, *key);
        if (dest_key == NULL) {
            SELF->vtable->bitwise_not_keyed(INTERP, SELF, &r_key, dest, NULL);
            return;
        }
        MAKE_KEY_INT(r_dest_key, *dest_key);
        SELF->vtable->bitwise_not_keyed(INTERP, SELF, &r_key, dest, &r_dest_key);
    }

    void bitwise_shr (PMC* value, PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            >> value->vtable->get_integer(INTERP, value);

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void bitwise_shr_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            >> value;

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void bitwise_shr_same (PMC* value, PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            >> value->vtable->get_integer(INTERP, value);

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void bitwise_shr_keyed (KEY* key, PMC* value, KEY* value_key,
            PMC* dest, KEY* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            INTVAL result;

            result = SELF->vtable->get_integer(INTERP, SELF) >> (
                value_key == NULL ?
                value->vtable->get_integer(INTERP, value) :
                value->vtable->get_integer_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                dest->vtable->set_integer_native(INTERP, dest, result);
            else
                dest->vtable->set_integer_keyed(INTERP, dest, dest_key, result);
        }
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void bitwise_shr_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {

        KEY r_key, r_value_key, r_dest_key;
        
        /* Lots of comparisons here, but any given path has a max of 3 */
        
        if (key == NULL) {
            if (value_key == NULL) {
                MAKE_KEY_INT(r_dest_key, *dest_key);
                SELF->vtable->bitwise_shr_keyed(INTERP, SELF, NULL, value, NULL, dest, &r_dest_key);
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                SELF->vtable->bitwise_shr_keyed(INTERP, SELF, NULL, value, &r_value_key, dest, NULL);
            }
        }
        else {
            MAKE_KEY_INT(r_key, *key);
            if (value_key == NULL) {
                if (dest_key == NULL)
                    SELF->vtable->bitwise_shr_keyed(INTERP, SELF, &r_key, value, NULL, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->bitwise_shr_keyed(INTERP, SELF, &r_key, value, NULL, dest, &r_dest_key);
                }
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                if (dest_key == NULL)
                    SELF->vtable->bitwise_shr_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->bitwise_shr_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, &r_dest_key);
                }
            }
        }
    }

    void bitwise_shl (PMC* value, PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            << value->vtable->get_integer(INTERP, value);

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void bitwise_shl_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            << value;

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void bitwise_shl_same (PMC* value, PMC* dest) {
        INTVAL result;

        result = SELF->vtable->get_integer(INTERP, SELF)
            << value->vtable->get_integer(INTERP, value);

        dest->vtable->set_integer_native(INTERP, dest, result);
    }

    void bitwise_shl_keyed (KEY* key, PMC* value, KEY* value_key,
            PMC* dest, KEY* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            INTVAL result;

            result = SELF->vtable->get_integer(INTERP, SELF) << (
                value_key == NULL ?
                value->vtable->get_integer(INTERP, value) :
                value->vtable->get_integer_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                dest->vtable->set_integer_native(INTERP, dest, result);
            else
                dest->vtable->set_integer_keyed(INTERP, dest, dest_key, result);
        }
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void bitwise_shl_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {

        KEY r_key, r_value_key, r_dest_key;
        
        /* Lots of comparisons here, but any given path has a max of 3 */
        
        if (key == NULL) {
            if (value_key == NULL) {
                MAKE_KEY_INT(r_dest_key, *dest_key);
                SELF->vtable->bitwise_shl_keyed(INTERP, SELF, NULL, value, NULL, dest, &r_dest_key);
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                SELF->vtable->bitwise_shl_keyed(INTERP, SELF, NULL, value, &r_value_key, dest, NULL);
            }
        }
        else {
            MAKE_KEY_INT(r_key, *key);
            if (value_key == NULL) {
                if (dest_key == NULL)
                    SELF->vtable->bitwise_shl_keyed(INTERP, SELF, &r_key, value, NULL, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->bitwise_shl_keyed(INTERP, SELF, &r_key, value, NULL, dest, &r_dest_key);
                }
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                if (dest_key == NULL)
                    SELF->vtable->bitwise_shl_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->bitwise_shl_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, &r_dest_key);
                }
            }
        }
    }

    void concatenate (PMC* value,  PMC* dest) {
        STRING* s = string_concat(INTERP,
            SELF->vtable->get_string(INTERP, SELF),
            value->vtable->get_string(INTERP, value), 0);

        dest->vtable->set_string_native(INTERP, dest, s);
    }

    void concatenate_native (STRING* value,  PMC* dest) {
        /* dest = SELF (concat) value */
        STRING* s = string_concat(INTERP,
            SELF->vtable->get_string(INTERP, SELF),
            value, 0);

        dest->vtable->set_string_native(INTERP, dest, s);
    }

    void concatenate_unicode (STRING* value,  PMC* dest) {
        /* dest = SELF (concat) value */
        STRING* s = string_concat(INTERP,
            SELF->vtable->get_string(INTERP, SELF),
            value, 0);

        dest->vtable->set_string_native(INTERP, dest, s);
    }

    void concatenate_other (STRING* value,  PMC* dest) {
        /* dest = SELF (concat) value */
        STRING* s = string_concat(INTERP,
            SELF->vtable->get_string(INTERP, SELF),
            value, 0);

        dest->vtable->set_string_native(INTERP, dest, s);
    }

    void concatenate_same (PMC* value,  PMC* dest) {
        STRING* s = string_concat(INTERP,
            SELF->vtable->get_string(INTERP, SELF),
            value->vtable->get_string(INTERP, value), 0);

        dest->vtable->set_string_native(INTERP, dest, s);
    }

    void concatenate_keyed (KEY* key, PMC* value, KEY* value_key,
            PMC* dest, KEY* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {

            STRING* result;

            if (value_key == NULL)
                result = string_concat(INTERP,
                    SELF->vtable->get_string(INTERP, SELF),
                    value->vtable->get_string(INTERP, value), 0);
            else
                result = string_concat(INTERP,
                    SELF->vtable->get_string(INTERP, SELF),
                    value->vtable->get_string_keyed(INTERP, value, value_key), 0);

            if (dest_key == NULL)
                dest->vtable->set_string_native(INTERP, dest, result);
            else
                dest->vtable->set_string_keyed(INTERP, dest, dest_key, result);
        }
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void concatenate_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {

        KEY r_key, r_value_key, r_dest_key;
        
        /* Lots of comparisons here, but any given path has a max of 3 */
        
        if (key == NULL) {
            if (value_key == NULL) {
                MAKE_KEY_INT(r_dest_key, *dest_key);
                SELF->vtable->concatenate_keyed(INTERP, SELF, NULL, value, NULL, dest, &r_dest_key);
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                SELF->vtable->concatenate_keyed(INTERP, SELF, NULL, value, &r_value_key, dest, NULL);
            }
        }
        else {
            MAKE_KEY_INT(r_key, *key);
            if (value_key == NULL) {
                if (dest_key == NULL)
                    SELF->vtable->concatenate_keyed(INTERP, SELF, &r_key, value, NULL, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->concatenate_keyed(INTERP, SELF, &r_key, value, NULL, dest, &r_dest_key);
                }
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                if (dest_key == NULL)
                    SELF->vtable->concatenate_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->concatenate_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, &r_dest_key);
                }
            }
        }
    }

    INTVAL is_equal (PMC* value) {
        /* I think we need to check everything, do the easiest first... */
        if (SELF->vtable->get_integer(INTERP, SELF)
                == value->vtable->get_integer(INTERP, value)
            && SELF->vtable->get_number(INTERP, SELF)
                == value->vtable->get_number(INTERP, value)
            && 0 == string_compare(INTERP,
                SELF->vtable->get_string(INTERP, SELF),
                value->vtable->get_string(INTERP, value))
            )
        {
            return 1;
        }
        return 0;
    }

    INTVAL is_equal_keyed (KEY* key, PMC* value, KEY* value_key) {
        if (key == NULL) {
            if (SELF->vtable->get_integer(INTERP, SELF)
                    == value->vtable->get_integer_keyed(INTERP, value, value_key)
                && SELF->vtable->get_number(INTERP, SELF)
                    == value->vtable->get_number_keyed(INTERP, value, value_key)
                && 0 == string_compare(INTERP,
                    SELF->vtable->get_string(INTERP, SELF),
                    value->vtable->get_string_keyed(INTERP, value, value_key))
                )
            {
                return 1;
            }
            return 0;
        }
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0;
    }

    INTVAL is_equal_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key) {
        KEY r_key, r_value_key;
        if (key == NULL) {
            MAKE_KEY_INT(r_value_key, *value_key);
            return SELF->vtable->is_equal_keyed(INTERP, SELF, NULL, value, &r_value_key);
        }
        MAKE_KEY_INT(r_key, *key);
        if (value_key == NULL) {
            return SELF->vtable->is_equal_keyed(INTERP, SELF, &r_key, value, NULL);
        }
        MAKE_KEY_INT(r_value_key, *value_key);
        return SELF->vtable->is_equal_keyed(INTERP, SELF, &r_key, value, &r_value_key);
    }

    INTVAL cmp (PMC* value) {
        /* XXX: What does this mean for this class? */
        return 0;
    }

    INTVAL cmp_keyed (KEY* key, PMC* value, KEY* value_key) {
        if (key == NULL)
            /* XXX: What does this mean for this class? */
            return 0;
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0;
    }

    INTVAL cmp_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key) {
        KEY r_key, r_value_key;
        if (key == NULL) {
            MAKE_KEY_INT(r_value_key, *value_key);
            return SELF->vtable->cmp_keyed(INTERP, SELF, NULL, value, &r_value_key);
        }
        MAKE_KEY_INT(r_key, *key);
        if (value_key == NULL) {
            return SELF->vtable->cmp_keyed(INTERP, SELF, &r_key, value, NULL);
        }
        MAKE_KEY_INT(r_value_key, *value_key);
        return SELF->vtable->cmp_keyed(INTERP, SELF, &r_key, value, &r_value_key);
    }

    INTVAL cmp_num (PMC* value) {
        /* XXX - Floating-point precision errors possible? */
        FLOATVAL diff = value->vtable->get_number(INTERP, value) -
                        SELF->vtable->get_number(INTERP, SELF);

        return diff == 0.0 ? 0 : diff < 0.0 ? -1 : 1;
    }

    INTVAL cmp_num_keyed (KEY* key, PMC* value, KEY* value_key) {
        if (key == NULL) {
            /* XXX - Floating-point precision errors possible? */
            FLOATVAL diff = value->vtable->get_number_keyed(INTERP, value, value_key) -
                            SELF->vtable->get_number(INTERP, SELF);

            return diff == 0.0 ? 0 : diff < 0.0 ? -1 : 1;
        }
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0;
    }

    INTVAL cmp_num_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key) {
        KEY r_key, r_value_key;
        if (key == NULL) {
            MAKE_KEY_INT(r_value_key, *value_key);
            return SELF->vtable->cmp_num_keyed(INTERP, SELF, NULL, value, &r_value_key);
        }
        MAKE_KEY_INT(r_key, *key);
        if (value_key == NULL) {
            return SELF->vtable->cmp_num_keyed(INTERP, SELF, &r_key, value, NULL);
        }
        MAKE_KEY_INT(r_value_key, *value_key);
        return SELF->vtable->cmp_num_keyed(INTERP, SELF, &r_key, value, &r_value_key);
    }

    INTVAL cmp_string (PMC* value) {
        return string_compare(INTERP, SELF->vtable->get_string(INTERP, SELF),
            value->vtable->get_string(INTERP, value));
    }

    INTVAL cmp_string_keyed (KEY* key, PMC* value, KEY* value_key) {
        if (key == NULL)
            return string_compare(INTERP, SELF->vtable->get_string(INTERP, SELF),
                value->vtable->get_string_keyed(INTERP, value, value_key));
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0;
    }

    INTVAL cmp_string_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key) {
        KEY r_key, r_value_key;
        if (key == NULL) {
            MAKE_KEY_INT(r_value_key, *value_key);
            return SELF->vtable->cmp_string_keyed(INTERP, SELF, NULL, value, &r_value_key);
        }
        MAKE_KEY_INT(r_key, *key);
        if (value_key == NULL) {
            return SELF->vtable->cmp_string_keyed(INTERP, SELF, &r_key, value, NULL);
        }
        MAKE_KEY_INT(r_value_key, *value_key);
        return SELF->vtable->cmp_string_keyed(INTERP, SELF, &r_key, value, &r_value_key);
    }

    void logical_or (PMC* value,  PMC* dest) {
        if (SELF->vtable->get_bool(INTERP, SELF)) {
            dest->vtable->set_pmc(INTERP, dest, SELF);
        }
        else {
            dest->vtable->set_pmc(INTERP, dest, value);
        }
    }

    void logical_or_keyed (KEY* key, PMC* value, KEY* value_key, PMC* dest, KEY* dest_key) {
        if (key == NULL) {
            PMC* new_value;
            if (SELF->vtable->get_bool(INTERP, SELF)) {
                if (dest_key != NULL)
                    dest->vtable->set_pmc_keyed(INTERP, dest, dest_key, SELF, NULL);
                else
                    dest->vtable->set_pmc(INTERP, dest, SELF);
            }
            else
                /* Either value_key or dest_key is not NULL */
                dest->vtable->set_pmc_keyed(INTERP, dest, dest_key, value, value_key);
        }
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void logical_or_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {

        KEY r_key, r_value_key, r_dest_key;
        
        /* Lots of comparisons here, but any given path has a max of 3 */
        
        if (key == NULL) {
            if (value_key == NULL) {
                MAKE_KEY_INT(r_dest_key, *dest_key);
                SELF->vtable->logical_or_keyed(INTERP, SELF, NULL, value, NULL, dest, &r_dest_key);
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                SELF->vtable->logical_or_keyed(INTERP, SELF, NULL, value, &r_value_key, dest, NULL);
            }
        }
        else {
            MAKE_KEY_INT(r_key, *key);
            if (value_key == NULL) {
                if (dest_key == NULL)
                    SELF->vtable->logical_or_keyed(INTERP, SELF, &r_key, value, NULL, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->logical_or_keyed(INTERP, SELF, &r_key, value, NULL, dest, &r_dest_key);
                }
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                if (dest_key == NULL)
                    SELF->vtable->logical_or_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->logical_or_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, &r_dest_key);
                }
            }
        }
    }

    void logical_and (PMC* value,  PMC* dest) {
        if (SELF->vtable->get_bool(INTERP, SELF)) {
            dest->vtable->set_pmc(INTERP, dest, value);
        }
        else {
            dest->vtable->set_pmc(INTERP, dest, SELF);
        }
    }

    void logical_and_keyed (KEY* key, PMC* value, KEY* value_key, PMC* dest, KEY* dest_key) {
        if (key == NULL) {
            if (SELF->vtable->get_bool(INTERP, SELF))
                /* Either value_key or dest_key is not NULL */
                dest->vtable->set_pmc_keyed(INTERP, dest, dest_key, value, value_key);
            else {
                if (dest_key != NULL)
                    dest->vtable->set_pmc_keyed(INTERP, dest, dest_key, SELF, NULL);
                else
                    dest->vtable->set_pmc(INTERP, dest, SELF);
            }
        }
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void logical_and_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {

        KEY r_key, r_value_key, r_dest_key;
        
        /* Lots of comparisons here, but any given path has a max of 3 */
        
        if (key == NULL) {
            if (value_key == NULL) {
                MAKE_KEY_INT(r_dest_key, *dest_key);
                SELF->vtable->logical_and_keyed(INTERP, SELF, NULL, value, NULL, dest, &r_dest_key);
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                SELF->vtable->logical_and_keyed(INTERP, SELF, NULL, value, &r_value_key, dest, NULL);
            }
        }
        else {
            MAKE_KEY_INT(r_key, *key);
            if (value_key == NULL) {
                if (dest_key == NULL)
                    SELF->vtable->logical_and_keyed(INTERP, SELF, &r_key, value, NULL, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->logical_and_keyed(INTERP, SELF, &r_key, value, NULL, dest, &r_dest_key);
                }
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                if (dest_key == NULL)
                    SELF->vtable->logical_and_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->logical_and_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, &r_dest_key);
                }
            }
        }
    }

    void logical_xor (PMC* value,  PMC* dest) {

        INTVAL my_bool, value_bool;

        my_bool = SELF->vtable->get_bool(INTERP, SELF);
        value_bool = value->vtable->get_bool(INTERP, value);

        if (my_bool && ! value_bool) {
            dest->vtable->set_pmc(INTERP, dest, SELF);
        }
        else if (value_bool && ! my_bool) {
            dest->vtable->set_pmc(INTERP, dest, value);
        }
        else {
            /* XXX - Need a better way to set FALSE */
            dest->vtable->set_integer_native(INTERP, dest, 0);
        }
    }

    void logical_xor_keyed (KEY* key, PMC* value, KEY* value_key, PMC* dest, KEY* dest_key) {

        if (key == NULL) {

            INTVAL my_bool, value_bool;

            my_bool = SELF->vtable->get_bool(INTERP, SELF);

            if (value_key == NULL)
                value_bool = value->vtable->get_bool(INTERP, value);
            else
                value_bool = value->vtable->get_bool_keyed(INTERP, value, value_key);

            if (my_bool && ! value_bool) {
                if (dest_key == NULL)
                    dest->vtable->set_pmc(INTERP, dest, SELF);
                else
                    dest->vtable->set_pmc_keyed(INTERP, dest, dest_key, SELF, NULL);
            }
            else if (value_bool && ! my_bool) {
                /* Either dest_key or value_key must be non-NULL */
                dest->vtable->set_pmc_keyed(INTERP, dest, dest_key, value, value_key);
            }
            else {
                /* XXX - Need a better way to set FALSE */
                if (dest_key == NULL)
                    dest->vtable->set_integer_native(INTERP, dest, 0);
                else
                    dest->vtable->set_integer_keyed(INTERP, dest, dest_key, 0);
            }
        }
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }


    void logical_xor_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {

        KEY r_key, r_value_key, r_dest_key;
        
        /* Lots of comparisons here, but any given path has a max of 3 */
        
        if (key == NULL) {
            if (value_key == NULL) {
                MAKE_KEY_INT(r_dest_key, *dest_key);
                SELF->vtable->logical_xor_keyed(INTERP, SELF, NULL, value, NULL, dest, &r_dest_key);
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                SELF->vtable->logical_xor_keyed(INTERP, SELF, NULL, value, &r_value_key, dest, NULL);
            }
        }
        else {
            MAKE_KEY_INT(r_key, *key);
            if (value_key == NULL) {
                if (dest_key == NULL)
                    SELF->vtable->logical_xor_keyed(INTERP, SELF, &r_key, value, NULL, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->logical_xor_keyed(INTERP, SELF, &r_key, value, NULL, dest, &r_dest_key);
                }
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                if (dest_key == NULL)
                    SELF->vtable->logical_xor_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->logical_xor_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, &r_dest_key);
                }
            }
        }
    }

    void logical_not (PMC* dest) {
        /* XXX - Need a better way to set boolean state */
        dest->vtable->set_integer_native(INTERP, dest,
            ! SELF->vtable->get_bool(INTERP, SELF));
    }

    void logical_not_keyed (KEY* key, PMC* dest, KEY* dest_key) {
        /* XXX - Need a better way to set boolean state */
        if (key == NULL)
            dest->vtable->set_integer_keyed(INTERP, dest,
                dest_key, ! SELF->vtable->get_bool(INTERP, SELF));
        else
            internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void logical_not_keyed_int (INTVAL* key, PMC* dest, INTVAL* dest_key) {
        KEY r_key, r_dest_key;
        if (key == NULL) {
            MAKE_KEY_INT(r_dest_key, *dest_key);
            SELF->vtable->logical_not_keyed(INTERP, SELF, NULL, dest, &r_dest_key);
            return;
        }
        MAKE_KEY_INT(r_key, *key);
        if (dest_key == NULL) {
            SELF->vtable->logical_not_keyed(INTERP, SELF, &r_key, dest, NULL);
            return;
        }
        MAKE_KEY_INT(r_dest_key, *dest_key);
        SELF->vtable->logical_not_keyed(INTERP, SELF, &r_key, dest, &r_dest_key);
    }

    void repeat (PMC* value,  PMC* dest) {
        dest->vtable->set_string_native(INTERP, dest,
            string_repeat(INTERP, SELF->vtable->get_string(INTERP,SELF),
                (UINTVAL)value->vtable->get_integer(INTERP, value), NULL) );
    }

    void repeat_keyed (KEY* key, PMC* value, KEY* value_key, PMC* dest, KEY* dest_key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void repeat_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {

        KEY r_key, r_value_key, r_dest_key;
        
        /* Lots of comparisons here, but any given path has a max of 3 */
        
        if (key == NULL) {
            if (value_key == NULL) {
                MAKE_KEY_INT(r_dest_key, *dest_key);
                SELF->vtable->repeat_keyed(INTERP, SELF, NULL, value, NULL, dest, &r_dest_key);
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                SELF->vtable->repeat_keyed(INTERP, SELF, NULL, value, &r_value_key, dest, NULL);
            }
        }
        else {
            MAKE_KEY_INT(r_key, *key);
            if (value_key == NULL) {
                if (dest_key == NULL)
                    SELF->vtable->repeat_keyed(INTERP, SELF, &r_key, value, NULL, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->repeat_keyed(INTERP, SELF, &r_key, value, NULL, dest, &r_dest_key);
                }
            }
            else {
                MAKE_KEY_INT(r_value_key, *value_key);
                if (dest_key == NULL)
                    SELF->vtable->repeat_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, NULL);
                else {
                    MAKE_KEY_INT(r_dest_key, *dest_key);
                    SELF->vtable->repeat_keyed(INTERP, SELF, &r_key, value, &r_value_key, dest, &r_dest_key);
                }
            }
        }
    }

    void repeat_int (INTVAL value, PMC* dest) {
        SELF->vtable->set_string_native(INTERP, dest,
            string_repeat(INTERP, SELF->vtable->get_string(INTERP,SELF),
                (UINTVAL)value, NULL) );
    }

    void repeat_int_keyed (KEY* key, INTVAL value, PMC* dest, KEY* dest_key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void repeat_int_keyed_int (INTVAL* key, INTVAL value, PMC* dest, INTVAL* dest_key) {
        KEY r_key, r_dest_key;
        if (key == NULL) {
            MAKE_KEY_INT(r_dest_key, *dest_key);
            SELF->vtable->repeat_int_keyed(INTERP, SELF, NULL, value, dest, &r_dest_key);
            return;
        }
        MAKE_KEY_INT(r_key, *key);
        if (dest_key == NULL) {
            SELF->vtable->repeat_int_keyed(INTERP, SELF, &r_key, value, dest, NULL);
            return;
        }
        MAKE_KEY_INT(r_dest_key, *dest_key);
        SELF->vtable->repeat_int_keyed(INTERP, SELF, &r_key, value, dest, &r_dest_key);
    }

    void increment () {
        SELF->cache.int_val = SELF->vtable->get_integer(INTERP, SELF) + 1;
    }

    void increment_keyed (KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void increment_keyed_int (INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        SELF->vtable->increment_keyed(INTERP, SELF, &r_key);
    }

    void decrement () {
        SELF->cache.int_val = SELF->vtable->get_integer(INTERP, SELF) - 1;
    }

    void decrement_keyed (KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void decrement_keyed_int (INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        SELF->vtable->decrement_keyed(INTERP, SELF, &r_key);
    }

    INTVAL exists_keyed (KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0;
    }

    INTVAL exists_keyed_int (INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->exists_keyed(INTERP, SELF, &r_key);
    }

    INTVAL defined () {
        return 1;
    }

    INTVAL defined_keyed (KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return 0;
    }

    INTVAL defined_keyed_int (INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->defined_keyed(INTERP, SELF, &r_key);
    }

    void delete_keyed(KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void delete_keyed_int(INTVAL* key) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        SELF->vtable->delete_keyed(INTERP, SELF, &r_key);
    }

    KEY* nextkey_keyed (KEY* key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return NULL;
    }

    KEY* nextkey_keyed_int (INTVAL* key) {
        /* XXX - Something's not right with this method */
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->nextkey_keyed(INTERP, SELF, &r_key);
    }

    void substr(INTVAL offset, INTVAL length, PMC* dest) {
    }

    void substr_keyed(KEY* key, INTVAL offset, INTVAL length, PMC* dest, KEY* dest_key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void substr_keyed_int(INTVAL* key, INTVAL offset, INTVAL length, PMC* dest, INTVAL* dest_key) {
        KEY r_key, r_dest_key;
        if (key == NULL) {
            MAKE_KEY_INT(r_dest_key, *dest_key);
            SELF->vtable->substr_keyed(INTERP, SELF, NULL, offset, length, dest, &r_dest_key);
            return;
        }
        MAKE_KEY_INT(r_key, *key);
        if (dest_key == NULL) {
            SELF->vtable->substr_keyed(INTERP, SELF, &r_key, offset, length, dest, NULL);
            return;
        }
        MAKE_KEY_INT(r_dest_key, *dest_key);
        SELF->vtable->substr_keyed(INTERP, SELF, &r_key, offset, length, dest, &r_dest_key);
    }

    STRING* substr_str(INTVAL offset, INTVAL length) {
        return string_substr(INTERP, SELF->vtable->get_string(INTERP,SELF),
            offset, length, NULL);
    }

    STRING* substr_str_keyed(KEY* key, INTVAL offset, INTVAL length) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
        return NULL;
    }

    STRING* substr_str_keyed_int (INTVAL* key, INTVAL offset, INTVAL length) {
        KEY r_key;
        MAKE_KEY_INT(r_key, *key);
        return SELF->vtable->substr_str_keyed(INTERP, SELF, &r_key, offset, length);
    }

    INTVAL invoke() {
	/* 
         * FIXME: should be an exception instead: 
         * "Invoking something that can not be invoked" ??
         */

        /* returning 0 should mean the interpretor will move on to the next op */
        return 0;

    }
}
