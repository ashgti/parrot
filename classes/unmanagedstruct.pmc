/* NCI.pmc
 *  Copyright: 2002-2003 Yet Another Society
 *  CVS Info
 *     $Id$
 *  Overview:
 *     PMC class to hold structs that parrot's not responsible for disposing of
 *     If a number is assigned to a PMC, creates a buffer of that size suitable for
 *			passing to external programs in NCI.  Buffer can be resized by re-assignment.
 *			If set to 0, or the PMC is destroyed, buffer is free()'d.
 *	   Buffer can be accessed using keyed assignments to PMC.  Out of bounds (on a 
 *			"managed" UnManagedStruct) will return -1 on a get.
 *	   If the PMC is assigned to an Ix register, returns the size of the managed, UnManagedStruct
 *			or 0 if completely unmanaged.
 *  Data Structure and Algorithms:
 *  History:
 *     Initial revision by sean 2002/08/04
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"
#include "parrot/method_util.h"
#include "parrot/pobj.h"

enum {
    PObj_UnManagedStruct_my_memory_FLAG = PObj_private0_FLAG
};

pmclass UnManagedStruct {

    STRING* name () {
        return whoami;
    }

    INTVAL is_equal (PMC* value) {
        return (SELF->vtable == value->vtable
		&& SELF->data == value->data);
    }

    INTVAL defined () {
        return SELF->data != NULL;
    }
    
    /* May cause segfaults if value is out of bounds */
    INTVAL get_integer_keyed(PMC* key) {
		INTVAL ix;
		
		if (!key) return -1;
        ix = key_integer(INTERP, key);
        if (ix < 0) return -1;
		return  (unsigned char)((char *)SELF->data)[ix];      
        
    }
    
    /* May cause segfaults if value is out of bounds */
    void set_integer_keyed (PMC* key, INTVAL value) {
		INTVAL ix;
		
        if (!key) return;
        ix = key_integer(INTERP, key);
        if (ix < 0) return;
		((char *)SELF->data)[ix]=(0xff & value);
		return;
	}
  
}
