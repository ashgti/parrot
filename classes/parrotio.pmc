/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/parrotio.pmc - Parrot IO

=head1 DESCRIPTION

These are the vtable functions for Parrot IO.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

/* This class is actually part of the io subsystem */
#include "../io/io_private.h"


pmclass ParrotIO need_ext {

/*

=item C<METHOD INTVAL say(STRING *s)>

Print the string with newline appended to SELF or to stdout if used
as class method

=cut

*/

    METHOD INTVAL say(STRING *s) {
        PMC *out = SELF == Parrot_base_vtables[enum_class_ParrotIO]->class ?
            PIO_STDOUT(INTERP) : SELF;
        INTVAL r = PIO_putps(INTERP, out, s);
        r  += PIO_puts(INTERP, out, "\n");
        return r;
    }
/*

=item C<METHOD PMC* open(STRING* file, STRING *mode, STRING* layer)>

Open the file with the given mode and use the IO given layer.

=cut

*/

    METHOD PMC* open(STRING* file, STRING *mode, STRING* layer) {
        ParrotIOLayer *l;
        const char *c_file, *c_mode, *c_layer;
        PMC *pio;

        c_file = string_to_cstring(INTERP, file);
        c_mode = string_to_cstring(INTERP, mode);
        c_layer = string_to_cstring(INTERP, layer);
        l = PIO_get_layer(INTERP, c_layer);
        pio = PIO_open(INTERP, l, c_file, c_mode);
        if (!pio || !PMC_struct_val(pio))
            return pmc_new(INTERP, enum_class_Undef);
        if (l) {
            ParrotIO *io = PMC_data(pio);
            int is_mmap = strcmp(c_layer, "mmap") == 0;
            /*
             * XXX move this into the layer
             */
            if ((is_mmap && (io->b.flags & PIO_BF_MMAP)) || !is_mmap) {
                l = interpreter->piodata->default_stack;
                if (!strcmp(l->name, "buf"))
                    l = l->down;
                /* XXX layer is stored twice - which is used when */
                io->stack = PMC_struct_val(pio) = l;
                /* push the layer */
                PIO_push_layer_str(INTERP, pio, layer);
            }
            else {
                l = interpreter->piodata->default_stack;
                io->stack = PMC_struct_val(pio) = l;
            }
        }
        /* XXX leaks as in ops/io.ops: open */
        return pio;
    }

/*

=item C<void class_init()>

Class initialization.

=item C<METHOD INTVAL eof()>

Return 0/1 according to eof state of the object.

=item C<METHOD void flush()>

Flush pending writes.

=item C<METHOD INTVAL setbuf(INTVAL)>

XXX TBD

=item C<METHOD INTVAL setlinebuf()>

XXX TBD

=cut

*/

    void class_init () {

        if (pass) {
            enter_nci_method(INTERP, enum_class_ParrotIO,
                    F2DPTR(PIO_flush), "flush", "vJO");
            enter_nci_method(INTERP, enum_class_ParrotIO,
                    F2DPTR(PIO_setbuf), "setbuf", "iJOi");
            enter_nci_method(INTERP, enum_class_ParrotIO,
                    F2DPTR(PIO_setlinebuf), "setlinebuf", "iJO");
            enter_nci_method(INTERP, enum_class_ParrotIO,
                    F2DPTR(PIO_puts), "puts", "iJOt");
            enter_nci_method(INTERP, enum_class_ParrotIO,
                    F2DPTR(PIO_eof), "eof", "iJO");
        }
    }

/*

=item C<void init()>

Initializes the IO PMC.

=cut

*/

    void init () {
        PObj_active_destroy_SET(SELF);
    }

/*

=item C<void destroy()>

Destroys the IO PMC, flushing and closing as necessary.

=cut

*/

    void destroy () {
        ParrotIO *io = PMC_data(SELF);
        if (io) {
            /* shared filehandles will only get flushed */
            if (io->flags & PIO_F_SHARED) {
                PIO_flush(INTERP, SELF);
            }
            else {
                PIO_close(INTERP, SELF);
            }
        }
    }

/*

=item C<PMC* clone()>

Clones the IO PMC.

For now both PMCs refer to the same C<ParrotIO> object. If we have
different IO layers, we might copy C<data> and C<struct_val>.

=cut

*/

    PMC* clone () {
        PMC* dest = pmc_new(INTERP, SELF->vtable->base_type);
        PMC_data(dest) = PMC_data(SELF);
        PMC_struct_val(dest) = PMC_struct_val(SELF);
        return dest;
    }

/*

=item C<INTVAL get_bool()>

Returns whether at C<EOF> or not.

=cut

*/

    INTVAL get_bool() {
        return !PIO_eof(INTERP, SELF);
    }

/*

=item C<STRING* get_string_keyed_int(INTVAL n)>

Return the name of the nth layer. B<n> >= 0 returns layer names up
from the bottom.
If B<n> is negative returns layer names from top down. For non-existing
layers an empty string is returned.

=cut

*/

    STRING* get_string_keyed_int(INTVAL n) {
        ParrotIO *io = PMC_data(SELF);
        ParrotIOLayer *layer;
        if (!io)
            return const_string(INTERP, "");
        layer = io->stack;
        if (n >= 0) {
            ParrotIOLayer *last;
            last = layer;
            for (; layer; layer = layer->down)
                last = layer;
            for (; n && last; --n, last = last->up)
                ;
            if (last)
                return string_from_cstring(INTERP, last->name, 0);
            return const_string(INTERP, "");
        }
        for (++n; n && layer; layer = layer->down, ++n)
            ;
        if (layer)
            return string_from_cstring(INTERP, layer->name, 0);
        return const_string(INTERP, "");
    }
/*

=item C<void push_string (STRING* value)>

Push the layer name C<value> onto the PIO's layer stack.

=item C<STRING* pop_string ()>

Pop a layer off the PIO's layer stack. Returns the layer name.

=cut

*/

    void push_string (STRING* value) {
        PIO_push_layer_str(INTERP, SELF, value);
    }

    STRING* pop_string () {
        return PIO_pop_layer_str(INTERP, SELF);
    }

}

/*

=back

=head1 HISTORY

Initial version by leo 2003/06/23.

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
