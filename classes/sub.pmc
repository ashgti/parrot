/* Sub.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the Sub (subroutine) base class
 *  Data Structure and Algorithms:
 *  History:
 *     Initial version by Melvin on 2002/06/6
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"

pmclass Sub {

   INTVAL type () {
       return enum_class_Sub;
   }


   STRING* name () {
	return whoami;
   }

   void init () {
       INTVAL address = 0; /* XXX this was originally passed as a
                            * parameter, but that's not valid.  So
                            * this is totally broken now. */
       SELF->data = new_sub(INTERP, (opcode_t*)address);
       PObj_custom_mark_destroy_SETALL(SELF);
   }

   PMC* mark (PMC *end_of_used_list) {
       PMC * pad = ((struct Parrot_Sub *)SELF->data)->lex_pad;
       if (pad) {
           return mark_used(pad, end_of_used_list);
       }
       else {
           return end_of_used_list;
       }
   }

   void destroy () {
       mem_sys_free(SELF->data);
   }

   void set_integer (PMC * value) {
       ((struct Parrot_Sub*)SELF->data)->init = (opcode_t*)value->vtable->get_integer(INTERP, value);
   }

   void set_integer_native (INTVAL value) {
       ((struct Parrot_Sub*)SELF->data)->init = (opcode_t*)value;
   }

   void* invoke (void* next) {
       PMC * pad = ((struct Parrot_Sub *)SELF->data)->lex_pad;

       if (pad) {
           /* put the correct pad in place */
           stack_push(INTERP, &INTERP->ctx.pad_stack, pad,
                      STACK_ENTRY_PMC, STACK_CLEANUP_NULL);
       }

       /* return address that the interpreter should jump to */
       stack_push(INTERP, &(INTERP->ctx.control_stack), next,
		  STACK_ENTRY_DESTINATION, STACK_CLEANUP_NULL);

       return ((struct Parrot_Sub*)SELF->data)->init;
   }

   PMC* clone () {
	PMC * ret = new_pmc_header(INTERP);
        PObj_custom_mark_destroy_SETALL(ret);
	ret->vtable = &Parrot_base_vtables[enum_class_Sub];
	ret->data = mem_sys_allocate(sizeof(struct Parrot_Sub));
	memcpy(ret->data, SELF->data, sizeof(struct Parrot_Sub));
	return ret;
   }

}
