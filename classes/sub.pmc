/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/sub.pmc - Subroutine

=head1 DESCRIPTION

These are the vtable functions for the Sub (subroutine) base class

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "parrot/oplib/ops.h"
#include "sub.str"
#include <assert.h>

static void
clear_fixup(Interp* interpreter, PMC* self)
{
    opcode_t i, ci;
    struct PackFile_ByteCode *seg;
    struct PackFile_FixupTable *ft;
    struct PackFile_ConstTable *ct;

    seg = PMC_sub(self)->seg;
    ft = seg->fixups;
    if (!ft)
        return;
    ct = seg->const_table;
    if (!ct)
        return;
    for (i = 0; i < ft->fixup_count; i++) {
        switch (ft->fixups[i]->type) {
            case enum_fixup_sub:
                ci = ft->fixups[i]->offset;
                if (ct->constants[ci]->u.key == self) {
                    ct->constants[ci]->u.key = NULL;
                    ft->fixups[i]->type = 0;
                    break;
                }

        }
    }
}

static void
print_sub_name(Interp* interpreter, PMC* sub)
{

        /* sub was located via globals */
    PIO_eprintf(interpreter, "# Calling sub '%Ss'\n#",
        Parrot_full_sub_name(interpreter, sub));
    print_pbc_location(interpreter);
}

opcode_t *
parrot_pass_args(Interp *interpreter, struct Parrot_sub * sub,
        struct parrot_regs_t *caller_regs, int what)
{
    PMC *args_signature, *param_signature;
    INTVAL src_i, dst_i, src_n, dst_n, src_sig, dst_sig, args_op, dst_typ;
    opcode_t *src_pc, *dst_pc;
    struct PackFile_Constant **constants;
    INTVAL i_arg;
    FLOATVAL f_arg;
    PMC *p_arg;
    STRING *s_arg;
    STRING *_array;
    PMC *slurp_ar;
    const char *action;

    _array = CONST_STRING(interpreter, "array");
    constants = interpreter->code->const_table->constants;
    if (what == PARROT_OP_get_params_pc) {
        if (interpreter->ctx.current_params)
            dst_pc = interpreter->ctx.current_params;
        else if (*sub->address != what)
            return sub->address;
        else
            dst_pc = sub->address;
        args_op = PARROT_OP_set_args_pc;
        src_pc = interpreter->current_args;

        interpreter->ctx.current_params = NULL;
        action = "params";
    }
    else {
        dst_pc = interpreter->ctx.current_results;
        args_op = PARROT_OP_set_returns_pc;
        src_pc = interpreter->current_returns;
        interpreter->ctx.current_results = NULL;
        action = "results";
    }

    assert(*dst_pc == what);
    param_signature = constants[dst_pc[1]]->u.key;
    assert(PObj_is_PMC_TEST(param_signature));
    assert(param_signature->vtable->base_type == enum_class_FixedIntegerArray);

    /* we point to the set_args opcode */
    assert(*src_pc == args_op);
    args_signature = constants[src_pc[1]]->u.key;
    assert(PObj_is_PMC_TEST(args_signature));
    assert(args_signature->vtable->base_type == enum_class_FixedIntegerArray);

    src_n = VTABLE_elements(interpreter, args_signature);
    /* never get more then the caller expects */
    dst_n = VTABLE_elements(interpreter, param_signature);

    slurp_ar = NULL;
    for (src_i = dst_i = 0, src_pc += 2, dst_pc += 2;
            src_i < src_n && dst_i < dst_n; ++src_i, ++dst_i) {
        src_sig = VTABLE_get_integer_keyed_int(interpreter,
                args_signature, src_i);
        if (!slurp_ar) {
            /* TODO create some means to reuse a user-provided
             *      result array
             */
            dst_sig = VTABLE_get_integer_keyed_int(interpreter,
                    param_signature, dst_i);
            dst_typ = dst_sig & PARROT_ARG_TYPE_MASK;
            if (dst_sig & PARROT_ARG_SLURPY_ARRAY) {
                /* create array */
                slurp_ar = pmc_new(interpreter,
                        Parrot_get_ctx_HLL_type(interpreter,
                            enum_class_ResizablePMCArray));
                REG_PMC(dst_pc[dst_i]) = slurp_ar;
            }
        }
        switch (src_sig & PARROT_ARG_TYPE_MASK) {
            /* TODO verify param_signature */
            /* XXX pdd03 Type Conversions */
            case PARROT_ARG_INTVAL:
                i_arg = src_pc[src_i];
                if (!(src_sig & PARROT_ARG_CONSTANT)) {
                    i_arg = BP_REG_INT(caller_regs, i_arg);
                }
                if (slurp_ar) {
                    VTABLE_push_integer(interpreter, slurp_ar, i_arg);
                }
                else if (dst_typ == PARROT_ARG_INTVAL)
                    REG_INT(dst_pc[dst_i]) = i_arg;
                else if (dst_typ == PARROT_ARG_PMC) {
                    PMC *d = pmc_new(interpreter,
                            Parrot_get_ctx_HLL_type(interpreter,
                                enum_class_Integer));
                    VTABLE_set_integer_native(interpreter, d, i_arg);
                    REG_PMC(dst_pc[dst_i]) = d;
                }
                else
                    real_exception(interpreter, NULL, E_ValueError,
                            "argument type mismatch");
                break;
            case PARROT_ARG_STRING:
                i_arg = src_pc[src_i];
                if ((src_sig & PARROT_ARG_CONSTANT)) {
                    s_arg = constants[i_arg]->u.string;
                }
                else {
                    s_arg = BP_REG_STR(caller_regs, i_arg);
                }
                if (slurp_ar) {
                    VTABLE_push_string(interpreter, slurp_ar, s_arg);
                }
                else if (dst_typ == PARROT_ARG_STRING)
                    REG_STR(dst_pc[dst_i]) = s_arg;
                else if (dst_typ == PARROT_ARG_PMC) {
                    PMC *d = pmc_new(interpreter,
                            Parrot_get_ctx_HLL_type(interpreter,
                                enum_class_String));
                    VTABLE_set_string_native(interpreter, d, s_arg);
                    REG_PMC(dst_pc[dst_i]) = d;
                }
                else
                    real_exception(interpreter, NULL, E_ValueError,
                            "argument type mismatch");
                break;
            case PARROT_ARG_FLOATVAL:
                i_arg = src_pc[src_i];
                if ((src_sig & PARROT_ARG_CONSTANT)) {
                    f_arg = constants[i_arg]->u.number;
                }
                else {
                    f_arg = BP_REG_NUM(caller_regs, i_arg);
                }
                if (slurp_ar) {
                    VTABLE_push_float(interpreter, slurp_ar, f_arg);
                }
                else if (dst_typ == PARROT_ARG_FLOATVAL)
                    REG_NUM(dst_pc[dst_i]) = f_arg;
                else if (dst_typ == PARROT_ARG_PMC) {
                    PMC *d = pmc_new(interpreter,
                            Parrot_get_ctx_HLL_type(interpreter,
                                enum_class_Float));
                    VTABLE_set_number_native(interpreter, d, f_arg);
                    REG_PMC(dst_pc[dst_i]) = d;
                }
                else
                    real_exception(interpreter, NULL, E_ValueError,
                            "argument type mismatch");
                break;
            case PARROT_ARG_PMC:
                i_arg = src_pc[src_i];
                if ((src_sig & PARROT_ARG_CONSTANT)) {
                    p_arg = constants[i_arg]->u.key;
                }
                else {
                    p_arg = BP_REG_PMC(caller_regs, i_arg);
                }
                if ((src_sig & PARROT_ARG_FLATTEN) ||
                        (slurp_ar && (src_sig & PARROT_ARG_MAYBE_FLATTEN))) {
                    INTVAL i, n, is_array;
                    PMC *elem;

                    is_array = VTABLE_does(interpreter, p_arg, _array);
                    if (!is_array) {
                        if (src_sig & PARROT_ARG_FLATTEN) {
                            /* src ought to be an array */
                            real_exception(interpreter, NULL, E_ValueError,
                                    "argument doesn't array");
                        }
                        /* maybe_flatten takes normal PMCs too */
                        goto normal_pmc;
                    }
                    n = VTABLE_elements(interpreter, p_arg);
                    for (i = 0; i < n && dst_i < dst_n; ++i) {
                        if (dst_typ != PARROT_ARG_PMC) {
                            real_exception(interpreter, NULL, E_ValueError,
                                    "param isn't a PMC");
                        }
                        elem = VTABLE_get_pmc_keyed_int(interpreter, p_arg, i);
                        if (slurp_ar)
                            VTABLE_push_pmc(interpreter, slurp_ar, elem);
                        else {
                            REG_PMC(dst_pc[dst_i++]) = elem;
                            dst_sig = VTABLE_get_integer_keyed_int(interpreter,
                                    param_signature, dst_i);
                            dst_typ = dst_sig & PARROT_ARG_TYPE_MASK;
                        }
                    }
                    if (!slurp_ar)
                        --dst_i;
                }
                else {
normal_pmc:
                    if (slurp_ar) {
                        VTABLE_push_pmc(interpreter, slurp_ar, p_arg);
                    }
                    else if (dst_typ == PARROT_ARG_PMC)
                        REG_PMC(dst_pc[dst_i]) = p_arg;
                    else if (dst_typ == PARROT_ARG_INTVAL)
                        REG_INT(dst_pc[dst_i]) =
                            VTABLE_get_integer(interpreter, p_arg);
                    else if (dst_typ == PARROT_ARG_FLOATVAL)
                        REG_NUM(dst_pc[dst_i]) =
                            VTABLE_get_number(interpreter, p_arg);
                    else if (dst_typ == PARROT_ARG_STRING)
                        REG_STR(dst_pc[dst_i]) =
                            VTABLE_get_string(interpreter, p_arg);
                }
                break;
        }
        if (slurp_ar)
            --dst_i;
    }
    /*
     * check for arg count mismatch
     */
    if (src_i != src_n) {
        real_exception(interpreter, NULL, E_ValueError,
                "too many arguments passed (%d) - %d %s expected",
                src_n, dst_n, action);
    }
    else if (dst_i != dst_n) {
        dst_sig = VTABLE_get_integer_keyed_int(interpreter,
                param_signature, dst_i);
        if (!(dst_sig & (PARROT_ARG_OPTIONAL|PARROT_ARG_SLURPY_ARRAY))) {
            real_exception(interpreter, NULL, E_ValueError,
                    "too few arguments passed (%d) - %d %s expected",
                    src_n, dst_n, action);
        }
    }

    return dst_pc + dst_n;
}

/*
 * A sub now contains more data like name_space, which makes it
 * effectively a container. Therefore need_ext has to be set
 */
pmclass Sub need_ext {

/*

=item C<void init()>

Initializes the subroutine.

=cut

*/

    /*
     * Sub PMC's flags usage:
     * - private0 ... Coroutine flip/flop - C exception handler
     * - private1 ... Fixup is done
     * - private2 ... tailcall invoked this Sub
     * - private3 ... pythonic coroutine generator flag
     * - private4 ... @MAIN
     * - private5 ... @LOAD
     * - private6 ... @IMMEDIATE
     * - private7 ... @POSTCOMP
     *
     * see also the enum in include/parrot/sub.h
     *
     * Data used:
     *   PMC_struct_val ... Parrot_sub structure
     *   PMC_pmc_val    ... unused / bound object in Bound_Meth PMC
     */
    void init () {
        PMC_sub(SELF) = new_sub(INTERP);
        PMC_pmc_val(SELF) = NULL;
        PObj_custom_mark_destroy_SETALL(SELF);
#if 0
        if (Interp_flags_TEST(INTERP, PARROT_DEBUG_FLAG))
            printf("Address of base segment is %p\n",
                ((struct Parrot_sub *)PMC_sub(SELF))->seg->base.pf->base.data);
#endif
    }

/*

=item C<void destroy()>

Destroys the subroutine.

=cut

*/

    void destroy () {
        struct Parrot_sub * sub = PMC_sub(SELF);
        if (!sub)
            return;
#if 0
        {
            STRING *n = Parrot_full_sub_name(INTERP, SELF);
            fprintf(stderr, "DESTROY sub %p %s\n", SELF,
                    n && n->strstart ? (char*)n->strstart : "???");
        }
#endif
        clear_fixup(INTERP, SELF);
        mem_sys_free(sub);
        PMC_sub(SELF) = NULL;
    }

/*

=item C<STRING *get_string()>

Returns the name of the subroutine.

=cut

*/

    STRING* get_string () {
        return Parrot_full_sub_name(INTERP, SELF);
    }

/*

=item C<void set_pointer(void *value)>

Sets the pointer to the actual subroutine.

=cut

*/

    void set_pointer (void* value) {
        struct Parrot_sub * sub = PMC_sub(SELF);
        PObj_get_FLAGS(SELF) |= SUB_FLAG_FIXUP_DONE;
        sub->address = value;
    }

/*

=item C<void *get_pointer()>

Returns the pointer to the actual subroutine.

=cut

*/

    void* get_pointer () {
        struct Parrot_sub * sub = PMC_sub(SELF);
        return sub->address;
    }

/*

=item C<INTVAL get_integer_keyed(PMC *key)>

I<This just unconditionally returns the start of bytecode. It's wrong,
wrong, wrong, *WRONG*. And there's no other good way, so it's here for
now.> -DRS

=cut

*/

    INTVAL get_integer_keyed (PMC* key) {
        return (INTVAL) ((PMC_sub(SELF))->seg->base.data);
    }

/*

=item C<INTVAL defined()>

=item C<INTVAL get_bool()>

Returns whether the subroutine is defined.

=cut

*/

    INTVAL defined () {
        struct Parrot_sub * sub = PMC_sub(SELF);
        return sub->address != NULL;
    }

    INTVAL get_bool () {
        struct Parrot_sub * sub = PMC_sub(SELF);
        return sub->address != NULL;
    }

/*

=item C<void *invoke(void *next)>

Invokes the subroutine.

=cut

*/

    void* invoke (void* next) {
        struct Parrot_sub * sub = PMC_sub(SELF);
        struct parrot_regs_t *caller_regs;
        PMC *ccont;
        struct PackFile_ByteCode * old_seg;
        opcode_t *pc;

        if (Interp_trace_TEST(INTERP, PARROT_TRACE_SUB_CALL_FLAG)) {
            print_sub_name(INTERP, SELF);
        }
        old_seg = INTERP->code;
        if (old_seg != sub->seg) {
            Parrot_switch_to_cs(INTERP, sub->seg, 1);
        }
        /*
         * if that's really according to pdd03, we now should have
         * P0 ... sub
         * P1 ... continuation
         * P2 ... object, if it's a method call
         *
         * create new register frame, remember old
         */
        caller_regs = INTERP->ctx.bp;
        ccont = INTERP->ctx.current_cont;
        /*
         * we have:
         * sub A:
         *    ...
         *    B()
         *    ...
         * sub B:
         *    ...
         *    return C(...)
         *    # end of B
         *
         * that is the sub B() returns in its last statement whatever
         * C() returns.
         *
         * We are just calling the sub C().
         * If the private2 flagi is set, this code is called by a
         * tailcall opcode.
         *
         * We don't allocate a new register frame, we execute the sub
         * C() in this frame. Therefore we don't have to copy function
         * arguments to the new frame.
         * As no new frame is allocated, we don't check the recursion limit.
         *
         * Running in this frame is always safe:
         * - no return continuation is invoked, which could get
         *   recycled
         * - we just pass the current continuation on to C(), whatever
         *   kind of continuation it is.
         *   Using this continuation is as safe as the execution of
         *   this sub B() was.
         * - And finally: as continuations don't close over registers
         *   any changes in the register done by C() can't have any
         *   impact on possible continuations executing later here.
         *
         */
        pc = sub->address;
        /* not yet seen */
        INTERP->ctx.current_params = INTERP->ctx.current_results = NULL;

        if (!PMC_IS_NULL(ccont)) {
            if (PObj_get_FLAGS(ccont) & SUB_FLAG_TAILCALL) {
                PObj_get_FLAGS(ccont) &= ~SUB_FLAG_TAILCALL;
                assert(ccont == REG_PMC(1));
                if (INTERP->current_args) {
                    pc = parrot_pass_args(INTERP, sub, caller_regs,
                            PARROT_OP_get_params_pc);
                }
                goto is_tail_call;
            }
        }
        if (++INTERP->ctx.recursion_depth >
                INTERP->recursion_limit) {
            real_exception(INTERP, next, E_RuntimeError,
                    "maximum recursion depth exceeded");
        }
        INTERP->ctx.bp = new_register_frame(INTERP,
                &INTERP->ctx.reg_stack);
        /*
         * when next == NULL the call creates args in the
         * new frame, e.g.
         * called from runops_fromc
         */
        if (next) {
            /* XXX temporary hack during call syntax switch */
            if (INTERP->current_args) {
                INTERP->ctx.current_sub = SELF;
                INTERP->ctx.current_pc = pc;
                pc = parrot_pass_args(INTERP, sub, caller_regs,
                        PARROT_OP_get_params_pc);
            }
            else {
                /* copy function arguments */
                copy_regs(INTERP, caller_regs);
            }
            /*
             * and copy set context variables
             */
            INTERP->ctx.current_cont = BP_REG_PMC(caller_regs, 1);
is_tail_call:
            INTERP->ctx.current_sub = SELF;
        }
        INTERP->ctx.current_HLL = sub->HLL_id;
        return pc;
    }

/*

=item C<PMC *clone()>

Creates and returns a clone of the subroutine.

=cut

*/

    PMC* clone () {
        struct Parrot_sub * sub;
        PMC* ret = pmc_new_noinit(INTERP, SELF->vtable->base_type);
        /*
         * we have to mark it ourselves
         */
        PObj_custom_mark_destroy_SETALL(ret);
        sub = PMC_sub(ret) = mem_sys_allocate(sizeof(struct Parrot_sub));
        memcpy(sub, PMC_sub(SELF), sizeof(struct Parrot_sub));
        sub->name = string_copy(INTERP, sub->name);
        PMC_pmc_val(ret) = NULL;
        return ret;
    }

/*

=item C<void mark()>

Marks the continuation as live.

=cut

*/

    void mark () {
        struct Parrot_sub * sub = PMC_sub(SELF);
        if (!sub)
            return;
        if (sub->name)
            pobject_lives(INTERP, (PObj *) sub->name);
        if (!PMC_IS_NULL(sub->name_space))
            pobject_lives(INTERP, (PObj *) sub->name_space);
        if (!PMC_IS_NULL(sub->multi_signature))
            pobject_lives(INTERP, (PObj *) sub->multi_signature);
    }
/*

=item C<void set_same(PMC *value)>

Sets the subroutine to C<*value>.

=cut

*/

    void set_same (PMC* value) {
        internal_exception(UNIMPLEMENTED, "set_same");
    }

/*

=item C<INTVAL is_equal(PMC *value)>

Returns whether the two subroutines are equal.

=cut

*/

    INTVAL is_equal (PMC* value) {
        return SELF->vtable == value->vtable &&
            (PMC_sub(SELF))->address == (PMC_sub(value))->address;
    }

/*

=item C<void visit(visit_info *info)>

This is used by freeze/thaw to visit the contents of the sub.

=item C<void freeze(visit_info *info)>

Archives the subroutine.

=cut

*/

    void visit(visit_info *info) {
        struct Parrot_sub * sub = PMC_sub(SELF);

        info->thaw_ptr = &sub->name_space;
        (info->visit_pmc_now)(INTERP, sub->name_space, info);
        info->thaw_ptr = &sub->multi_signature;
        (info->visit_pmc_now)(INTERP, sub->multi_signature, info);
        SUPER(info);
    }

    void freeze(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        struct Parrot_sub * sub = PMC_sub(SELF);
        size_t start_offs, end_offs;

        SUPER(info);
        /*
         * we currently need to write these items:
         * - start offset in byte-code segment
         * - end   offset in byte-code segment
         * - segment TODO ???
         * - flags  (i.e. @LOAD pragma and such)
         * - name of the sub's label
         * - name_space
         * - HLL_id
         * - multi_signature
         */

        /*
         * if sub addresses are absolute, the flag is set
         */
        if (PObj_get_FLAGS(SELF) & SUB_FLAG_FIXUP_DONE) {
            ptrdiff_t code = (ptrdiff_t) sub->seg->base.data;

            start_offs = ((ptrdiff_t)sub->address - code) / sizeof(opcode_t*);
            end_offs = ((ptrdiff_t)sub->end - code) / sizeof(opcode_t*);
        }
        else {
            start_offs = (size_t)sub->address;
            end_offs =   (size_t)sub->end;
        }
        io->vtable->push_integer(INTERP, io, (INTVAL) start_offs);
        io->vtable->push_integer(INTERP, io, (INTVAL) end_offs);
        io->vtable->push_integer(INTERP, io,
                PObj_get_FLAGS(pmc) & SUB_FLAG_PF_MASK);
        io->vtable->push_string(INTERP, io, sub->name);
        io->vtable->push_integer(INTERP, io, sub->HLL_id);
    }

/*

=item C<void thaw(visit_info *info)>

Unarchives the subroutine.

=cut

*/

    void thaw(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        SUPER(info);

        if (info->extra_flags == EXTRA_IS_NULL) {
            struct Parrot_sub * sub = PMC_sub(SELF);
            size_t start_offs, end_offs;
            INTVAL flags;
            /*
             * we get relative offsets
             */
            PObj_get_FLAGS(SELF) &= ~SUB_FLAG_FIXUP_DONE;
            start_offs = (size_t) io->vtable->shift_integer(INTERP, io);
            end_offs   = (size_t) io->vtable->shift_integer(INTERP, io);
            sub->address = (opcode_t*) start_offs;
            sub->end = (opcode_t*) end_offs;
            flags = io->vtable->shift_integer(INTERP, io);
            PObj_get_FLAGS(SELF) |= flags & SUB_FLAG_PF_MASK;
            sub->name = io->vtable->shift_string(INTERP, io);
            sub->HLL_id  = io->vtable->shift_integer(INTERP, io);
        }
    }

/*

=item C<void thawfinish(visit_info *info)>

Called after the subroutine as been unarchived.

=cut

*/

    void thawfinish(visit_info *info) {
        /*
         * for now do fixup here until packfile issues are sorted out
         */
        opcode_t *code;
        struct Parrot_sub * sub = PMC_sub(SELF);
        opcode_t *start_offs, *end_offs;

        /* if its absolute already - done */
        if (PObj_get_FLAGS(SELF) & SUB_FLAG_FIXUP_DONE)
            return;
        code = sub->seg->base.data;
        start_offs = code + (size_t) sub->address;
        end_offs =   code + (size_t) sub->end;
        sub->address = start_offs;
        sub->end = end_offs;
        PObj_get_FLAGS(SELF) |= SUB_FLAG_FIXUP_DONE;
    }

/*

=back

=head2 METHODS

=over 4

=item C<METHOD PMC* get_name_space()>

Return the name_space PMC or Undef. The name_space PMC is either a
String PMC or a Key PMC for a nested name_space.

=cut

*/

    METHOD PMC* get_name_space() {
        struct Parrot_sub * sub = PMC_sub(SELF);

        return PMC_IS_NULL(sub->name_space) ?
            pmc_new(INTERP, enum_class_Undef) : sub->name_space;
    }

}

/*

=back

=head1 HISTORY

Initial version by Melvin on 2002/06/6.

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
