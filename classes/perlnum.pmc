/* perlnum.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the PerlNum base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"

pmclass PerlNum {
        
    void init () {
        SELF->cache.num_val = 0.0;
    }

    void morph (INTVAL type) {
fprintf(stderr,"morph not implemented\n");
    }

    void destroy () {
    }

    INTVAL type () {
        return enum_class_PerlNum;
    }

    STRING* name() {
        return whoami;
    }

    PMC* clone () { 
        PMC* dest;
        dest = pmc_new(INTERP, enum_class_PerlNum);
        dest->vtable = SELF->vtable;
        dest->cache.num_val = SELF->cache.num_val;
        return dest;
    }

    INTVAL get_integer () {
        return (INTVAL)SELF->cache.num_val;
    }

    FLOATVAL get_number () {
        return SELF->cache.num_val;
    }

    BIGNUM* get_bignum () {
    }

    STRING* get_string () {
        char* buff = mem_sys_allocate(80);
        STRING* s;
#ifdef HAS_SNPRINTF
        snprintf(buff,80,FLOATVAL_FMT,SELF->cache.num_val);
#else
        sprintf(buff,FLOATVAL_FMT,SELF->cache.num_val);  /* XXX buffer overflow! */
#endif
        s = string_make(INTERP,buff,strlen(buff),NULL,0,NULL);
        free(buff);
        return s;
    }

    INTVAL get_bool () {
        return (INTVAL)(pmc->cache.num_val != 0.0);
    }

    INTVAL is_same (PMC* other) {
        /* Do you refer to exactly the same data that I do? */
        return (INTVAL)( other->vtable == SELF->vtable /* You never know if you've been inherited...*/
            && SELF->cache.num_val == other->cache.num_val );
    }

    void set_integer (PMC* value) {
        SELF->vtable = &(Parrot_base_vtables[enum_class_PerlInt]);
        SELF->cache.int_val = value->cache.int_val;
    }

    void set_integer_native (INTVAL value) {
        SELF->vtable = &(Parrot_base_vtables[enum_class_PerlInt]);
        SELF->cache.int_val = value;
    }

    void set_integer_bignum (BIGNUM* value) {
    }

    void set_integer_same (PMC* value) {
        SELF->vtable = &(Parrot_base_vtables[enum_class_PerlInt]);
        SELF->cache.int_val = value->cache.int_val;
    }

    void set_number (PMC* value) {
        SELF->cache.num_val = (FLOATVAL)value->vtable->get_number(INTERP, value);
    }

    void set_number_native (FLOATVAL value) {
        SELF->cache.num_val = value;
    }

    void set_number_bignum (BIGNUM* value) {
    }

    void set_number_same (PMC* value) {
        SELF->cache.num_val = value->cache.num_val;
    }

    void set_bignum (PMC* value) {
    }
    
    void set_bignum_int (INTVAL value) {
    }

    void set_bignum_native (BIGNUM* value) {
    }
    
    void set_bignum_float (FLOATVAL value) {
    }
    
    void set_bignum_same (PMC* value) {
    }
    
    void set_string (PMC* value) {
        SELF->vtable = &(Parrot_base_vtables[enum_class_PerlString]);
        SELF->data = value->data;
    }

    void set_string_native (STRING * value) {
        SELF->vtable = &(Parrot_base_vtables[enum_class_PerlString]);
        SELF->data = value;
    }

    void set_string_unicode (STRING * value) {
        SELF->vtable = &(Parrot_base_vtables[enum_class_PerlString]);
        SELF->data = value;
    }

    void set_string_other (STRING * value) {
        SELF->vtable = &(Parrot_base_vtables[enum_class_PerlString]);
        SELF->data = value;
    }

    void set_string_same (PMC * value) {
        SELF->vtable = &(Parrot_base_vtables[enum_class_PerlString]);
        SELF->data = value->data;
    }

    void add (PMC* value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->cache.num_val +
                value->vtable->get_number(INTERP, value)
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->cache.num_val +
                value->vtable->get_number(INTERP, value)
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlString]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->cache.num_val +
                value->vtable->get_number(INTERP, value)
            );
        }
    }

    void add_int (INTVAL value, PMC* dest) {
        dest->vtable->set_number_native(INTERP, dest, SELF->cache.num_val + value);
    }

    void add_bignum (BIGNUM* value, PMC* dest) {
    }

    void add_float (FLOATVAL value, PMC* dest) {
        dest->vtable->set_number_native(INTERP, dest, SELF->cache.num_val + value);
    }

    void add_same (PMC* value, PMC* dest) {
        dest->cache.num_val = SELF->cache.num_val + value->cache.num_val;
    }

    void subtract (PMC* value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->cache.num_val -
                value->vtable->get_number(INTERP, value)
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->cache.num_val -
                value->vtable->get_number(INTERP, value)
            );
        }
        else {
        }
    }

    void subtract_int (INTVAL value, PMC* dest) {
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->cache.num_val - (FLOATVAL)value
        );
    }

    void subtract_bignum (BIGNUM* value, PMC* dest) {
    }

    void subtract_float (FLOATVAL value, PMC* dest) {
        dest->vtable->set_number_native(INTERP, dest, SELF->cache.num_val - value);
    }

    void subtract_same (PMC* value, PMC* dest) {
        dest->cache.num_val = SELF->cache.num_val - value->cache.num_val;
    }

    void multiply (PMC* value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->cache.num_val *
                value->vtable->get_number(INTERP, value)
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->cache.num_val *
                value->vtable->get_number(INTERP, value)
            );
        }
        else {
        }
    }

    void multiply_int (INTVAL value, PMC* dest) {
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->cache.num_val * value
        );
    }

    void multiply_bignum (BIGNUM* value, PMC* dest) {
    }

    void multiply_float (FLOATVAL value, PMC* dest) {
        dest->vtable->set_number_native(INTERP, dest, SELF->cache.num_val * value);
    }

    void multiply_same (PMC* value, PMC* dest) {
        dest->cache.num_val = SELF->cache.num_val * value->cache.num_val;
    }

    void divide (PMC* value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->cache.num_val /
                value->vtable->get_number(INTERP, value)
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->cache.num_val /
                value->vtable->get_number(INTERP, value)
            );
        }
        else {
        }
    }

    void divide_int (INTVAL value, PMC* dest) {
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->cache.num_val / value
        );
    }

    void divide_bignum (BIGNUM* value, PMC* dest) {
    }

    void divide_float (FLOATVAL value, PMC* dest) {
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->cache.num_val / value
        );
    }

    void divide_same (PMC* value, PMC* dest) {
        dest->cache.num_val = SELF->cache.num_val / value->cache.num_val;
    }

    void modulus (PMC* value, PMC* dest) {
    /* XXX - Exception here */
fprintf(stderr,"modulus not implemented\n");
    }

    void modulus_int (INTVAL value, PMC* dest) {
fprintf(stderr,"modulus_int not implemented\n");
    }

    void modulus_bignum (BIGNUM* value, PMC* dest) {
fprintf(stderr,"modulus_bigint not implemented\n");
    }

    void modulus_float (FLOATVAL value, PMC* dest) {
fprintf(stderr,"modulus_float not implemented\n");
    }

    void modulus_same (PMC* value, PMC* dest) {
fprintf(stderr,"modulus_same not implemented\n");
    }

    void concatenate (PMC* value, PMC* dest) {
        STRING* s;
        s = string_concat(INTERP,
                          SELF->vtable->get_string(INTERP, SELF),
                          value->vtable->get_string(INTERP, value),
                          0
        );
        dest->vtable = &Parrot_base_vtables[enum_class_PerlString];
        dest->vtable->set_string_native(INTERP,dest,s);
    }

    void concatenate_native (STRING* value, PMC* dest) {
        STRING* s;
        s = string_concat(INTERP,
                          SELF->vtable->get_string(INTERP, SELF),
                          value,
                          0
        );
        dest->vtable = &Parrot_base_vtables[enum_class_PerlString];
        dest->vtable->set_string_native(INTERP,dest,s);
    }

    void concatenate_unicode (STRING* value, PMC* dest) {
        STRING* s;
        s = string_concat(INTERP,
                          SELF->vtable->get_string(INTERP, SELF),
                          value,
                          0
        );
        dest->vtable = &Parrot_base_vtables[enum_class_PerlString];
        dest->vtable->set_string_native(INTERP,dest,s);
    }

    void concatenate_other (STRING* value, PMC* dest) {
        STRING* s;
        s = string_concat(INTERP,
                          SELF->vtable->get_string(INTERP, SELF),
                          value,
                          0
        );
        dest->vtable = &Parrot_base_vtables[enum_class_PerlString];
        dest->vtable->set_string_native(INTERP,dest,s);
    }

    void concatenate_same (PMC* value, PMC* dest) {
        STRING* s;
        s = string_concat(INTERP,
                          SELF->vtable->get_string(INTERP, SELF),
                          value->vtable->get_string(INTERP, value),
                          0
        );
        dest->vtable = &Parrot_base_vtables[enum_class_PerlString];
        dest->vtable->set_string_native(INTERP,dest,s);
    }

    /* == operation */
    INTVAL is_equal (PMC* value) {
        return (INTVAL)(SELF->cache.num_val == value->vtable->get_number(INTERP, value));
    }

    void repeat (PMC* value, PMC* dest) {
fprintf(stderr,"repeat not implemented\n");
    }

    void repeat_int (INTVAL value, PMC* dest) {
fprintf(stderr,"repeat_int not implemented\n");
    }

    void increment () {
        SELF->cache.num_val ++;
    }

    void decrement () {
        SELF->cache.num_val --;
    }
}
