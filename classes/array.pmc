/* array.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the Array base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *     TODO: Create global immutable undef object
 *     TODO: PerlUndef should really be just Undef
 *     TODO: Array should not autocreate something called a PerlInt,
 *           PerlString, etc. Either nothing should get autocreated,
 *           or * those should all lose the Perl prefix.
 *  References:
 */

#include "parrot/parrot.h"

#define THROW_UNSUPPORTED internal_exception(INVALID_OPERATION, "Operation not supported\n")

static PMC* undef(struct Parrot_Interp* interpreter)
{
    return pmc_new(interpreter, enum_class_PerlUndef);
}

#define resize_array Parrot_Array_resize_array
extern void Parrot_Array_resize_array (struct Parrot_Interp *, PMC*, INTVAL);
void Parrot_Array_resize_array (struct Parrot_Interp *interpreter, PMC* self, INTVAL size)
{
    int oldsize = self->cache.int_val;
    Buffer* buffer = (Buffer *) self->data;
    if(buffer != NULL) {
        if(size >= 0) {
            Parrot_reallocate(interpreter, buffer, size * sizeof(PMC *));
            size = buffer->buflen / sizeof(PMC *);
            if (size > oldsize)
                memset((char *)buffer->bufstart + oldsize * sizeof(PMC *), 0, (size - oldsize) * sizeof(PMC *));
        }
        else {
            internal_exception(OUT_OF_BOUNDS,
                               "Array resize out of bounds!\n");
        }
    }
    else {
        buffer = (Buffer *) (self->data = new_buffer_header(interpreter));
        
        self->flags |= PMC_is_buffer_ptr_FLAG;
        self->flags |= PMC_is_PMC_ptr_FLAG;
        Parrot_allocate(interpreter, buffer, sizeof(PMC*)*size);
        memset(buffer->bufstart, 0, size * sizeof(PMC *));
    }

    self->cache.int_val = size;
}

pmclass Array {

    void init () {
        SELF->data = NULL;
        SELF->cache.int_val = 0;
        resize_array(INTERP, SELF, 0);
    }

    void morph (INTVAL type) {
    }

    void destroy () {
    }

    INTVAL type () {
        return enum_class_Array;
    }

    STRING* name() {
        return whoami;
    }

    PMC* clone () { 
        PMC* dest;
        INTVAL ix, size;
        PMC* element;
        PMC** array;

        dest = pmc_new(INTERP, enum_class_Array);
        dest->vtable = SELF->vtable;
	dest->vtable->init(interpreter, dest);
	size = SELF->cache.int_val;
	resize_array(interpreter, dest, size);
	for (ix = 0; ix < size; ix++) {
	    PMC *copy;
	    array = ((Buffer *) SELF->data)->bufstart;
	    element = array[ix];

	    if (element) {
		copy = element->vtable->clone(interpreter, element);
		((PMC**)((Buffer *) dest->data)->bufstart)[ix] = copy;
	    }

	}
        return dest;
    }

    INTVAL get_integer () {
        return SELF->cache.int_val;
    }

    INTVAL get_integer_keyed_int (INTVAL* key) {
        INTVAL ix;
        PMC* value;
        PMC** array;

        if (!key) {
            return 0;
        }

        ix = *key;

        if ((ix >= SELF->cache.int_val) || (ix < -SELF->cache.int_val)) {
            internal_exception(OUT_OF_BOUNDS,
                               "Array index out of bounds!\n");
        }

        if (ix < 0) {
            ix += SELF->cache.int_val;
        }

        array = ((Buffer *) SELF->data)->bufstart;
        value = array[ix];
        if (value == NULL) value = undef(INTERP);
        return value->vtable->get_integer(INTERP, value);
    }

    INTVAL get_integer_keyed (PMC* key) {
        INTVAL ix;
        PMC* nextkey;
        PMC* box;

        if (!key) return 0;
        ix = key_integer(INTERP, key);
        nextkey = key_next(INTERP, key);
        if (nextkey == NULL) return SELF.get_integer_keyed_int(&ix);

        box = SELF.get_pmc_keyed_int(&ix);
        if (box == NULL) box = undef(INTERP);
        return box->vtable->get_integer_keyed(INTERP, box, nextkey);
    }

    FLOATVAL get_number () {
        return (FLOATVAL)SELF->cache.int_val;
    }

    FLOATVAL get_number_keyed_int (INTVAL* key) {
        INTVAL ix;
        PMC* value;
        PMC** array;

        if (!key) {
            return 0;
        }

        ix = *key;

        if ((ix >= SELF->cache.int_val) || (ix < -SELF->cache.int_val)) {
            internal_exception(OUT_OF_BOUNDS,
                               "Array index out of bounds!\n");
        }

        if (ix < 0) {
            ix += SELF->cache.int_val;
        }

        array = ((Buffer *) SELF->data)->bufstart;
        value = array[ix];
        if (value == NULL) value = undef(INTERP);
        return value->vtable->get_number(INTERP, value);
    }

    FLOATVAL get_number_keyed (PMC* key) {
        INTVAL ix;
        PMC* nextkey;
        PMC* box;

        if (!key) return 0;
        ix = key_integer(INTERP, key);
        nextkey = key_next(INTERP, key);
        if (nextkey == NULL) return SELF.get_number_keyed_int(&ix);

        box = SELF.get_pmc_keyed_int(&ix);
        if (box == NULL) box = undef(INTERP);
        return box->vtable->get_number_keyed(INTERP, box, nextkey);
    }

    STRING* get_string () {
        return NULL;
    }

    STRING* get_string_keyed_int (INTVAL* key) {
        INTVAL ix;
        PMC* value;
        PMC** array;

        if (!key) {
            return 0;
        }

        ix = *key;

        if ((ix >= SELF->cache.int_val) || (ix < -SELF->cache.int_val)) {
            internal_exception(OUT_OF_BOUNDS,
                               "Array index out of bounds!\n");
        }

        if (ix < 0) {
            ix += SELF->cache.int_val;
        }

        array = ((Buffer *) SELF->data)->bufstart;
        value = array[ix];
        if (value == NULL) value = undef(INTERP);
        return value->vtable->get_string(INTERP, value);
    }

    STRING* get_string_keyed (PMC* key) {
        INTVAL ix;
        PMC* nextkey;
        PMC* box;

        if (!key) return 0;
        ix = key_integer(INTERP, key);
        nextkey = key_next(INTERP, key);
        if (nextkey == NULL) return SELF.get_string_keyed_int(&ix);

        box = SELF.get_pmc_keyed_int(&ix);
        if (box == NULL) box = undef(INTERP);
        return box->vtable->get_string_keyed(INTERP, box, nextkey);
    }

    PMC* get_pmc_keyed_int (INTVAL* key) {
        INTVAL ix;
        PMC* value;
        PMC** array;

        if (!key) {
            return 0;
        }

        ix = *key;

        if ((ix >= SELF->cache.int_val) || (ix < -SELF->cache.int_val)) {
            internal_exception(OUT_OF_BOUNDS,
                               "Array index out of bounds!\n");
        }

        if (ix < 0) {
            ix += SELF->cache.int_val;
        }

        array = ((Buffer *) SELF->data)->bufstart;
        value = array[ix];
        if (value == NULL) value = undef(INTERP);
        return value;
    }

    PMC* get_pmc_keyed (PMC* key) {
        INTVAL ix;
        PMC* nextkey;
        PMC* box;

        if (!key) return 0;
        ix = key_integer(INTERP, key);
        nextkey = key_next(INTERP, key);
        if (nextkey == NULL) return SELF.get_pmc_keyed_int(&ix);

        box = SELF.get_pmc_keyed_int(&ix);
        if (box == NULL) box = undef(INTERP);
        return box->vtable->get_pmc_keyed(INTERP, box, nextkey);
    }

    INTVAL get_bool () {
        INTVAL size = SELF->cache.int_val;
        return (INTVAL)(size != 0);
    }

    INTVAL elements () {
        return SELF->cache.int_val;
    }

    INTVAL is_same (PMC* pmc2) {
        STRING* s1 = (STRING*)SELF->cache.struct_val;
        STRING* s2 = (STRING*)pmc2->cache.struct_val;
        return (INTVAL)( pmc2->vtable == SELF->vtable &&
                          s1->bufused   == s2->bufused  &&
            (memcmp(s1->bufstart,s2->bufstart,(size_t)s1->bufused)==0));
    }

    void set_integer (PMC* value) {
        INTVAL size = value->vtable->get_integer(INTERP,value);
        resize_array(interpreter, SELF, size);
    }

    void set_integer_native (INTVAL size) {
        resize_array(interpreter, SELF, size);
    }

    void set_integer_same (PMC* value) {
        INTVAL size = value->cache.int_val;
        resize_array(interpreter, SELF, size);
    }

    void set_integer_keyed_int (INTVAL* key, INTVAL value) {
        INTVAL ix;
        PMC* element;
        PMC** array;

        if (!key) {
            return;
        }

        ix = *key;

        if (ix >= SELF->cache.int_val || ix < -SELF->cache.int_val) {
            internal_exception(OUT_OF_BOUNDS,
                               "Array index out of bounds!\n");
        }

        if (ix < 0) {
            ix += SELF->cache.int_val;
        }

        array = ((Buffer *) SELF->data)->bufstart;
        element = array[ix];
        if (element == NULL) {
            element = pmc_new(INTERP, enum_class_PerlInt);
            array = ((Buffer *) SELF->data)->bufstart; /* May have moved */
            array[ix] = element;
        }

        element->vtable->set_integer_native(INTERP, element, value);
    }

    void set_integer_keyed (PMC* key, INTVAL value) {
        INTVAL ix;

        if (!key) return;

        ix = key_integer(INTERP, key);
        SELF.set_integer_keyed_int(&ix, value);
    }

    void set_number (PMC* value) {
        INTVAL size = (INTVAL)value->cache.num_val;
        resize_array(interpreter, SELF, size+1);
    }

    void set_number_native (FLOATVAL size) {
        resize_array(interpreter, SELF, (INTVAL)size);
    }

    void set_number_same (PMC* value) {
        INTVAL size = value->cache.int_val;
        resize_array(interpreter, SELF, size);
    }

    void set_number_keyed_int (INTVAL* key, FLOATVAL value) {
        INTVAL ix;
        PMC* element;
        PMC** array;

        if (!key) {
            return;
        }

        ix = *key;

        if (ix >= SELF->cache.int_val || ix < -SELF->cache.int_val) {
            internal_exception(OUT_OF_BOUNDS,
                               "Array index out of bounds!\n");
        }
        else if (ix < 0) {
            ix += SELF->cache.int_val;
        }

        array = ((Buffer *) SELF->data)->bufstart;
        element = array[ix];
        if (element == NULL) {
            element = pmc_new(INTERP, enum_class_PerlNum);
            array = ((Buffer *) SELF->data)->bufstart; /* May have moved */
            array[ix] = element;
        }

        element->vtable->set_number_native(INTERP, element, value);
    }

    void set_number_keyed (PMC* key, FLOATVAL value) {
        INTVAL ix;

        if (!key) return;
        ix = key_integer(INTERP, key);
        SELF.set_number_keyed_int(&ix, value);
    }

    void set_string (PMC* value) {
        THROW_UNSUPPORTED;
    }

    void set_string_native (STRING* value) {
        THROW_UNSUPPORTED;
    }

    void set_string_same (PMC* value) {
        THROW_UNSUPPORTED;
    }

    void set_string_keyed_int (INTVAL* key, STRING* value) {
        INTVAL ix;
        PMC** array;
        PMC* element;

        if (!key) {
            return;
        }

        ix = *key;

        if (ix >= SELF->cache.int_val || ix < -SELF->cache.int_val) {
            internal_exception(OUT_OF_BOUNDS,
                               "Array index out of bounds!\n");
        }
        else if (ix < 0) {
            ix += SELF->cache.int_val;
        }

        array = ((Buffer *) SELF->data)->bufstart;
        element = array[ix];
        if (element == NULL) {
            element = pmc_new(INTERP, enum_class_PerlString);
            array = ((Buffer *) SELF->data)->bufstart; /* May have moved */
            array[ix] = element;
        }

        element->vtable->set_string_native(INTERP, element, value);
    }

    void set_string_keyed (PMC* key, STRING* value) {
        INTVAL ix;

        if (!key) return;
        ix = key_integer(INTERP, key);
        SELF->vtable->set_string_keyed_int(INTERP, SELF, &ix, value);
    }

    void set_pmc_keyed_int (INTVAL* dest_key, PMC* src, INTVAL* src_key) {
        INTVAL ix;
        PMC** array;

        if (!dest_key) {
            return;
        }

        ix = *dest_key;

        if ((ix >= SELF->cache.int_val) || (ix < -SELF->cache.int_val)) {
            internal_exception(OUT_OF_BOUNDS,
                               "Array index out of bounds!\n");
        }

        if (ix < 0) {
            ix += SELF->cache.int_val;
        }

        if (src_key) src = src->vtable->get_pmc_keyed_int(INTERP, src, src_key);

        array = ((Buffer *) SELF->data)->bufstart;
        /* XXX I don't pretend to understand how this is supposed to work.
         * With "set P0[0], P1[1]", I am ignoring P0[0]'s old value and just
         * overwriting it with P1[1]. */
        array[ix] = src;
    }

    void set_pmc_keyed (PMC* dest_key, PMC* src, PMC* src_key) {
        INTVAL src_ix;
        INTVAL dest_ix;

        if (!dest_key) return;

        dest_ix = key_integer(INTERP, dest_key);
        if (src_key) {
            src_ix = key_integer(INTERP, src_key);
            SELF.set_pmc_keyed_int(&dest_ix, src, &src_ix);
        }
        else {
            SELF.set_pmc_keyed_int(&dest_ix, src, NULL);
        }
    }

    void push_integer (INTVAL value) {
        INTVAL nextix = SELF->cache.int_val;
        DYNSELF.set_integer_keyed_int(&nextix, value);
    }

    void push_float (FLOATVAL value) {
        INTVAL nextix = SELF->cache.int_val;
        DYNSELF.set_number_keyed_int(&nextix, value);
    }

    void push_string (STRING* value) {
        INTVAL nextix = SELF->cache.int_val;
        DYNSELF.set_string_keyed_int(&nextix, value);
    }

    void push_pmc (PMC* value) {
        INTVAL nextix = SELF->cache.int_val;
        DYNSELF.set_pmc_keyed_int(&nextix, value, NULL);
    }

    INTVAL defined_keyed_int (INTVAL* key) {
        INTVAL ix;
        PMC* value;
        PMC** array;

        if (!key)
            return 0;

        ix = *key;

        if ((ix >= SELF->cache.int_val) || (ix < -SELF->cache.int_val))
	    return 0;

        if (ix < 0)
            ix += SELF->cache.int_val;

        array = ((Buffer *) SELF->data)->bufstart;
        value = array[ix];
        if (value == NULL)
	    return 0;
        return value->vtable->defined(INTERP, value);
    }

    INTVAL defined_keyed (PMC* key) {
        INTVAL ix;
        PMC* nextkey;
        PMC* box;

        if (!key)
	    return 0;
        ix = key_integer(INTERP, key);
        nextkey = key_next(INTERP, key);
        if (nextkey == NULL)
	    return SELF.defined_keyed_int(&ix);

        box = SELF.get_pmc_keyed_int(&ix);
        if (box == NULL)
	    return 0;
        return box->vtable->defined_keyed(INTERP, box, nextkey);
    }

    INTVAL exists_keyed_int (INTVAL* key) {
        INTVAL ix;
        PMC* value;
        PMC** array;

        if (!key)
            return 0;

        ix = *key;

        if ((ix >= SELF->cache.int_val) || (ix < -SELF->cache.int_val))
	    return 0;

        if (ix < 0)
            ix += SELF->cache.int_val;

        array = ((Buffer *) SELF->data)->bufstart;
        return array[ix] != NULL;
    }

    INTVAL defined_keyed (PMC* key) {
        INTVAL ix;
        PMC* nextkey;
        PMC* box;

        if (!key)
	    return 0;
        ix = key_integer(INTERP, key);
        nextkey = key_next(INTERP, key);
        if (nextkey == NULL)
	    return SELF.exists_keyed_int(&ix);

        box = SELF.get_pmc_keyed_int(&ix);
        if (box == NULL)
	    return 0;
        return box->vtable->exists_keyed(INTERP, box, nextkey);
    }

    /* == operation */
    INTVAL is_equal (PMC* value) {
        return 0;
    }
    
    INTVAL is_equal_keyed (PMC* key, PMC* value, PMC* value_key) {
        return 0;
    }

    INTVAL is_equal_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key) {
        return 0;
    }

    void logical_or (PMC* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void logical_and (PMC* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void logical_not (PMC* value) {
        THROW_UNSUPPORTED;
    }

    void add (PMC* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void add_int (INTVAL value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void add_bignum (BIGNUM* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void add_float (FLOATVAL value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void add_same (PMC* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void add_keyed (PMC* key, PMC* value, PMC* value_key,
                               PMC* dest, PMC* dest_key) {
        THROW_UNSUPPORTED;
    }

    void add_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key,
                                      PMC* dest, INTVAL* dest_key) {
        THROW_UNSUPPORTED;
    }

    void subtract (PMC* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void subtract_int (INTVAL value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void subtract_bignum (BIGNUM* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void subtract_float (FLOATVAL value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void subtract_same (PMC* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void subtract_keyed (PMC* key, PMC* value, PMC* value_key,
                                    PMC* dest, PMC* dest_key) {
        THROW_UNSUPPORTED;
    }

    void subtract_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key,
                                           PMC* dest, INTVAL* dest_key) {
        THROW_UNSUPPORTED;
    }

    void multiply (PMC* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void multiply_int (INTVAL value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void multiply_bignum (BIGNUM* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void multiply_float (FLOATVAL value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void multiply_same (PMC* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void multiply_keyed (PMC* key, PMC* value, PMC* value_key,
                                    PMC* dest, PMC* dest_key) {
        THROW_UNSUPPORTED;
    }

    void multiply_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key,
                                           PMC* dest, INTVAL* dest_key) {
        THROW_UNSUPPORTED;
    }

    void divide (PMC* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void divide_int (INTVAL value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void divide_bignum (BIGNUM* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void divide_float (FLOATVAL value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void divide_same (PMC* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void divide_keyed (PMC* key, PMC* value, PMC* value_key,
                                  PMC* dest, PMC* dest_key) {
        THROW_UNSUPPORTED;
    }

    void divide_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key,
                                         PMC* dest, INTVAL* dest_key) {
        THROW_UNSUPPORTED;
    }

    void modulus (PMC* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void modulus_int (INTVAL value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void modulus_bignum (BIGNUM* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void modulus_float (FLOATVAL value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void modulus_same (PMC* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void modulus_keyed (PMC* key, PMC* value, PMC* value_key,
                                   PMC* dest, PMC* dest_key) {
        THROW_UNSUPPORTED;
    }

    void modulus_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key,
                                          PMC* dest, INTVAL* dest_key) {
        THROW_UNSUPPORTED;
    }

    void concatenate (PMC* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void concatenate_native (STRING* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void concatenate_same (PMC* value, PMC* dest) {
        THROW_UNSUPPORTED;
    }

    void concatenate_keyed (PMC* key, PMC* value, PMC* value_key,
                                       PMC* dest, PMC* dest_key) {
        THROW_UNSUPPORTED;
    }

    void concatenate_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key,
                                              PMC* dest, INTVAL* dest_key) {
        THROW_UNSUPPORTED;
    }
}
