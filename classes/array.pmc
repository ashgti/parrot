/* array.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the Array base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"

static INTVAL kp2int(struct Parrot_Interp *interpreter, KEY_PAIR kp) {
    switch ((int)kp.type) {
        case enum_key_undef:
        default:
            return 0;
        case enum_key_int:
            return kp.cache.int_val;
        case enum_key_num:
            return (INTVAL)kp.cache.num_val;
        case enum_key_pmc:
            return kp.cache.pmc_val->vtable->get_integer(interpreter, kp.cache.pmc_val);
    }
}

static void resize_array ( struct Parrot_Interp *interpreter, PMC* self, INTVAL size ) {
    int i;
    int old_size = self->cache.int_val;
    if(self->data != NULL) {
	if(size >= 0) {

	    Parrot_reallocate(interpreter, ((Buffer *)self->data), sizeof(PMC *) * size);
	    size = ((Buffer *)self->data)->buflen / sizeof(PMC *);
	    self->cache.int_val = size;
	}
	else {
            internal_exception(OUT_OF_BOUNDS,
                               "Array resize out of bounds!\n");
	}
    }
    else {
	(Buffer *)self->data = new_buffer_header(interpreter);
	Parrot_allocate(interpreter, (Buffer *)self->data, sizeof(PMC*)*size);
        self->cache.int_val = size;
    }

    for (i = old_size; i < size; i++) {
	PMC** array = ((Buffer *)self->data)->bufstart;
	/* I guess we need an undef PMC? A non-perl array should not
           be populated with perl PMCs */
	array[i] = pmc_new(interpreter, enum_class_PerlUndef);
    }
}

pmclass Array {

    INTVAL type () {
        return 0;
    }

    STRING* name() {
        return whoami;
    }

    void init (INTVAL size) {
	SELF->data = new_buffer_header(interpreter);
	((Buffer *)SELF->data)->bufstart = NULL;
	((Buffer *)SELF->data)->buflen = 0;
	SELF->flags |= (PMC_is_buffer_ptr_FLAG | PMC_is_PMC_ptr_FLAG);
	SELF->cache.int_val = 0;
    }

    void clone (PMC* dest) { 
    }

    void morph (INTVAL type) {
    }

    INTVAL real_size () {
	return SELF->cache.int_val * sizeof(PMC*);
    }

    INTVAL get_integer () {
	return SELF->cache.int_val;
    }

    INTVAL get_integer_keyed (KEY * key) {
        KEY_PAIR* kp;
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        kp = &key->keys[0];
        ix = kp2int(INTERP, *kp);

        if (ix > SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        return value->vtable->get_integer(INTERP, value);
    }

    FLOATVAL get_number () {
	return (FLOATVAL)(SELF->cache.int_val);
    }

    FLOATVAL get_number_keyed (KEY * key) {
        KEY_PAIR* kp;
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        kp = &key->keys[0];
        ix = kp2int(INTERP, *kp);

        if (ix > SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        return value->vtable->get_number(INTERP, value);
    }

    STRING* get_string () {
	return NULL;
    }

    STRING* get_string_keyed (KEY * key) {
        KEY_PAIR* kp;
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        kp = &key->keys[0];
        ix = kp2int(INTERP, *kp);

        if (ix > SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        return value->vtable->get_string(INTERP, value);
    }

    BOOLVAL get_bool () {
	return (BOOLVAL)(SELF->cache.int_val != 0);
    }

    void* get_value () {
        return &SELF->data;
    }

    BOOLVAL is_same (PMC* other) {
        STRING* s1 = (STRING*)SELF->cache.struct_val;
        STRING* s2 = (STRING*)other->cache.struct_val;
        return (BOOLVAL)( other->vtable == SELF->vtable &&
                          s1->bufused   == s2->bufused  &&
            (memcmp(s1->bufstart,s2->bufstart,(size_t)s1->bufused)==0));
    }

    void set_integer (PMC* value) {
	INTVAL idx = value->vtable->get_integer(INTERP,value);
	resize_array(interpreter, SELF, idx);
    }

    void set_integer_native (INTVAL idx) {
	resize_array(interpreter, SELF, idx);
    }

    void set_integer_same (PMC * value) {
	INTVAL idx = value->cache.int_val;
	resize_array(interpreter, SELF, idx);
    }

    void set_integer_keyed (KEY * key, INTVAL value) {
        KEY_PAIR* kp;
        INTVAL ix;
        PMC* mypmc;

        if (!key) {
            return;
        }

        kp = &key->keys[0];
        ix = kp2int(INTERP, *kp);

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

	mypmc = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        mypmc->vtable->set_integer_native(INTERP, mypmc, value);
    }

    void set_number (PMC * value) {
	INTVAL idx = (INTVAL)value->cache.num_val;
	resize_array(interpreter, SELF, idx+1);
    }

    void set_number_native (FLOATVAL idx) {
	resize_array(interpreter, SELF, (INTVAL)idx + 1);
    }

    void set_number_same (PMC * value) {
	INTVAL idx = value->cache.int_val;
	resize_array(interpreter, SELF, idx);
    }

    void set_number_keyed (KEY * key, FLOATVAL value) {
        KEY_PAIR* kp;
        INTVAL ix;
        PMC* mypmc;

        if (!key) {
            return;
        }

        kp = &key->keys[0];
        ix = kp2int(INTERP, *kp);

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

	mypmc = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        mypmc->vtable->set_number_native(INTERP, mypmc, value);
    }

    void set_string_keyed (KEY * key, STRING * value) {
        KEY_PAIR* kp;
        INTVAL ix;
        PMC* mypmc;

        if (!key) {
            return;
        }

        kp = &key->keys[0];
        ix = kp2int(INTERP, *kp);

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

	mypmc = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        mypmc->vtable->set_string_native(INTERP, mypmc, value);
    }

    void set_pmc_keyed(KEY * dest_key, PMC* src, KEY* src_key) {
        if (src_key) {
            src = src->vtable->get_pmc_keyed(INTERP, src, src_key);
        }
        if (dest_key) {
            INTVAL ix = kp2int(INTERP, dest_key->keys[0]);
            PMC* dest = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
            dest->vtable->set_pmc(INTERP, dest, src);
        } 
        else {
            /* $#array = $foo[$bar] */
            resize_array(interpreter, SELF, 1+src->vtable->get_integer(INTERP, src));
        }       
    }

    void add (PMC * value, PMC* dest) {
	if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
	    dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
		SELF->vtable->get_integer(INTERP, SELF) +
                value->cache.int_val
            );
	}
	else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
	    dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
		SELF->vtable->get_number(INTERP, SELF) +
                value->cache.num_val
            );
	}
	else {
	}
    }

    void add_int (INTVAL value, PMC* dest) {
	dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
	    SELF->vtable->get_integer(INTERP, SELF) +
            value
        );
    }

    void add_float (FLOATVAL value, PMC* dest) {
	dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
	dest->vtable->set_number_native(INTERP, dest, 
	    SELF->vtable->get_number(INTERP, SELF) +
            value
        );
    }

    void subtract (PMC * value, PMC* dest) {
	if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
	    dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
		SELF->vtable->get_integer(INTERP, SELF) -
                value->cache.int_val
            );
	}
	else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
	    dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
		SELF->vtable->get_number(INTERP, SELF) -
                value->cache.num_val
            );
	}
	else {
	}
    }

    void subtract_int (INTVAL value, PMC* dest) {
	dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
	    SELF->vtable->get_integer(INTERP, SELF) -
            value
        );
    }

    void subtract_float (FLOATVAL value, PMC* dest) {
	dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
	dest->vtable->set_number_native(INTERP, dest, 
	    SELF->vtable->get_number(INTERP, SELF) -
            value
        );
    }

    void multiply (PMC * value, PMC* dest) {
	if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
	    dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
		SELF->vtable->get_integer(INTERP, SELF) *
                value->cache.int_val
            );
	}
	else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
	    dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
		SELF->vtable->get_number(INTERP, SELF) *
                value->cache.num_val
            );
	}
	else {
	}
    }

    void multiply_int (INTVAL value, PMC* dest) {
	dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
	    SELF->vtable->get_integer(INTERP, SELF) *
            value
        );
    }

    void multiply_float (FLOATVAL value, PMC* dest) {
	dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
	dest->vtable->set_number_native(INTERP, dest, 
	    SELF->vtable->get_number(INTERP, SELF) *
            value
        );
    }

    void divide (PMC * value, PMC* dest) {
	if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
	    dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
		SELF->vtable->get_integer(INTERP, SELF) /
                value->cache.int_val
            );
	}
	else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
	    dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
		SELF->vtable->get_number(INTERP, SELF) /
                value->cache.num_val
            );
	}
	else {
	}
    }

    void divide_int (INTVAL value, PMC* dest) {
	dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
	    SELF->vtable->get_integer(INTERP, SELF) /
            value
        );
    }

    void divide_float (FLOATVAL value, PMC* dest) {
	dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
	dest->vtable->set_number_native(INTERP, dest, 
	    SELF->vtable->get_number(INTERP, SELF) /
            value
        );
    }

    void modulus (PMC * value, PMC* dest) {
	if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
	    dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
		SELF->vtable->get_integer(INTERP, SELF) %
                value->cache.int_val
            );
	}
	else {
	}
    }

    void modulus_int (INTVAL value, PMC* dest) {
	dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
	    SELF->vtable->get_integer(INTERP, SELF) %
            value
        );
    }

    void concatenate (PMC * value, PMC* dest) {
	dest->cache.struct_val =
	    string_concat(INTERP,
			  SELF->cache.struct_val,
			  value->vtable->get_string(INTERP, value),
			  0
			 );
    }

    void concatenate_native (STRING * value, PMC* dest) {
	dest->cache.struct_val =
	    string_concat(INTERP,
			  SELF->cache.struct_val,
			  value,
			  0
			 );
    }

    void concatenate_unicode (STRING * value, PMC* dest) {
	dest->cache.struct_val =
	    string_concat(INTERP,
			  SELF->cache.struct_val,
			  value,
			  0
			 );
    }

    void concatenate_other (STRING * value, PMC* dest) {
	dest->cache.struct_val =
	    string_concat(INTERP,
			  SELF->cache.struct_val,
			  value,
			  0
			 );
    }

    void concatenate_same (PMC * value, PMC* dest) {
	dest->cache.struct_val =
	    string_concat(INTERP,
			  SELF->cache.struct_val,
			  value->cache.struct_val,
			  0
			 );
    }

    /* == operation */
    BOOLVAL is_equal (PMC* value) {
        return 0;
    }
}
