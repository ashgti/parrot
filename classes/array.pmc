/* array.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the Array base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"

static INTVAL atom2int(Interp *interpreter, KEY_ATOM* atom) {
    switch ((int)atom->type) {
        case enum_key_undef:
        default:
            return 0;
        case enum_key_int:
            return atom->val.int_val;
        case enum_key_num:
            return (INTVAL)atom->val.num_val;
        case enum_key_pmc:
            return atom->val.pmc_val->vtable->get_integer(interpreter, atom->val.pmc_val);
        case enum_key_string:
            return string_to_int(atom->val.struct_val);
    }
}

static void resize_array ( struct Parrot_Interp *interpreter, PMC* self, INTVAL size ) {
    int i;
    int old_size = self->cache.int_val;
    if(self->data != NULL) {
        if(size >= 0) {

            Parrot_reallocate(interpreter, ((Buffer *)self->data), sizeof(PMC *) * size);
            size = ((Buffer *)self->data)->buflen / sizeof(PMC *);
            self->cache.int_val = size;
        }
        else {
            internal_exception(OUT_OF_BOUNDS,
                               "Array resize out of bounds!\n");
        }
    }
    else {
        self->data = new_buffer_header(interpreter);
        Parrot_allocate(interpreter, (Buffer *)self->data, sizeof(PMC*)*size);
        self->cache.int_val = size;
    }

    for (i = old_size; i < size; i++) {
        PMC** array = ((Buffer *)self->data)->bufstart;
        /* I guess we need an undef PMC? A non-perl array should not
           be populated with perl PMCs */
        array[i] = pmc_new(interpreter, enum_class_PerlUndef);
    }
}

pmclass Array {

    void init () {
        SELF->data = new_buffer_header(interpreter);
        ((Buffer *)SELF->data)->bufstart = NULL;
        ((Buffer *)SELF->data)->buflen = 0;
        SELF->flags |= (PMC_is_buffer_ptr_FLAG | PMC_is_PMC_ptr_FLAG);
        SELF->cache.int_val = 0;
    }

    void morph (INTVAL type) {
    }
    
    INTVAL type () {
        return enum_class_Array;
    }
    
    INTVAL type_keyed (KEY* key) {
        /* XXX - Do this */
        return 0;
    }
    
    INTVAL type_keyed_int (INTVAL* key) {
        /* XXX - Do this */
        return 0;
    }

    UINTVAL subtype (INTVAL type) {
        /* XXX */
        return 0;
    }
    
    UINTVAL subtype_keyed (KEY* key, INTVAL type) {
        /* XXX */
        return 0;
    }

    UINTVAL subtype_keyed_int (INTVAL* key, INTVAL type) {
        /* XXX */
        return 0;
    }

    STRING* name () {
        return whoami;
    }
    
    STRING* name_keyed (KEY* key) {
        /* XXX */
        return NULL;
    }

    STRING* name_keyed_int (INTVAL* key) {
        /* XXX */
        return NULL;
    }

    PMC* clone () {
        return NULL;
    }
    
    PMC* clone_keyed (KEY* key) {
        /* XXX */
        return NULL;
    }
    
    PMC* clone_keyed_int (INTVAL* key) {
        /* XXX */
        return NULL;
    }

    PMC* find_method (STRING* method_name) {
        return NULL;
    }
    
    PMC* find_method_keyed (KEY* key, STRING* method_name) {
        /* XXX */
        return NULL;
    }

    PMC* find_method_keyed_int (INTVAL* key, STRING* method_name) {
        /* XXX */
        return NULL;
    }

    INTVAL get_integer () {
        return SELF->cache.int_val;
    }

    INTVAL get_integer_keyed (KEY* key) {
        KEY_ATOM* kp;
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        kp = &key->atom;
        ix = atom2int(INTERP, kp);

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];

        if(key->next != NULL) {
            return value->vtable->get_integer_keyed(INTERP, value, key->next);
        }
        else {
            return value->vtable->get_integer(INTERP, value);
        }
    }

    INTVAL get_integer_keyed_int (INTVAL* key) {
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        ix = *key;

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        return value->vtable->get_integer(INTERP, value);
    }

    FLOATVAL get_number () {
        return (FLOATVAL)(SELF->cache.int_val);
    }

    FLOATVAL get_number_keyed (KEY* key) {
        KEY_ATOM* kp;
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        kp = &key->atom;
        ix = atom2int(INTERP, kp);

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];

        if(key->next != NULL) {
            return value->vtable->get_number_keyed(INTERP, value, key->next);
        }
        else {
            return value->vtable->get_number(INTERP, value);
        }
    }

    FLOATVAL get_number_keyed_int (INTVAL* key) {
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        ix = *key;

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        return value->vtable->get_number(INTERP, value);
    }

    BIGNUM* get_bignum () {
        /* XXX - Cast cache.int_val to BIGNUM and return it */
        return NULL;
    }
    
    BIGNUM* get_bignum_keyed (KEY* key) {
        KEY_ATOM* kp;
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        kp = &key->atom;
        ix = atom2int(INTERP, kp);

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];

        if(key->next != NULL) {
            return value->vtable->get_bignum_keyed(INTERP, value, key->next);
        }
        else {
            return value->vtable->get_bignum(INTERP, value);
        }
    }

    BIGNUM* get_bignum_keyed_int (INTVAL* key) {
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        ix = *key;

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        return value->vtable->get_bignum(INTERP, value);
    }

    STRING* get_string () {
        return NULL;
    }

    STRING* get_string_keyed (KEY * key) {
        KEY_ATOM* kp;
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        kp = &key->atom;
        ix = atom2int(INTERP, kp);

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];

        if(key->next != NULL) {
            return value->vtable->get_string_keyed(INTERP, value, key->next);
        }
        else {
            return value->vtable->get_string(INTERP, value);
        }
    }

    STRING* get_string_keyed_int (INTVAL * key) {
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        ix = *key;

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        return value->vtable->get_string(INTERP, value);
    }

    INTVAL get_bool () {
        return (INTVAL)(SELF->cache.int_val != 0);
    }
    
    INTVAL get_bool_keyed (KEY* key) {
        KEY_ATOM* kp;
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        kp = &key->atom;
        ix = atom2int(INTERP, kp);

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];

        if(key->next != NULL) {
            return value->vtable->get_bool_keyed(INTERP, value, key->next);
        }
        else {
            return value->vtable->get_bool(INTERP, value);
        }
    }

    INTVAL get_bool_keyed_int (INTVAL* key) {
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        ix = *key;

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        return value->vtable->get_bool(INTERP, value);
    }

    INTVAL elements () {
        /* XXX - this seems redundant in view of get_integer */
        return SELF->cache.int_val;
    }
    
    INTVAL elements_keyed (KEY* key) {
        KEY_ATOM* kp;
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        kp = &key->atom;
        ix = atom2int(INTERP, kp);

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];

        if(key->next != NULL) {
            return value->vtable->elements_keyed(INTERP, value, key->next);
        }
        else {
            return value->vtable->elements(INTERP, value);
        }
    }        

    INTVAL elements_keyed_int (INTVAL* key) {
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        ix = *key;

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        return value->vtable->elements(INTERP, value);
    }

    PMC* get_pmc_keyed (KEY* key) {
        KEY_ATOM* kp;
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        kp = &key->atom;
        ix = atom2int(INTERP, kp);

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];

        if(key->next != NULL) {
            return value->vtable->get_pmc_keyed(INTERP, value, key->next);
        }
        else {
            /* XXX - should this be value->get_pmc? */
            return value;
        }
    }

    PMC* get_pmc_keyed_int (INTVAL* key) {
        INTVAL ix;
        PMC* value;

        if (!key) {
            return 0;
        }

        ix = *key;

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        value = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        /* XXX - should this be value->get_pmc? */
        return value;
    }

    INTVAL is_same (PMC* other) {
        STRING* s1 = (STRING*)SELF->cache.struct_val;
        STRING* s2 = (STRING*)other->cache.struct_val;
        return (INTVAL)( other->vtable == SELF->vtable &&
                          s1->bufused   == s2->bufused  &&
            (memcmp(s1->bufstart,s2->bufstart,(size_t)s1->bufused)==0));
    }
    
    INTVAL is_same_keyed (KEY* key, PMC* pmc2, KEY* pmc2_key) {
        /* XXX */
        return 0;
    }

    INTVAL is_same_keyed_int (INTVAL* key, PMC* pmc2, INTVAL* pmc2_key) {
        /* XXX */
        return 0;
    }

    void set_integer (PMC* value) {
        INTVAL idx = value->vtable->get_integer(INTERP,value);
        resize_array(interpreter, SELF, idx);
    }

    void set_integer_native (INTVAL idx) {
        resize_array(interpreter, SELF, idx);
    }
    
    void set_integer_bignum (BIGNUM* value) {
        /* XXX - BIGNUM stuffs */
    }

    void set_integer_same (PMC* value) {
        INTVAL idx = value->cache.int_val;
        resize_array(interpreter, SELF, idx);
    }

    void set_integer_keyed (KEY* key, INTVAL value) {
        KEY_ATOM* kp;
        INTVAL ix;
        PMC* mypmc;

        if (!key) {
            return;
        }

        kp = &key->atom;
        ix = atom2int(INTERP, kp);

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        mypmc = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];

        if(key->next != NULL) {
            mypmc->vtable->set_integer_keyed(INTERP, mypmc, key->next, value);
        }
        else {
            mypmc->vtable->set_integer_native(INTERP, mypmc, value);
        }
    }

    void set_integer_keyed_int (INTVAL* key, INTVAL value) {
        INTVAL ix;
        PMC* mypmc;

        if (!key) {
            return;
        }

        ix = *key;

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        mypmc = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        mypmc->vtable->set_integer_native(INTERP, mypmc, value);
    }

    void set_number (PMC * value) {
        INTVAL idx = (INTVAL)value->cache.num_val;
        resize_array(interpreter, SELF, idx);
    }

    void set_number_native (FLOATVAL idx) {
        resize_array(interpreter, SELF, (INTVAL)idx);
    }

    void set_number_bignum (BIGNUM* value) {
        /* XXX - BIGNUM stuffs */
    }

    void set_number_same (PMC * value) {
        INTVAL idx = value->cache.int_val;
        resize_array(interpreter, SELF, idx);
    }

    void set_number_keyed (KEY * key, FLOATVAL value) {
        KEY_ATOM* kp;
        INTVAL ix;
        PMC* mypmc;

        if (!key) {
            return;
        }

        kp = &key->atom;
        ix = atom2int(INTERP, kp);

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        mypmc = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        if(key->next != NULL) {
            mypmc->vtable->set_number_keyed(INTERP, mypmc, key->next, value);
        }
        else {
            mypmc->vtable->set_number_native(INTERP, mypmc, value);
        }
    }

    void set_number_keyed_int (INTVAL * key, FLOATVAL value) {
        INTVAL ix;
        PMC* mypmc;

        if (!key) {
            return;
        }

        ix = *key;

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        mypmc = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        mypmc->vtable->set_number_native(INTERP, mypmc, value);
    }

    void set_string_keyed (KEY * key, STRING * value) {
        KEY_ATOM* kp;
        INTVAL ix;
        PMC* mypmc;

        if (!key) {
            return;
        }

        kp = &key->atom;
        ix = atom2int(INTERP, kp);

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        mypmc = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        if(key->next != NULL) {
            mypmc->vtable->set_string_keyed(INTERP, mypmc, key->next, value);
        }
        else {
            mypmc->vtable->set_string_native(INTERP, mypmc, value);
        }
    }

    void set_string_keyed_int (INTVAL * key, STRING * value) {
        INTVAL ix;
        PMC* mypmc;

        if (!key) {
            return;
        }

        ix = *key;

        if (ix >= SELF->cache.int_val || ix < 0) {
            internal_exception(OUT_OF_BOUNDS, "Array element out of bounds!\n");
        }

        mypmc = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
        mypmc->vtable->set_string_native(INTERP, mypmc, value);
    }

    void set_pmc_keyed(KEY * dest_key, PMC* src, KEY* src_key) {
        if (src_key) {
            src = src->vtable->get_pmc_keyed(INTERP, src, src_key);
        }
        if (dest_key) {
            INTVAL ix = atom2int(INTERP, &dest_key->atom);
            PMC* dest = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
            dest->vtable->set_pmc(INTERP, dest, src);
        } 
        else {
            /* $#array = $foo[$bar] */
            resize_array(interpreter, SELF, 1+src->vtable->get_integer(INTERP, src));
        }       
    }

    void set_pmc_keyed_int(INTVAL * dest_key, PMC* src, INTVAL* src_key) {
        if (src_key) {
            src = src->vtable->get_pmc_keyed_int(INTERP, src, src_key);
        }
        if (dest_key) {
            INTVAL ix = *dest_key;
            PMC* dest = ((PMC**)(((Buffer *)SELF->data)->bufstart))[ix];
            dest->vtable->set_pmc(INTERP, dest, src);
        }
        else {
            /* $#array = $foo[$bar] */
            resize_array(interpreter, SELF, 1+src->vtable->get_integer(INTERP, src));
        }
    }

    void add (PMC * value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
                SELF->vtable->get_integer(INTERP, SELF) +
                value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->vtable->get_number(INTERP, SELF) +
                value->cache.num_val
            );
        }
        else {
        }
    }

    void add_int (INTVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) +
            value
        );
    }

    void add_bignum (BIGNUM* value, PMC* dest) {
        /* XXX - You know it */
    }

    void add_float (FLOATVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->vtable->get_number(INTERP, SELF) +
            value
        );
    }

    void subtract (PMC * value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
                SELF->vtable->get_integer(INTERP, SELF) -
                value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->vtable->get_number(INTERP, SELF) -
                value->cache.num_val
            );
        }
        else {
        }
    }

    void subtract_int (INTVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) -
            value
        );
    }

    void subtract_float (FLOATVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->vtable->get_number(INTERP, SELF) -
            value
        );
    }

    void multiply (PMC * value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
                SELF->vtable->get_integer(INTERP, SELF) *
                value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->vtable->get_number(INTERP, SELF) *
                value->cache.num_val
            );
        }
        else {
        }
    }

    void multiply_int (INTVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) *
            value
        );
    }

    void multiply_float (FLOATVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->vtable->get_number(INTERP, SELF) *
            value
        );
    }

    void divide (PMC * value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
                SELF->vtable->get_integer(INTERP, SELF) /
                value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->vtable->get_number(INTERP, SELF) /
                value->cache.num_val
            );
        }
        else {
        }
    }

    void divide_int (INTVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) /
            value
        );
    }

    void divide_float (FLOATVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->vtable->get_number(INTERP, SELF) /
            value
        );
    }

    void modulus (PMC * value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
                SELF->vtable->get_integer(INTERP, SELF) %
                value->cache.int_val
            );
        }
        else {
        }
    }

    void modulus_int (INTVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) %
            value
        );
    }

    void concatenate (PMC * value, PMC* dest) {
        dest->cache.struct_val =
            string_concat(INTERP,
                      SELF->cache.struct_val,
                      value->vtable->get_string(INTERP, value),
                      0
                     );
    }

    void concatenate_native (STRING * value, PMC* dest) {
        dest->cache.struct_val =
            string_concat(INTERP,
                      SELF->cache.struct_val,
                      value,
                      0
                     );
    }

    void concatenate_same (PMC * value, PMC* dest) {
        dest->cache.struct_val =
            string_concat(INTERP,
                      SELF->cache.struct_val,
                      value->cache.struct_val,
                      0
                     );
    }

    /* == operation */
    INTVAL is_equal (PMC* value) {
        return 0;
    }
}
