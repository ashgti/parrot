/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/resizablefloatarray.pmc - resizable array for floating point 
numbers only

=head1 DESCRIPTION

This class, C<ResizableFloatArray>, implements an array of resizable size, 
which stores FLOATVALs. It uses Float PMCs to do all necessary conversions.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

typedef struct _SizeFloatData {
    INTVAL size;
    FLOATVAL data[1];
} SizeFloatData;
#define NEEDED_SIZE(n) ((n-1)*sizeof(FLOATVAL) + sizeof(SizeFloatData))

pmclass ResizableFloatArray extends FixedFloatArray need_ext does array {
    

/*

=item C<FLOATVAL get_number_keyed_int(INTVAL key)>

Returns the floating-point value of the element at index C<key>.

=cut

*/

    FLOATVAL get_number_keyed_int (INTVAL key) {
        SizeFloatData *sd;
        if (key < 0)
            internal_exception(OUT_OF_BOUNDS, 
                "ResizableFloatArray: index out of bounds!");
        if (key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);
        
        sd = (SizeFloatData *)PMC_data(SELF);
        return sd->data[key];
    }

/*

=item C<void set_number_keyed_int(INTVAL key, FLOATVAL value)>

Sets the floating-point value of the element at index C<key> to
C<value>.

=cut

*/

    void set_number_keyed_int (INTVAL key, FLOATVAL value) {
        SizeFloatData *sd;
        if (key < 0)
            internal_exception(OUT_OF_BOUNDS, 
                "ResizableFloatArray: index out of bounds!");
        if(key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);

        sd = (SizeFloatData *)PMC_data(SELF);
        sd->data[key] = value;
    }

/*

=item C<void set_integer_native(INTVAL size)>

Resizes the array to C<size> elements.

When growing, if the new size stays smaller than twice the old size,
grow to twice the old size; otherwise, grow to the new size.

When shrinking, if the new size is smaller than half the old size,
shrink to one and half times the new size (which is less than or
equal to three quarters of the old size).

=cut

*/

    void set_integer_native (INTVAL size) {
        SizeFloatData *sd;
        if (size < 0)
            internal_exception(OUT_OF_BOUNDS, 
                    "ResizableFloatArray: Can't resize to negative value!");

        sd = PMC_data(SELF);
        PMC_int_val(SELF) = size;
        if (sd == NULL) {
            sd = mem_sys_allocate(NEEDED_SIZE(size));
            sd->size = size;
        } else if (size >= sd->size) {
            sd->size = size < 2 * sd->size ? 2 * sd->size : size;
            sd = mem_sys_realloc(sd, NEEDED_SIZE(sd->size));
        } else if (size < sd->size / 2) {
            sd->size = size * 3 / 2;
            sd = mem_sys_realloc(sd, NEEDED_SIZE(sd->size));
        } else {
            return;
        }

        PMC_data(SELF) = sd;
        PObj_active_destroy_SET(SELF);
    }

/*

=item C<PMC *clone()>

Creates and returns a copy of the array.

=cut

*/

    PMC* clone () {
        SizeFloatData *sd;
        PMC * dest = pmc_new(INTERP, SELF->vtable->base_type);
    
        if (!PMC_data(SELF))
            return dest;
        PMC_int_val(dest) = PMC_int_val(SELF);
        sd = PMC_data(SELF);
        
        PMC_data(dest) = mem_sys_allocate(NEEDED_SIZE(sd->size));
        mem_sys_memcopy(PMC_data(dest), PMC_data(SELF), NEEDED_SIZE(sd->size));
        PObj_active_destroy_SET(dest);
        return dest;
    }

/*

=item C<void push_float(FLOATVAL value)>

Adds C<value> to the end of the array.

=cut

*/

    void push_float (FLOATVAL value) {
        INTVAL size;
        SizeFloatData *sd;

        size = PMC_int_val(SELF);
        DYNSELF.set_integer_native(size+1);
        sd = (SizeFloatData *)PMC_data(SELF);
        sd->data[size] = value;
    }

/*

=item C<FLOATVAL pop_float()>

Removes and returns the last element in the array.

=cut

*/

    FLOATVAL pop_float() {
        INTVAL size;
        FLOATVAL value;
        SizeFloatData *sd;

        size = PMC_int_val(SELF);
        sd = (SizeFloatData *)PMC_data(SELF);

        if (sd == NULL || size == 0) {
            internal_exception(OUT_OF_BOUNDS, 
                    "ResizableFloatArray: Can't pop from an empty array!");
        }

	value = sd->data[size - 1];
        DYNSELF.set_integer_native(size - 1);

        return value;
    }

}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd17_basic_types.pod>.

=head1 HISTORY

Initial version                  - Matt Fowles 2004-06-11
Changed allocator to double size - Matt Fowles 2004-06-15

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
