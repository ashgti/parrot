/*
Copyright: 2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/float.pmc - Floating-point number

=head1 DESCRIPTION

C<Float> extends C<scalar> to provide floating-point number operations.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass Float extends scalar {

/*

=item C<void init()>

Initializes the number to zero.

=cut

*/

    void init() {
        PMC_num_val(SELF) = 0.0;
    }

/*

=item C<PMC* instantiate()>

Create a new Float from the passed in argument. This is a class method,
arguments are passed according to pdd03.

=cut

*/
    PMC* instantiate() {
        int argcP = REG_INT(3);
        PMC *class = REG_PMC(2);
        PMC *res = pmc_new(INTERP, class->vtable->base_type);
        /* TODO non-PMC arguments */
        if (argcP)
            VTABLE_set_number_native(INTERP, res,
                    VTABLE_get_number(INTERP, REG_PMC(5)));
        return res;
    }

/*

=item C<FLOATVAL get_number()>

Returns the value of the number.

=cut

*/

    FLOATVAL get_number() {
        return PMC_num_val(SELF);
    }

/*

=item C<INTVAL get_integer()>

Returns an integer representation of the number (by casting).

=cut

*/

   INTVAL get_integer() {
        return (INTVAL) PMC_num_val(SELF);
   }

/*

=item C<INTVAL get_bool()>

Evaluates the number as a boolean, i.e. it's true if it's not zero.

=cut

*/

    INTVAL get_bool () {
        return (INTVAL)(PMC_num_val(SELF) != 0.0);
    }

/*

=item C<STRING* get_string()>

Returns a Parrot string representation of the number.

=item C<STRING* get_repr()>

=cut

*/

    STRING* get_string() {
        return string_from_num(INTERP, PMC_num_val(SELF));
    }

    STRING* get_repr () {
        double d = (double) PMC_num_val(SELF);
        const char *sign = "-";
	if (!signbit(PMC_num_val(SELF)))
            sign = "";
        d = fabs(d);
        return Parrot_sprintf_c(INTERP, "%s" FLOATVAL_FMT, sign, d);
    }

/*

=item C<void set_integer_native(INTVAL value)>

=cut

*/

    void set_integer_native (INTVAL value) {
        DYNSELF.morph(enum_class_Integer);
        DYNSELF.set_integer_native(value);
    }

/*

=item C<void set_number_native(FLOATVAL value)>

Sets the value of the number to C<value>.

=cut

*/

    void set_number_native(FLOATVAL value) {
        PMC_num_val(SELF) = value;
    }

/*

=item C<void set_number_same(PMC* value)>

Sets the value of the number to the value of C<*value>.

=cut

*/

    void set_number_same (PMC* value) {
        PMC_num_val(SELF) = PMC_num_val(value);
    }

/*

=item C<void set_string_native(STRING *value)>

Sets the value of the number to the value of C<*value>.

Note that this method morphs the number into a C<String>.

=cut

*/

    void set_string_native (STRING * value) {
        DYNSELF.morph(enum_class_String);
        DYNSELF.set_string_native(value);
    }

/*

=item C<void set_pmc(PMC *value)>

Sets the value of the number to the value in C<*value>.

=cut

*/

    void set_pmc(PMC *value) {
        PMC_num_val(SELF) = VTABLE_get_number(INTERP, value);
    }
/*

=item C<void morph(INTVAL type)>

Morphs the scalar to the specified type.

=cut

*/

    void morph (INTVAL type) {
        if (SELF->vtable->base_type == type)
            return;
        if (type == enum_class_String) {
            /*
             * if we morph to a string, first clear str_val
             * so that after changing the vtable a parallel
             * reader doesn't get a garbage pointer
             */
            PMC_str_val(SELF) = NULL;
            PObj_custom_mark_SET(SELF);
            SELF->vtable = Parrot_base_vtables[type];
            return;
        }
        if (type == enum_class_BigInt || type == enum_class_Complex) {
            PMC_str_val(SELF) = NULL;
            SELF->vtable = Parrot_base_vtables[type];
            DYNSELF.init();
            return;
        }
        SELF->vtable = Parrot_base_vtables[type];
    }
/*

=item C<void add(PMC *value, PMC *dest)>

=item C<void add_int(INTVAL value, PMC *dest)>

=item C<void add_float(FLOATVAL value, PMC *dest)>

Adds C<value> to the number and returns the result in C<*dest>.

=item C<void i_add(PMC *value)>

=item C<void i_add(INTVAL value)>

=item C<void i_add(FLOATVAL value)>

Adds C<value> to C<SELF> inplace.

=cut

*/

    PMC* add (PMC* value, PMC* dest) {
MMD_Complex: {
            FLOATVAL a = DYNSELF.get_number();
            if (dest)
                VTABLE_morph(INTERP, dest, value->vtable->base_type);
            else
                dest = pmc_new(INTERP, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                    a + VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, dest, 1,
                    VTABLE_get_number_keyed_int(INTERP, value, 1));
            return dest;
        }
MMD_DEFAULT: {
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                    DYNSELF.get_number() + VTABLE_get_number(INTERP, value));
            return dest;
        }
    }

    PMC* add_int (INTVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_number() + (FLOATVAL)value);
        return dest;
    }

    PMC* add_float (FLOATVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_number() + value);
        return dest;
    }

    void i_add (PMC* value) {
MMD_Complex: {
            FLOATVAL a = DYNSELF.get_number();
            VTABLE_morph(INTERP, SELF, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, SELF,
                    a + VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, SELF, 1,
                    VTABLE_get_number_keyed_int(INTERP, value, 1));
        }
MMD_DEFAULT: {
            VTABLE_set_number_native(INTERP, SELF,
                DYNSELF.get_number() + VTABLE_get_number(INTERP, value));
        }
    }

    void i_add_int (INTVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() + (FLOATVAL)value);
    }

    void i_add_float (FLOATVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() + value);
    }

/*

=item C<PMC* subtract(PMC *value, PMC *dest)>

=item C<PMC* subtract_int(INTVAL value, PMC *dest)>

=item C<PMC* subtract_float(FLOATVAL value, PMC *dest)>

Subtracts C<value> from the number and returns the result in C<*dest>.
If C<dest> doesn't exist a new C<Float> is created.

=item C<void i_subtract(PMC *value)>

=item C<void i_subtract_int(INTVAL value)>

=item C<void i_subtract_float(FLOATVAL value)>

Subtracts C<value> from C<SELF> inplace.

=cut

*/

    PMC* subtract (PMC* value, PMC* dest) {
MMD_Complex: {
            FLOATVAL a = DYNSELF.get_number();
            if (dest)
                VTABLE_morph(INTERP, dest, value->vtable->base_type);
            else
                dest = pmc_new(INTERP, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                    a - VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, dest, 1,
                    -VTABLE_get_number_keyed_int(INTERP, value, 1));
            return dest;
        }
MMD_DEFAULT: {
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                    DYNSELF.get_number() - VTABLE_get_number(INTERP, value));
            return dest;
        }
    }

    PMC* subtract_int (INTVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_number() - (FLOATVAL)value);
        return dest;
    }

    PMC* subtract_float (FLOATVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_number() - value);
        return dest;
    }

    void i_subtract (PMC* value) {
MMD_Complex: {
            FLOATVAL a = DYNSELF.get_number();
            VTABLE_morph(INTERP, SELF, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, SELF,
                    a - VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, SELF, 1,
                    -VTABLE_get_number_keyed_int(INTERP, value, 1));
        }
MMD_DEFAULT: {
            VTABLE_set_number_native(INTERP, SELF,
                DYNSELF.get_number() - VTABLE_get_number(INTERP, value));
        }
    }

    void i_subtract_int (INTVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() - (FLOATVAL)value);
    }

    void i_subtract_float (FLOATVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() - value);
    }

/*

=item C<PMC* multiply(PMC *value, PMC *dest)>

=item C<PMC* multiply_int(INTVAL value, PMC *dest)>

=item C<PMC* multiply_float(FLOATVAL value, PMC *dest)>

Multiplies the number by C<value> and returns the result in C<*dest>.

=cut

*/

    PMC* multiply (PMC* value, PMC* dest) {
MMD_Complex: {
            internal_exception(1, "TODO mul<Float, Complex>");
            return dest;
        }
MMD_DEFAULT: {
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_number() * VTABLE_get_number(INTERP, value));
            return dest;
        }
    }

    PMC* multiply_int (INTVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
            DYNSELF.get_number() * value);
        return dest;
    }

    PMC* multiply_float (FLOATVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
            DYNSELF.get_number() * value);
        return dest;
    }

    void i_multiply (PMC* value) {
MMD_Complex: {
            internal_exception(1, "TODO i_mul<Float, Complex>");
        }
MMD_DEFAULT: {
            VTABLE_set_number_native(INTERP, SELF,
                DYNSELF.get_number() * VTABLE_get_number(INTERP, value));
        }
    }

    void i_multiply_int (INTVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() * (FLOATVAL)value);
    }

    void i_multiply_float (FLOATVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() * value);
    }

/*

=item C<void divide(PMC *value, PMC *dest)>

Divides the number by C<*value> and returns the result in C<*dest>.

=cut

*/

    void divide (PMC* value, PMC* dest) {
MMD_Float: {
        /* TODO zero dividde */
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) / PMC_num_val(value));
        }
MMD_DEFAULT: {
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) / VTABLE_get_number(INTERP, value));
        }
    }

/*

=item C<void divide_int(INTVAL value, PMC *dest)>

=cut

*/

    void divide_int (INTVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) / value
        );
    }

/*

=item C<void divide_float(FLOATVAL value, PMC *dest)>

Divides the number by C<value> and returns the result in C<*dest>.

=cut

*/

    void divide_float (FLOATVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            PMC_num_val(SELF) / value
        );
    }

/*

=item C<void cmodulus(PMC *value, PMC *dest)>

Calculates the value of the number C-style C<mod> C<*value> and returns
the result in C<*dest>.

=cut

*/

    void cmodulus (PMC* value, PMC* dest) {
MMD_Float: {
        /* TODO zero dividde */
        FLOATVAL f = PMC_num_val(value);
        VTABLE_set_number_native(INTERP, dest,
            fmod(PMC_num_val(SELF), f));
        }
MMD_DEFAULT: {
        FLOATVAL f = VTABLE_get_number(INTERP, value);
        VTABLE_set_number_native(INTERP, dest,
            fmod(PMC_num_val(SELF), f));
        }
    }

/*

=item C<void cmodulus_float(FLOATVAL value, PMC *dest)>

=cut

*/

    void cmodulus_float (FLOATVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            fmod(PMC_num_val(SELF), value));
    }

/*

=item C<void cmodulus_int(INTVAL value, PMC *dest)>

Calculates the value of the number C-style C<mod> C<value> and returns
the result in C<*dest>.

=cut

*/

    void cmodulus_int (INTVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            fmod(PMC_num_val(SELF), value));
    }

/*

=item C<void modulus(PMC *value, PMC *dest)>

Calculates the value of the number C<mod> C<*value> and returns the
result in C<*dest>.

=cut

*/

    void modulus (PMC* value, PMC* dest) {
MMD_Float: {
        /* TODO zero dividde */
        FLOATVAL f = PMC_num_val(value);
        VTABLE_set_number_native(INTERP, dest,
            floatval_mod(PMC_num_val(SELF), f));
        }
MMD_DEFAULT: {
        FLOATVAL f = VTABLE_get_number(INTERP, value);
        VTABLE_set_number_native(INTERP, dest,
            floatval_mod(PMC_num_val(SELF), f));
        }
    }

/*

=item C<void modulus_float(FLOATVAL value, PMC *dest)>

=cut

*/

    void modulus_float (FLOATVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            floatval_mod(PMC_num_val(SELF), value));
    }

/*

=item C<void modulus_int(INTVAL value, PMC *dest)>

Calculates the value of the number C<mod> C<value> and returns the
result in C<*dest>.

=cut

*/

    void modulus_int (INTVAL value, PMC* dest) {
        VTABLE_set_number_native(INTERP, dest,
            floatval_mod(PMC_num_val(SELF), value));
    }

/*

=item C<void neg(PMC *dest)>

Set C<dest> to the negated value of C<SELF>.

=cut

*/

    void neg (PMC * dest) {
        if (dest == SELF)
            PMC_num_val(SELF) = -PMC_num_val(SELF);
        else
            VTABLE_set_number_native(INTERP, dest, -PMC_num_val(SELF));
    }

/*

=item C<INTVAL is_equal(PMC* value)>

The C<==> operation.

=cut

*/

    INTVAL is_equal (PMC* value) {
MMD_Float: {
        return (INTVAL)(PMC_num_val(SELF) == PMC_num_val(value));
        }
MMD_DEFAULT: {
        return (INTVAL)(PMC_num_val(SELF) == VTABLE_get_number(INTERP, value));
        }
    }

    INTVAL is_equal_num (PMC* value) {
MMD_Float: {
        return (INTVAL)(PMC_num_val(SELF) == PMC_num_val(value));
        }
MMD_DEFAULT: {
        return (INTVAL)(PMC_num_val(SELF) == VTABLE_get_number(INTERP, value));
        }
    }

/*

=item C<INTVAL cmp(PMC* value)>



=cut

*/

    INTVAL cmp(PMC* value) {
MMD_Float: {
            FLOATVAL diff;
            diff = PMC_num_val(SELF) - PMC_num_val(value);
            return diff > 0 ? 1 : diff < 0 ? -1 : 0;
        }
MMD_DEFAULT: {
            FLOATVAL diff;
            diff = PMC_num_val(SELF) - VTABLE_get_number(INTERP, value);
            return diff > 0 ? 1 : diff < 0 ? -1 : 0;
        }
    }

/*

=item C<INTVAL cmp_num(PMC *value)>

Returns the result of comparing the number with C<*value>.

=cut

*/

    INTVAL cmp_num(PMC* value) {
MMD_Float: {
            FLOATVAL diff;
            diff = PMC_num_val(SELF) - PMC_num_val(value);
            return diff > 0 ? 1 : diff < 0 ? -1 : 0;
        }
MMD_DEFAULT: {
            FLOATVAL diff;
            diff = PMC_num_val(SELF) - VTABLE_get_number(INTERP, value);
            return diff > 0 ? 1 : diff < 0 ? -1 : 0;
        }
    }

/*

=item C<void increment()>

Increments the number.

=cut

*/

    void increment () {
        PMC_num_val(SELF) ++;
    }

/*

=item C<void decrement()>

Decrements the number.

=cut

*/

    void decrement () {
        PMC_num_val(SELF) --;
    }
/*

=item C<void absolute()>

Sets C<dest> to the absolute value of SELF.

=cut

*/

    void absolute(PMC *dest) {
        VTABLE_set_number_native(INTERP, dest, fabs(PMC_num_val(SELF)));
    }

/*

=item C<void freeze(visit_info *info)>

Used to archive the number.

=cut

*/
    void freeze(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        SUPER(info);
        io->vtable->push_float(INTERP, io, PMC_num_val(SELF));
    }

/*

=item C<void thaw(visit_info *info)>

Used to unarchive the number.

=cut

*/
    void thaw(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        SUPER(info);
        if (info->extra_flags == EXTRA_IS_NULL)
            PMC_num_val(SELF) = io->vtable->shift_float(INTERP, io);
    }
/*

=back

=head2 Methods

=over 4

=item C<METHOD PMC* cos()>

Return a new PMC of the type of C<SELF> with the cosine of SELF.

=cut

*/

    METHOD PMC* cos() {
        PMC *d = pmc_new(INTERP, SELF->vtable->base_type);
        PMC_num_val(d) = cos((double)PMC_num_val(SELF));
        return d;
    }

}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
