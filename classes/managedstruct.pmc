/* NCI.pmc
 *  Copyright: 2002-2003 Yet Another Society
 *  CVS Info
 *     $Id$
 *  Overview:
 *     PMC class to hold structs that parrot's responsible for disposing of
 *  Data Structure and Algorithms:
 *  History:
 *     Initial revision by sean 2002/08/04
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"
#include "parrot/method_util.h"

pmclass ManagedStruct extends UnManagedStruct {

    void init () {
      PObj_active_destroy_SET(SELF);
      SELF->cache.int_val = 0;
      SELF->data = NULL;
    }

    void destroy () {
      if (SELF->data) {
        free(SELF->data);
      }
    }

    STRING* name () {
        return whoami;
    }

    /* For out of bounds gets, will return -1 */
    INTVAL get_integer_keyed(PMC* key) {
	INTVAL ix;

	if (!key) 
            return -1;
        ix = key_integer(INTERP, key);
        if (ix < 0) 
            return -1;
	if (ix >= SELF->cache.int_val) 
	    return -1;
	return  (unsigned char)((char *)SELF->data)[ix];      
        
    }
    
    /* For out of bounds sets, will do noop */
    void set_integer_keyed (PMC* key, INTVAL value) {
        INTVAL ix;
	
        if (!key) 
            return;
        ix = key_integer(INTERP, key);
        if (ix < 0) 
            return;
        if (ix >= SELF->cache.int_val)
	    return;
        ((char *)SELF->data)[ix]=(0xff & value);
        return;
    }
   
    INTVAL get_integer () {
        return(SELF->cache.int_val);
    }

    void set_integer_native (INTVAL value) {
		if (SELF->data && (! value)) {
			free(SELF->data);
			SELF->data=NULL;
			SELF->cache.int_val = 0;
		} else if (value && (! SELF->data)) {
			SELF->data=mem_sys_allocate_zeroed(value);
			SELF->cache.int_val=value;
		} else if (value && SELF->data) {
			SELF->data=mem_sys_realloc(SELF->data, value);
			SELF->cache.int_val=value;
		}	
		return;
	}
    
}
