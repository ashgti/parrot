 /* perlhash.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the PerlHash base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *     PerlHash values should probably only be allowed to be PMCs.
 *  References:
 *     pdd08_keys.pod
 */

#include "parrot/parrot.h"

static PMC* undef = NULL;

static STRING* make_hash_key_helper(Interp* interpreter, KEY * key)
{
    if (key == NULL) {
        internal_exception(OUT_OF_BOUNDS, "Cannot use NULL key for PerlHash!\n");
        return NULL;
    }

    if (key->next != NULL) {
        internal_exception(OUT_OF_BOUNDS, "PerlHash does not support compound keys!\n");
        return NULL;
    }

    switch (key->atom.type) {
    case enum_key_int:
        return string_from_int(interpreter, key->atom.val.int_val);
    case enum_key_num:
        return string_from_num(interpreter, key->atom.val.num_val);
    case enum_key_pmc: {
        PMC* pmc = key->atom.val.pmc_val;
        return string_copy(interpreter,
                           pmc->vtable->get_string(interpreter, pmc));
    }
    case enum_key_string:
        return string_copy(interpreter, key->atom.val.string_val);
    default:
        internal_exception(OUT_OF_BOUNDS, "Cannot make hash key from type %d\n", key->atom.type);
    }

    return NULL;
}

static STRING* make_hash_key(Interp* interpreter, KEY * key)
{
        STRING* s = make_hash_key_helper(interpreter, key);
        return s;
}

pmclass PerlHash {

    void init () {
        if (undef == NULL) {
            undef = pmc_new(INTERP, enum_class_PerlUndef);
            undef->flags |= PMC_constant_FLAG;
        }
        SELF->flags |= PMC_custom_mark_FLAG;
        new_hash(INTERP, (HASH **)&SELF->data);
    }

    /* The end of used parameter is passed into the mark_used function of
     * the garbage collector.
     */
    PMC* mark (PMC *end_of_used_list) {
        if (SELF->data) {
            return mark_hash(INTERP, SELF->data, end_of_used_list);
        } else {
            return end_of_used_list;
        }
    }

    INTVAL type () {
        return enum_class_PerlHash;
    }

    STRING* name() {
        return whoami;
    }

    PMC* clone () {
	PMC * ret = new_pmc_header(INTERP);
	if (!pmc) {
	    internal_exception(ALLOCATION_ERROR,
			       "Parrot VM: PMC allocation failed!\n");
	}

	ret->vtable = &(Parrot_base_vtables[enum_class_PerlHash]);
        ret->flags |= PMC_custom_mark_FLAG;
        hash_clone(INTERP, (HASH *)SELF->data, (HASH **)&ret->data);
	return ret;
    }
    
    INTVAL get_integer () {
        return hash_size(INTERP, SELF->data);
    }

    INTVAL get_integer_keyed (KEY* key) {
        PMC* valpmc;
        STRING* key_string = make_hash_key(INTERP, key);
        KEY_ATOM* atom = hash_get(INTERP, (HASH*) SELF->data, key_string);
        if (atom == NULL) {
            /* XXX Warning: use of uninitialized value */
            return undef->vtable->get_integer(INTERP, undef);
        }
        if (atom->type == enum_key_int) return atom->val.int_val;
        if (atom->type == enum_key_pmc) {
            valpmc = atom->val.pmc_val;
            return valpmc->vtable->get_integer(INTERP, valpmc);
        }
        /* XXX This should convert to an integer if possible */
        internal_exception(OUT_OF_BOUNDS, "Cannot fetch integer out of non-integer key!\n");
        return -1;
    }

    FLOATVAL get_number () {
        return (FLOATVAL)SELF->cache.int_val;
    }

    FLOATVAL get_number_keyed (KEY* key) {
        PMC* valpmc;
        STRING* key_string = make_hash_key(INTERP, key);
        KEY_ATOM* atom = hash_get(INTERP, (HASH*) SELF->data, key_string);
        if (atom == NULL) {
            /* XXX Warning: Use of uninitialized value */
            return undef->vtable->get_number(INTERP, undef);
        }
        if (atom->type == enum_key_num) return atom->val.num_val;
        /* XXX This should convert to a number if possible */
        if (atom->type == enum_key_pmc) {
            valpmc = atom->val.pmc_val;
            return valpmc->vtable->get_number(INTERP, valpmc);
        }
        internal_exception(OUT_OF_BOUNDS, "Cannot fetch number out of non-numeric key!\n");
        return 0.0;
    }

    BIGNUM* get_bignum () {
        /* XXX */
        return NULL;
    }

    BIGNUM* get_bignum_keyed (KEY* key) {
        PMC* valpmc;
        STRING* key_string = make_hash_key(INTERP, key);
        KEY_ATOM* atom = hash_get(INTERP, (HASH*) SELF->data, key_string);
        if (atom == NULL) {
            /* XXX Warning: Use of uninitialized value */
            return undef->vtable->get_bignum(INTERP, undef);
        }
        if (atom->type == enum_key_num) return (BIGNUM*)atom->val.struct_val;
        /* XXX This should convert to a number if possible */
        if (atom->type == enum_key_pmc) {
            valpmc = atom->val.pmc_val;
            return valpmc->vtable->get_bignum(INTERP, valpmc);
        }
        internal_exception(OUT_OF_BOUNDS, "Cannot fetch number out of non-numeric key!\n");
        return NULL;
    }

    STRING* get_string () {
        return (STRING*)SELF->cache.struct_val;
    }

    STRING* get_string_keyed (KEY* key) {
        PMC* valpmc;
        STRING* key_string = make_hash_key(INTERP, key);
        KEY_ATOM* atom = hash_get(INTERP, (HASH*) SELF->data, key_string);
        if (atom == NULL) {
            /* XXX Warning: use of uninitialized value */
            return undef->vtable->get_string(INTERP, undef);
        }
        if (atom->type == enum_key_string) return atom->val.string_val;
        /* XXX This should convert to a string */
        if (atom->type == enum_key_pmc) {
            valpmc = atom->val.pmc_val;
            return valpmc->vtable->get_string(INTERP, valpmc);
        }
        internal_exception(OUT_OF_BOUNDS, "Cannot fetch string out of non-string key!\n");
        return NULL;
    }

    INTVAL get_bool () {
        return 0;
    }

    INTVAL elements () {
        return hash_size(INTERP, SELF->data);
    }

    PMC* get_pmc_keyed (KEY* key) {
        STRING* key_string = make_hash_key(INTERP, key);
        KEY_ATOM* atom = hash_get(INTERP, (HASH*) SELF->data, key_string);
        if (atom == NULL) {
            /* XXX Warning: use of uninitialized value */
            return (PMC*)undef->vtable->get_pmc(INTERP, undef);
        }
        if (atom->type == enum_key_pmc) {
            return atom->val.pmc_val;
        }
        internal_exception(OUT_OF_BOUNDS, "Cannot fetch PMC out of non-PMC key!\n");
        return NULL;
    }

    INTVAL is_same (PMC* other) {
        STRING* s1 = (STRING*)SELF->cache.struct_val;
        STRING* s2 = (STRING*)other->cache.struct_val;
        return (INTVAL)( other->vtable == SELF->vtable &&
                          s1->bufused   == s2->bufused  &&
            (memcmp(s1->bufstart,s2->bufstart,(size_t)s1->bufused)==0));
    }

    void set_integer (PMC* value) {
        internal_exception(INTERNAL_PANIC, "Cannot set hash to int\n");
    }

    void set_integer_native (INTVAL size) {
        internal_exception(INTERNAL_PANIC, "Cannot set hash to int\n");
    }

    void set_integer_same (PMC* value) {
        internal_exception(INTERNAL_PANIC, "Cannot set hash to int\n");
    }

    void set_integer_keyed (KEY* key, INTVAL value) {
        STRING* key_string = make_hash_key(INTERP, key);
        KEY_ATOM atom;
        atom.type = enum_key_int;
        atom.val.int_val = value;
        hash_put(INTERP, SELF->data, key_string, &atom);
    }

    void set_number (PMC* value) {
        internal_exception(INTERNAL_PANIC, "Cannot set hash to number\n");
    }

    void set_number_native (FLOATVAL size) {
        internal_exception(INTERNAL_PANIC, "Cannot set hash to number\n");
    }

    void set_number_same (PMC* value) {
        internal_exception(INTERNAL_PANIC, "Cannot set hash to number\n");
    }

    void set_number_keyed (KEY* key, FLOATVAL value) {
        STRING* key_string = make_hash_key(INTERP, key);
        KEY_ATOM atom;
        atom.type = enum_key_num;
        atom.val.num_val = value;
        hash_put(INTERP, SELF->data, key_string, &atom);
    }

    void set_bignum (PMC* value) {
        internal_exception(INTERNAL_PANIC, "Cannot set hash to bignum\n");
    }

    void set_bignum_native (BIGNUM* size) {
        internal_exception(INTERNAL_PANIC, "Cannot set hash to bignum\n");
    }

    void set_bignum_same (PMC* value) {
        internal_exception(INTERNAL_PANIC, "Cannot set hash to bignum\n");
    }

    void set_bignum_keyed (KEY* key, BIGNUM* value) {
        /* XXX */
    }

    void set_string (PMC* value) {
        internal_exception(INTERNAL_PANIC, "Cannot set hash to string\n");
    }

    void set_string_native (STRING* value) {
        internal_exception(INTERNAL_PANIC, "Cannot set hash to string\n");
    }

    void set_string_same (PMC* value) {
        internal_exception(INTERNAL_PANIC, "Cannot set hash to string\n");
    }

    void set_string_keyed (KEY* key, STRING* value) {
        STRING* key_string = make_hash_key(INTERP, key);
        KEY_ATOM atom;
        atom.type = enum_key_string;
        atom.val.string_val = value;
        hash_put(INTERP, SELF->data, key_string, &atom);
    }

    void set_pmc_keyed (KEY* dest_key, PMC* value, KEY* val_key) {
        STRING* key_string = make_hash_key(INTERP, val_key);
        KEY_ATOM atom;
        atom.type = enum_key_pmc;
        atom.val.pmc_val = value;
        hash_put(INTERP, SELF->data, key_string, &atom);
    }

    void add (PMC* value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
                SELF->vtable->get_integer(INTERP, SELF) +
                value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->vtable->get_number(INTERP, SELF) +
                value->cache.num_val
            );
        }
        else {
        }
    }

    void add_int (INTVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) +
            value
        );
    }

    void add_bignum (BIGNUM* value, PMC* dest) {
    }

    void add_float (FLOATVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->vtable->get_number(INTERP, SELF) +
            value
        );
    }

    void add_same (PMC* value, PMC* dest) {
    }

    void subtract (PMC* value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
                SELF->vtable->get_integer(INTERP, SELF) -
                value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->vtable->get_number(INTERP, SELF) -
                value->cache.num_val
            );
        }
        else {
        }
    }

    void subtract_int (INTVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) -
            value
        );
    }

    void subtract_bignum (BIGNUM* value, PMC* dest) {
    }

    void subtract_float (FLOATVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->vtable->get_number(INTERP, SELF) -
            value
        );
    }

    void subtract_same (PMC* value, PMC* dest) {
    }

    void multiply (PMC* value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
                SELF->vtable->get_integer(INTERP, SELF) *
                value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->vtable->get_number(INTERP, SELF) *
                value->cache.num_val
            );
        }
        else {
        }
    }

    void multiply_int (INTVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) *
            value
        );
    }

    void multiply_bignum (BIGNUM* value, PMC* dest) {
    }

    void multiply_float (FLOATVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->vtable->get_number(INTERP, SELF) *
            value
        );
    }

    void multiply_same (PMC * value, PMC* dest) {
    }

    void divide (PMC* value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
                SELF->vtable->get_integer(INTERP, SELF) /
                value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->vtable->get_number(INTERP, SELF) /
                value->cache.num_val
            );
        }
        else {
        }
    }

    void divide_int (INTVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) /
            value
        );
    }

    void divide_bignum (BIGNUM* value, PMC* dest) {
    }

    void divide_float (FLOATVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->vtable->get_number(INTERP, SELF) /
            value
        );
    }

    void divide_same (PMC* value, PMC* dest) {
    }

    void modulus (PMC* value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
                SELF->vtable->get_integer(INTERP, SELF) %
                value->cache.int_val
            );
        }
        else {
        }
    }

    void modulus_int (INTVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) %
            value
        );
    }

    void modulus_bignum (BIGNUM* value, PMC* dest) {
    }

    void modulus_float (FLOATVAL value, PMC* dest) {
    }

    void modulus_same (PMC* value, PMC* dest) {
    }

    void concatenate (PMC* value, PMC* dest) {
        dest->cache.struct_val =
            string_concat(INTERP,
                          SELF->cache.struct_val,
                          value->vtable->get_string(INTERP, value),
                          0
                         );
    }

    void concatenate_native (STRING* value, PMC* dest) {
        dest->cache.struct_val =
            string_concat(INTERP,
                          SELF->cache.struct_val,
                          value,
                          0
                         );
    }

    void concatenate_same (PMC* value, PMC* dest) {
        dest->cache.struct_val =
            string_concat(INTERP,
                          SELF->cache.struct_val,
                          value->cache.struct_val,
                          0
                         );
    }

    /* == operation */
    INTVAL is_equal (PMC* value) {
        return 0;
    }
}
