/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/perlhash.pmc - Perl Hash

=head1 DESCRIPTION

These are the vtable functions for the PerlHash base class

PerlHash values should probably only be allowed to be PMCs.

=head2 Functions

=over 4

=item C<static void
fromkeys(Interp *interpreter, PMC *self, PMC *keys, PMC *value)>

Fill the hash with keys from the aggregate keys and with the
optional value. If value isn't given, a None object is filled
in as value.

=cut

*/

#include "parrot/parrot.h"

static size_t
key_hash_int(Interp *interp, Hash *hash, void *value)
{
    UNUSED(interp);
    UNUSED(hash);
    return (size_t) value;
}

static int
int_compare(Parrot_Interp interp, void *a, void *b)
{
    UNUSED(interp);
    return a != b;
}

/* XXX duplicated from classes/slice.pmc */

typedef struct {
    INTVAL i;
    STRING *s;
} RUnion;

#define RVal_int(u) u.i
#define RVal_str(u) u.s

typedef struct _range_t {
    int type;                   /* enum_type_INTVAL or STRING */
    RUnion start;             /* start of this range */
    RUnion end;               /* end of this range */
    RUnion step;              /* step of this range */
    RUnion cur;               /* current value */
    struct _range_t *next;       /* next in chain */
} range_t;

static void
fromkeys(Interp *interpreter, PMC *self, PMC *keys, PMC *value)
{
    INTVAL elems, dod_disabled, i;
    PMC *iter;

    if (PMC_IS_NULL(value))
        value = pmc_new(interpreter, enum_class_None);

    /*
     * if the number of keys is bigger then the current PMC
     * count, we do one DOD run and then disable DOD/GC
     */
    dod_disabled = 0;
    elems = 999999; /* TODO VTABLE_elements(interpreter, keys); */
    if (elems > (INTVAL)interpreter->arena_base->pmc_pool->total_objects) {
        Parrot_do_dod_run(interpreter, 0);
        Parrot_block_DOD(interpreter);
        Parrot_block_GC(interpreter);
        dod_disabled = 1;
    }
    /*
     * keys should be able to iterate
     * TODO check that
     */
    if (keys->vtable->base_type == enum_class_Iterator ||
            VTABLE_isa(interpreter, keys,
                const_string(interpreter, "Iterator"))) {
        iter = keys;
        if (PMC_pmc_val(iter)) {
            PMC *xr = PMC_pmc_val(iter);
            /* check, if we got an xrange iterator */
            if (PObj_is_PMC_TEST(xr) &&
                    xr->vtable->base_type == enum_class_Slice) {
                INTVAL start, end, step;
                Hash* hash;
                range_t *range = PMC_struct_val(xr);
                new_hash_x(interpreter, &hash, enum_type_ptr,
                        0, Hash_key_type_int,
                        int_compare, key_hash_int,
                        (hash_mark_key_fn) NULL);
                PMC_struct_val(self) = hash;
                start = RVal_int(range->start);
                end   = RVal_int(range->end);
                step  = RVal_int(range->step);
                /* TODO step
                 * TODO reversed range, negative step
                 */
                for (i = start; i <= end; i+= step) {
                    hash_put(interpreter, hash, (void *)i, value);
                }
                goto done;
            }
        }
    }
    else
        iter = pmc_new_init(interpreter, enum_class_Iterator, keys);
    VTABLE_set_integer_native(interpreter, iter, ITERATE_FROM_START);
    for (; VTABLE_get_bool(interpreter, iter); ) {
        STRING *s = VTABLE_shift_string(interpreter, iter);
        VTABLE_set_pmc_keyed_str(interpreter, self, s, value);
    }
done:
    if (dod_disabled) {
        Parrot_unblock_DOD(interpreter);
        Parrot_unblock_GC(interpreter);
    }
}


static PMC* undef = NULL;
STRING * hash_get_idx(Interp *interpreter, Hash *hash, PMC *key);

/*

=item C<static STRING* make_hash_key(Interp *interpreter, PMC *key)>

Returns a Parrot string for C<*key>.

=cut

*/

static STRING* make_hash_key(Interp* interpreter, PMC * key)
{
    if (key == NULL) {
        internal_exception(OUT_OF_BOUNDS,
        "Cannot use NULL key for PerlHash!\n");
        return NULL;
    }
    return key_string(interpreter, key);
}

/* Albeit PerlHash doesn't use PMC_data, it needs the next_for_GC pointer
 * We would get recursive marking of a deeply nested HoHoH...
 */
pmclass PerlHash need_ext does hash {

/*

=item C<void class_init()>

Class initialization. Allocates the memory for the hash.

=cut

*/

    void class_init() {
        /* class_init_code */
        make_bufferlike_pool(INTERP, sizeof(struct _hash));
        if (pass) {
            enter_nci_method(INTERP, enum_class_PerlHash,
                    F2DPTR(fromkeys), "fromkeys", "vIOPP");
        }
    }
/*

=item C<void init()>

Initializes the instance. Creates a global C<PerlUndef> if it doesn't
already exist.

=cut

*/

    void init () {
        if (undef == NULL) {
            undef = constant_pmc_new_noinit(INTERP, enum_class_PerlUndef);
            VTABLE_init(INTERP, undef);
        }
        PObj_custom_mark_SET(SELF);
        new_hash(INTERP, (Hash**)&PMC_struct_val(SELF));
    }

/*

=item C<void mark()>

Marks the hash as live.

=cut

*/

    void mark () {
        if (PMC_struct_val(SELF))
            mark_hash(INTERP, PMC_struct_val(SELF));
    }

/*

=item C<INTVAL type_keyed_str(STRING *key)>

Returns the type of the element for C<*key>.

=cut

*/

    INTVAL type_keyed_str (STRING* key) {
        HashBucket* b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF),
                                        key);
        if (!b)
            return enum_hash_undef;
        return VTABLE_type(INTERP, (PMC*) b->value);
    }

/*

=item C<INTVAL type_keyed (PMC *key)>

Returns the type of the element for C<*key>.

=cut

*/

    INTVAL type_keyed (PMC* key) {
        PMC* valpmc;
        PMC* nextkey;
        STRING* keystr = make_hash_key(INTERP, key);
        HashBucket* b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF),
                                            keystr);
        if (b == NULL) {
            return enum_hash_undef;
        }
        nextkey = key_next(INTERP, key);
        valpmc = b->value;
        if (!nextkey)
            return VTABLE_type(INTERP, valpmc);
        return VTABLE_type_keyed(INTERP, valpmc, nextkey);
    }

/*

=item C<PMC *clone()>

Creates and returns a clone of the hash.

=cut

*/

    PMC* clone () {
        PMC* dest = pmc_new_noinit(INTERP, SELF->vtable->base_type);
        PObj_custom_mark_SET(dest);
        hash_clone(INTERP, (Hash *)PMC_struct_val(SELF),
                   (Hash**)&PMC_struct_val(dest));
        return dest;
    }

/*

=item C<INTVAL get_integer()>

Returns the size of the hash.

=cut

*/

    INTVAL get_integer () {
        return hash_size(INTERP, PMC_struct_val(SELF));
    }

/*

=item C<INTVAL get_integer_keyed_str(STRING *key)>

=cut

*/

    INTVAL get_integer_keyed_str (STRING* key) {
        HashBucket *b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF),
                                        key);
        if (b == NULL) {
            /* XXX Warning: use of uninitialized value */
            return VTABLE_get_integer(INTERP, undef);
        }
        return VTABLE_get_integer(INTERP, (PMC*) b->value);
    }

/*

=item C<INTVAL get_integer_keyed(PMC *key)>

Returns the integer value for the element at C<*key>.

=cut

*/

    INTVAL get_integer_keyed (PMC* key) {
        PMC* valpmc;
        STRING* keystr;
        Hash *hash = PMC_struct_val(SELF);
        HashBucket *b;
        PMC* nextkey;

        switch (PObj_get_FLAGS(key) & KEY_type_FLAGS) {
            case KEY_integer_FLAG:
                /* called from iterator with an integer idx in key
                 * check if we really have Hash_key_type_int
                 */
                if (hash->key_type == Hash_key_type_int) {
                    return (INTVAL)hash_get_idx(INTERP, hash, key);
                }
                else {
                    STRING *s = hash_get_idx(INTERP, hash, key);
                    return string_to_int(interpreter, s);
                }
            default:
                keystr = make_hash_key(INTERP, key);
        }
        b = hash_get_bucket(INTERP, hash, keystr);
        if (b == NULL) {
            /* XXX Warning: use of uninitialized value */
            return VTABLE_get_integer(INTERP, undef);
        }
        nextkey = key_next(INTERP, key);
        valpmc = b->value;
        if (!nextkey)
            return VTABLE_get_integer(INTERP, valpmc);
        return VTABLE_get_integer_keyed(INTERP, valpmc, nextkey);
    }

/*

=item C<FLOATVAL get_number_keyed_str(STRING *key)>

=cut

*/

    FLOATVAL get_number_keyed_str (STRING* key) {
        HashBucket *b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF),
                                        key);
        if (b == NULL) {
            /* XXX Warning: Use of uninitialized value */
            return VTABLE_get_number(INTERP, undef);
        }
        return VTABLE_get_number(INTERP, (PMC*) b->value);
    }

/*

=item C<FLOATVAL get_number_keyed(PMC *key)>

Returns the floating-point value for the element at C<*key>.

=cut

*/

    FLOATVAL get_number_keyed (PMC* key) {
        PMC* valpmc;
        STRING* keystr = make_hash_key(INTERP, key);
        HashBucket *b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF),
                                        keystr);
        PMC* nextkey;
        if (b == NULL) {
            /* XXX Warning: Use of uninitialized value */
            return VTABLE_get_number(INTERP, undef);
        }
        nextkey = key_next(INTERP, key);
        valpmc = b->value;
        if (!nextkey)
            return VTABLE_get_number(INTERP, valpmc);
        return VTABLE_get_number_keyed(INTERP, valpmc, nextkey);
    }

/*

=item C<BIGNUM *get_bignum_keyed_str(STRING *key)>

=cut

*/

    BIGNUM* get_bignum_keyed_str (STRING* key) {
        HashBucket *b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF),
                                        key);
        if (b == NULL) {
            /* XXX Warning: Use of uninitialized value */
            return VTABLE_get_bignum(INTERP, undef);
        }
        return VTABLE_get_bignum(INTERP, (PMC*) b->value);
    }

/*

=item C<BIGNUM *get_bignum_keyed(PMC *key)>

Returns the big number value for the element at C<*key>.

=cut

*/

    BIGNUM* get_bignum_keyed (PMC* key) {
        PMC* valpmc;
        STRING* keystr = make_hash_key(INTERP, key);
        HashBucket *b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF),
                                        keystr);
        PMC* nextkey;
        if (b == NULL) {
            /* XXX Warning: Use of uninitialized value */
            return VTABLE_get_bignum(INTERP, undef);
        }
        nextkey = key_next(INTERP, key);
        valpmc = b->value;
        if (!nextkey)
            return VTABLE_get_bignum(INTERP, valpmc);
        return VTABLE_get_bignum_keyed(INTERP, valpmc, nextkey);
    }

/*

=item C<STRING *get_string()>

Returns a string representation of the hash, showing its class name and
memory address.

=cut

*/

    STRING* get_string () {
        return Parrot_sprintf_c(INTERP, "PerlHash[0x%x]", SELF);
    }

/*

=item C<STRING *get_string_keyed_str(STRING *key)>

=cut

*/

    STRING* get_string_keyed_str (STRING* key) {
        HashBucket *b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF),
                                        key);
        if (b == NULL) {
            /* XXX Warning: use of uninitialized value */
            return VTABLE_get_string(INTERP, undef);
        }
        return VTABLE_get_string(INTERP, (PMC*) b->value);
    }

/*

=item C<STRING *get_string_keyed(PMC *key)>

Returns the big number value for the element at C<*key>.

=cut

*/

    STRING* get_string_keyed (PMC* key) {
        PMC* valpmc;
        STRING* keystr;
        HashBucket *b;
        Hash *hash = PMC_struct_val(SELF);
        PMC* nextkey;

        switch (PObj_get_FLAGS(key) & KEY_type_FLAGS) {
            case KEY_integer_FLAG:
                /* called from iterator with an integer idx in key */
                if (hash->key_type == Hash_key_type_int) {
                    INTVAL i = (INTVAL)hash_get_idx(INTERP, hash, key);
                    return string_from_int(interpreter, i);
                }
                return hash_get_idx(INTERP, hash, key);
            default:
                keystr = make_hash_key(INTERP, key);
        }
        b = hash_get_bucket(INTERP, hash, keystr);
        if (b == NULL) {
            /* XXX Warning: use of uninitialized value */
            return VTABLE_get_string(INTERP, undef);
        }
        nextkey = key_next(INTERP, key);
        valpmc = b->value;
        if (!nextkey)
            return VTABLE_get_string(INTERP, valpmc);
        return VTABLE_get_string_keyed(INTERP, valpmc, nextkey);
    }

/*

=item C<INTVAL get_bool()>

Returns true if the hash size is not zero.

=cut

*/

    INTVAL get_bool () {
        return hash_size(INTERP, PMC_struct_val(SELF)) != 0;
    }

/*

=item C<INTVAL elements()>

Returns the number of elements in the hash.

=cut

*/

    INTVAL elements () {
        return hash_size(INTERP, PMC_struct_val(SELF));
    }

/*

=item C<PMC *get_pmc_keyed_str(STRING *key)>

=cut

*/

    PMC* get_pmc_keyed_str (STRING* key) {
        HashBucket *b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF),
                                        key);
        if (b == NULL) {
            /* XXX should store the undef for consistency */
            PMC *new_undef = pmc_new(INTERP, enum_class_PerlUndef);
            return new_undef;
        }
        return b->value;
    }

/*

=item C<PMC* slice (PMC *key)>

Return a new iterator for the slice PMC C<key>

=item C<PMC *get_pmc_keyed(PMC *key)>

Returns the PMC value for the element at C<*key>.

=cut

*/

    PMC* slice (PMC* key) {
	return NULL;
    }

    PMC* get_pmc_keyed (PMC* key) {
        STRING* keystr = make_hash_key(INTERP, key);
        HashBucket *b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF),
                                        keystr);
        PMC* nextkey;
        if (b == NULL) {
            /* XXX should store the undef for consistency */
            PMC *new_undef = pmc_new(INTERP, enum_class_PerlUndef);
            return new_undef;
        }
        nextkey = key_next(INTERP, key);
        if (!nextkey)
            return b->value;
        return VTABLE_get_pmc_keyed(INTERP, (PMC*)b->value, nextkey);
    }

/*

=item C<INTVAL is_same(PMC *other)>

Returns whether the hash is the same as C<*other>.

=cut

*/

    INTVAL is_same (PMC* other) {
        return (INTVAL)( other->vtable == SELF->vtable &&
            PMC_struct_val(other) == PMC_struct_val(SELF));
    }

/*

=item C<void set_integer_keyed(PMC *key, INTVAL value)>

=cut

*/

    void set_integer_keyed (PMC* key, INTVAL value) {
        STRING* keystr;
        PMC* nextkey;
        PMC* box;
        PMC* val;

        if (!key) return;
        keystr = make_hash_key(INTERP, key);
        nextkey = key_next(INTERP, key);
        if (nextkey == NULL) {
            val = pmc_new(interpreter, enum_class_PerlInt);
            VTABLE_set_integer_native(INTERP, val, value);
            hash_put(INTERP, PMC_struct_val(SELF), keystr, val);
            return;
        }
        box = SELF.get_pmc_keyed_str(keystr);
        if (box == NULL) {
            /* autovivify an PerlHash */
            box = pmc_new(INTERP, DYNSELF.type());
        }
        VTABLE_set_integer_keyed(INTERP, box, nextkey, value);
    }

/*

=item C<void set_integer_keyed_str(STRING *key, INTVAL value)>

=cut

*/

    void set_integer_keyed_str (STRING* key, INTVAL value) {
        PMC *val = pmc_new(interpreter, enum_class_PerlInt);
        PMC_int_val(val) = value;
        hash_put(INTERP, PMC_struct_val(SELF), key, val);
    }

/*

=item C<void set_number_keyed (PMC *key, FLOATVAL value)>

=cut

*/

    void set_number_keyed (PMC* key, FLOATVAL value) {
        STRING* keystr;
        PMC* nextkey;
        PMC* box;
        PMC* val;

        if (!key) return;
        keystr = make_hash_key(INTERP, key);
        nextkey = key_next(INTERP, key);
        if (nextkey == NULL) {
            val = pmc_new(interpreter, enum_class_PerlNum);
            PMC_num_val(val) = value;
            hash_put(INTERP, PMC_struct_val(SELF), keystr, val);
            return;
        }
        box = SELF.get_pmc_keyed_str(keystr);
        if (box == NULL) {
            /* autovivify an PerlHash */
            box = pmc_new(INTERP, DYNSELF.type());
        }
        VTABLE_set_number_keyed(INTERP, box, nextkey, value);
    }

/*

=item C<void set_number_keyed_str(STRING *key, FLOATVAL value)>

Sets C<value> as the value for C<*key>.

=cut

*/

    void set_number_keyed_str (STRING* key, FLOATVAL value) {
        PMC *val = pmc_new(interpreter, enum_class_PerlNum);
        PMC_num_val(val) = value;
        hash_put(INTERP, PMC_struct_val(SELF), key, val);
    }

/*

=item C<void set_bignum_keyed(PMC *key, BIGNUM *value)>

=cut

*/

    void set_bignum_keyed (PMC* key, BIGNUM* value) {
        /* XXX */
    }

/*

=item C<void set_bignum_keyed_str(STRING *key, BIGNUM *value)>

These two methods are unimplemented.

=cut

*/

    void set_bignum_keyed_str (STRING* key, BIGNUM* value) {
        /* XXX */
    }

/*

=item C<void set_string_keyed(PMC *key, STRING *value)>

=cut

*/

    void set_string_keyed (PMC* key, STRING* value) {
        STRING* keystr;
        PMC* nextkey;
        PMC* box;
        PMC* val;

        if (!key) return;
        keystr = make_hash_key(INTERP, key);
        nextkey = key_next(INTERP, key);
        if (nextkey == NULL) {
            val = pmc_new(interpreter, enum_class_PerlString);
            VTABLE_set_string_native(INTERP, val, value);
            hash_put(INTERP, PMC_struct_val(SELF), keystr, val);
            return;
        }
        box = SELF.get_pmc_keyed_str(keystr);
        if (box == NULL) {
            /* autovivify an PerlHash */
            box = pmc_new(INTERP, DYNSELF.type());
        }
        VTABLE_set_string_keyed(INTERP, box, nextkey, value);
    }

/*

=item C<void set_string_keyed_str(STRING *key, STRING *value)>

=cut

*/

    void set_string_keyed_str (STRING* key, STRING* value) {
        PMC *val = pmc_new(interpreter, enum_class_PerlString);
        VTABLE_set_string_native(INTERP, val, value);
        hash_put(INTERP, PMC_struct_val(SELF), key, val);
    }

/*

=item C<void set_pmc_keyed(PMC *dest_key, PMC *value)>

=cut

*/

    void set_pmc_keyed (PMC* key, PMC* value) {
        STRING* keystr;
        PMC* nextkey;
        PMC* box;
        PMC* val;

        if (!key) return;
        keystr = make_hash_key(INTERP, key);
        nextkey = key_next(INTERP, key);
        if (nextkey == NULL) {
            hash_put(INTERP, PMC_struct_val(SELF), keystr, value);
            return;
        }
        box = SELF.get_pmc_keyed_str(keystr);
        if (box == NULL) {
            /* autovivify an PerlHash */
            box = pmc_new(INTERP, DYNSELF.type());
        }
        VTABLE_set_pmc_keyed(INTERP, box, nextkey, value);
    }

/*

=item C<void set_pmc_keyed_str(STRING *key, PMC *value)>

Sets C<*value> as the value for C<*key>.

=cut

*/

    void set_pmc_keyed_str (STRING* key, PMC* value) {
        hash_put(INTERP, PMC_struct_val(SELF), key, value);
    }

/*

=item C<INTVAL is_equal(PMC *value)>

The C<==> operation.

Currently just returns false, C<*value> is ignored.

=cut

*/

    INTVAL is_equal (PMC* value) {
        return 0;
    }

/*

=item C<INTVAL exists_keyed_str(STRING *key)>

=cut

*/

    INTVAL exists_keyed_str(STRING* key) {
        HashBucket *b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF),
                                        key);
        return b != NULL;
    }

/*

=item C<INTVAL exists_keyed(PMC *key)>

Returns whether a key C<*key> exists in the hash.

=cut

*/

    INTVAL exists_keyed(PMC* key) {
        STRING * sx;
        Hash * h = (Hash *)PMC_struct_val(SELF);
        HashBucket *b;
        sx = key_string(INTERP, key);
        key = key_next(INTERP, key);
        b = hash_get_bucket(INTERP, h, sx);
        if (b == NULL)
            return 0;       /* no such key */
        if (key == NULL)
            return 1;       /* lookup stops here */
        return VTABLE_exists_keyed(INTERP, (PMC*)b->value, key);
    }

/*

=item C<INTVAL defined_keyed_str(STRING *key)>

=cut

*/

    INTVAL defined_keyed_str(STRING* key) {
        HashBucket *b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF),
                                        key);
        if (b == NULL)
            return 0;       /* no such key */
        return VTABLE_defined(INTERP, (PMC*)b->value);
    }

/*

=item C<INTVAL defined_keyed(PMC *key)>

Returns whether the value for C<*key> is defined.

=cut

*/

    INTVAL defined_keyed(PMC* key) {
        STRING * sx;
        Hash * h = (Hash *)PMC_struct_val(SELF);
        HashBucket *b;
        sx = key_string(INTERP, key);
        key = key_next(INTERP, key);
        b = hash_get_bucket(INTERP, h, sx);
        if (b == NULL)
            return 0;       /* no such key */
        if (key == NULL)
            return VTABLE_defined(INTERP, (PMC*)b->value);
        else
            return VTABLE_defined_keyed( INTERP, (PMC*)b->value, key);
    }

/*

=item C<void delete_keyed_str(STRING *key)>

=cut

*/

    void delete_keyed_str(STRING* key) {
        hash_delete(INTERP, (Hash *)PMC_struct_val(SELF), key);
    }

/*

=item C<void delete_keyed(PMC *key)>

Deletes the element associated with C<*key>.

=cut

*/

    void delete_keyed(PMC* key) {
        STRING * sx;
        Hash * h = (Hash *)PMC_struct_val(SELF);
        HashBucket *b;
        sx = key_string(INTERP, key);
        key = key_next(INTERP, key);
        b = hash_get_bucket(INTERP, h, sx);
        if (b == NULL)
                return;  /* no such key */
        else if (key == NULL)
            hash_delete(INTERP, h, sx);
        else
            VTABLE_delete_keyed(INTERP, (PMC*)b->value, key);
    }

/*

=item C<PMC* slice (PMC *key)>

Return a new iterator for the slice PMC C<key>

=cut

*/

    PMC* slice (PMC* key) {
	PMC *iter = pmc_new_init(interpreter, enum_class_Iterator, SELF);
        PMC_struct_val(iter) = key;
        return iter;
    }


/*

=item C<void visit(visit_info *info)>

Used during archiving to visit the elements in the hash.

=cut

*/

    void visit(visit_info *info) {
        hash_visit(INTERP, (Hash*)PMC_struct_val(SELF), info);
        SUPER(info);
    }

/*

=item C<void freeze(visit_info *info)>

Used to archive the hash.

=cut

*/

    void freeze(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        SUPER(info);
        io->vtable->push_integer(INTERP, io, VTABLE_elements(INTERP, SELF));
    }

/*

=item C<void thaw(visit_info *info)>

Used to unarchive the hash.

=cut

*/

    void thaw(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        SUPER(info);
        if (info->extra_flags == EXTRA_IS_NULL) {
            info->extra_flags = EXTRA_IS_COUNT;
            info->extra = (void *)io->vtable->shift_integer(INTERP, io);
        }
    }
}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd08_keys.pod>.

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
