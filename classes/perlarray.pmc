/* perlarray.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the PerlArray base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *     TODO: Fix the arithmetic ops (right now they just corrupt the
 *           array length and possibly seg fault)
 *  References:
 */

#include "parrot/parrot.h"

#define THROW_UNSUPPORTED internal_exception(INTERP_ERROR, "Operation not supported\n")

#define resize_array Parrot_Array_resize_array
extern void Parrot_Array_resize_array ( struct Parrot_Interp *, PMC*, INTVAL);

static PMC* undef(struct Parrot_Interp* interpreter)
{
    return pmc_new(interpreter, enum_class_PerlUndef);
}

static INTVAL atom2int(Interp *interpreter, KEY_ATOM* atom) {
    switch ((int)atom->type) {
        case enum_key_undef:
        default:
            return 0;
        case enum_key_int:
            return atom->val.int_val;
        case enum_key_num:
            return (INTVAL)atom->val.num_val;
        case enum_key_pmc:
            return atom->val.pmc_val->vtable->get_integer(interpreter, atom->val.pmc_val);
        case enum_key_string:
            return string_to_int(atom->val.struct_val);
    }
}

pmclass PerlArray extends Array {

    INTVAL type () {
        return enum_class_PerlArray;
    }

    STRING* name() {
        return whoami;
    }

    PMC* clone () { 
        PMC* dest;
        INTVAL ix, size;
        PMC* element;
        PMC** array;

        dest = pmc_new(INTERP, enum_class_PerlArray);
        dest->vtable = SELF->vtable;
	dest->vtable->init(interpreter, dest);
	size = SELF->cache.int_val;
	resize_array(interpreter, dest, size);
	for (ix = 0; ix < size; ix++) {
	    PMC *new;
	    array = ((Buffer *) SELF->data)->bufstart;
	    element = array[ix];

	    if (element) {
		new = element->vtable->clone(interpreter, element);
		((PMC**)((Buffer *) dest->data)->bufstart)[ix] = new;
	    }

	}
        return dest;
    }

    void set_integer_keyed (KEY* key, INTVAL value) {
        INTVAL ix;

        if (!key) return;

        ix = atom2int(interpreter, &key->atom);

        if (ix >= SELF->cache.int_val) {
            resize_array(interpreter, SELF, ix+1);
        }

        SUPER(key, value);
    };

    void set_number_keyed (KEY* key, FLOATVAL value) {
        INTVAL ix;

        if (!key) return;

        ix = atom2int(interpreter, &key->atom);

        if (ix >= SELF->cache.int_val) {
            resize_array(interpreter, SELF, ix+1);
        }

        SUPER(key, value);
    };

    void set_string_keyed (KEY* key, STRING* value) {
        INTVAL ix;

        if (!key) return;

        ix = atom2int(interpreter, &key->atom);

        if (ix >= SELF->cache.int_val) {
            resize_array(interpreter, SELF, ix+1);
        }

        SUPER(key, value);
    };

    void set_pmc_keyed (KEY* key, PMC* src, KEY* src_key) {
        INTVAL ix;

        if (!key) return;

        ix = atom2int(interpreter, &key->atom);

        if (ix >= SELF->cache.int_val) {
            resize_array(interpreter, SELF, ix+1);
        }

        SUPER(key, src, src_key);
    };

    INTVAL get_integer_keyed_int (INTVAL* key) {
        if (*key >= SELF->cache.int_val) {
            PMC* temp = undef(INTERP);
            return temp->vtable->get_integer(INTERP, temp);
        }
        else
            return SUPER(key);
    }

    INTVAL get_integer_keyed (KEY* key) {
        INTVAL ix;
        PMC* box;

        if (!key) return 0;
        ix = atom2int(interpreter, &key->atom);
        if (key->next == NULL) return SELF.get_integer_keyed_int(&ix);

        box = SELF.get_pmc_keyed_int(&ix);
        if (box == NULL) box = undef(INTERP);
        return box->vtable->get_integer_keyed(INTERP, box, key->next);
    }

    FLOATVAL get_number_keyed_int (INTVAL* key) {
        if (*key >= SELF->cache.int_val) {
            PMC* temp = undef(INTERP);
            return temp->vtable->get_number(INTERP, temp);
        }
        else
            return SUPER(key);
    }

    FLOATVAL get_number_keyed (KEY* key) {
        INTVAL ix;
        PMC* box;

        if (!key) return 0;
        ix = atom2int(interpreter, &key->atom);
        if (key->next == NULL) return SELF.get_number_keyed_int(&ix);

        box = SELF.get_pmc_keyed_int(&ix);
        if (box == NULL) box = undef(INTERP);
        return box->vtable->get_number_keyed(INTERP, box, key->next);
    }

    STRING* get_string_keyed_int (INTVAL* key) {
        if (*key >= SELF->cache.int_val) {
            PMC* value = undef(INTERP);
            return value->vtable->get_string(INTERP, value);
        }
        else
            return SUPER(key);
    }

    STRING* get_string_keyed (KEY* key) {
        INTVAL ix;
        PMC* box;

        if (!key) return 0;
        ix = atom2int(interpreter, &key->atom);
        if (key->next == NULL) return SELF.get_string_keyed_int(&ix);

        box = SELF.get_pmc_keyed_int(&ix);
        if (box == NULL) box = undef(INTERP);
        return box->vtable->get_string_keyed(INTERP, box, key->next);
    }

    PMC* get_pmc_keyed_int (INTVAL* key) {
        if (*key >= SELF->cache.int_val)
            return undef(INTERP);
        else
            return SUPER(key);
    }

    PMC* get_pmc_keyed (KEY* key) {
        INTVAL ix;
        PMC* box;

        if (!key) return 0;
        ix = atom2int(interpreter, &key->atom);
        if (key->next == NULL) return SELF.get_pmc_keyed_int(&ix);

        box = SELF.get_pmc_keyed_int(&ix);
        if (box == NULL) box = undef(INTERP);
        return box->vtable->get_pmc_keyed(INTERP, box, key->next);
    }

    void add (PMC * value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
                DYNSELF.get_integer() + value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                DYNSELF.get_number() + value->cache.num_val
            );
        }
        else {
            dest->vtable->set_integer_native(INTERP, dest,
                DYNSELF.get_integer() +
                value->vtable->get_integer(INTERP, value)
            );
        }
    }

    void add_int (INTVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
            DYNSELF.get_integer() + value
        );
    }

    void add_bignum (BIGNUM* value, PMC* dest) {
        /* XXX - You know it */
    }

    void add_float (FLOATVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
        dest->vtable->set_number_native(INTERP, dest, 
            DYNSELF.get_number() + value
        );
    }

    void subtract (PMC * value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
                DYNSELF.get_integer() - value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                DYNSELF.get_number() - value->cache.num_val
            );
        }
        else {
            dest->vtable->set_integer_native(INTERP, dest,
                DYNSELF.get_integer() -
                value->vtable->get_integer(INTERP, value)
            );
        }
    }

    void subtract_int (INTVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
            DYNSELF.get_integer() - value
        );
    }

    void subtract_float (FLOATVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
        dest->vtable->set_number_native(INTERP, dest, 
            DYNSELF.get_number() - value
        );
    }

    void multiply (PMC * value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
                DYNSELF.get_integer() * value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                DYNSELF.get_number() * value->cache.num_val
            );
        }
        else {
            dest->vtable->set_integer_native(INTERP, dest,
                DYNSELF.get_integer() *
                value->vtable->get_integer(INTERP, value)
            );
        }
    }

    void multiply_int (INTVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
            DYNSELF.get_integer() * value
        );
    }

    void multiply_float (FLOATVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
        dest->vtable->set_number_native(INTERP, dest, 
            DYNSELF.get_number() * value
        );
    }

    void divide (PMC * value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
                DYNSELF.get_integer() / value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
            dest->vtable->set_number_native(INTERP, dest, 
                DYNSELF.get_number() / value->cache.num_val
            );
        }
        else {
            dest->vtable->set_integer_native(INTERP, dest,
                DYNSELF.get_integer() /
                value->vtable->get_integer(INTERP, value)
            );
        }
    }

    void divide_int (INTVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
            DYNSELF.get_integer() / value
        );
    }

    void divide_float (FLOATVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlNum];
        dest->vtable->set_number_native(INTERP, dest, 
            DYNSELF.get_number() / value
        );
    }

    void modulus (PMC * value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
            dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
            dest->vtable->set_integer_native(INTERP, dest, 
                DYNSELF.get_integer() % value->cache.int_val
            );
        }
        else {
            dest->vtable->set_integer_native(INTERP, dest,
                DYNSELF.get_integer() %
                value->vtable->get_integer(INTERP, value)
            );
        }
    }

    void modulus_int (INTVAL value, PMC* dest) {
        dest->vtable = &Parrot_base_vtables[enum_class_PerlInt];
        dest->vtable->set_integer_native(INTERP, dest, 
            DYNSELF.get_integer() % value
        );
    }

    void concatenate (PMC * value, PMC* dest) {
        dest->cache.struct_val =
            string_concat(INTERP,
                      SELF->cache.struct_val,
                      value->vtable->get_string(INTERP, value),
                      0
                     );
    }

    void concatenate_native (STRING * value, PMC* dest) {
        dest->cache.struct_val =
            string_concat(INTERP,
                      SELF->cache.struct_val,
                      value,
                      0
                     );
    }

    void concatenate_same (PMC * value, PMC* dest) {
        dest->cache.struct_val =
            string_concat(INTERP,
                      SELF->cache.struct_val,
                      value->cache.struct_val,
                      0
                     );
    }
}
