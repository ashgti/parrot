/* perlarray.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the PerlArray base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *     TODO: Fix the arithmetic ops (right now they just corrupt the
 *           array length and possibly seg fault)
 *  References:
 */

#include "parrot/parrot.h"

#define THROW_UNSUPPORTED internal_exception(INTERP_ERROR, "Operation not supported\n")

#define resize_array Parrot_Array_resize_array
extern void Parrot_Array_resize_array ( struct Parrot_Interp *, PMC*, INTVAL);

static PMC* undef(struct Parrot_Interp* interpreter)
{
    return pmc_new(interpreter, enum_class_PerlUndef);
}

pmclass PerlArray extends Array {

    INTVAL type () {
        return enum_class_PerlArray;
    }

    STRING* name() {
        return whoami;
    }

    void set_integer_keyed_int (INTVAL* key, INTVAL value) {
        INTVAL ix;

        if (!key) return;

        ix = *key;

        if (ix >= SELF->cache.int_val) {
            resize_array(interpreter, SELF, ix+1);
        }
	else if (ix < -SELF->cache.int_val)
            resize_array(interpreter, SELF, -ix-SELF->cache.int_val);

        SUPER(key, value);
    };


    void set_integer_keyed (PMC* key, INTVAL value) {
        INTVAL ix;

        if (!key) return;

        ix = key_integer(INTERP, key);

        if (ix >= SELF->cache.int_val) {
            resize_array(interpreter, SELF, ix+1);
        }
	else if (ix < -SELF->cache.int_val)
            resize_array(interpreter, SELF, -ix-SELF->cache.int_val);

        SUPER(key, value);
    };


    void set_number_keyed_int (INTVAL* key, FLOATVAL value) {
        INTVAL ix;

        if (!key) return;

        ix = *key;

        if (ix >= SELF->cache.int_val) {
            resize_array(interpreter, SELF, ix+1);
        }
	else if (ix < -SELF->cache.int_val)
            resize_array(interpreter, SELF, -ix-SELF->cache.int_val);

        SUPER(key, value);
    };

    void set_number_keyed (PMC* key, FLOATVAL value) {
        INTVAL ix;

        if (!key) return;

        ix = key_integer(INTERP, key);

        if (ix >= SELF->cache.int_val) {
            resize_array(interpreter, SELF, ix+1);
        }
	else if (ix < -SELF->cache.int_val)
            resize_array(interpreter, SELF, -ix-SELF->cache.int_val);

        SUPER(key, value);
    };


    void set_string_keyed_int (INTVAL* key, STRING* value) {
        INTVAL ix;

        if (!key) return;

        ix = *key;

        if (ix >= SELF->cache.int_val) {
            resize_array(interpreter, SELF, ix+1);
        }
	else if (ix < -SELF->cache.int_val)
            resize_array(interpreter, SELF, -ix-SELF->cache.int_val);

        SUPER(key, value);
    };

    void set_string_keyed (PMC* key, STRING* value) {
        INTVAL ix;

        if (!key) return;

        ix = key_integer(INTERP, key);

        if (ix >= SELF->cache.int_val) {
            resize_array(interpreter, SELF, ix+1);
        }
	else if (ix < -SELF->cache.int_val)
            resize_array(interpreter, SELF, -ix-SELF->cache.int_val);

        SUPER(key, value);
    };

    void set_pmc_keyed_int (INTVAL* key, PMC* src, INTVAL* src_key) {
        INTVAL ix;

        if (!key) return;

        ix = *key;

        if (ix >= SELF->cache.int_val) {
            resize_array(interpreter, SELF, ix+1);
        }
	else if (ix < -SELF->cache.int_val)
            resize_array(interpreter, SELF, -ix-SELF->cache.int_val);

        SUPER(key, src, src_key);
    };

    void set_pmc_keyed (PMC* key, PMC* src, PMC* src_key) {
        INTVAL ix;

        if (!key) return;

        ix = key_integer(INTERP, key);

        if (ix >= SELF->cache.int_val) {
            resize_array(interpreter, SELF, ix+1);
        }
	else if (ix < -SELF->cache.int_val)
            resize_array(interpreter, SELF, -ix-SELF->cache.int_val);

        SUPER(key, src, src_key);
    };

    INTVAL get_integer_keyed_int (INTVAL* key) {
        if (*key >= SELF->cache.int_val || *key < -SELF->cache.int_val) {
            PMC* temp = undef(INTERP);
            return temp->vtable->get_integer(INTERP, temp);
        }
        else
            return SUPER(key);
    }

    INTVAL get_integer_keyed (PMC* key) {
	return SUPER(key);
    }

    FLOATVAL get_number_keyed_int (INTVAL* key) {
        if (*key >= SELF->cache.int_val || *key < -SELF->cache.int_val) {
            PMC* temp = undef(INTERP);
            return temp->vtable->get_number(INTERP, temp);
        }
        else
            return SUPER(key);
    }

    FLOATVAL get_number_keyed (PMC* key) {
	return SUPER(key);
    }

    STRING* get_string () {
	return string_from_int(INTERP, SELF->cache.int_val);
    }

    STRING* get_string_keyed_int (INTVAL* key) {
        if (*key >= SELF->cache.int_val || *key < -SELF->cache.int_val) {
            PMC* value = undef(INTERP);
            return value->vtable->get_string(INTERP, value);
        }
        else
            return SUPER(key);
    }

    STRING* get_string_keyed (PMC* key) {
	return SUPER(key);
    }

    PMC* get_pmc_keyed_int (INTVAL* key) {
        if (*key >= SELF->cache.int_val || *key < -SELF->cache.int_val)
            return undef(INTERP);
        else
            return SUPER(key);
    }

    PMC* get_pmc_keyed (PMC* key) {
	return SUPER(key);
    }

}
