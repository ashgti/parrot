/* perlarray.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the PerlArray base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *     TODO: Fix the arithmetic ops (right now they just corrupt the
 *           array length and possibly seg fault)
 *  References:
 */

#include "parrot/parrot.h"


static PMC* undef(struct Parrot_Interp* interpreter)
{
    return pmc_new(interpreter, enum_class_PerlUndef);
}

static PMC *
Parrot_PerlArray_set_pmc_ptr(Interp *interp, List *list, INTVAL key)
{
    void * ret = list_get(interp, list, key, enum_type_PMC);
    PMC *value;

    /* assign into a sparse or past end */
    if (ret == 0 || ret == (void*) -1 || *(PMC**)ret == 0) {
	value = undef(interp);
	list_assign(interp, list, key, value, enum_type_PMC);
    }
    else
	value = *(PMC**) ret;
    return value;
}

pmclass PerlArray extends Array {

    INTVAL type () {
        return enum_class_PerlArray;
    }

    STRING* name() {
        return whoami;
    }

    void set_integer_keyed_int (INTVAL* key, INTVAL value) {
	PMC * ptr = Parrot_PerlArray_set_pmc_ptr(INTERP,
		(List *) SELF->data, *key);
        ptr->vtable->set_integer_native(INTERP, ptr, value);
    };


    void set_integer_keyed (PMC* key, INTVAL value) {
        INTVAL ix;

        if (!key) return;

        ix = key_integer(INTERP, key);
	DYNSELF.set_integer_keyed_int(&ix, value);
    };


    void set_number_keyed_int (INTVAL* key, FLOATVAL value) {
	PMC * ptr = Parrot_PerlArray_set_pmc_ptr(INTERP,
		(List *) SELF->data, *key);
        ptr->vtable->set_number_native(INTERP, ptr, value);
    };

    void set_number_keyed (PMC* key, FLOATVAL value) {
        INTVAL ix;

        if (!key) return;

        ix = key_integer(INTERP, key);
	DYNSELF.set_number_keyed_int(&ix, value);
    };


    void set_string_keyed_int (INTVAL* key, STRING* value) {
	PMC * ptr = Parrot_PerlArray_set_pmc_ptr(INTERP,
		(List *) SELF->data, *key);
        ptr->vtable->set_string_native(INTERP, ptr, value);
    };

    void set_string_keyed (PMC* key, STRING* value) {
        INTVAL ix;

        if (!key) return;

        ix = key_integer(INTERP, key);
	DYNSELF.set_string_keyed_int(&ix, value);
    };

    void set_pmc_keyed_int (INTVAL* key, PMC* src, INTVAL* src_key) {
	Parrot_PerlArray_set_pmc_ptr(INTERP, (List *) SELF->data, *key);
        SUPER(key, src, src_key);
    };

    void set_pmc_keyed (PMC* key, PMC* src, PMC* src_key) {
        INTVAL ix;

        if (!key) return;

        ix = key_integer(INTERP, key);
	DYNSELF.set_pmc_keyed_int(&ix, src, src_key);
    };

    INTVAL get_integer_keyed_int (INTVAL* key) {
        if (*key >= DYNSELF.elements() || *key < -DYNSELF.elements()) {
            PMC* temp = undef(INTERP);
            return temp->vtable->get_integer(INTERP, temp);
        }
        else
            return SUPER(key);
    }

    INTVAL get_integer_keyed (PMC* key) {
	return SUPER(key);
    }

    FLOATVAL get_number_keyed_int (INTVAL* key) {
        if (*key >= DYNSELF.elements() || *key < -DYNSELF.elements()) {
            PMC* temp = undef(INTERP);
            return temp->vtable->get_number(INTERP, temp);
        }
        else
            return SUPER(key);
    }

    FLOATVAL get_number_keyed (PMC* key) {
	return SUPER(key);
    }

    STRING* get_string () {
	return string_from_int(INTERP, DYNSELF.elements());
    }

    STRING* get_string_keyed_int (INTVAL* key) {
        if (*key >= DYNSELF.elements() || *key < -DYNSELF.elements()) {
            PMC* value = undef(INTERP);
            return value->vtable->get_string(INTERP, value);
        }
        else
            return SUPER(key);
    }

    STRING* get_string_keyed (PMC* key) {
	return SUPER(key);
    }

    PMC* get_pmc_keyed_int (INTVAL* key) {
        if (*key >= DYNSELF.elements() || *key < -DYNSELF.elements())
            return undef(INTERP);
        else
            return SUPER(key);
    }

    PMC* get_pmc_keyed (PMC* key) {
	return SUPER(key);
    }

}
