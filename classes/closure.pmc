/* Closure.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the Closure (subroutine) base class.
 *     This are subroutines which take a context structure.
 *  Data Structure and Algorithms:
 *  History:
 *     Initial version by Leo.
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"
#include "parrot/method_util.h"

pmclass Closure extends Sub {

   STRING* name () {
	return whoami;
   }

   void init () {
       PMC_data(SELF) = new_closure(INTERP);
       SELF->cache.struct_val = NULL;
       PObj_custom_mark_destroy_SETALL(SELF);
   }

   void mark () {
        struct Parrot_Closure * sub = (struct Parrot_Closure *)PMC_data(SELF);
        mark_stack(INTERP, sub->ctx.pad_stack);
        pobject_lives(INTERP, sub->ctx.warns);
   }

   void destroy () {
       struct Parrot_Closure * sub = (struct Parrot_Closure *)PMC_data(SELF);
       stack_destroy(sub->ctx.pad_stack);
       mem_sys_free(sub);
   }


   void* invoke (void* next) {
       struct Parrot_Closure * sub = (struct Parrot_Closure *)PMC_data(SELF);
       INTERP->ctx.pad_stack = sub->ctx.pad_stack;

       return SELF->cache.struct_val;
   }

   void clone (PMC *ret) {
       struct Parrot_Closure * sub;
       PObj_custom_mark_destroy_SETALL(ret);
       sub = PMC_data(ret) = mem_sys_allocate(sizeof(struct Parrot_Closure));
       memcpy(sub, PMC_data(SELF), sizeof(struct Parrot_Closure));
       stack_mark_cow(sub->ctx.pad_stack);
       ret->cache.struct_val = SELF->cache.struct_val;
   }

    void set_same (PMC* value) {
	PMC_data(SELF) = PMC_data(value);
	SELF->cache.struct_val = value->cache.struct_val;
    }

    INTVAL is_equal (PMC* value) {
	return (SELF->vtable == value->vtable &&
		SELF->cache.struct_val == value->cache.struct_val &&
		memcmp(PMC_data(value), PMC_data(SELF),
		    sizeof(struct Parrot_Closure)) == 0);
    }

}
