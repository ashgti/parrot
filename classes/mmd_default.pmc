/*
Copyright: 2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/mmd_default.pmc - Abstract default for multi-method dispatch

=head1 DESCRIPTION

C<mmd_default> extends C<default> to provide multi-method dispatch
versions of all the binary operators for PMC classes to inherit from.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass mmd_default extends default {

/*

=item C<void init()>

Initialises the PMC with a default value of C<0.0>.

=cut

*/

    void init() {
        PMC_num_val(SELF) = 0.0;
    }

/*

=item C<void add(PMC *value, PMC *dest)>

Returns in C<*dest> the result of adding the PMC to C<*value>.

=cut

*/

    void add(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_ADD);
    }

/*

=item C<void subtract(PMC *value, PMC *dest)>

Returns in C<*dest> the result of subtracting C<*value> from the PMC.

=cut

*/

    void subtract(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_SUBTRACT);
    }

/*

=item C<void multiply(PMC *value, PMC *dest)>

Returns in C<*dest> the result of multiplying the PMC by C<*value>.

=cut

*/

    void multiply(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_MULTIPLY);
    }

/*

=item C<void divide(PMC *value, PMC *dest)>

Returns in C<*dest> the result of dividing the PMC by C<*value>.

=cut

*/

    void divide(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_DIVIDE);
    }

/*

=item C<void modulus(PMC *value, PMC *dest)>

Returns in C<*dest> the result of PMC modulo C<*value>.

=cut

*/

    void modulus(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_MOD);
    }

/*

=item C<void cmodulus(PMC *value, PMC *dest)>

Returns in C<*dest> the result of PMC C-style modulo C<*value>.

=cut

*/

    void cmodulus(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_CMOD);
    }

/*

=item C<void bitwise_and(PMC *value, PMC *dest)>

Returns in C<*dest> the result of applying a bitwise C<AND> between the
PMC and C<*value>.

=cut

*/

    void bitwise_and(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_BAND);
    }

/*

=item C<void bitwise_or(PMC *value, PMC *dest)>

Returns in C<*dest> the result of applying a bitwise C<OR> between the
PMC and C<*value>.

=cut

*/

    void bitwise_or(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_BOR);
    }

/*

=item C<void bitwise_xor(PMC *value, PMC *dest)>

Returns in C<*dest> the result of applying a bitwise C<XOR> between the
PMC and C<*value>.

=cut

*/

    void bitwise_xor(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_BXOR);
    }

/*

=item C<void bitwise_shl(PMC *value, PMC *dest)>

Returns in C<*dest> the result of applying a bitwise shift left
(C<<<<<>>>) between the PMC and C<*value>.

=cut

*/

    void bitwise_shl(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_BSL);
    }

/*

=item C<void bitwise_shr(PMC *value, PMC *dest)>

Returns in C<*dest> the result of applying a bitwise shift right
(C<<<>>>>>) between the PMC and C<*value>.

=cut

*/

    void bitwise_shr(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_BSR);
    }

/*

=item C<void concatenate(PMC *value, PMC *dest)>

Returns in C<*dest> the result of concatenating the PMC with C<*value>.

=cut

*/

    void concatenate(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_CONCAT);
    }

/*

=item C<void logical_and(PMC *value, PMC *dest)>

Returns in C<*dest> the result of applying a logical C<AND> between the
PMC and C<*value>.

=cut

*/

    void logical_and(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_LAND);
    }

/*

=item C<void logical_or(PMC *value, PMC *dest)>

Returns in C<*dest> the result of applying a logical C<OR> between the
PMC and C<*value>.

=cut

*/

    void logical_or(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_LOR);
    }

/*

=item C<void logical_xor(PMC *value, PMC *dest)>

Returns in C<*dest> the result of applying a logical C<XOR> between the
PMC and C<*value>.

=cut

*/

    void logical_xor(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_LXOR);
    }

/*

=item C<void repeat(PMC *value, PMC *dest)>

Returns in C<*dest> the result of repeating the PMC C<*value> times.

=cut

*/

    void repeat(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_REPEAT);
    }

/*

=item C<INTVAL is_equal(PMC *value)>

Returns whether the PMC is equal to C<*value>.

=cut

*/

    INTVAL is_equal(PMC* value) {
        return mmd_dispatch_i_pp(INTERP, SELF, value, MMD_NUMEQ);
    }

/*

=item C<INTVAL cmp_num(PMC *value)>

=item C<INTVAL cmp_string(PMC *value)>

Returns a comparison result (i.e. one of C<{-1, 0, 1}>) for the PMC and
C<*value>.

=cut

*/

    INTVAL cmp(PMC* value) {
        return mmd_dispatch_i_pp(INTERP, SELF, value, MMD_CMP);
    }

    INTVAL cmp_num(PMC* value) {
        return mmd_dispatch_i_pp(INTERP, SELF, value, MMD_NUMCMP);
    }

    INTVAL cmp_string(PMC* value) {
        return mmd_dispatch_i_pp(INTERP, SELF, value, MMD_STRCMP);
    }

/*

=item C<void bitwise_ors(PMC *value, PMC *dest)>

Returns in C<*dest> the result of the string bitwise C<OR> of the PMC
and C<*value>.

=cut

*/

    void bitwise_ors(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_SOR);
    }

/*

=item C<void bitwise_ands(PMC *value, PMC *dest)>

Returns in C<*dest> the result of the string bitwise C<AND> of the PMC
and C<*value>.

=cut

*/

    void bitwise_ands(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_SAND);
    }

/*

=item C<void bitwise_xors(PMC *value, PMC *dest)>

Returns in C<*dest> the result of the string bitwise C<XOR> of the PMC
and C<*value>.

=cut

*/

    void bitwise_xors(PMC* value, PMC* dest) {
        mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_SXOR);
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
