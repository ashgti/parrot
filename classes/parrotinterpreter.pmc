/* parrotinterpreter.pmc
 *  Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the ParrotInterpreter base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *     getinterp P0
 *     set P1, P0[.IGLOBALS_*]	# access interpreter globals
 *     set I0, P0[x]		# interpinfo I0, x
 *     set I0, P0[-1]		# get interpreter flags
 *     set P0[-1], x		# set flags on interpreter
 *                              # NOTE: this doesn't restart
 *  References:
 */

#include "parrot/parrot.h"
#include "parrot/embed.h"
#include <assert.h>

/*
 * copy / clone interpreter registers
 * all resources are created in the destination interpreter
 */
static void
clone_regs(Parrot_Interp d, Parrot_Interp s, PMC *dest)
{
    int i;
    mem_sys_memcopy(d->int_reg.registers,
	    s->int_reg.registers, sizeof(struct IReg));
    mem_sys_memcopy(d->num_reg.registers,
	    s->num_reg.registers, sizeof(struct NReg));
    for (i = 0; i < NUM_REGISTERS; i++) {
	if (s->string_reg.registers[i])
	    d->string_reg.registers[i] =
		string_copy(d, s->string_reg.registers[i]);
	/*
	 * clone PMCS - ignore the shared case for now
	 */
	if (!PMC_IS_NULL(s->pmc_reg.registers[i])) {
	    PMC *sp = s->pmc_reg.registers[i];
	    /* special case, dont clone SELF again - ugly */
	    if (sp->vtable->base_type == enum_class_ParrotInterpreter &&
		    PMC_data(sp) == s)
		d->pmc_reg.registers[i] = dest;
	    else {
		PMC *dp = pmc_new_noinit(d, sp->vtable->base_type);
		VTABLE_clone(d, sp, dp);
		d->pmc_reg.registers[i] = dp;
	    }
	}
    }
}

/*
 * copied from parrotio.pmc - this ought to be a global
 * helper function
 */
static void
enter_nci_method(struct Parrot_Interp *interpreter, PMC *method_table,
		 void *func, const char *name, const char *proto)
{
    PMC *method;

    method = pmc_new(interpreter, enum_class_NCI);
    VTABLE_set_string_keyed(interpreter, method, func,
	    string_make(interpreter, proto, strlen(proto),
		NULL, PObj_constant_FLAG|PObj_external_FLAG, NULL));
    VTABLE_set_pmc_keyed_str(interpreter, method_table,
	    string_make(interpreter, name,
		strlen(name), NULL,
		PObj_constant_FLAG|PObj_external_FLAG, NULL),
	    method);
}

/*
 * the actual thread function
 */
static void*
thread_func(void *arg)
{
    PMC *self = (PMC*) arg;
    Parrot_Interp interpreter = PMC_data(self);
    runops(interpreter, (opcode_t *)self->cache.struct_val -
			(opcode_t *)interpreter->code->byte_code);

    return NULL;
}

/*
 * run the sub PMC in a separate thread using interpreter in dest_interp
 */
static int
thread_run(Parrot_Interp interp, PMC* dest_interp, PMC* sub)
{
    Parrot_thread t;
    Parrot_Interp interpreter = PMC_data(dest_interp);

    dest_interp->cache.struct_val = sub->cache.struct_val;
    Interp_flags_SET(interpreter, PARROT_EXTERN_CODE_FLAG);
    interpreter->code = interp->code;
    /*
     * for now create a detached thread - enough for testing
     */
    THREAD_CREATE_DETACHED(t, thread_func, dest_interp);
    return 0;
}

void Parrot_NCI_class_init(Parrot_Interp, int);
void Parrot_PerlHash_class_init(Parrot_Interp, int);
void Parrot_PerlUndef_class_init(Parrot_Interp, int);

pmclass ParrotInterpreter need_ext {

    void class_init () {
        PMC *method_table;

        /* These classes are needed now so make sure they are inited */
        Parrot_NCI_class_init(interp, enum_class_NCI);
        Parrot_PerlHash_class_init(interp, enum_class_PerlHash);
        Parrot_PerlUndef_class_init(interp, enum_class_PerlUndef);

        method_table = pmc_new(INTERP, enum_class_PerlHash);

        enter_nci_method(INTERP, method_table,
                         F2DPTR(thread_run), "thread", "vIPP");
        Parrot_base_vtables[enum_class_ParrotInterpreter]->method_table =
	    method_table;
    }

    void init () {
	struct Parrot_Interp *new_interp;
	new_interp = make_interpreter(INTERP, 0);
	PMC_data(SELF) = new_interp;
	SELF->cache.struct_val = NULL;
    }

    void set_pointer (void* value) {
	SELF->cache.struct_val = value;
    }

    void* get_pointer () {
	return SELF->cache.struct_val;
    }

    void* invoke (void* next) {
	struct Parrot_Interp * new_interp =
	    (struct Parrot_Interp *)PMC_data(SELF);
	Interp_flags_SET(new_interp, PARROT_EXTERN_CODE_FLAG);
	new_interp->code = interpreter->code;
	/* calculate offset */
	runops(new_interp, (opcode_t *)SELF->cache.struct_val -
			(opcode_t *)interpreter->code->byte_code);
	return next;
    }

    PMC* get_pmc_keyed_int(INTVAL key) {
	struct Parrot_Interp * new_interp =
	    (struct Parrot_Interp *)PMC_data(SELF);
	if (key >= 0 && key < IGLOBALS_SIZE)
	    return VTABLE_get_pmc_keyed_int(new_interp,
		    new_interp->iglobals, key);
	return NULL;
    }

    INTVAL get_integer_keyed_int(INTVAL key) {
	struct Parrot_Interp * new_interp =
	    (struct Parrot_Interp *)PMC_data(SELF);
	switch (key) {
	    case -1:
		return (INTVAL) new_interp->flags;
	    default:
		return interpinfo(new_interp, key);
	}
    }

    void set_integer_keyed_int(INTVAL key, INTVAL val) {
	struct Parrot_Interp * new_interp =
	    (struct Parrot_Interp *)PMC_data(SELF);
	INTVAL allowed;

	switch (key) {
	    case -1:	/* set interpreter flags */
		allowed =
		    PARROT_DEBUG_FLAG |
		    PARROT_TRACE_FLAG |
		    PARROT_BOUNDS_FLAG |
		    PARROT_PROFILE_FLAG |
		    PARROT_GC_DEBUG_FLAG;
		Parrot_clear_flag(new_interp, allowed);
		Parrot_set_flag(new_interp, val & allowed);
		break;
	}
    }

    /*
     * First attempt to make things running, and to see, where problmes
     * may arise.
     * Only minimal items are done yet
     */
    void clone(PMC* dest) {
	Parrot_Interp s = PMC_data(SELF);
	Parrot_Interp d;

	VTABLE_init(INTERP, dest);
	d = PMC_data(dest);
	/*
	 * first a sanity check
	 */
	if (d->parent_interpreter != s)
	    internal_exception(1, "Wrong parent interpreter");

	/*
	 * copy register files
	 */
	clone_regs(d, s, dest);
	/*
	 * copy over packfile - done currently in the runinterp opcode
	 * for multi-threading we have to generate separate
	 * profile, prederef, and JIT data
	 */
	/*
	 * set flags and run core
	 */
	d->run_core = s->run_core;
	d->flags = s->flags;
    }
}
