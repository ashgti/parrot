/* parrotinterpreter.pmc
 *  Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the ParrotInterpreter base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *     getinterp P0
 *     set P1, P0[.IGLOBALS_*]	# access interpreter globals
 *     set I0, P0[x]		# interpinfo I0, x
 *     set I0, P0[-1]		# get interpreter flags
 *     set P0[-1], x		# set flags on interpreter
 *                              # NOTE: this doesn't restart
 *  References:
 */

#include "parrot/parrot.h"
#include "parrot/embed.h"

/*
 * copy / clone interpreter registers
 * all resources are created in the destination interpreter
 */
static void
clone_regs(Parrot_Interp d, Parrot_Interp s, PMC *dest)
{
    int i;
    mem_sys_memcopy(d->int_reg.registers,
	    s->int_reg.registers, sizeof(struct IReg));
    mem_sys_memcopy(d->num_reg.registers,
	    s->num_reg.registers, sizeof(struct NReg));
    for (i = 0; i < NUM_REGISTERS; i++) {
	if (s->string_reg.registers[i])
	    d->string_reg.registers[i] =
		string_copy(d, s->string_reg.registers[i]);
	/*
	 * clone PMCS - ignore the shared case for now
	 */
	if (!PMC_IS_NULL(s->pmc_reg.registers[i])) {
	    PMC *sp = s->pmc_reg.registers[i];
	    /* special case, dont clone SELF again - ugly */
	    if (sp->vtable->base_type == enum_class_ParrotInterpreter &&
		    PMC_data(sp) == s)
		d->pmc_reg.registers[i] = dest;
	    else {
		PMC *dp = pmc_new_noinit(d, sp->vtable->base_type);
		VTABLE_clone(d, sp, dp);
		d->pmc_reg.registers[i] = dp;
	    }
	}
    }
}

pmclass ParrotInterpreter need_ext {

    void init () {
	struct Parrot_Interp *new_interp;
	new_interp = make_interpreter(INTERP, 0);
	PMC_data(SELF) = new_interp;
	SELF->cache.struct_val = NULL;
    }

    void set_pointer (void* value) {
	SELF->cache.struct_val = value;
    }

    void* get_pointer () {
	return SELF->cache.struct_val;
    }

    void* invoke (void* next) {
	struct Parrot_Interp * new_interp =
	    (struct Parrot_Interp *)PMC_data(SELF);
	Interp_flags_SET(new_interp, PARROT_EXTERN_CODE_FLAG);
	new_interp->code = interpreter->code;
	/* calculate offset */
	runops(new_interp, (opcode_t *)SELF->cache.struct_val -
			(opcode_t *)interpreter->code->byte_code);
	return next;
    }

    PMC* get_pmc_keyed_int(INTVAL key) {
	struct Parrot_Interp * new_interp =
	    (struct Parrot_Interp *)PMC_data(SELF);
	if (key >= 0 && key < IGLOBALS_SIZE)
	    return VTABLE_get_pmc_keyed_int(new_interp,
		    new_interp->iglobals, key);
	return NULL;
    }

    INTVAL get_integer_keyed_int(INTVAL key) {
	struct Parrot_Interp * new_interp =
	    (struct Parrot_Interp *)PMC_data(SELF);
	switch (key) {
	    case -1:
		return (INTVAL) new_interp->flags;
	    default:
		return interpinfo(new_interp, key);
	}
    }

    void set_integer_keyed_int(INTVAL key, INTVAL val) {
	struct Parrot_Interp * new_interp =
	    (struct Parrot_Interp *)PMC_data(SELF);
	INTVAL allowed;

	switch (key) {
	    case -1:	/* set interpreter flags */
		allowed =
		    PARROT_DEBUG_FLAG |
		    PARROT_TRACE_FLAG |
		    PARROT_BOUNDS_FLAG |
		    PARROT_PROFILE_FLAG |
		    PARROT_GC_DEBUG_FLAG;
		Parrot_clear_flag(new_interp, allowed);
		Parrot_set_flag(new_interp, val & allowed);
		break;
	}
    }

    /*
     * First attempt to make things running, and to see, where problmes
     * may arise.
     * Only minimal items are done yet
     */
    void clone(PMC* dest) {
	Parrot_Interp s = PMC_data(SELF);
	Parrot_Interp d;

	VTABLE_init(INTERP, dest);
	d = PMC_data(dest);
	/*
	 * first a sanity check
	 */
	if (d->parent_interpreter != s)
	    internal_exception(1, "Wrong parent interpreter");

	/*
	 * copy register files
	 */
	clone_regs(d, s, dest);
	/*
	 * copy over packfile - done currently in the runinterp opcode
	 * for multi-threading we have to generate separate
	 * profile, prederef, and JIT data
	 */
	/*
	 * set flags and run core
	 */
	d->run_core = s->run_core;
	d->flags = s->flags;
    }
}
