/* boolean.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the Boolean base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"
#include "parrot/perltypes.h"

pmclass Boolean extends PerlInt {


    STRING* name() {
        return whoami;
    }

    void set_integer (PMC* value) {
    /* XXX change type on set_xx? */
        SELF->cache.int_val = (VTABLE_get_integer(INTERP, value) != 0);
    }

    void set_integer_native (INTVAL value) {
        SELF->cache.int_val = (value != 0);
    }

    void set_integer_same (PMC * value) {
        SELF->cache.int_val = value->cache.int_val;
    }

    void set_number (PMC * value) {
	SELF->cache.int_val = (value!=0);
    }

    void set_number_native (FLOATVAL value) {
	SELF->cache.int_val = (value!=0);
    }

    void set_number_same (PMC * value) {
	SELF->cache.int_val = value->cache.int_val;
    }

    void set_string (PMC* value) {
	SELF->cache.int_val = string_bool(value->data);
    }

    void set_string_native (STRING* value) {
	SELF->cache.int_val = string_bool(value);
    }

    void set_string_same (PMC* value) {
	SELF->cache.int_val = string_bool(value->data);
    }


    void neg (PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest, !SELF->cache.int_val);
    }


    void logical_or (PMC* value, PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest,
					 SELF->cache.int_val ||
					 VTABLE_get_bool(INTERP, value)
	    );
    }

    void logical_and (PMC* value, PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest,
					 SELF->cache.int_val &&
					 VTABLE_get_bool(INTERP, value)
	    );
    }

    void logical_xor (PMC* value, PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest,
            ( SELF->cache.int_val ? 1 : 0 ) ^
					 VTABLE_get_bool(INTERP, value)
	    );
    }


}
