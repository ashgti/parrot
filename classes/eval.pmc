/* Eval.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for evaluating a code segment
 *  Data Structure and Algorithms:
 *  History:
 *     Initial version by leo 2003/01/16
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"
#include "parrot/runops_cores.h"
#include "parrot/interp_guts.h"
#include "parrot/packfile.h"

pmclass Eval extends Closure {

   STRING* name () {
	return whoami;
   }

   void* invoke (void* next) {
       struct PackFile_ByteCode *old_cs;
       struct PackFile_ByteCode *eval_cs = (struct PackFile_ByteCode *)
	   SUPER(next);	/* invoke on Sub returns the address */

       /* return address that the interpreter should jump to */
       stack_push(INTERP, &(INTERP->ctx.control_stack), next,
	       STACK_ENTRY_DESTINATION, STACK_CLEANUP_NULL);
       /* switch to code segment */
       old_cs = Parrot_switch_to_cs(interpreter, eval_cs);
       if (Interp_flags_TEST(interpreter, PARROT_TRACE_FLAG)) {
	   PIO_eprintf(interpreter, "*** invoking %s\n",
		   eval_cs->base.name);
       }
       runops_int(interpreter, 0);
       if (Interp_flags_TEST(interpreter, PARROT_TRACE_FLAG)) {
	   PIO_eprintf(interpreter, "*** back from %s\n",
		   eval_cs->base.name);
       }
       /* restore ctx */
       interpreter->ctx.pad_stack =
	       ((struct Parrot_Closure*) PMC_data(SELF))->ctx.pad_stack;
       /* if code jumped to different code segment, go out of runloop
	* which then actually will switch segments */
       if (interpreter->resume_flag & 2)
	   next = 0;
       else
	   (void)Parrot_switch_to_cs(interpreter, old_cs);
       return next;
   }
}
