/*
Copyright: 2004 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/complex.pmc - Complex Numbers PMC Class

=head1 DESCRIPTION

C<Complex> provides a representation of complex numbers. It handles
string parsing/generating and basic mathematical operations.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"


#define RE(obj) (((FLOATVAL*)PMC_struct_val(obj))[0])
#define IM(obj) (((FLOATVAL*)PMC_struct_val(obj))[1])


/*

=item C<static void
complex_parse_string (Parrot_Interp interp,
        FLOATVAL *re, FLOATVAL *im, STRING *value)>

Parses the string in C<value> to produce a complex number, represented by the real
(C<*re>) and imaginary (C<*im>) parts. Raises an exception if it cannot understand
the string.
The string should be of the form C<a+bi> with optional spaces around C<+> and before C<i>. You can also use C<j> instead of C<i>.

=cut

*/

static void
complex_parse_string (Parrot_Interp interp,
        FLOATVAL *re, FLOATVAL *im, STRING *value) {
    char *str;
    INTVAL first_num_length, second_num_length;
    INTVAL first_num_minus, second_num_minus, i;
    char *first_num_offset, *second_num_offset, *t;
    STRING *S;

    t = str = string_to_cstring(interp, value);
    i = 0;
    first_num_offset = str;
    first_num_minus = second_num_minus = 0;

    /* walk the string and identify the real and imaginary parts */

    if(*t == '-') {
        /* first number is negative */
        t++;
        first_num_minus = 1;
        if(*t == ' ') t++; /* allow for an optional space */
        first_num_offset = t;
    }
    while(*t >= '0' && *t <= '9') t++; /* skip digits */
    if(*t == '.') {
        /* this number has a decimal point */
        t++;
        while(*t >= '0' && *t <= '9') t++; /* skip digits */
    }
    /* save the length of the real part */
    first_num_length = t - first_num_offset;

    if(*t == 0) {
        /* end of string; we only have a real part */
        second_num_length = 0;
    }
    else if( (*t == 'i' || *t == 'j') && *(t+1) == 0 ) {
        /* there is only an imaginary part, so the first number was
            actually the imaginary part */
        second_num_length = first_num_length;
        first_num_length = 0;
        second_num_offset = first_num_offset;
        second_num_minus = first_num_minus;
        /* this is useful if there is no number for
            the imaginary part, like in "-i" */
        i = 1;
    }
    else {
        if(*t == ' ') t++; /* skip an optional space */
        /* expect "+" or "-" and the imaginary part */
        if(*t == '+' || *t == '-') {
            second_num_minus = (*t == '-'); /* save the sign */
            t++;
            if(*t == ' ') t++; /* skip another optional space */

            /* save the beginning of the imaginary part */
            second_num_offset = t;
            while(*t >= '0' && *t <= '9') t++; /* skip digits */
            if(*t == '.') {
                /* this number has a decimal point */
                t++;
                while(*t >= '0' && *t <= '9') t++; /* skip digits */
            }
            /* save the length of the imaginary part */
            second_num_length = t - second_num_offset;

            if(*t == ' ') t++; /* allow for one more optional space */

            /* verify that the string ends properly */
            if( (*t != 'i' && *t != 'j') || (*(t+1) != 0) ) {
                /* imaginary part does not end in 'i' or 'j' */
                internal_exception(INVALID_STRING_REPRESENTATION,
                    "Complex: malformed string\n");
                first_num_length = second_num_length = 0;
            }
            /* this is useful if there is no number for the
                imaginary part, like in "2+i" */
            i = 1;

            /* all is OK, save the number */
        }
        else {
            /* "+" or "-" not found: error */
            internal_exception(INVALID_STRING_REPRESENTATION,
                "Complex: malformed string\n");
            first_num_length = second_num_length = 0;
        }
    }

    /* now we have the offsets and the lengths;
        we turn them into float values */

    if(first_num_length) {
        /* there is a real part, interpret it */
        S = string_from_cstring(interp,
                first_num_offset, first_num_length);
        *re = string_to_num(interp, S);
    }
    else {
        /* consider the real part 0.0 */
        *re = 0.0;
    }

    if(second_num_length) {
        /* there is an imaginary part, interpret it */
        S = string_from_cstring(interp,
                second_num_offset, second_num_length);
        *im = string_to_num(interp, S);
    }
    else {
        /* consider the imaginary part 0.0 */
        if(i) /* the string was something like "1+i" */
            *im = 1.0;
        else
            *im = 0.0;
    }
    if(first_num_minus) *re = - *re;
    if(second_num_minus) *im = - *im;

    string_cstring_free(str);
}

/*

=item C<static FLOATVAL*
complex_locate_keyed_num(Parrot_Interp interp, PMC* self, STRING *key)>

Interpret the string C<key>; valid keys are C<real> and C<imag>,
representing the real and imaginary parts of the complex number.

=cut

*/

static FLOATVAL*
complex_locate_keyed_num(Parrot_Interp interp, PMC* self, STRING *key) {
    /* do imag first since real can be read much faster anyway */
    STRING *imag = string_from_cstring(interp, "imag", 4);
    STRING *real;

    if(0 == string_equal(interp, key, imag))
        return &IM(self);
    real = string_from_cstring(interp, "real", 4);
    if(0 == string_equal(interp, key, real))
        return &RE(self);
    internal_exception(KEY_NOT_FOUND,
        "Complex: key is neither 'real' or 'imag'\n");
    return NULL;
}

pmclass Complex {

/*

=back

=head2 Methods

=over 4

=item C<void init()>

Initializes the complex number with the value 0+0i.

=item C<void init_pmc (PMC* initializer)>

Initializes the complex number with the specified values.
(not implemented)

=item C<void destroy ()>

Cleans up.

=item C<PMC* clone ()>

Creates an identical copy of the complex number.

=cut

*/

    void init () {
        /* XXX should check if mem_sys_allocate failed */
        FLOATVAL* data = (FLOATVAL*)mem_sys_allocate(2 * sizeof(FLOATVAL));
        PMC_struct_val(SELF) = data;
        PObj_active_destroy_SET(SELF);
        RE(SELF) = IM(SELF) = 0.0;
    }

    void init_pmc (PMC* initializer) {
        /* XXX not implemented */
        DYNSELF.init();
    }

    void destroy () {
        mem_sys_free(PMC_struct_val(SELF));
    }

    void morph (INTVAL type) {
        if (SELF->vtable->base_type == type)
            return;
        SUPER(type);
    }

    PMC* clone () {
        PMC* dest = pmc_new_noinit(INTERP, SELF->vtable->base_type);
        FLOATVAL* data = (FLOATVAL*)mem_sys_allocate(2 * sizeof(FLOATVAL));
        PMC_struct_val(dest) = data;
        PObj_active_destroy_SET(dest);
        RE(dest) = RE(SELF);
        IM(dest) = IM(SELF);
        return dest;
    }

/*

=item C<INTVAL get_integer ()>

Returns the modulus of the complex number as an integer.

=item C<FLOATVAL get_number ()>

Returns the modulus of the complex number.

=item C<STRING* get_string ()>

Returns the complex number as a string in the form C<a+bi>.

=item C<INTVAL get_bool ()>

Returns true if the complex number is non-zero.

=cut

*/

    INTVAL get_integer () {
        return (INTVAL)(DYNSELF.get_number());
    }

    FLOATVAL get_number () {
        /* XXX calculate modulus */
        return (FLOATVAL)0;
    }

    STRING* get_string () {
        STRING *s;
        if(IM(SELF) >= 0)
            s = Parrot_sprintf_c(INTERP,
                    "%vg+%vgi", RE(SELF), IM(SELF));
        else
            s = Parrot_sprintf_c(INTERP,
                    "%vg-%vgi", RE(SELF), -IM(SELF));
        return s;
    }

    INTVAL get_bool () {
        return (INTVAL)(RE(SELF) != 0.0 || IM(SELF) != 0.0);
    }

/*

=item C<INTVAL get_integer_keyed (PMC* key)>

=item C<INTVAL get_integer_keyed_str (STRING* key)>

=item C<FLOATVAL get_number_keyed (PMC* key)>

=item C<FLOATVAL get_number_keyed_str (STRING* key)>

=item C<PMC* get_pmc_keyed (PMC* key)>

=item C<PMC* get_pmc_keyed_str (STRING* key)>

Returns the requested number (real part for C<real> and imaginary for C<imag>).

=cut

*/

    INTVAL get_integer_keyed (PMC* key) {
        STRING* s = VTABLE_get_string(INTERP, key);
        return DYNSELF.get_integer_keyed_str(s);
    }

    INTVAL get_integer_keyed_str (STRING* key) {
        return (INTVAL)(DYNSELF.get_number_keyed_str(key));
    }

    FLOATVAL get_number_keyed (PMC* key) {
        STRING* s = VTABLE_get_string(INTERP, key);
        return DYNSELF.get_number_keyed_str(s);
    }

    FLOATVAL get_number_keyed_str (STRING* key) {
        FLOATVAL *num = complex_locate_keyed_num(INTERP, SELF, key);
        if(num)
            return *num;
        return 0.0;
    }

    PMC* get_pmc_keyed (PMC* key) {
        STRING* s = VTABLE_get_string(INTERP, key);
        return DYNSELF.get_pmc_keyed_str(s);
    }

    PMC* get_pmc_keyed_str (STRING* key) {
        PMC *ret;
        FLOATVAL val;

        ret = pmc_new(INTERP, enum_class_Float);
        val = DYNSELF.get_number_keyed_str(key);
        VTABLE_set_number_native(INTERP, ret, val);
        return ret;
    }

/*

=item C<void set_string_native (STRING* value)>

Parses the string C<value> into a complex number; raises an exception on failure.

=item C<void set_pmc (PMC* value)>

if C<value> is a Complex PMC then the complex number is set to its value; otherwise
C<value>'s string representation is parsed with C<set_string_native()>.

=item C<void set_integer_native (INTVAL value)>

=item C<void set_number_native (FLOATVAL value)>

Sets the real part of the complex number to C<value> and the imaginary
part to C<0.0>

=cut

*/

    void set_string_native (STRING* value) {
        complex_parse_string(INTERP, &RE(SELF), &IM(SELF), value);
    }

    void set_pmc (PMC* value) {
        if(value->vtable->base_type == enum_class_Complex) {
            RE(SELF) = RE(value);
            IM(SELF) = IM(value);
        }
        else {
            DYNSELF.set_string_native(VTABLE_get_string(INTERP, value));
        }
    }

    void set_integer_native (INTVAL value) {
        DYNSELF.set_number_native(value);
    }

    void set_number_native (FLOATVAL value) {
        RE(SELF) = value;
        IM(SELF) = 0.0;
    }

/*

=item C<void set_integer_keyed (PMC* key, INTVAL value)>

=item C<void set_integer_keyed_str (STRING* key, INTVAL value)>

=item C<void set_number_keyed (PMC* key, FLOATVAL value)>

=item C<void set_number_keyed_str (STRING* key, FLOATVAL value)>

=item C<void set_pmc_keyed (PMC* key, PMC* value)>

=item C<void set_pmc_keyed_str (STRING* key, PMC* value)>

Sets the requested number (real part for C<real> and imaginary for C<imag>)
to C<value>.

=cut

*/

    void set_integer_keyed (PMC* key, INTVAL value) {
        DYNSELF.set_number_keyed(key, value);
    }

    void set_integer_keyed_str (STRING* key, INTVAL value) {
        DYNSELF.set_number_keyed_str(key, value);
    }

    void set_number_keyed (PMC* key, FLOATVAL value) {
        STRING* s = VTABLE_get_string(INTERP, key);
        DYNSELF.set_number_keyed_str(s, value);
    }

    void set_number_keyed_str (STRING* key, FLOATVAL value) {
        FLOATVAL *num = complex_locate_keyed_num(INTERP, SELF, key);
        if(num)
            *num = value;
    }

    void set_pmc_keyed (PMC* key, PMC* value) {
        FLOATVAL f = VTABLE_get_number(INTERP, value);
        DYNSELF.set_number_keyed(key, f);
    }

    void set_pmc_keyed_str (STRING* key, PMC* value) {
        FLOATVAL f = VTABLE_get_number(INTERP, value);
        DYNSELF.set_number_keyed_str(key, f);
    }

/*

=item C<void add (PMC* value, PMC* dest)>

=item C<void add_int (INTVAL value, PMC* dest)>

=item C<void add_float (FLOATVAL value, PMC* dest)>

Adds C<value> to the complex number, placing the result in C<dest>.

=cut

*/

    void add (PMC* value, PMC* dest) {
        VTABLE_morph(INTERP, dest, enum_class_Complex);
        RE(dest) = RE(SELF) + RE(value);
        IM(dest) = IM(SELF) + IM(value);
    }

    void add_int (INTVAL value, PMC* dest) {
        VTABLE_morph(INTERP, dest, enum_class_Complex);
        RE(dest) = RE(SELF) + value;
        IM(dest) = IM(SELF);
    }

    void add_float (FLOATVAL value, PMC* dest) {
        VTABLE_morph(INTERP, dest, enum_class_Complex);
        RE(dest) = RE(SELF) + value;
        IM(dest) = IM(SELF);
    }

/*

=item C<void subtract (PMC* value, PMC* dest)>

=item C<void subtract_int (INTVAL value, PMC* dest)>

=item C<void subtract_float (FLOATVAL value, PMC* dest)>

Subtracts C<value> from the complex number, placing the result in C<dest>.

=cut

*/

    void subtract (PMC* value, PMC* dest) {
        VTABLE_morph(INTERP, dest, enum_class_Complex);
        RE(dest) = RE(SELF) - RE(value);
        IM(dest) = IM(SELF) - IM(value);
    }

    void subtract_int (INTVAL value, PMC* dest) {
        VTABLE_morph(INTERP, dest, enum_class_Complex);
        RE(dest) = RE(SELF) - value;
        IM(dest) = IM(SELF);
    }

    void subtract_float (FLOATVAL value, PMC* dest) {
        VTABLE_morph(INTERP, dest, enum_class_Complex);
        RE(dest) = RE(SELF) - value;
        IM(dest) = IM(SELF);
    }

/*

=item C<void multiply (PMC* value, PMC* dest)>

=item C<void multiply_int (INTVAL value, PMC* dest)>

=item C<void multiply_float (FLOATVAL value, PMC* dest)>

Multiplies the complex number with C<value>, placing the result in C<dest>.

=cut

*/

    void multiply (PMC* value, PMC* dest) {
        FLOATVAL re = RE(SELF) * RE(value) - IM(SELF) * IM(value);
        FLOATVAL im = IM(SELF) * RE(value) + RE(SELF) * IM(value);
        VTABLE_morph(INTERP, dest, enum_class_Complex);
        RE(dest) = re;
        IM(dest) = im;
    }

    void multiply_int (INTVAL value, PMC* dest) {
        VTABLE_morph(INTERP, dest, enum_class_Complex);
        RE(dest) = RE(SELF) * value;
        IM(dest) = IM(SELF) * value;
    }

    void multiply_float (FLOATVAL value, PMC* dest) {
        VTABLE_morph(INTERP, dest, enum_class_Complex);
        RE(dest) = RE(SELF) * value;
        IM(dest) = IM(SELF) * value;
    }

/*

=item C<void divide (PMC* value, PMC* dest)>

=item C<void divide_int (INTVAL value, PMC* dest)>

=item C<void divide_float (FLOATVAL value, PMC* dest)>

Divide the complex number by C<value>, placing the result in C<dest>.

=cut

*/

    void divide (PMC* value, PMC* dest) {
        FLOATVAL mod, re, im;

        VTABLE_morph(INTERP, dest, enum_class_Complex);
        /* a little speed optimisation: cache an intermediate number;
            i'm not sure the compiler does this */
        mod = (RE(value) * RE(value) + IM(value) * IM(value));

        re = (RE(SELF) * RE(value) + IM(SELF) * IM(value)) / mod;

        im = (IM(SELF) * RE(value) - RE(SELF) * IM(value)) / mod;

        RE(dest) = re;
        IM(dest) = im;
    }

    void divide_int (INTVAL value, PMC* dest) {
        VTABLE_morph(INTERP, dest, enum_class_Complex);
        RE(dest) = RE(SELF) / value;
        IM(dest) = IM(SELF) / value;
    }

    void divide_float (FLOATVAL value, PMC* dest) {
        VTABLE_morph(INTERP, dest, enum_class_Complex);
        RE(dest) = RE(SELF) / value;
        IM(dest) = IM(SELF) / value;
    }

/*

=item C<INTVAL is_equal (PMC* value)>

Compares the complex number with C<value> and returs true if they are equal.

=cut

*/

    INTVAL is_equal (PMC* value) {
        if(value->vtable->base_type == enum_class_Complex)
            return (INTVAL)(
                    RE(SELF) == RE(value) &&
                    IM(SELF) == IM(value)
                );
        if(IM(SELF) != 0.0)
            return (INTVAL)0;
        return (RE(SELF) == VTABLE_get_number(INTERP, value));
    }

}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
