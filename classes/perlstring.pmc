/* perlstring.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the PerlString base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"
#include "parrot/perltypes.h"

pmclass PerlString {

    void init () {
        SELF->data = string_make(INTERP,NULL,0,NULL,0,NULL);
        SELF->flags = PMC_is_buffer_ptr_FLAG;
    }

    void morph (INTVAL type) {
    }

    INTVAL type () {
        return SELF->vtable->base_type;
    }

    STRING* name() {
        return whoami;
    }

    PMC* clone () {
        PMC* dest;
        dest = pmc_new(INTERP, enum_class_PerlString);
        dest->vtable = SELF->vtable;
	dest->flags = PMC_is_buffer_ptr_FLAG;
        dest->data = string_copy(INTERP,SELF->data);
        return dest;
    }

    void destroy () {
        string_destroy(SELF->data);
    }

    INTVAL get_integer () {
        STRING* s = (STRING*) SELF->data;
        return string_to_int(s);
    }

    FLOATVAL get_number () {
        STRING* s = (STRING*) SELF->data;
        return string_to_num(s);
    }
    
    BIGNUM* get_bignum () {
        /* XXX */
        return NULL;
    }

    STRING* get_string () {
        return (STRING*)SELF->data;
    }

    INTVAL get_bool () {
        return string_bool(SELF->data);
    }

    INTVAL is_same (PMC* other) {
        STRING* s1 = (STRING*)SELF->data;
        STRING* s2 = (STRING*)other->data;
        return (INTVAL)( other->vtable == SELF->vtable &&
                          s1->bufused   == s2->bufused  &&
            (memcmp(s1->bufstart,s2->bufstart,(size_t)s1->bufused)==0));
    }

    void set_integer (PMC* value) {
	CHANGE_TYPE(SELF, PerlInt);
        SELF->cache.int_val = value->vtable->get_integer(INTERP,value);
    }

    void set_integer_native (INTVAL value) {
	CHANGE_TYPE(SELF, PerlInt);
        SELF->cache.int_val = value;
    }

    void set_integer_bignum (BIGNUM* value) {
    }

    void set_integer_same (PMC* value) {
	CHANGE_TYPE(SELF, PerlInt);
        SELF->cache.int_val = value->vtable->get_integer(INTERP,value);
    }

    void set_number (PMC * value) {
	CHANGE_TYPE(SELF, PerlNum);
        SELF->cache.num_val = value->vtable->get_number(INTERP,value);
    }

    void set_number_native (FLOATVAL value) {
	CHANGE_TYPE(SELF, PerlNum);
        SELF->cache.num_val = value;
    }

    void set_number_bignum (BIGNUM* value) {
    }

    void set_number_same (PMC * value) {
	CHANGE_TYPE(SELF, PerlNum);
        SELF->cache.num_val = (FLOATVAL)value->cache.int_val;
    }

    void set_string (PMC * value) {
        SELF->data = string_copy(INTERP, (STRING*)value->data);
    }

    void set_string_native (STRING * value) {
        SELF->data = string_copy(INTERP, value);
    }

    void set_string_unicode (STRING * value) {
        SELF->data = string_copy(INTERP, value);
    }

    void set_string_other (STRING * value) {
        SELF->data = string_copy(INTERP, value);
    }

    void set_string_same (PMC * value) {
        SELF->data = string_copy(INTERP, (STRING*)value->data);
    }

    void add (PMC * value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
	    CHANGE_TYPE(dest, PerlInt);
            dest->vtable->set_integer_native(INTERP, dest, 
                SELF->vtable->get_integer(INTERP, SELF) +
                value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
	    CHANGE_TYPE(dest, PerlNum);
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->vtable->get_number(INTERP, SELF) +
                value->cache.num_val
            );
        }
        else {
        }
    }

    void add_int (INTVAL value, PMC* dest) {
	CHANGE_TYPE(dest, PerlInt);
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) +
            value
        );
    }

    void add_bignum (BIGNUM* value, PMC* dest) {
    }

    void add_float (FLOATVAL value, PMC* dest) {
	CHANGE_TYPE(dest, PerlNum);
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->vtable->get_number(INTERP, SELF) +
            value
        );
    }

    void add_same (PMC* value, PMC* dest) {
    }

    void subtract (PMC* value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
	    CHANGE_TYPE(dest, PerlInt);
            dest->vtable->set_integer_native(INTERP, dest, 
                SELF->vtable->get_integer(INTERP, SELF) -
                value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
	    CHANGE_TYPE(dest, PerlNum);
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->vtable->get_number(INTERP, SELF) -
                value->cache.num_val
            );
        }
        else {
        }
    }

    void subtract_int (INTVAL value, PMC* dest) {
	CHANGE_TYPE(dest, PerlInt);
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) -
            value
        );
    }

    void subtract_bignum (BIGNUM* value, PMC* dest) {
    }

    void subtract_float (FLOATVAL value, PMC* dest) {
	CHANGE_TYPE(dest, PerlNum);
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->vtable->get_number(INTERP, SELF) -
            value
        );
    }

    void subtract_same (PMC* value, PMC* dest) {
    }

    void multiply (PMC* value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
	    CHANGE_TYPE(dest, PerlInt);
            dest->vtable->set_integer_native(INTERP, dest, 
                SELF->vtable->get_integer(INTERP, SELF) *
                value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
	    CHANGE_TYPE(dest, PerlNum);
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->vtable->get_number(INTERP, SELF) *
                value->cache.num_val
            );
        }
        else {
        }
    }

    void multiply_int (INTVAL value, PMC* dest) {
	CHANGE_TYPE(dest, PerlInt);
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) *
            value
        );
    }

    void multiply_bignum (BIGNUM* value, PMC* dest) {
    }

    void multiply_float (FLOATVAL value, PMC* dest) {
	CHANGE_TYPE(dest, PerlNum);
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->vtable->get_number(INTERP, SELF) *
            value
        );
    }

    void multiply_same (PMC* value, PMC* dest) {
    }

    void divide (PMC* value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
	    CHANGE_TYPE(dest, PerlInt);
            dest->vtable->set_integer_native(INTERP, dest, 
                SELF->vtable->get_integer(INTERP, SELF) /
                value->cache.int_val
            );
        }
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
	    CHANGE_TYPE(dest, PerlNum);
            dest->vtable->set_number_native(INTERP, dest, 
                SELF->vtable->get_number(INTERP, SELF) /
                value->cache.num_val
            );
        }
        else {
        }
    }

    void divide_int (INTVAL value, PMC* dest) {
	CHANGE_TYPE(dest, PerlInt);
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) /
            value
        );
    }

    void divide_bignum (BIGNUM* value, PMC* dest) {
    }

    void divide_float (FLOATVAL value, PMC* dest) {
	CHANGE_TYPE(dest, PerlNum);
        dest->vtable->set_number_native(INTERP, dest, 
            SELF->vtable->get_number(INTERP, SELF) /
            value
        );
    }

    void divide_same (PMC* value, PMC* dest) {
    }

    void modulus (PMC* value, PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
	    CHANGE_TYPE(dest, PerlInt);
            dest->vtable->set_integer_native(INTERP, dest, 
                SELF->vtable->get_integer(INTERP, SELF) %
                value->cache.int_val
            );
        }
        else {
        }
    }

    void modulus_int (INTVAL value, PMC* dest) {
	CHANGE_TYPE(dest, PerlInt);
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) %
            value
        );
    }

    void modulus_bignum (BIGNUM* value, PMC* dest) {
    }

    void modulus_float (FLOATVAL value, PMC* dest) {
    }

    void modulus_same (PMC* value, PMC* dest) {
    }

    void bitwise_or (PMC* value, PMC* dest) {
	CHANGE_TYPE(dest, PerlInt);
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) |
            value->vtable->get_integer(INTERP, value)
        );
    }    

    void bitwise_or_int (INTVAL value, PMC* dest) {
	CHANGE_TYPE(dest, PerlInt);
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) |
            value
        );
    }    

    void bitwise_or_same (PMC* value, PMC* dest) {
	CHANGE_TYPE(dest, PerlInt);
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) |
            value->vtable->get_integer(INTERP, value)
        );
    }    

    void bitwise_and (PMC* value, PMC* dest) {
	CHANGE_TYPE(dest, PerlInt);
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) &
            value->vtable->get_integer(INTERP, value)
        );
    }    

    void bitwise_and_int (INTVAL value, PMC* dest) {
	CHANGE_TYPE(dest, PerlInt);
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) &
            value
        );
    }    

    void bitwise_and_same (PMC* value, PMC* dest) {
	CHANGE_TYPE(dest, PerlInt);
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) &
            value->vtable->get_integer(INTERP, value)
        );
    }    

    void bitwise_xor (PMC* value, PMC* dest) {
	CHANGE_TYPE(dest, PerlInt);
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) ^
            value->vtable->get_integer(INTERP, value)
        );
    }    

    void bitwise_xor_int (INTVAL value, PMC* dest) {
	CHANGE_TYPE(dest, PerlInt);
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) ^
            value
        );
    }    

    void bitwise_xor_same (PMC* value, PMC* dest) {
	CHANGE_TYPE(dest, PerlInt);
        dest->vtable->set_integer_native(INTERP, dest, 
            SELF->vtable->get_integer(INTERP, SELF) ^
            value->vtable->get_integer(INTERP, value)
        );
    }
    
    void bitwise_not (PMC* dest) {
	CHANGE_TYPE(dest, PerlInt);
        dest->vtable->set_integer_native(INTERP, dest,
            ~SELF->vtable->get_integer(INTERP, SELF)
        );
    }

    void concatenate (PMC* value, PMC* dest) {
        STRING* s = string_copy(INTERP, (STRING*)SELF->data);
        dest->data =
            string_concat(INTERP,
                          s,
                          value->vtable->get_string(INTERP, value),
                          0
                         );
        /* don't destroy s, as it is dest->data */
    }

    void concatenate_native (STRING* value, PMC* dest) {
        STRING* s = string_copy(INTERP, (STRING*)SELF->data);
        dest->data =
            string_concat(INTERP,
                          s,
                          value,
                          0
                         );
        /* don't destroy s, as it is dest->data */
    }

    void concatenate_unicode (STRING* value, PMC* dest) {
        STRING* s = string_copy(INTERP, (STRING*)SELF->data);
        dest->data =
            string_concat(INTERP,
                          s,
                          value,
                          0
                         );
            /* don't destroy s, as it is dest->data */
    }

    void concatenate_other (STRING* value, PMC* dest) {
        STRING* s = string_copy(INTERP, (STRING*)SELF->data);
        dest->data =
            string_concat(INTERP,
                          s,
                          value,
                          0
                         );
        /* don't destroy s, as it is dest->data */
    }

    void concatenate_same (PMC* value, PMC* dest) {
        dest->data =
            string_concat(INTERP,
                          SELF->data,
                          value->data,
                          0
                         );
    }

    /* == operation */
    INTVAL is_equal (PMC* value) {
        return (INTVAL)( 0 == string_compare(INTERP,
                                             SELF->data,
                                             value->vtable->get_string(INTERP, value)
                                            ));
    }

    INTVAL cmp(PMC* value) {
        return string_compare(INTERP, SELF->data,
			      value->vtable->get_string(INTERP, value));
    }

    INTVAL cmp_num(PMC* value) {
	/* XXX: need to add this, but there's no way to get to it from
	 * Parrot assembly, so it can wait. */
        return 0;
    }

    void repeat (PMC* value, PMC* dest) {
	CHANGE_TYPE(dest, PerlString);
        dest->data =
           string_repeat(INTERP, SELF->data,
                         (UINTVAL)value->vtable->get_integer(INTERP, value), NULL
                        );
    }

    void repeat_int (INTVAL value, PMC* dest) {
	CHANGE_TYPE(dest, PerlString);
        dest->data = string_repeat(INTERP, SELF->data, (UINTVAL)value, NULL);
    }
    
    void increment () {
    }
    
    void decrement () {
    }

    void substr (INTVAL offset, INTVAL length, PMC* dest) {
	CHANGE_TYPE(dest, PerlString);
        dest->data = string_substr(INTERP, SELF->data, offset, length, NULL);
    }
    
    STRING* substr_str (INTVAL offset, INTVAL length) {
        return string_substr(INTERP, SELF->data, offset, length, NULL);
    }
}
