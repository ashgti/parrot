/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/perlstring.pmc - Perl String

=head1 DESCRIPTION

C<PerlString> extends C<perlscalar> to provide Perl string behaviour.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

void Parrot_perlscalar_morph(Interp* , PMC* pmc, INTVAL type);
void Parrot_perlscalar_set_pmc(Interp* , PMC* pmc, PMC* value);

pmclass PerlString extends String {


/*

=item C<STRING* get_repr()>

Returns pythons string repr (w/o any escaping, just single quotes around)

=cut

*/

    STRING* get_repr() {
        STRING *start, *s, *q, *repr;
        q = const_string(interpreter, "'");
        s = DYNSELF.get_string();
        if (PObj_get_FLAGS(s) & PObj_private7_FLAG)
            start = const_string(interpreter, "u'");
        else
            start = q;
        repr = string_copy(interpreter, start);
        repr = string_append(interpreter, repr, s, 0);
        repr = string_append(interpreter, repr, q, 0);
        return repr;
    }

/*

=item C<void set_integer_native(INTVAL value)>

Morphs the string to a C<PerlInt> and sets its value to C<value>.

=cut

*/

    void set_integer_native (INTVAL value) {
        DYNSELF.morph(enum_class_PerlInt);
        DYNSELF.set_integer_native(value);
    }

/*

=item C<void set_number_native(FLOATVAL value)>

Morphs the string to a C<PerlNum> and sets its value to C<value>.

=cut

*/

    void set_number_native (FLOATVAL value) {
        DYNSELF.morph(enum_class_PerlNum);
        DYNSELF.set_number_native(value);
    }


/*

=item C<void set_pmc(PMC *value)>

Sets the value of the number to the value in C<*value>.

=cut

*/

    void set_pmc (PMC* value) {
        perlscalar.SELF.set_pmc(value);
    }

/*

=item C<void morph(INTVAL type)>

Morphs the scalar to the specified type.

=cut

*/

    void morph (INTVAL type) {
        perlscalar.SELF.morph(type);
    }
/*

=item C<void add(PMC *value, PMC *dest)>

Adds C<*value> to the string and returns the result in C<*dest>.

=cut

*/

    void add (PMC * value, PMC* dest) {
MMD_PerlString: {
            /* work around MMD setup bug */
	     VTABLE_set_number_native(INTERP, dest,
		     VTABLE_get_number(INTERP, SELF) +
		     VTABLE_get_number(INTERP, value));
        }
MMD_PerlNum: {
	     VTABLE_set_number_native(INTERP, dest,
		     VTABLE_get_number(INTERP, SELF) +
		     PMC_num_val(value)
		     );
	 }
MMD_DEFAULT: {
	     FLOATVAL pmcf, valf;
	     INTVAL  pmci, vali;

	     pmcf = VTABLE_get_number(INTERP, SELF);
	     pmci = VTABLE_get_integer(INTERP, SELF);
	     valf = VTABLE_get_number(INTERP, value);
	     vali = VTABLE_get_integer(INTERP, value);

	     if (pmcf == pmci && valf == vali)
		 VTABLE_set_integer_native(INTERP, dest, pmci + vali);
	     else
		 VTABLE_set_number_native(INTERP, dest, pmcf + valf);
	 }
    }

/*

=item C<void subtract(PMC *value, PMC *dest)>

Subtracts C<*value> from the string and returns the result in C<*dest>.

=cut

*/

    void subtract (PMC* value, PMC* dest) {
        if(value->vtable == Parrot_base_vtables[enum_class_PerlInt]) {
            VTABLE_set_integer_native(INTERP, dest,
                VTABLE_get_integer(INTERP, SELF) -
                PMC_int_val(value)
            );
        }
        else if(value->vtable == Parrot_base_vtables[enum_class_PerlNum]) {
            VTABLE_set_number_native(INTERP, dest,
                VTABLE_get_number(INTERP, SELF) -
                PMC_num_val(value)
            );
        }
        else {
            SUPER(value, dest);
        }
    }

/*

=item C<void multiply(PMC *value, PMC *dest)>

Multiplies the string by C<*value> and returns the result in C<*dest>.

=cut

*/

    void multiply (PMC* value, PMC* dest) {
        if(value->vtable == Parrot_base_vtables[enum_class_PerlInt]) {
            VTABLE_set_integer_native(INTERP, dest,
                VTABLE_get_integer(INTERP, SELF) *
                PMC_int_val(value)
            );
        }
        else if(value->vtable == Parrot_base_vtables[enum_class_PerlNum]) {
            VTABLE_set_number_native(INTERP, dest,
                VTABLE_get_number(INTERP, SELF) *
                PMC_num_val(value)
            );
        }
        else {
            SUPER(value, dest);
        }
    }

/*

=item C<void divide(PMC *value, PMC *dest)>

Divides the string by C<*value> and returns the result in C<*dest>.

=cut

*/

    void divide (PMC* value, PMC* dest) {
        if(value->vtable == Parrot_base_vtables[enum_class_PerlInt]) {
            VTABLE_set_integer_native(INTERP, dest,
                VTABLE_get_integer(INTERP, SELF) /
                PMC_int_val(value)
            );
        }
        else if(value->vtable == Parrot_base_vtables[enum_class_PerlNum]) {
            VTABLE_set_number_native(INTERP, dest,
                VTABLE_get_number(INTERP, SELF) /
                PMC_num_val(value)
            );
        }
        else {
            SUPER(value, dest);
        }
    }

/*

=item C<void modulus(PMC *value, PMC *dest)>

Calculates the string C<mod> C<*value> and returns the result in
C<*dest>.

When Python mode is enabled does sprintf :(

=cut

*/

    void modulus (PMC* value, PMC* dest) {
        if (Interp_flags_TEST(INTERP, PARROT_PYTHON_MODE)) {
            PMC *ar = value;
            /*
             * SELF is formatstring, value = argument array or item
             */
            if (value->vtable->base_type != enum_class_FixedPMCArray) {
                /* not a tuple - make one */
                ar = pmc_new(INTERP, enum_class_FixedPMCArray);
                VTABLE_set_integer_native(INTERP, ar, 1);
                VTABLE_set_pmc_keyed_int( INTERP, ar, 0, value);
            }
            VTABLE_set_string_native(INTERP, dest,
                    Parrot_psprintf(INTERP, PMC_str_val(SELF), ar));
            return;
        }
        if (value->vtable == Parrot_base_vtables[enum_class_PerlInt]) {
            VTABLE_set_integer_native(INTERP, dest,
                    VTABLE_get_integer(INTERP, SELF) %
                    PMC_int_val(value)
                    );
        }
        else {
            internal_exception(INVALID_OPERATION,
                    "modulus() not implemented for PerlString\n");
        }
    }

/*

=item C<void increment()>

=item C<void decrement()>

These two methods are partially implemented. They should provide
Perl 5 like string increment/decrement.

=cut

*/

    void increment () {
        STRING* s = PMC_str_val(SELF);
	PMC_str_val(SELF) = string_increment(INTERP, s);
    }

    void decrement () {
        INTVAL i = VTABLE_get_integer(INTERP, SELF);
	VTABLE_set_integer_native(INTERP, SELF, i - 1);
    }


/*

=item C<PMC *get_pmc_keyed(PMC *key)>

Returns the string value for C<SELF[key]>.

=cut

*/

    PMC* get_pmc_keyed(PMC* key) {
        STRING *s = PMC_str_val(SELF);
        PMC *ret;

        if (key->vtable->base_type == enum_class_Slice)
            return Parrot_py_get_slice(INTERP, SELF, key);
        ret = pmc_new_noinit(INTERP, enum_class_PerlString);
        PMC_str_val(ret) = string_substr(INTERP, s,
                key_integer(INTERP,key), 1, NULL, 0);
        PObj_custom_mark_SET(ret);
        return ret;
    }

}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
