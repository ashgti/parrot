/* perlundef.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the perlundef base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"

pmclass PerlUndef {

   INTVAL type () {
   }

   STRING* name () {
        return whoami;
   }

   void init () {
        /* Nothing */
   }

   void clone (PMC* dest) {
        dest->vtable = pmc->vtable;
   }

   void morph (INTVAL type) {
   }

   BOOLVAL move_to (void * destination) {
        /* Nothing */
   }

   INTVAL real_size () {
        return 0;
   }

   void destroy () {
        /* Nothing */
   }

   INTVAL get_integer () {
      return 0;
   }

   INTVAL get_integer_index (INTVAL index) {
   }

   FLOATVAL get_number () {
      return 0;
   }

   FLOATVAL get_number_index (INTVAL index) {
      return 0;
   }

   STRING* get_string () {
      return string_make(INTERP,NULL,0,NULL,0,NULL);
   }

   STRING* get_string_index (INTVAL index) {
      return NULL;
   }

   BOOLVAL get_bool () {
      return 0;
   }

   void* get_value () {
      return NULL;
   }

   BOOLVAL is_same (PMC* pmc2) {
      return pmc2->vtable == pmc->vtable;
   }

   void set_integer (PMC * value) {
      pmc->vtable = &Parrot_base_vtables[enum_class_PerlInt];
      pmc->vtable->set_integer(interpreter, pmc, value);
   }

   void set_integer_native (INTVAL value) {
      pmc->vtable = &Parrot_base_vtables[enum_class_PerlInt];
      pmc->vtable->set_integer_native(interpreter, pmc, value);
   }

   void set_integer_bigint (BIGINT value) {
      pmc->vtable = &Parrot_base_vtables[enum_class_PerlInt];
      pmc->vtable->set_integer_bigint(interpreter, pmc, value);
   }

   void set_integer_same (PMC * value) {
      /* Do nothing; Can't happen? */ 
   }

   void set_integer_index (INTVAL value, INTVAL index) {
   }

   void set_number (PMC * value) {
      pmc->vtable = &Parrot_base_vtables[enum_class_PerlNum];
      pmc->vtable->set_number(interpreter, pmc, value);
   }

   void set_number_native (FLOATVAL value) {
      pmc->vtable = &Parrot_base_vtables[enum_class_PerlNum];
      pmc->vtable->set_number_native(interpreter, pmc, value);
   }

   void set_number_bigfloat (BIGFLOAT value) {
      pmc->vtable = &Parrot_base_vtables[enum_class_PerlNum];
      pmc->vtable->set_number_bigfloat(interpreter, pmc, value);
   }

   void set_number_same (PMC * value) {
      /* Do nothing; Can't happen? */ 
   }

   void set_number_index (FLOATVAL value, INTVAL index) {
   }

   void set_string (PMC * value) {
      pmc->vtable = &Parrot_base_vtables[enum_class_PerlString];
      pmc->vtable->set_string(interpreter, pmc, value);
   }

   void set_string_native (STRING * value) {
      pmc->vtable = &Parrot_base_vtables[enum_class_PerlString];
      pmc->vtable->set_string_native(interpreter, pmc, value);
   }

   void set_string_unicode (STRING * value) {
      pmc->vtable = &Parrot_base_vtables[enum_class_PerlString];
      pmc->vtable->set_string_unicode(interpreter, pmc, value);
   }

   void set_string_other (STRING * value) {
      pmc->vtable = &Parrot_base_vtables[enum_class_PerlString];
      pmc->vtable->set_string_other(interpreter, pmc, value);
   }

   void set_string_same (PMC * value) {
      /* Do nothing; Can't happen? */ 
   }

   void set_string_index (STRING * value, INTVAL index) {
   }

   void set_value (void* value) {
      /* Do nothing; Can't happen? */ 
   }

   void add (PMC * value,  PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlUndef]) {
	    dest->vtable->set_integer_native(INTERP, dest, 0);
	}
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
	    dest->vtable->set_integer(INTERP, dest, value);
	}
	else {
	    dest->vtable->set_number(INTERP, dest, value);
	}
   }

   void add_int (INTVAL value,  PMC* dest) {
	dest->vtable->set_integer_native(INTERP, dest, value);
   }

   void add_bigint (BIGINT value,  PMC* dest) {
   }

   void add_float (FLOATVAL value,  PMC* dest) {
	dest->vtable->set_number_native(INTERP, dest, value);
   }

   void add_bigfloat (BIGFLOAT value,  PMC* dest) {
   }

   void add_same (PMC * value,  PMC* dest) {
      dest->vtable->set_integer_native(INTERP, dest, 0);
   }

   void subtract (PMC * value,  PMC* dest) {
        if(value->vtable == &Parrot_base_vtables[enum_class_PerlUndef]) {
	    dest->vtable->set_integer_native(INTERP, dest, 0);
	}
        else if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
	    dest->vtable->set_integer_native(INTERP, dest,
		-value->vtable->get_integer(INTERP, value));
	}
	else {
	    dest->vtable->set_number_native(INTERP, dest,
		-value->vtable->get_number(INTERP, value));
	}
   }

   void subtract_int (INTVAL value,  PMC* dest) {
	dest->vtable->set_integer_native(INTERP, dest, -value);
   }

   void subtract_bigint (BIGINT value,  PMC* dest) {
   }

   void subtract_float (FLOATVAL value,  PMC* dest) {
	dest->vtable->set_number_native(INTERP, dest, -value);
   }

   void subtract_bigfloat (BIGFLOAT value,  PMC* dest) {
   }

   void subtract_same (PMC * value,  PMC* dest) {
	dest->vtable->set_integer_native(INTERP, dest, 0);
   }

   void multiply (PMC * value,  PMC* dest) {
	dest->vtable->set_integer_native(INTERP, dest, 0);
   }

   void multiply_int (INTVAL value,  PMC* dest) {
	dest->vtable->set_integer_native(INTERP, dest, 0);
   }

   void multiply_bigint (BIGINT value,  PMC* dest) {
	dest->vtable->set_integer_native(INTERP, dest, 0);
   }

   void multiply_float (FLOATVAL value,  PMC* dest) {
	dest->vtable->set_integer_native(INTERP, dest, 0);
   }

   void multiply_bigfloat (BIGFLOAT value,  PMC* dest) {
	dest->vtable->set_integer_native(INTERP, dest, 0);
   }

   void multiply_same (PMC * value,  PMC* dest) {
	dest->vtable->set_integer_native(INTERP, dest, 0);
   }

   void divide (PMC * value,  PMC* dest) {
	if(value->vtable == &Parrot_base_vtables[enum_class_PerlUndef]) {
		fprintf(stderr, "division by zero!\n");
		exit(1);
	}
	else if(value->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
	    if(value->vtable->get_integer(INTERP, value) == 0) {
		fprintf(stderr, "division by zero!\n");
		exit(1);
	    }
	}
	else if(value->vtable->get_number(INTERP, value) == 0) {
		fprintf(stderr, "division by zero!\n");
		exit(1);
	}

	dest->vtable->set_integer_native(INTERP, dest, 0);
   }

   void divide_int (INTVAL value,  PMC* dest) {
	if(value == 0) {
		fprintf(stderr, "division by zero!\n");
		exit(1);
	}
	dest->vtable->set_integer_native(INTERP, dest, 0);
   }

   void divide_bigint (BIGINT value,  PMC* dest) {
	/* need test for value == 0 */
	dest->vtable->set_integer_native(INTERP, dest, 0);
   }

   void divide_float (FLOATVAL value,  PMC* dest) {
	if(value == 0) {
		fprintf(stderr, "division by zero!\n");
		exit(1);
	}
	dest->vtable->set_integer_native(INTERP, dest, 0);
   }

   void divide_bigfloat (BIGFLOAT value,  PMC* dest) {
	/* need test for value == 0 */
	dest->vtable->set_integer_native(INTERP, dest, 0);
   }

   void divide_same (PMC * value,  PMC* dest) {
	fprintf(stderr, "division by zero!\n");
	exit(1);
   }

   void modulus (PMC * value,  PMC* dest) {
   }

   void modulus_int (INTVAL value,  PMC* dest) {
   }

   void modulus_bigint (BIGINT value,  PMC* dest) {
   }

   void modulus_float (FLOATVAL value,  PMC* dest) {
   }

   void modulus_bigfloat (BIGFLOAT value,  PMC* dest) {
   }

   void modulus_same (PMC * value,  PMC* dest) {
   }

   void concatenate (PMC * value,  PMC* dest) {
   }

   void concatenate_native (STRING * value,  PMC* dest) {
   }

   void concatenate_unicode (STRING * value,  PMC* dest) {
   }

   void concatenate_other (STRING * value,  PMC* dest) {
   }

   void concatenate_same (PMC * value,  PMC* dest) {
   }

   BOOLVAL is_equal (PMC* value) {
   }

   void logical_or (PMC* value,  PMC* dest) {
        dest->vtable->set_integer_native(INTERP, dest,
	    value->vtable->get_bool(INTERP, value));
   }

   void logical_and (PMC* value,  PMC* dest) {
        dest->vtable->set_integer_native(INTERP, dest, 0);
   }

   void logical_not (PMC* dest) {
        dest->vtable->set_integer_native(INTERP, dest, 1);
   }

   void match (PMC * value,  REGEX* re) {
   }

   void match_native (STRING * value,  REGEX* re) {
   }

   void match_unicode (STRING * value,  REGEX* re) {
   }

   void match_other (STRING * value,  REGEX* re) {
   }

   void match_same (PMC * value,  REGEX* re) {
   }

   void repeat (PMC * value,  PMC* dest) {
	dest->vtable = &Parrot_base_vtables[enum_class_PerlString];
	dest->cache.struct_val = string_make(INTERP, NULL,0,NULL,0, NULL);
   }

   void repeat_native (STRING * value,  PMC* dest) {
	dest->vtable = &Parrot_base_vtables[enum_class_PerlString];
	dest->cache.struct_val = string_make(INTERP, NULL,0,NULL,0, NULL);
   }

   void repeat_unicode (STRING * value,  PMC* dest) {
	dest->vtable = &Parrot_base_vtables[enum_class_PerlString];
	dest->cache.struct_val = string_make(INTERP, NULL,0,NULL,0, NULL);
   }

   void repeat_other (STRING * value,  PMC* dest) {
	dest->vtable = &Parrot_base_vtables[enum_class_PerlString];
	dest->cache.struct_val = string_make(INTERP, NULL,0,NULL,0, NULL);
   }

   void repeat_same (PMC * value,  PMC* dest) {
	dest->vtable = &Parrot_base_vtables[enum_class_PerlString];
	dest->cache.struct_val = string_make(INTERP, NULL,0,NULL,0, NULL);
   }

}
