/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/ - Parrot Object

=head1 DESCRIPTION

A Parrot Object is reasonably simple. It's data pointer points to an
array with the attributes of the object in it. The int cache value holds
the offset in that array of the first attribute, so we can front-load
the array with invisible options.

The array holds:

=over 4

=item 0

The first element of the attribute array is a pointer to the class PMC
for this object.

=item 1

The class name (taken from the class PMC)

=item 2...

Attributes.

=back

The object is actually constructed by the instantiation code in
F<src/objects.c>, at least for right now.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"


pmclass ParrotObject extends ParrotClass need_ext {

/*

=item C<void init()>

Raises an exception to make sure all users call C<new> on the registered
class PMC and not the ParrotObject itself.

During C<Parrot_class_register()> this C<init()> method gets replaced by
C<Parrot_instantiate_object()>.

=cut

*/

    void init() {
        internal_exception(1, "Can't create new ParrotObjects\n",
            "use the registered class instead");
    }

/*

=item C<void init_pmc(PMC *init)>

=cut

*/

    void init_pmc(PMC* init) {
        SELF.init();
    }

/*

=item C<void init_pmc_props(PMC *init, PMC *props)>

These two methods just call C<init()>. The arguments are ignored.

=cut

*/

    void init_pmc_props(PMC* init, PMC* props) {
        SELF.init();
    }

/*

=item C<PMC *find_method(STRING *name)>

Finds the method for C<*name>.

=cut

*/

    PMC* find_method(STRING* name) {
        PMC *class = VTABLE_get_pmc_keyed_int(INTERP, (PMC *)PMC_data(SELF), 0);
        return Parrot_find_method_with_cache(INTERP, class, name);
    }

/*

=item C<INTVAL elements()>

=cut

*/

    INTVAL elements() {
        PMC* data_array = (PMC*) PMC_data(SELF);
        return VTABLE_elements(interpreter, data_array) - PMC_int_val(SELF);
    }

/*

=item C<INTVAL get_integer()>

The both return the attribute count.

=cut

*/

    INTVAL get_integer() {
        return SELF.elements();
    }

/*

=item C<INTVAL get_integer_keyed_int(INTVAL idx)>

=cut

*/

    INTVAL get_integer_keyed_int (INTVAL idx) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        return VTABLE_get_integer_keyed_int(interpreter, data_array,
            idx + PMC_int_val(SELF));
    }

/*

=back

=head2 Attribute Accessors

If there is a chance that attributes are accessed with an explicit
C<Key> PMC, we need the test for the key type, if not then only the
keyed_str C<*attr> is necessary.

This holds true for all plain C<_keyed get_> and C<set_> variants.

=over 4

=item C<INTVAL get_integer_keyed_str(STRING *attr)>

=cut

*/

    INTVAL get_integer_keyed_str (STRING* attr) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        PMC *class = VTABLE_get_pmc_keyed_int(interpreter, data_array,
            POD_CLASS);
        INTVAL idx = VTABLE_get_integer_keyed_str(interpreter, class, attr);
        if (idx < 0)
            internal_exception(1, "No such attribute");
        return SELF.get_integer_keyed_int(idx);
    }

/*

=item C<INTVAL get_integer_keyed(PMC *attr)>

Returns the attribute value for C<*attr>.

=cut

*/

    INTVAL get_integer_keyed (PMC* attr) {
        int flag = PObj_get_FLAGS(attr) & KEY_type_FLAGS;
        if ( flag & KEY_integer_FLAG) {
            return SELF.get_integer_keyed_int(key_integer(interpreter, attr));
        } else {
            return SELF.get_integer_keyed_str(key_string(interpreter, attr));
        }
    }

/*

=item C<void set_integer_keyed_int(INTVAL idx, INTVAL value)>

Sets C<*value> as the value of attribute C<idx>.

=cut

*/

    void set_integer_keyed_int (INTVAL idx, INTVAL value) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        VTABLE_set_integer_keyed_int(interpreter, data_array,
            idx + PMC_int_val(SELF), value);
    }

/*

=item C<void set_integer_keyed_str(STRING *attr, INTVAL value)>

=cut

*/

    void set_integer_keyed_str (STRING* attr, INTVAL value) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        PMC *class = VTABLE_get_pmc_keyed_int(interpreter, data_array,
            POD_CLASS);
        INTVAL idx = VTABLE_get_integer_keyed_str(interpreter, class, attr);
        if (idx < 0)
            internal_exception(1, "No such attribute");
        SELF.set_integer_keyed_int(idx, value);
    }

/*

=item C<void set_integer_keyed(PMC *attr, INTVAL value)>

Sets C<*value> as the value of attribute C<*attr>.

=cut

*/

    void set_integer_keyed (PMC* attr, INTVAL value) {
        int flag = PObj_get_FLAGS(attr) & KEY_type_FLAGS;
        if ( flag & KEY_integer_FLAG) {
            SELF.set_integer_keyed_int(key_integer(interpreter, attr), value);
        } else {
            SELF.set_integer_keyed_str(key_string(interpreter, attr), value);
        }
    }


/*

=item C<FLOATVAL get_number_keyed_int(INTVAL idx)>

Returns the value of attribute C<idx>.

=cut

*/

    FLOATVAL get_number_keyed_int (INTVAL idx) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        return VTABLE_get_number_keyed_int(interpreter, data_array,
            idx + PMC_int_val(SELF));
    }

/*

=item C<FLOATVAL get_number_keyed_str(STRING *attr)>

=cut

*/

    FLOATVAL get_number_keyed_str (STRING* attr) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        PMC *class = VTABLE_get_pmc_keyed_int(interpreter, data_array,
            POD_CLASS);
        INTVAL idx = VTABLE_get_integer_keyed_str(interpreter, class, attr);
        if (idx < 0)
            internal_exception(1, "No such attribute");
        return SELF.get_number_keyed_int(idx);
    }

/*

=item C<FLOATVAL get_number_keyed(PMC *attr)>

Returns the value of attribute C<*attr>.

=cut

*/

    FLOATVAL get_number_keyed (PMC* attr) {
        int flag = PObj_get_FLAGS(attr) & KEY_type_FLAGS;
        if ( flag & KEY_integer_FLAG) {
            return SELF.get_number_keyed_int(key_integer(interpreter, attr));
        } else {
            return SELF.get_number_keyed_str(key_string(interpreter, attr));
        }
    }

/*

=item C<void set_number_keyed_int(INTVAL idx, FLOATVAL value)>

Sets C<*value> as the value of attribute C<idx>.

=cut

*/

    void set_number_keyed_int (INTVAL idx, FLOATVAL value) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        VTABLE_set_number_keyed_int(interpreter, data_array,
            idx + PMC_int_val(SELF), value);
    }

/*

=item C<void set_number_keyed_str(STRING *attr, FLOATVAL value)>

=cut

*/

    void set_number_keyed_str (STRING* attr, FLOATVAL value) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        PMC *class = VTABLE_get_pmc_keyed_int(interpreter, data_array,
            POD_CLASS);
        INTVAL idx = VTABLE_get_integer_keyed_str(interpreter, class, attr);
        if (idx < 0)
            internal_exception(1, "No such attribute");
        SELF.set_number_keyed_int(idx, value);
    }

/*

=item C<void set_number_keyed(PMC *attr, FLOATVAL value)>

Sets C<*value> as the value of attribute C<*attr>.

=cut

*/

    void set_number_keyed (PMC* attr, FLOATVAL value) {
        int flag = PObj_get_FLAGS(attr) & KEY_type_FLAGS;
        if ( flag & KEY_integer_FLAG) {
            SELF.set_number_keyed_int(key_integer(interpreter, attr), value);
        } else {
            SELF.set_number_keyed_str(key_string(interpreter, attr), value);
        }
    }

/*

=item C<STRING *get_string_keyed_int(INTVAL idx)>

Returns the value of attribute C<idx>.

=cut

*/

    STRING* get_string_keyed_int (INTVAL idx) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        return VTABLE_get_string_keyed_int(interpreter, data_array,
            idx + PMC_int_val(SELF));
    }

/*

=item C<STRING *get_string_keyed_str(STRING *attr)>

=cut

*/

    STRING* get_string_keyed_str (STRING* attr) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        PMC *class = VTABLE_get_pmc_keyed_int(interpreter, data_array,
            POD_CLASS);
        INTVAL idx = VTABLE_get_integer_keyed_str(interpreter, class, attr);
        if (idx < 0)
            internal_exception(1, "No such attribute");
        return SELF.get_string_keyed_int(idx);
    }

/*

=item C<STRING *get_string_keyed(PMC *attr)>

Returns the value of attribute C<*attr>.

=cut

*/

    STRING* get_string_keyed (PMC* attr) {
        int flag = PObj_get_FLAGS(attr) & KEY_type_FLAGS;
        if ( flag & KEY_integer_FLAG) {
            return SELF.get_string_keyed_int(key_integer(interpreter, attr));
        } else {
            return SELF.get_string_keyed_str(key_string(interpreter, attr));
        }
    }

/*

=item C<void set_string_keyed_int(INTVAL idx, STRING *value)>

Sets C<*value> as the value of attribute C<idx>.

=cut

*/

    void set_string_keyed_int (INTVAL idx, STRING* value) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        VTABLE_set_string_keyed_int(interpreter, data_array,
            idx + PMC_int_val(SELF), value);
    }

/*

=item C<void set_string_keyed_str(STRING *attr, STRING *value)>

=cut

*/

    void set_string_keyed_str (STRING* attr, STRING* value) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        PMC *class = VTABLE_get_pmc_keyed_int(interpreter, data_array,
            POD_CLASS);
        INTVAL idx = VTABLE_get_integer_keyed_str(interpreter, class, attr);
        if (idx < 0)
            internal_exception(1, "No such attribute");
        SELF.set_string_keyed_int(idx, value);
    }

/*

=item C<void set_string_keyed(PMC *attr, STRING *value)>

Sets C<*value> as the value of attribute C<*attr>.

=cut

*/

    void set_string_keyed (PMC* attr, STRING* value) {
    int flag = PObj_get_FLAGS(attr) & KEY_type_FLAGS;
        if ( flag & KEY_integer_FLAG) {
            SELF.set_string_keyed_int(key_integer(interpreter, attr), value);
        } else {
            SELF.set_string_keyed_str(key_string(interpreter, attr), value);
        }
    }

/*

=item C<PMC *get_pmc_keyed_int(INTVAL idx)>

Returns the value of attribute C<idx>.

=cut

*/

    PMC* get_pmc_keyed_int (INTVAL idx) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        return VTABLE_get_pmc_keyed_int(interpreter, data_array,
            idx + PMC_int_val(SELF));
    }

/*

=item C<PMC *get_pmc_keyed_str(STRING *attr)>

=cut

*/

    PMC* get_pmc_keyed_str (STRING* attr) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        PMC *class = VTABLE_get_pmc_keyed_int(interpreter, data_array,
            POD_CLASS);
        INTVAL idx = VTABLE_get_integer_keyed_str(interpreter, class, attr);
        if (idx < 0)
            internal_exception(1, "No such attribute");
        return SELF.get_pmc_keyed_int(idx);
    }

/*

=item C<PMC *get_pmc_keyed(PMC *attr)>

Returns the value of attribute C<*attr>.

=cut

*/

    PMC* get_pmc_keyed (PMC* attr) {
        int flag = PObj_get_FLAGS(attr) & KEY_type_FLAGS;
        if ( flag & KEY_integer_FLAG) {
            return SELF.get_pmc_keyed_int(key_integer(interpreter, attr));
        } else {
            return SELF.get_pmc_keyed_str(key_string(interpreter, attr));
        }
    }

/*

=item C<void set_pmc_keyed_int(INTVAL idx, PMC *value)>

Sets C<*value> as the value of attribute C<idx>.

=cut

*/

    void set_pmc_keyed_int (INTVAL idx, PMC* value) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        VTABLE_set_pmc_keyed_int(interpreter, data_array,
            idx + PMC_int_val(SELF), value);
    }

/*

=item C<void set_pmc_keyed_str(STRING *attr, PMC *value)>

=cut

*/

    void set_pmc_keyed_str (STRING* attr, PMC* value) {
        PMC* data_array = (PMC*) PMC_data(SELF);
        PMC *class = VTABLE_get_pmc_keyed_int(interpreter, data_array,
            POD_CLASS);
        INTVAL idx = VTABLE_get_integer_keyed_str(interpreter, class, attr);
        if (idx < 0)
            internal_exception(1, "No such attribute");
        SELF.set_pmc_keyed_int(idx, value);
    }

/*

=item C<void set_pmc_keyed(PMC *attr, PMC *value)>

Sets C<*value> as the value of attribute C<*attr>.

=cut

*/

    void set_pmc_keyed (PMC* attr, PMC* value) {
        int flag = PObj_get_FLAGS(attr) & KEY_type_FLAGS;
        if ( flag & KEY_integer_FLAG) {
            SELF.set_pmc_keyed_int(key_integer(interpreter, attr), value);
        } else {
            SELF.set_pmc_keyed_str(key_string(interpreter, attr), value);
        }
    }
}

/*

=back

=cut

*/
