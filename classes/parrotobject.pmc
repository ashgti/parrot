/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/ - Parrot Object

=head1 DESCRIPTION

A Parrot Object is reasonably simple. It's data pointer points to an
array with the attributes of the object in it. The int cache value holds
the offset in that array of the first attribute, so we can front-load
the array with invisible options.

The array holds:

=over 4

=item 0

The first element of the attribute array is a pointer to the class PMC
for this object.

=item 1

The class name (taken from the class PMC)

=item 2...

Attributes.

=back

The object is actually constructed by the instantiation code in
F<src/objects.c>, at least for right now.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass ParrotObject extends ParrotClass need_ext {

/*

=item C<void init()>

Raises an exception to make sure all users call C<new> on the registered
class PMC and not the ParrotObject itself.

During C<Parrot_class_register()> this C<init()> method gets replaced by
C<Parrot_instantiate_object()>.

=cut

*/

    void init() {
        internal_exception(1, "Can't create new ParrotObjects\n",
            "use the registered class instead");
    }

    void mark() {
        Buffer *trace_buf = PMC_data(SELF);
        UINTVAL i;

        /* mark saved registers area */
        Parrot_delegate_mark(INTERP, SELF);

        if (trace_buf) {
            PMC **cur_pmc = PObj_bufstart(trace_buf);

            pobject_lives(interpreter, trace_buf);
            for (i = 0; i < ATTRIB_COUNT(SELF); i++) {
                if (cur_pmc[i]) {
                    pobject_lives(interpreter, (PObj *)cur_pmc[i]);
                }
            }
        }
    }

/*

=item C<void init_pmc(PMC *init)>

=cut

*/

    void init_pmc(PMC* init) {
        SELF.init();
    }

/*

=item C<void init_pmc_props(PMC *init, PMC *props)>

These two methods just call C<init()>. The arguments are ignored.

=cut

*/

    void init_pmc_props(PMC* init, PMC* props) {
        SELF.init();
    }


    STRING* name() {
        return VTABLE_get_string(INTERP,
                (PMC *)get_attrib_num((Buffer *)PMC_data(SELF),
                                      POD_CLASS_NAME));
    }


/*

=item C<PMC *find_method(STRING *name)>

Finds the method for C<*name>.

=cut

*/

    PMC* find_method(STRING* name) {
        PMC *class = GET_CLASS((PMC *)PMC_data(SELF), pmc);
        return Parrot_find_method_with_cache(INTERP, class, name);
    }

}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
