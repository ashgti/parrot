/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/scalar.pmc - Scalar Abstract Superclass

=head1 DESCRIPTION

These are the vtable functions for the scalar base PMC class

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass scalar abstract noinit {

/*

=item C<PMC *clone()>

Creates and returns a clone of the scalar.

=cut

*/

    PMC* clone () {
        PMC* dest = pmc_new(INTERP, SELF->vtable->base_type);
        memcpy(&PMC_union(dest), &PMC_union(SELF), sizeof(UnionVal));
        return dest;
    }


/*

=back

=head1 Mathematical Methods

=over 4


/*

=item C<PMC* subtract(PMC *value, PMC *dest)>

=cut

*/

/*

=item C<void add(PMC *value, PMC *dest)>

=item C<void add_int(INTVAL value, PMC *dest)>

=item C<void add_float(FLOATVAL value, PMC *dest)>

Adds C<value> to the number and returns the result in C<*dest>.
If C<dest> is NULL it's created.

=item C<void i_add(PMC *value)>

=item C<void i_add(INTVAL value)>

=item C<void i_add(FLOATVAL value)>

Adds C<value> to C<SELF> inplace.

=cut

*/

    PMC* add (PMC* value, PMC* dest) {
MMD_Complex: {
            FLOATVAL a = DYNSELF.get_number();
            if (dest)
                VTABLE_morph(INTERP, dest, value->vtable->base_type);
            else
                dest = pmc_new(INTERP, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                    a + VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, dest, 1,
                    VTABLE_get_number_keyed_int(INTERP, value, 1));
            return dest;
        }
MMD_DEFAULT: {
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                    DYNSELF.get_number() + VTABLE_get_number(INTERP, value));
            return dest;
        }
    }

    PMC* add_int (INTVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_number() + (FLOATVAL)value);
        return dest;
    }

    PMC* add_float (FLOATVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_number() + value);
        return dest;
    }

    void i_add (PMC* value) {
MMD_Complex: {
            FLOATVAL a = DYNSELF.get_number();
            VTABLE_morph(INTERP, SELF, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, SELF,
                    a + VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, SELF, 1,
                    VTABLE_get_number_keyed_int(INTERP, value, 1));
        }
MMD_DEFAULT: {
            VTABLE_set_number_native(INTERP, SELF,
                DYNSELF.get_number() + VTABLE_get_number(INTERP, value));
        }
    }

    void i_add_int (INTVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() + (FLOATVAL)value);
    }

    void i_add_float (FLOATVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() + value);
    }

/*

=item C<PMC* subtract(PMC *value, PMC *dest)>

=item C<PMC* subtract_int(INTVAL value, PMC *dest)>

=item C<PMC* subtract_float(FLOATVAL value, PMC *dest)>

Subtracts C<value> from the number and returns the result in C<*dest>.
If C<dest> doesn't exist a new C<Float> is created.

=item C<void i_subtract(PMC *value)>

=item C<void i_subtract_int(INTVAL value)>

=item C<void i_subtract_float(FLOATVAL value)>

Subtracts C<value> from C<SELF> inplace.

=cut

*/

    PMC* subtract (PMC* value, PMC* dest) {
MMD_Complex: {
            FLOATVAL a = DYNSELF.get_number();
            if (dest)
                VTABLE_morph(INTERP, dest, value->vtable->base_type);
            else
                dest = pmc_new(INTERP, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                    a - VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, dest, 1,
                    -VTABLE_get_number_keyed_int(INTERP, value, 1));
            return dest;
        }
MMD_DEFAULT: {
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                    DYNSELF.get_number() - VTABLE_get_number(INTERP, value));
            return dest;
        }
    }

    PMC* subtract_int (INTVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_number() - (FLOATVAL)value);
        return dest;
    }

    PMC* subtract_float (FLOATVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_number() - value);
        return dest;
    }

    void i_subtract (PMC* value) {
MMD_Complex: {
            FLOATVAL a = DYNSELF.get_number();
            VTABLE_morph(INTERP, SELF, value->vtable->base_type);
            VTABLE_set_number_native(INTERP, SELF,
                    a - VTABLE_get_number_keyed_int(INTERP, value, 0));
            VTABLE_set_number_keyed_int(INTERP, SELF, 1,
                    -VTABLE_get_number_keyed_int(INTERP, value, 1));
        }
MMD_DEFAULT: {
            VTABLE_set_number_native(INTERP, SELF,
                DYNSELF.get_number() - VTABLE_get_number(INTERP, value));
        }
    }

    void i_subtract_int (INTVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() - (FLOATVAL)value);
    }

    void i_subtract_float (FLOATVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() - value);
    }


/*

=item C<PMC* multiply(PMC *value, PMC *dest)>

=item C<PMC* multiply_int(INTVAL value, PMC *dest)>

=item C<PMC* multiply_float(FLOATVAL value, PMC *dest)>

Multiplies the number by C<value> and returns the result in C<*dest>.

=cut

*/

    PMC* multiply (PMC* value, PMC* dest) {
MMD_Complex: {
            internal_exception(1, "TODO mul<Float, Complex>");
            return dest;
        }
MMD_DEFAULT: {
            if (!dest)
                dest = pmc_new(INTERP, SELF->vtable->base_type);
            VTABLE_set_number_native(INTERP, dest,
                DYNSELF.get_number() * VTABLE_get_number(INTERP, value));
            return dest;
        }
    }

    PMC* multiply_int (INTVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
            DYNSELF.get_number() * value);
        return dest;
    }

    PMC* multiply_float (FLOATVAL value, PMC* dest) {
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
            DYNSELF.get_number() * value);
        return dest;
    }

    void i_multiply (PMC* value) {
MMD_Complex: {
            internal_exception(1, "TODO i_mul<Float, Complex>");
        }
MMD_DEFAULT: {
            VTABLE_set_number_native(INTERP, SELF,
                DYNSELF.get_number() * VTABLE_get_number(INTERP, value));
        }
    }

    void i_multiply_int (INTVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() * (FLOATVAL)value);
    }

    void i_multiply_float (FLOATVAL value) {
        VTABLE_set_number_native(INTERP, SELF,
            DYNSELF.get_number() * value);
    }

/*

=item C<PMC* divide(PMC *value, PMC *dest)>

=item C<PMC* divide_int(INTVAL value, PMC *dest)>

=item C<PMC* divide_float(FLOATVAL value, PMC *dest)>

Divides the number by C<value> and returns the result in C<*dest>.

=item C<void i_divide(PMC *value)>

=item C<void i_divide_int(INTVAL value)>

=item C<void i_divide_float(FLOATVAL value)>

Divides C<SELF> by C<value> inplace.

=cut

*/

    PMC* divide (PMC* value, PMC* dest) {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        if (d == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest, DYNSELF.get_number() / d);
        return dest;
    }

    PMC* divide_int (INTVAL value, PMC* dest) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest, DYNSELF.get_number() / value);
        return dest;
    }

    PMC* divide_float (FLOATVAL value, PMC* dest) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest, DYNSELF.get_number() / value);
        return dest;
    }

    void i_divide (PMC* value) {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        if (d == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        VTABLE_set_number_native(INTERP, SELF, DYNSELF.get_number() / d);
    }

    void i_divide_int (INTVAL value) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        VTABLE_set_number_native(INTERP, SELF, DYNSELF.get_number() / value);
    }

    void i_divide_float (FLOATVAL value) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        VTABLE_set_number_native(INTERP, SELF, DYNSELF.get_number() / value);
    }

/*

=item C<PMC* floor_divide(PMC *value, PMC *dest)>

=item C<PMC* floor_divide_int(INTVAL value, PMC *dest)>

=item C<PMC* floor_divide_float(FLOATVAL value, PMC *dest)>

Divides the number by C<value> and returns the result in C<*dest>.

=item C<void i_floor_divide(PMC *value)>

=item C<void i_floor_divide_int(INTVAL value)>

=item C<void i_floor_divide_float(FLOATVAL value)>

Divides C<SELF> by C<value> inplace.

=cut

*/

    PMC* floor_divide (PMC* value, PMC* dest) {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        if (d == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                floor(DYNSELF.get_number() / d));
        return dest;
    }

    PMC* floor_divide_int (INTVAL value, PMC* dest) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                floor(DYNSELF.get_number() / value));
        return dest;
    }

    PMC* floor_divide_float (FLOATVAL value, PMC* dest) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        if (!dest)
            dest = pmc_new(INTERP, SELF->vtable->base_type);
        VTABLE_set_number_native(INTERP, dest,
                floor(DYNSELF.get_number() / value));
        return dest;
    }

    void i_floor_divide (PMC* value) {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        if (d == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        VTABLE_set_number_native(INTERP, SELF,
                floor(DYNSELF.get_number() / d));
    }

    void i_floor_divide_int (INTVAL value) {
        if (value == 0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        VTABLE_set_number_native(INTERP, SELF,
                floor(DYNSELF.get_number() / value));
    }

    void i_floor_divide_float (FLOATVAL value) {
        if (value == 0.0)
            real_exception(INTERP, NULL, E_ZeroDivisionError,
                    "float division by zero");
        VTABLE_set_number_native(INTERP, SELF,
                floor(DYNSELF.get_number() / value));
    }




/*

=item C<void modulus(PMC* value, PMC* dest)>

This does perl-like modulus.

Returns in C<*dest> the value of the scalar C<mod> the integer value of
C<*value>.

=cut

*/

    void modulus (PMC* value,  PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            % VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void modulus_int(INTVAL value, PMC* dest)>

Returns in C<*dest> the value of the scalar C<mod> C<value>.

=cut

*/

    void modulus_int (INTVAL value,  PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            % value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void modulus_float(FLOATVAL value, PMC *dest)>

Calls the superclass implementation.

=cut

*/

    void modulus_float (FLOATVAL value,  PMC* dest) {
        SUPER(value, dest);
    }

/*

=item C<void neg(PMC *dest)>

Set C<dest> to the negated value of C<SELF>.

=cut

*/

    void neg (PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest, -DYNSELF.get_integer());
    }

/*

=back

=head2 Bitwise Methods

=over 4

=item C<void bitwise_or(PMC *value, PMC *dest)>

Returns in C<*dest> the bitwise C<OR> of the scalar and C<*value>.

=cut

*/

    void bitwise_or (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            | VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_or_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the bitwise C<OR> of the scalar and C<value>.

=cut

*/

    void bitwise_or_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            | value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_and(PMC *value, PMC *dest)>

Returns in C<*dest> the bitwise C<AND> of the scalar and C<*value>.

=cut

*/

    void bitwise_and (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            & VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_and_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the bitwise C<AND> of the scalar and C<value>.

=cut

*/

    void bitwise_and_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            & value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_xor(PMC *value, PMC *dest)>

Returns in C<*dest> the bitwise C<XOR> of the scalar and C<*value>.

=cut

*/

    void bitwise_xor (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            ^ VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_xor_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the bitwise C<XOR> of the scalar and C<value>.

=cut

*/

    void bitwise_xor_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            ^ value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_not(PMC *dest)>

Returns in C<*dest> the bitwise negation of the scalar and C<value>.

=cut

*/

    void bitwise_not (PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest, ~DYNSELF.get_integer());
    }


/*

=item C<void bitwise_shr(PMC *value, PMC *dest)>

Returns in C<*dest> the shift right of the scalar by C<*value>.

=cut

*/

    void bitwise_shr (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            >> VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_shr_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the shift right of the scalar by C<value>.

=cut

*/

    void bitwise_shr_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            >> value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_shl(PMC *value, PMC *dest)>

Returns in C<*dest> the shift left of the scalar by C<*value>.

=cut

*/

    void bitwise_shl (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            << VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=item C<void bitwise_shl_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the shift left of the scalar by C<value>.

=cut

*/

    void bitwise_shl_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            << value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

/*

=back

=head2 String Methods

=over 4

=item C<void concatenate(PMC *value, PMC *dest)>

Returns in C<*dest> the result of concatenating the scalar and C<*value>.

=cut

*/

    void concatenate (PMC* value,  PMC* dest) {
        STRING* s = string_concat(INTERP,
            DYNSELF.get_string(),
            VTABLE_get_string(INTERP, value), 0);

        VTABLE_set_string_native(INTERP, dest, s);
    }

/*

=item C<void concatenate_str(STRING *value, PMC *dest)>

Returns in C<*dest> the result of concatenating the scalar and C<*value>.

=cut

*/

    void concatenate_str (STRING* value,  PMC* dest) {
        /* dest = SELF (concat) value */
        STRING* s = string_concat(INTERP,
            DYNSELF.get_string(),
            value, 0);

        VTABLE_set_string_native(INTERP, dest, s);
    }

/*

=back

=head2 Comparison Methods

=over 4

=item C<INTVAL is_equal(PMC *value)>

Returns whether the scalar is equal to C<*value>.

=cut

*/

    INTVAL is_equal (PMC* value) {
        /* I think we need to check everything, do the easiest first... */
        if (DYNSELF.get_integer()
                == VTABLE_get_integer(INTERP, value)
            && DYNSELF.get_number()
                == VTABLE_get_number(INTERP, value)
            && 0 == string_compare(INTERP,
                DYNSELF.get_string(),
                VTABLE_get_string(INTERP, value))
            )
        {
            return 1;
        }
        return 0;
    }


/*

=item C<INTVAL cmp_num(PMC *value)>

Returns the result of comparing the floating-point values of the scalar
and C<*value>.

=cut

*/

    INTVAL cmp_num (PMC* value) {
        /* XXX - Floating-point precision errors possible? */
        FLOATVAL diff = VTABLE_get_number(INTERP, value) -
                        DYNSELF.get_number();

        return diff == 0.0 ? 0 : diff < 0.0 ? -1 : 1;
    }

/*

=item C<INTVAL cmp_string(PMC *value)>

Returns the result of comparing the string values of the scalar and
C<*value>.

=cut

*/

    INTVAL cmp_string (PMC* value) {
        return string_compare(INTERP, DYNSELF.get_string(),
            VTABLE_get_string(INTERP, value));
    }

/*

=back

=head2 Logical Methods

=over 4

=item C<void logical_or(PMC *value, PMC *dest)>

Returns in C<*dest> the result of the logical C<OR> of the scalar and
C<*value>.

=cut

*/

    void logical_or (PMC* value,  PMC* dest) {
        if (DYNSELF.get_bool()) {
            VTABLE_set_pmc(INTERP, dest, SELF);
        }
        else {
            VTABLE_set_pmc(INTERP, dest, value);
        }
    }

/*

=item C< void logical_and(PMC *value, PMC *dest)>

Returns in C<*dest> the result of the logical C<AND> of the scalar and
C<*value>.

=cut

*/

    void logical_and (PMC* value,  PMC* dest) {
        if (DYNSELF.get_bool()) {
            VTABLE_set_pmc(INTERP, dest, value);
        }
        else {
            VTABLE_set_pmc(INTERP, dest, SELF);
        }
    }

/*

=item C<void logical_xor(PMC *value, PMC *dest)>

Returns in C<*dest> the result of the logical C<XOR> of the scalar and
C<*value>.

=cut

*/

    void logical_xor (PMC* value,  PMC* dest) {

        INTVAL my_bool, value_bool;

        my_bool = DYNSELF.get_bool();
        value_bool = VTABLE_get_bool(INTERP, value);

        if (my_bool && ! value_bool) {
            VTABLE_set_pmc(INTERP, dest, SELF);
        }
        else if (value_bool && ! my_bool) {
            VTABLE_set_pmc(INTERP, dest, value);
        }
        else {
            /* XXX - Need a better way to set FALSE */
            VTABLE_set_integer_native(INTERP, dest, 0);
        }
    }

/*

=item C<void logical_not(PMC *dest)>

Returns in C<*dest> the result of the logical negation of the scalar and
C<*value>.

=cut

*/

    void logical_not (PMC* dest) {
        /* XXX - Need a better way to set boolean state */
        VTABLE_set_integer_native(INTERP, dest,
            ! DYNSELF.get_bool());
    }

/*

=item C<void repeat(PMC *value, PMC *dest)>

Returns in C<*dest> the result of repeating the scalar C<*value> times.


=cut

*/

    void repeat (PMC* value,  PMC* dest) {
        VTABLE_set_string_native(INTERP, dest,
            string_repeat(INTERP, VTABLE_get_string(INTERP,SELF),
                (UINTVAL)VTABLE_get_integer(INTERP, value), NULL) );
    }

/*

=item C<void repeat_int(INTVAL value, PMC *dest)>

Returns in C<*dest> the result of repeating the scalar C<value> times.

=cut

*/

    void repeat_int (INTVAL value, PMC* dest) {
        VTABLE_set_string_native(INTERP, dest,
            string_repeat(INTERP, VTABLE_get_string(INTERP,SELF),
                (UINTVAL)value, NULL) );
    }


/*

=item C<INTVAL defined()>

Always returns true.

=cut

*/

    INTVAL defined () {
        return 1;
    }


/*

=item C<STRING *substr_str(INTVAL offset, INTVAL length)>

Returns the substring of length C<length> of the scalar starting at
C<offset>.

=cut

*/

    STRING* substr_str(INTVAL offset, INTVAL length) {
        return string_substr(INTERP, VTABLE_get_string(INTERP,SELF),
            offset, length, NULL, 0);
    }

}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
