/* scalar.pmc
 *  Copyright: (When this is determined...it will go here)
 *  CVS Info:
 *  Overview:
 *     These are the vtable functions for the scalar base PMC class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *  References:
 */

#include "parrot/parrot.h"

#define INT2KEY(i,k) ((k) ? key_new_integer((i), *(k)) : NULL)

pmclass scalar abstract noinit {

    void clone (PMC *dest) {
	VTABLE_init(INTERP, dest);
        memcpy(&dest->cache, &SELF->cache, sizeof(UnionVal));
    }

    INTVAL get_integer () {
        return SELF->cache.int_val;
    }

    FLOATVAL get_number () {
        return SELF->cache.num_val;
    }

    BIGNUM* get_bignum () {
        return (BIGNUM*)SELF->cache.struct_val;
    }

    STRING* get_string () {
        STRING*s = string_copy(INTERP, SELF->cache.struct_val);
        return s;
    }

    INTVAL get_bool () {
        /*  Everything has to be 0 */
        if (   DYNSELF.get_integer() == 0
            && DYNSELF.get_number() == 0.0
            && string_bool(DYNSELF.get_string()) == 0
            )
        {
            return 0;
        }
        return 1;
    }

    INTVAL elements () {
        /* XXX maybe this should be one */
        return 0;
    }

    PMC* get_pmc () {
        return SELF;
    }


    INTVAL is_same_keyed (PMC* key, PMC* value, PMC* value_key) {
        if (key == NULL) {
            /* pmc2_key must not be null, else why did you call me? */
            return VTABLE_is_same(INTERP, SELF,
		    VTABLE_get_pmc_keyed(INTERP,
			value, value_key));
        }
	return SUPER(key, value, value_key);
    }

    INTVAL is_same_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        return DYNSELF.is_same_keyed(r_key, value, r_value_key);
    }

    /* The set methods merely make the appropriate part of the cache
      be what it should be, more complex behaviour is left as an
      exercise for the inheriting class. */

    void set_integer (PMC* value) {
        SELF->cache.int_val = VTABLE_get_integer(INTERP, value);
    }

    void set_integer_native (INTVAL value) {
        SELF->cache.int_val = value;
    }

    void set_integer_same (PMC* value) {
        SELF->cache.int_val = VTABLE_get_integer(INTERP, value);
    }

    void set_number (PMC* value) {
        SELF->cache.num_val = VTABLE_get_number(INTERP, value);
    }

    void set_number_native (FLOATVAL value) {
        SELF->cache.num_val = value;
    }

    void set_number_same (PMC* value) {
        SELF->cache.num_val = VTABLE_get_number(INTERP, value);
    }

    void set_bignum (PMC* value) {
        SELF->cache.struct_val = (DPOINTER*)VTABLE_get_bignum(INTERP, value);
    }

    void set_bignum_native (BIGNUM* value) {
        SELF->cache.struct_val = (DPOINTER*)value;
    }

    void set_bignum_same (PMC* value) {
        SELF->cache.struct_val = (DPOINTER*)VTABLE_get_bignum(INTERP, value);
    }

    void set_string (PMC* value) {
        SELF->cache.struct_val = VTABLE_get_string(INTERP, value);
    }

    void set_string_native (STRING* value) {
        SELF->cache.struct_val = string_copy(INTERP, value);
    }

    void set_string_same (PMC* value) {
        SELF->cache.struct_val = VTABLE_get_string(INTERP, value);
    }

    void set_pmc (PMC* value) {
        SELF->cache.struct_val = VTABLE_get_pmc(INTERP, value);
    }

    void set_pmc_keyed (PMC* key, PMC* value, PMC* value_key) {
        /* Either key or value must NOT be NULL */
        if (key == NULL)
            VTABLE_set_pmc(INTERP, SELF,
		    VTABLE_get_pmc_keyed(INTERP, value,
			value_key));
        else
	    SUPER(key, value, value_key);
    }

    void set_pmc_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        DYNSELF.set_pmc_keyed(r_key, value, r_value_key);
    }

    void set_same (PMC* value) {
        SELF->cache = value->cache;
    }


    void add_int (INTVAL value, PMC* dest) {
        /* dest = SELF + value */

        INTVAL result;

        result = DYNSELF.get_integer() + value;
        /* XXX: overflow detection, bigint promotion? */
        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void add_bignum (BIGNUM* value, PMC* dest) {
        /* XXX: bignum magic */
    }

    void add_float (FLOATVAL value, PMC* dest) {
        /* dest = SELF + value */
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = DYNSELF.get_number() + value;

        VTABLE_set_number_native(INTERP, dest, result);
    }

    void add_same (PMC* value,  PMC* dest) {
        DYNSELF.add(value, dest);
    }

    void add_keyed (PMC* key, PMC* value, PMC* value_key,
        PMC* dest, PMC* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            FLOATVAL result;

            result = DYNSELF.get_number() + (
                value_key == NULL ?
                VTABLE_get_number(INTERP, value) :
                VTABLE_get_number_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                VTABLE_set_number_native(INTERP, dest, result);
            else
                VTABLE_set_number_keyed(INTERP, dest, dest_key, result);
        }
        else
            SUPER(key, value, value_key, dest, dest_key);
    }

    void add_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);

        DYNSELF.add_keyed(r_key, value, r_value_key, dest, r_dest_key);
    }

    void subtract (PMC* value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = DYNSELF.get_number()
            - VTABLE_get_number(INTERP, value);

        VTABLE_set_number_native(INTERP, dest, result);
    }

    void subtract_int (INTVAL value,  PMC* dest) {
        /* dest = SELF - value */
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = DYNSELF.get_number()
            - value;

        VTABLE_set_number_native(INTERP, dest, result);
    }

    void subtract_bignum (BIGNUM* value,  PMC* dest) {
        /* XXX: bignum magic */
    }

    void subtract_float (FLOATVAL value,  PMC* dest) {
        /* dest = SELF - value */
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = DYNSELF.get_number()
            - value;

        VTABLE_set_number_native(INTERP, dest, result);
    }

    void subtract_same (PMC* value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = DYNSELF.get_number()
            - VTABLE_get_number(INTERP, value);

        VTABLE_set_number_native(INTERP, dest, result);
    }

    void subtract_keyed (PMC* key, PMC* value, PMC* value_key,
            PMC* dest, PMC* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            FLOATVAL result;

            result = DYNSELF.get_number() - (
                value_key == NULL ?
                VTABLE_get_number(INTERP, value) :
                VTABLE_get_number_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                VTABLE_set_number_native(INTERP, dest, result);
            else
                VTABLE_set_number_keyed(INTERP, dest, dest_key, result);
        }
        else
            SUPER(key, value, value_key, dest, dest_key);
    }

    void subtract_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);

        DYNSELF.subtract_keyed(r_key, value, r_value_key, dest, r_dest_key);
    }

    void multiply (PMC* value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = DYNSELF.get_number()
            * VTABLE_get_number(INTERP, value);

        VTABLE_set_number_native(INTERP, dest, result);
    }

    void multiply_int (INTVAL value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = DYNSELF.get_number()
            * value;

        VTABLE_set_number_native(INTERP, dest, result);
    }

    void multiply_bignum (BIGNUM* value,  PMC* dest) {
        /* XXX: bignum magic */
    }

    void multiply_float (FLOATVAL value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = DYNSELF.get_number()
            * value;

        VTABLE_set_number_native(INTERP, dest, result);
    }

    void multiply_same (PMC* value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = DYNSELF.get_number()
            * VTABLE_get_number(INTERP, value);

        VTABLE_set_number_native(INTERP, dest, result);
    }

    void multiply_keyed (PMC* key, PMC* value, PMC* value_key,
            PMC* dest, PMC* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            FLOATVAL result;

            result = DYNSELF.get_number() * (
                value_key == NULL ?
                VTABLE_get_number(INTERP, value) :
                VTABLE_get_number_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                VTABLE_set_number_native(INTERP, dest, result);
            else
                VTABLE_set_number_keyed(INTERP, dest, dest_key, result);
        }
        else
            SUPER(key, value, value_key, dest, dest_key);
    }

    void multiply_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);

        DYNSELF.multiply_keyed(r_key, value, r_value_key, dest, r_dest_key);
    }

    void divide (PMC* value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = DYNSELF.get_number()
            / VTABLE_get_number(INTERP, value);

        VTABLE_set_number_native(INTERP, dest, result);
    }

    void divide_int (INTVAL value,  PMC* dest) {
        /* dest = SELF / value */

        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = DYNSELF.get_number()
            / value;

        VTABLE_set_number_native(INTERP, dest, result);
    }

    void divide_bignum (BIGNUM* value,  PMC* dest) {
        /* XXX: bignum magic */
    }

    void divide_float (FLOATVAL value,  PMC* dest) {
        /* dest = SELF / value */

        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = DYNSELF.get_number()
            / value;

        VTABLE_set_number_native(INTERP, dest, result);
    }

    void divide_same (PMC* value,  PMC* dest) {
        /* XXX: overflow detection, bignum promotion? */

        FLOATVAL result;

        result = DYNSELF.get_number()
            / VTABLE_get_number(INTERP, value);

        VTABLE_set_number_native(INTERP, dest, result);
    }

    void divide_keyed (PMC* key, PMC* value, PMC* value_key,
            PMC* dest, PMC* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            FLOATVAL result;

            result = DYNSELF.get_number() / (
                value_key == NULL ?
                VTABLE_get_number(INTERP, value) :
                VTABLE_get_number_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                VTABLE_set_number_native(INTERP, dest, result);
            else
                VTABLE_set_number_keyed(INTERP, dest, dest_key, result);
        }
        else
            SUPER(key, value, value_key, dest, dest_key);
    }

    void divide_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);

        DYNSELF.divide_keyed(r_key, value, r_value_key, dest, r_dest_key);
    }

    void modulus (PMC* value,  PMC* dest) {
        /* This does perl-like modulus */

        INTVAL result;

        result = DYNSELF.get_integer()
            % VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void modulus_int (INTVAL value,  PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            % value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void modulus_bignum (BIGNUM* value,  PMC* dest) {
        SUPER(value, dest);
    }

    void modulus_float (FLOATVAL value,  PMC* dest) {
        SUPER(value, dest);
    }

    void modulus_same (PMC* value,  PMC* dest) {
        /* This does perl-like modulus */
        INTVAL result;

        result = DYNSELF.get_integer()
            % VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void modulus_keyed (PMC* key, PMC* value, PMC* value_key,
            PMC* dest, PMC* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            INTVAL result;

            result = DYNSELF.get_integer() % (
                value_key == NULL ?
                VTABLE_get_integer(INTERP, value) :
                VTABLE_get_integer_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                VTABLE_set_integer_native(INTERP, dest, result);
            else
                VTABLE_set_integer_keyed(INTERP, dest, dest_key, result);
        }
        else
            SUPER(key, value, value_key, dest, dest_key);
    }

    void modulus_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);

        DYNSELF.modulus_keyed(r_key, value, r_value_key, dest, r_dest_key);
    }

    void neg (PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest, -DYNSELF.get_integer());
    }

    void neg_keyed (PMC* key, PMC* dest, PMC* dest_key) {
        if (key == NULL)
            VTABLE_set_integer_keyed(INTERP, dest,
                dest_key, -DYNSELF.get_integer());
        else
            SUPER(key, dest, dest_key);
    }

    void neg_keyed_int (INTVAL* key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);
        DYNSELF.neg_keyed(r_key, dest, r_dest_key);
    }

    void bitwise_or (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            | VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void bitwise_or_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            | value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void bitwise_or_same (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            | VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void bitwise_or_keyed (PMC* key, PMC* value, PMC* value_key,
            PMC* dest, PMC* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            INTVAL result;

            result = DYNSELF.get_integer() | (
                value_key == NULL ?
                VTABLE_get_integer(INTERP, value) :
                VTABLE_get_integer_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                VTABLE_set_integer_native(INTERP, dest, result);
            else
                VTABLE_set_integer_keyed(INTERP, dest, dest_key, result);
        }
        else
            SUPER(key, value, value_key, dest, dest_key);
    }

    void bitwise_or_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);

        DYNSELF.bitwise_or_keyed(r_key, value, r_value_key, dest, r_dest_key);
    }

    void bitwise_and (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            & VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void bitwise_and_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            & value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void bitwise_and_same (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            & VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void bitwise_and_keyed (PMC* key, PMC* value, PMC* value_key,
            PMC* dest, PMC* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            INTVAL result;

            result = DYNSELF.get_integer() & (
                value_key == NULL ?
                VTABLE_get_integer(INTERP, value) :
                VTABLE_get_integer_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                VTABLE_set_integer_native(INTERP, dest, result);
            else
                VTABLE_set_integer_keyed(INTERP, dest, dest_key, result);
        }
        else
            SUPER(key, value, value_key, dest, dest_key);
    }

    void bitwise_and_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);

        DYNSELF.bitwise_and_keyed(r_key, value, r_value_key, dest, r_dest_key);
    }

    void bitwise_xor (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            ^ VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void bitwise_xor_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            ^ value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void bitwise_xor_same (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            ^ VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void bitwise_xor_keyed (PMC* key, PMC* value, PMC* value_key,
            PMC* dest, PMC* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            INTVAL result;

            result = DYNSELF.get_integer() ^ (
                value_key == NULL ?
                VTABLE_get_integer(INTERP, value) :
                VTABLE_get_integer_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                VTABLE_set_integer_native(INTERP, dest, result);
            else
                VTABLE_set_integer_keyed(INTERP, dest, dest_key, result);
        }
        else
            SUPER(key, value, value_key, dest, dest_key);
    }

    void bitwise_xor_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);

        DYNSELF.bitwise_xor_keyed(r_key, value, r_value_key, dest, r_dest_key);
    }

    void bitwise_not (PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest, ~DYNSELF.get_integer());
    }

    void bitwise_not_keyed (PMC* key, PMC* dest, PMC* dest_key) {
        if (key == NULL)
            VTABLE_set_integer_keyed(INTERP, dest,
                dest_key, ~DYNSELF.get_integer());
        else
            SUPER(key, dest, dest_key);
    }

    void bitwise_not_keyed_int (INTVAL* key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);
        DYNSELF.bitwise_not_keyed(r_key, dest, r_dest_key);
    }

    void bitwise_shr (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            >> VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void bitwise_shr_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            >> value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void bitwise_shr_same (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            >> VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void bitwise_shr_keyed (PMC* key, PMC* value, PMC* value_key,
            PMC* dest, PMC* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            INTVAL result;

            result = DYNSELF.get_integer() >> (
                value_key == NULL ?
                VTABLE_get_integer(INTERP, value) :
                VTABLE_get_integer_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                VTABLE_set_integer_native(INTERP, dest, result);
            else
                VTABLE_set_integer_keyed(INTERP, dest, dest_key, result);
        }
        else
            SUPER(key, value, value_key, dest, dest_key);
    }

    void bitwise_shr_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);

        DYNSELF.bitwise_shr_keyed(r_key, value, r_value_key, dest, r_dest_key);
    }

    void bitwise_shl (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            << VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void bitwise_shl_int (INTVAL value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            << value;

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void bitwise_shl_same (PMC* value, PMC* dest) {
        INTVAL result;

        result = DYNSELF.get_integer()
            << VTABLE_get_integer(INTERP, value);

        VTABLE_set_integer_native(INTERP, dest, result);
    }

    void bitwise_shl_keyed (PMC* key, PMC* value, PMC* value_key,
            PMC* dest, PMC* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {
            INTVAL result;

            result = DYNSELF.get_integer() << (
                value_key == NULL ?
                VTABLE_get_integer(INTERP, value) :
                VTABLE_get_integer_keyed(INTERP, value, value_key)
            );

            if (dest_key == NULL)
                VTABLE_set_integer_native(INTERP, dest, result);
            else
                VTABLE_set_integer_keyed(INTERP, dest, dest_key, result);
        }
        else
            SUPER(key, value, value_key, dest, dest_key);
    }

    void bitwise_shl_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);

        DYNSELF.bitwise_shl_keyed(r_key, value, r_value_key, dest, r_dest_key);
    }

    void concatenate (PMC* value,  PMC* dest) {
        STRING* s = string_concat(INTERP,
            DYNSELF.get_string(),
            VTABLE_get_string(INTERP, value), 0);

        VTABLE_set_string_native(INTERP, dest, s);
    }

    void concatenate_native (STRING* value,  PMC* dest) {
        /* dest = SELF (concat) value */
        STRING* s = string_concat(INTERP,
            DYNSELF.get_string(),
            value, 0);

        VTABLE_set_string_native(INTERP, dest, s);
    }

    void concatenate_same (PMC* value,  PMC* dest) {
        STRING* s = string_concat(INTERP,
            DYNSELF.get_string(),
            VTABLE_get_string(INTERP, value), 0);

        VTABLE_set_string_native(INTERP, dest, s);
    }

    void concatenate_keyed (PMC* key, PMC* value, PMC* value_key,
            PMC* dest, PMC* dest_key) {

        /* At least one key MUST NOT be NULL */

        if (key == NULL) {

            STRING* result;

            if (value_key == NULL)
                result = string_concat(INTERP,
                    DYNSELF.get_string(),
                    VTABLE_get_string(INTERP, value), 0);
            else
                result = string_concat(INTERP,
                    DYNSELF.get_string(),
                    VTABLE_get_string_keyed(INTERP, value, value_key), 0);

            if (dest_key == NULL)
                VTABLE_set_string_native(INTERP, dest, result);
            else
                VTABLE_set_string_keyed(INTERP, dest, dest_key, result);
        }
        else
            SUPER(key, value, value_key, dest, dest_key);
    }

    void concatenate_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);

        DYNSELF.concatenate_keyed(r_key, value, r_value_key, dest, r_dest_key);
    }

    INTVAL is_equal (PMC* value) {
        /* I think we need to check everything, do the easiest first... */
        if (DYNSELF.get_integer()
                == VTABLE_get_integer(INTERP, value)
            && DYNSELF.get_number()
                == VTABLE_get_number(INTERP, value)
            && 0 == string_compare(INTERP,
                DYNSELF.get_string(),
                VTABLE_get_string(INTERP, value))
            )
        {
            return 1;
        }
        return 0;
    }

    INTVAL is_equal_keyed (PMC* key, PMC* value, PMC* value_key) {
        if (key == NULL) {
            if (DYNSELF.get_integer()
                    == VTABLE_get_integer_keyed(INTERP, value, value_key)
                && DYNSELF.get_number()
                    == VTABLE_get_number_keyed(INTERP, value, value_key)
                && 0 == string_compare(INTERP,
                    DYNSELF.get_string(),
                    VTABLE_get_string_keyed(INTERP, value, value_key))
                )
            {
                return 1;
            }
            return 0;
        }
        return SUPER(key, value, value_key);
    }

    INTVAL is_equal_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        return DYNSELF.is_equal_keyed(r_key, value, r_value_key);
    }


    INTVAL cmp_num (PMC* value) {
        /* XXX - Floating-point precision errors possible? */
        FLOATVAL diff = VTABLE_get_number(INTERP, value) -
                        DYNSELF.get_number();

        return diff == 0.0 ? 0 : diff < 0.0 ? -1 : 1;
    }

    INTVAL cmp_num_keyed (PMC* key, PMC* value, PMC* value_key) {
        if (key == NULL) {
            /* XXX - Floating-point precision errors possible? */
            FLOATVAL diff = VTABLE_get_number_keyed(INTERP, value, value_key) -
                            DYNSELF.get_number();

            return diff == 0.0 ? 0 : diff < 0.0 ? -1 : 1;
        }
        return SUPER(key, value, value_key);
    }

    INTVAL cmp_num_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        return DYNSELF.cmp_num_keyed(r_key, value, r_value_key);
    }

    INTVAL cmp_string (PMC* value) {
        return string_compare(INTERP, DYNSELF.get_string(),
            VTABLE_get_string(INTERP, value));
    }

    INTVAL cmp_string_keyed (PMC* key, PMC* value, PMC* value_key) {
        if (key == NULL)
            return string_compare(INTERP, DYNSELF.get_string(),
                VTABLE_get_string_keyed(INTERP, value, value_key));
        return SUPER(key, value, value_key);
    }

    INTVAL cmp_string_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        return DYNSELF.cmp_string_keyed(r_key, value, r_value_key);
    }

    void logical_or (PMC* value,  PMC* dest) {
        if (DYNSELF.get_bool()) {
            VTABLE_set_pmc(INTERP, dest, SELF);
        }
        else {
            VTABLE_set_pmc(INTERP, dest, value);
        }
    }

    void logical_or_keyed (PMC* key, PMC* value, PMC* value_key, PMC* dest, PMC* dest_key) {
        if (key == NULL) {
            if (DYNSELF.get_bool()) {
                if (dest_key != NULL)
                    VTABLE_set_pmc_keyed(INTERP, dest, dest_key, SELF, NULL);
                else
                    VTABLE_set_pmc(INTERP, dest, SELF);
            }
            else
                /* Either value_key or dest_key is not NULL */
                VTABLE_set_pmc_keyed(INTERP, dest, dest_key, value, value_key);
        }
        else
            SUPER(key, value, value_key, dest, dest_key);
    }

    void logical_or_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);

        DYNSELF.logical_or_keyed(r_key, value, r_value_key, dest, r_dest_key);
    }

    void logical_and (PMC* value,  PMC* dest) {
        if (DYNSELF.get_bool()) {
            VTABLE_set_pmc(INTERP, dest, value);
        }
        else {
            VTABLE_set_pmc(INTERP, dest, SELF);
        }
    }

    void logical_and_keyed (PMC* key, PMC* value, PMC* value_key, PMC* dest, PMC* dest_key) {
        if (key == NULL) {
            if (DYNSELF.get_bool())
                /* Either value_key or dest_key is not NULL */
                VTABLE_set_pmc_keyed(INTERP, dest, dest_key, value, value_key);
            else {
                if (dest_key != NULL)
                    VTABLE_set_pmc_keyed(INTERP, dest, dest_key, SELF, NULL);
                else
                    VTABLE_set_pmc(INTERP, dest, SELF);
            }
        }
        else
            SUPER(key, value, value_key, dest, dest_key);
    }

    void logical_and_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);

        DYNSELF.logical_and_keyed(r_key, value, r_value_key, dest, r_dest_key);
    }

    void logical_xor (PMC* value,  PMC* dest) {

        INTVAL my_bool, value_bool;

        my_bool = DYNSELF.get_bool();
        value_bool = VTABLE_get_bool(INTERP, value);

        if (my_bool && ! value_bool) {
            VTABLE_set_pmc(INTERP, dest, SELF);
        }
        else if (value_bool && ! my_bool) {
            VTABLE_set_pmc(INTERP, dest, value);
        }
        else {
            /* XXX - Need a better way to set FALSE */
            VTABLE_set_integer_native(INTERP, dest, 0);
        }
    }

    void logical_xor_keyed (PMC* key, PMC* value, PMC* value_key, PMC* dest, PMC* dest_key) {

        if (key == NULL) {

            INTVAL my_bool, value_bool;

            my_bool = DYNSELF.get_bool();

            if (value_key == NULL)
                value_bool = VTABLE_get_bool(INTERP, value);
            else
                value_bool = VTABLE_get_bool_keyed(INTERP, value, value_key);

            if (my_bool && ! value_bool) {
                if (dest_key == NULL)
                    VTABLE_set_pmc(INTERP, dest, SELF);
                else
                    VTABLE_set_pmc_keyed(INTERP, dest, dest_key, SELF, NULL);
            }
            else if (value_bool && ! my_bool) {
                /* Either dest_key or value_key must be non-NULL */
                VTABLE_set_pmc_keyed(INTERP, dest, dest_key, value, value_key);
            }
            else {
                /* XXX - Need a better way to set FALSE */
                if (dest_key == NULL)
                    VTABLE_set_integer_native(INTERP, dest, 0);
                else
                    VTABLE_set_integer_keyed(INTERP, dest, dest_key, 0);
            }
        }
        else
            SUPER(key, value, value_key, dest, dest_key);
    }


    void logical_xor_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);

        DYNSELF.logical_xor_keyed(r_key, value, r_value_key, dest, r_dest_key);
    }

    void logical_not (PMC* dest) {
        /* XXX - Need a better way to set boolean state */
        VTABLE_set_integer_native(INTERP, dest,
            ! DYNSELF.get_bool());
    }

    void logical_not_keyed (PMC* key, PMC* dest, PMC* dest_key) {
        /* XXX - Need a better way to set boolean state */
        if (key == NULL)
            VTABLE_set_integer_keyed(INTERP, dest,
                dest_key, ! DYNSELF.get_bool());
        else
            SUPER(key, dest, dest_key);
    }

    void logical_not_keyed_int (INTVAL* key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);
        DYNSELF.logical_not_keyed(r_key, dest, r_dest_key);
    }

    void repeat (PMC* value,  PMC* dest) {
        VTABLE_set_string_native(INTERP, dest,
            string_repeat(INTERP, VTABLE_get_string(INTERP,SELF),
                (UINTVAL)VTABLE_get_integer(INTERP, value), NULL) );
    }

    void repeat_keyed (PMC* key, PMC* value, PMC* value_key, PMC* dest, PMC* dest_key) {
            SUPER(key, value, value_key, dest, dest_key);
    }

    void repeat_keyed_int (INTVAL* key, PMC* value, INTVAL* value_key, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_value_key = INT2KEY(INTERP, value_key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);

        DYNSELF.repeat_keyed(r_key, value, r_value_key, dest, r_dest_key);
    }

    void repeat_int (INTVAL value, PMC* dest) {
        VTABLE_set_string_native(INTERP, dest,
            string_repeat(INTERP, VTABLE_get_string(INTERP,SELF),
                (UINTVAL)value, NULL) );
    }

    void repeat_int_keyed (PMC* key, INTVAL value, PMC* dest, PMC* dest_key) {
        internal_exception(OUT_OF_BOUNDS, "Subscript on something that's not an aggregate!\n");
    }

    void repeat_int_keyed_int (INTVAL* key, INTVAL value, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);
        DYNSELF.repeat_int_keyed(r_key, value, dest, r_dest_key);
    }

    void increment () {
        SELF->cache.int_val = DYNSELF.get_integer() + 1;
    }


    void decrement () {
        SELF->cache.int_val = DYNSELF.get_integer() - 1;
    }


    INTVAL defined () {
        return 1;
    }


    void substr_keyed_int(INTVAL* key, INTVAL offset, INTVAL length, PMC* dest, INTVAL* dest_key) {
        PMC* r_key = INT2KEY(INTERP, key);
        PMC* r_dest_key = INT2KEY(INTERP, dest_key);
        DYNSELF.substr_keyed(r_key, offset, length, dest, r_dest_key);
    }

    STRING* substr_str(INTVAL offset, INTVAL length) {
        return string_substr(INTERP, VTABLE_get_string(INTERP,SELF),
            offset, length, NULL, 0);
    }

    STRING* substr_str_keyed_int (INTVAL* key, INTVAL offset, INTVAL length) {
        PMC* r_key = INT2KEY(INTERP, key);
        return DYNSELF.substr_str_keyed(r_key, offset, length);
    }

}
