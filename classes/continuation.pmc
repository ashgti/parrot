/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/continuation.pmc - Continuation PMC

=head1 DESCRIPTION

A C<Continuation> has a copy of the interpreter's context at the location,
where the Continuation was constructed.
See the L<Glossary|docs/glossary.pod> for more information.

=head2 Functions

=over 4

=cut

*/


#include "parrot/parrot.h"
#include "parrot/oplib/ops.h"
#include <assert.h>


/*

=back

=head2 Methods

=over 4

=cut

*/

/*
 * A Continuation (and RetContinuation, Exception_Handler) has in its
 * context a pointer to the register frame, which contains active objects.
 * Additionally ct->current_cont has he continuation of the caller.
 * To avoid deep recursion during marking of nested subroutines, we
 * need the next_for_GC pointer in the pmc_ext area.
 */

static void
copy_args_from_callee(Interp *interpreter,
        struct parrot_regs_t *caller_regs)
{
    /*  returns           results */
    PMC *args_signature, *param_signature;
    INTVAL i, n, sig;
    opcode_t *pc, *param_pc;
    struct PackFile_Constant **constants;
    INTVAL i_arg;
    FLOATVAL f_arg;
    PMC *p_arg;
    STRING *s_arg;

    constants = interpreter->code->const_table->constants;
    /* check if there is a get_params */
    param_pc = interpreter->current_results;  /* XXX ctx. */
    assert(*param_pc == PARROT_OP_get_results_pc);
    param_signature = constants[param_pc[1]]->u.key;
    assert(PObj_is_PMC_TEST(param_signature));
    assert(param_signature->vtable->base_type == enum_class_FixedIntegerArray);

    /* we point to the set_return opcode */
    pc = interpreter->current_returns;
    assert(*pc == PARROT_OP_set_returns_pc);
    args_signature = constants[pc[1]]->u.key;
    assert(PObj_is_PMC_TEST(args_signature));
    assert(args_signature->vtable->base_type == enum_class_FixedIntegerArray);

    /* never get more then the caller expects */
    n = VTABLE_elements(interpreter, param_signature);

    for (i = 0, pc += 2, param_pc += 2; i < n; ++i) {
        /* fetch from args aka returns */
        sig = VTABLE_get_integer_keyed_int(interpreter, args_signature, i);
        switch (sig & PARROT_ARG_TYPE_MASK) {
            case PARROT_ARG_INTVAL:
                i_arg = pc[i];
                if (!(sig & PARROT_ARG_CONSTANT)) {
                    i_arg = BP_REG_INT(caller_regs, i_arg);
                }
                /* TODO verify param_signature */
                REG_INT(param_pc[i]) = i_arg;
                break;
        }
    }
}

pmclass Continuation need_ext {

/*

=item C<void init()>

Initializes the continuation.

=cut

*/

    void init () {
        PMC_cont(SELF) = new_continuation(INTERP);
        PMC_pmc_val(SELF) = NULL;
        PObj_custom_mark_destroy_SETALL(SELF);
        /*
         * Whenever we create a continuation, all return continuations
         * up the call chain maybe reused due to invoking the
         * continuation. To avoid that all return continuations are
         * converted to true continuations.
         */
        invalidate_retc_context(INTERP, &INTERP->ctx);
    }

/*

=item C<void mark()>

Marks the continuation as live.

=cut

*/

    void mark () {
        struct Parrot_cont * cc = PMC_cont(SELF);
        mark_context(INTERP, &cc->ctx);
    }

/*

=item C<void destroy()>

Destroys the continuation.

=cut

*/

    void destroy () {
        struct Parrot_cont * sub = PMC_cont(SELF);
        mem_sys_free(sub);
    }
/*

=item C<PMC *clone()>

Creates and returns a clone of the continuation.

=cut

*/

    PMC* clone() {
        struct Parrot_cont * sub;
        struct Parrot_cont *cc_self = PMC_cont(SELF);
        PMC* ret = pmc_new_noinit(INTERP, SELF->vtable->base_type);
        PObj_custom_mark_destroy_SETALL(ret);
        sub = PMC_cont(ret) = mem_sys_allocate(sizeof(struct Parrot_cont));
        memcpy(sub, cc_self, sizeof(struct Parrot_cont));

        PMC_pmc_val(ret) = PMC_pmc_val(SELF);
        return ret;
    }

/*

=item C<PMC *set_pmc()>

Assign context.

=cut

*/
    void set_pmc(PMC* src) {
        struct Parrot_cont *cc_self = PMC_cont(SELF);
        struct Parrot_cont *cc_src  = PMC_cont(src);

        memcpy(cc_self, cc_src, sizeof(struct Parrot_cont));
        PMC_pmc_val(SELF) = PMC_pmc_val(src);
    }
/*

=item C<void set_pointer(void *value)>

Sets the pointer to the actual subroutine.

=cut

*/

    void set_pointer (void* value) {
        PObj_get_FLAGS(SELF) |= PObj_private1_FLAG;
        PMC_cont(SELF)->address = value;
    }

/*

=item C<void *get_pointer()>

Returns the pointer to the actual subroutine.

=cut

*/

    void* get_pointer () {
        return PMC_cont(SELF)->address;
    }
/*

=item C<INTVAL defined()>

=item C<INTVAL get_bool()>

Returns whether the subroutine is defined.

=cut

*/

    INTVAL defined () {
        return PMC_cont(SELF)->address != NULL;
    }

    INTVAL get_bool () {
        return PMC_cont(SELF)->address != NULL;
    }

/*

=item C<void *invoke(void *next)>

Restores the "context" of the interpreter and returns the branch
destination to continue execution.

=cut

*/

    void* invoke (void* next) {
        struct Parrot_cont * cc = PMC_cont(SELF);
        struct parrot_regs_t *caller_regs;

        caller_regs = INTERP->ctx.bp;
        restore_context(INTERP, &cc->ctx);
        if (Interp_trace_TEST(INTERP, PARROT_TRACE_SUB_CALL_FLAG)) {
            PMC *sub = INTERP->ctx.current_sub;
            STRING *unk = CONST_STRING(INTERP, "(unknown");
            PIO_eprintf(INTERP, "# Back in sub '%Ss'\n",
                Parrot_full_sub_name(INTERP, sub));
        }
        if (cc->address) {
            if (INTERP->current_results) {      /* XXX ctx. */
                copy_args_from_callee(INTERP, caller_regs);
            }
            else {
                copy_regs(INTERP, caller_regs);
            }
        }
        else if (!cc->seg) {
            /* no address and no segment */
            return NULL;
        }
        if (INTERP->code != cc->seg) {
            Parrot_switch_to_cs(INTERP, cc->seg, 1);
        }
        return cc->address;
    }

/*

=item C<STRING* get_string()>

Experimental: return caller info as a STRING.

=cut

*/

    STRING* get_string() {
	return Parrot_Context_infostr(INTERP, &PMC_cont(SELF)->ctx);
    }

/*

=item C<METHOD PMC* "caller"()>

Experimental: return caller PMC or Undef if none.

=cut

*/

    METHOD PMC* caller() {
        struct Parrot_cont * cc = PMC_cont(SELF);
        PMC *caller = cc->ctx.current_sub;
        if (!caller || !PMC_sub(caller)->address) {
            caller = pmc_new(INTERP, enum_class_Undef);
        }
        return caller;

    }
/*

=item C<METHOD PMC* "continuation"()>

Experimental: return continuation PMC of this Continuation or Undef if none.

=cut

*/

    METHOD PMC* continuation() {
        struct Parrot_cont * cc = PMC_cont(SELF);
        PMC *cont = cc->ctx.current_cont;
        if (cont)
            return cont;
        return pmc_new(INTERP, enum_class_Undef);
    }
}

/*

=back

=head1 HISTORY

Initial revision by sean 2002/08/04.

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
