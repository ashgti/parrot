/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/parrotclass.pmc - Parrot Class

=head1 DESCRIPTION

The structure of a parrot class is reasonably straightforward. The PMC's
cached integer value is the number of attribute slots that an object of
this type requires. The data pointer holds a pointer to an array of
PMCs. That array has:

=over 4

=item 0, PCD_PARENTS

An array of immediate parents.

=item 1, PCD_CLASS_NAME

The class name PMC.

=item 2, PCD_ALL_PARENTS

A pruned array of all parents, in search order.

=item 3, PCD_ATTRIB_OFFS

A hash, keys are the class names, values are the offsets to their attributes.

=item 4, PCD_ATTRIBUTES

A hash, the keys are the classname/attrib name pair (separated by a
C<NULL>), while the value is the offset to the attribute.

=item 5, PCD_CLASS_ATTRIBUTES

Array of attribute of this class.

=item 6, PCD_OBJECT_VTABLE

Vtable PMC that holds the vtable for objects of this class.

=back

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass ParrotClass extends delegate need_ext {

/*

=item C<void init()>

Initializes the class.

=cut

*/

    void init () {
        /* No attributes to start with */
        PMC_int_val(SELF) = ATTRIB_COUNT(SELF) = 0;
        /* But we are a class, really */
        PObj_is_class_SET(SELF);
        PObj_data_is_PMC_array_SET(SELF);
        /* s. Parrot_new_class() for more initialization */
    }

/*

=item C<INTVAL isa(STRING *classname)>

Returns whether the class is or inherits from C<*classname>.

=cut

*/

    INTVAL isa(STRING* classname) {
        PMC *class;
        if (SUPER(classname))
            return 1;
        class = Parrot_class_lookup(interpreter, classname);
        return Parrot_object_isa(INTERP, SELF, class);
    }

/*

=item C<PMC *find_method(STRING *name)>

Figure out which method PMC we need. By default we just defer to the
system method lookup code.

=cut

*/

    PMC* find_method(STRING* name) {
        return Parrot_find_method_with_cache(INTERP, SELF, name);
    }

/*

=item C<INTVAL can(STRING *method)>

Returns whether the class can perform C<*method>.

=item C<PMC *get_class()>

Return SELF.

=cut

*/

    INTVAL can(STRING* method) {
        return VTABLE_find_method(interpreter, SELF, method) != NULL;
    }

    PMC* get_class() {
        return SELF;
    }

/*

=item C<void visit(visit_info *info)>

This is used by freeze/thaw to visit the contents of the class.

C<*info> is the visit info, (see F<include/parrot/pmc_freeze.h>).

=item C<void freeze(visit_info *info)>

Used to archive the class.

=item C<void thaw(visit_info *info)>

Used to unarchive the class.

=item C<void thawfinish(visit_info *info)>

Create the class from the thawed parents and attributes array.

=cut

*/

    void visit(visit_info *info) {
        PMC **class_data, **pos;

        class_data = (PMC **)PMC_data(SELF);

        if (info->extra_flags == EXTRA_CLASS_EXISTS)
            PIO_eprintf(INTERP, "class exists\n");
        /* 2) direct parents array */
        pos = class_data + PCD_PARENTS;
        (info->visit_pmc_now)(interpreter, *pos, info);

        /* 3) attributes array */
        pos = class_data + PCD_CLASS_ATTRIBUTES;
        (info->visit_pmc_now)(interpreter, *pos, info);

        SUPER(info);
    }

    void freeze(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        PMC **class_data, **pos;

        SUPER(info);
        class_data = (PMC **)PMC_data(SELF);

        /* 1) freeze class name */
        pos = class_data + PCD_CLASS_NAME;
        io->vtable->push_string(INTERP, io,
                VTABLE_get_string(INTERP, *pos));

    }

    void thaw(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        STRING *mark, *s;
        PMC *class;

        SUPER(info);
        if (info->extra_flags == EXTRA_IS_NULL) {
            STRING *class_name;
            INTVAL new_type;
            PMC *ar;

            /* thaw class name */
            class_name = io->vtable->shift_string(INTERP, io);
            /* if class exists in this interpreter, check if the
             * thawed class is the same, if not bail out, if yes
             * ignore the class, consume the byte string
             */
            new_type = pmc_type(INTERP, class_name);
            if (new_type > enum_type_undef) {
                /* info->extra_flags = EXTRA_CLASS_EXISTS; */
            }
            else {
                class = *info->thaw_ptr;
                Parrot_new_class(INTERP, class, class_name);
            }
        }
    }

    void thawfinish(visit_info *info) {
        INTVAL i, n;
        PMC * class = SELF;
        PMC *parents, *attribs;
        int ignore = 0; /* XXX */
        PMC **class_data = (PMC **)PMC_data(SELF);

        /*
         * we now have two plain arrays: parents and attributes
         * TODO if class did exists compare these with the
         *      information in the class
         * TODO don't thaw directly into class array - this destroys
         *      existing classes
         */

        parents = class_data[PCD_PARENTS];
        n = VTABLE_elements(INTERP, parents);
        for (i = 0; i < n; ++i) {
            Parrot_add_parent(INTERP, class,
                    VTABLE_get_pmc_keyed_int(INTERP, parents, i));
        }
        /*
         * preserve the thawed attrib array
         */
        attribs = class_data[PCD_CLASS_ATTRIBUTES];
        attribs = VTABLE_clone(INTERP, attribs);
        /* set an empty one in the class */
        class_data[PCD_CLASS_ATTRIBUTES] = pmc_new(INTERP, enum_class_Array);

        n = VTABLE_elements(INTERP, attribs);
        for (i = 0; i < n; ++i) {
            Parrot_add_attribute(INTERP, class,
                    VTABLE_get_string_keyed_int(INTERP, attribs, i));
        }
    }

}

/*
=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
