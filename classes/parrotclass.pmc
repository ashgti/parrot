/* parrotclass.pmc
 *  Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
 *  CVS Info
 *     $Id$
 *  Overview:
 *     These are the vtable functions for the ParrotClass base class
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *  References:
 */

/* The structure of a parrot class is reasonably straightforward. The
   PMC's cached integer value is the number of attribute slots that
   an object of this type requires. The data pointer holds a pointer
   to an array of PMCs. That array has:

   0: An array of immediate parents
   1: The class name PMC
   2: An array of all parents, in search order
   3: A hash, keys are the class names, values are the offsets to
      their attributes
   4: A hash, the keys are the classname/attrib name pair (separated
      by a NULL), while the value is the offset to the attribute

*/

#include "parrot/parrot.h"

pmclass ParrotClass need_ext {

  void init () {
    /* Hang an array off the data pointer, empty of course */
    PMC_data(SELF) = pmc_new(interpreter, enum_class_SArray);
    /* We will have five entries in this array */
    VTABLE_set_integer_native(interpreter, (PMC*)PMC_data(SELF), (INTVAL)5);
    /* No attributes to start with */
    SELF->cache.int_val = 0;
    /* But we are a class, really */
    PObj_is_class_SET(SELF);
    /* And, coincidentally, data points to a PMC. Fancy that... */
    PObj_flag_SET(is_PMC_ptr, SELF);
  }

    INTVAL isa(STRING * classname) {
	PMC *class = Parrot_class_lookup(interpreter, classname);
	if (PMC_IS_NULL(class))
	    return 0;
        return Parrot_object_isa(INTERP, SELF, class);
    }

    /* Figure out which method PMC we need. By default we just defer to the
     * system method lookup code
     */
    PMC* find_method(STRING* name) {
	PMC *class = VTABLE_get_pmc_keyed_int(INTERP, (PMC *)PMC_data(SELF), 0);
	return Parrot_find_method_with_cache(INTERP, class, name);
    }


}
