/*
Copyright: 2001-2005 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/scratchpad.pmc - Lexical Scratchpad

=head1 DESCRIPTION

These are the vtable functions for the Scratchpad PMC.

A ScratchPad PMC is a FixedPMCArray of OrderedHashes. It is used in the implementation
of the opcodes in F<ops/var.ops>.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass Scratchpad need_ext extends FixedPMCArray {

/*

=item C<PMC *get_pmc_keyed(PMC *key)>

Get a lexical variable. The key types are expected to match
one of the following:

=over 4

=item C<[STRING]>

A lexical name.

=item C<[INT]>

A lexical position in the current scope.

=item C<[INT;STRING]>

A scope, and a lexical name.

=item C<[INT;INT]>

A scope, and a lexical position in that scope.

=back

=cut

*/

    PMC* get_pmc_keyed (PMC* key) {
        INTVAL pad_index = 0, position = 0;
        STRING * name = NULL;
        PMC * ret = NULL;
        PMC * key2 = key_next(INTERP, key);
        PMC * name_key = key2 ? key2 : key;

        if (key_type(INTERP, name_key) == KEY_integer_FLAG) {
            position = key_integer(INTERP, name_key);
        }
        else if (key_type(INTERP, name_key) == KEY_string_FLAG) {
            name = key_string(INTERP, name_key);
        }
        else {
            internal_exception(-1, "Invalid key");
        }

        if (key2) {
            if (key_type(INTERP, key) == KEY_integer_FLAG) {
                pad_index = key_integer(INTERP, key);
            }
            else {
                internal_exception(-1, "Invalid key");
            }
            if (name)
                ret = scratchpad_get_by_name(INTERP, SELF, pad_index,
                                       name);
            else
                ret = scratchpad_get_by_index(INTERP, SELF, pad_index,
                                       position);
        }
        else {
            if (name)
                ret = scratchpad_find(INTERP, SELF, name);
            else
                ret = scratchpad_get_by_index(INTERP, SELF, -1, position);
        }

        return ret;
    }

    PMC* get_pmc_keyed_int (INTVAL key) {
        return scratchpad_get_by_index(INTERP, SELF, -1, key);
    }

    PMC* get_pmc_keyed_str (STRING* key) {
        return scratchpad_find(INTERP, SELF, key);
    }


/*

=item C<void set_pmc_keyed(PMC *key, PMC *value)>

Store a value as a lexical variable. The same key types that
C<get_pmc_keyed()> supports are supported here.

=cut

*/

    void set_pmc_keyed (PMC* key, PMC* value) {
        INTVAL pad_index = 0, position = 0;
        STRING * name = NULL;
        PMC * key2 = key_next(INTERP, key);
        PMC * name_key = key2 ? key2 : key;

        if (key_type(INTERP, name_key) == KEY_integer_FLAG) {
            position = key_integer(INTERP, name_key);
        }
        else if (key_type(INTERP, name_key) == KEY_string_FLAG) {
            name = key_string(INTERP, name_key);
        }
        else {
            internal_exception(-1, "Invalid key");
        }

        if (key2) {
            if (key_type(INTERP, key) == KEY_integer_FLAG) {
                pad_index = key_integer(INTERP, key);
            }
            else {
                internal_exception(-1, "Invalid key");
            }
            if (name)
                scratchpad_store_by_name(INTERP, SELF, pad_index, name,
                                   value);
            else
                scratchpad_store_by_index(INTERP, SELF, pad_index, position,
                                   value);
        }
        else {
            if (name)
                scratchpad_store(INTERP, SELF, name, value);
            else
                scratchpad_store_by_index(INTERP, SELF, -1, position, value);
        }
    }

    void set_pmc_keyed_int (INTVAL key, PMC *value) {
        scratchpad_store_by_index(INTERP, SELF, -1, key, value);
    }

    void set_pmc_keyed_str (STRING *key, PMC *value) {
        scratchpad_store(INTERP, SELF, key, value);
    }

/*

=item C<void delete_keyed(PMC *key)>

Deletes the lexical variable for C<*key>.

=cut

*/

    void delete_keyed(PMC* key) {
        STRING * name = NULL;
        INTVAL position;

        if (key_type(INTERP, key) == KEY_integer_FLAG) {
            position = key_integer(INTERP, key);
            /* TODO */
        }
        else if (key_type(INTERP, key) == KEY_string_FLAG) {
            name = key_string(INTERP, key);
            scratchpad_delete(INTERP, SELF, name);
        }
        else {
            return;
        }
    }
}

/*

=back

=head1 SEE ALSO

F<ops/var.ops>
F<src/lexical.c>

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
