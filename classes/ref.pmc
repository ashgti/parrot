/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/ref.pmc - Reference to a PMC

=head1 DESCRIPTION

The vtable functions for the Ref base class.

All methods not present below get a default body autogenerated inside
C<Parrot::Pmc2c>.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "parrot/method_util.h"
/*
 * bxor and bxor_int are already MMDs - dispatch
 * TODO generate appropriate macros
 */

#define VTABLE_bitwise_xor(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_BXOR)
#define VTABLE_bitwise_xor_int(i,l,r,d) mmd_dispatch_v_pip(i,l,r,d,MMD_BXOR_INT)
#define VTABLE_add(i, l, r, d) mmd_dispatch_v_ppp(i, l, r, d, MMD_ADD)
#define VTABLE_subtract(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_SUBTRACT)
#define VTABLE_multiply(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_MULTIPLY)
#define VTABLE_divide(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_DIVIDE)
#define VTABLE_modulus(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_MOD)
#define VTABLE_cmodulus(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_CMOD)
#define VTABLE_bitwise_and(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_BAND)
#define VTABLE_bitwise_ors(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_SOR)
#define VTABLE_bitwise_ands(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_SAND)
#define VTABLE_bitwise_xors(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_SXOR)
#define VTABLE_bitwise_shl(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_BSL)
#define VTABLE_bitwise_shr(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_BSR)
#define VTABLE_bitwise_or(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_BOR)
#define VTABLE_concatenate(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_CONCAT)
#define VTABLE_logical_or(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_LOR)
#define VTABLE_logical_and(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_LAND)
#define VTABLE_logical_xor(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_LXOR)
#define VTABLE_repeat(i,l,r,d) mmd_dispatch_v_ppp(i,l,r,d,MMD_REPEAT)
#define VTABLE_cmp(i,l,r) mmd_dispatch_i_pp(i,l,r,MMD_CMP)
#define VTABLE_cmp_num(i,l,r) mmd_dispatch_i_pp(i,l,r,MMD_NUMCMP)
#define VTABLE_cmp_string(i,l,r) mmd_dispatch_i_pp(i,l,r,MMD_STRCMP)
#define VTABLE_is_equal(i,l,r) mmd_dispatch_i_pp(i,l,r,MMD_EQ)
#define VTABLE_is_equal_num(i,l,r) mmd_dispatch_i_pp(i,l,r,MMD_NUMEQ)
#define VTABLE_is_equal_str(i,l,r) mmd_dispatch_i_pp(i,l,r,MMD_STREQ)


pmclass Ref does ref {

/*

=item C<void init()>

Raises an exception. Use C<init_pmc()> instead.

=cut

*/

    void init () {
        internal_exception(1, "Ref init without PMC\n");
    }

/*

=item C<void init_pmc(PMC *initializer)>

Sets the referenced PMC to C<*initializer>.

If C<initializer> is C<NULL> then an exception is raised.

=cut

*/

    void init_pmc (PMC* initializer) {
        if (initializer) {
            PMC_pmc_val(SELF) = initializer; /* the refered PMC itself */
            PObj_custom_mark_SET(SELF);
            /*
             * if referred PMC needs active destruction
             * we have to pass it on
             */
            if (PObj_active_destroy_TEST(initializer))
                PObj_active_destroy_SET(SELF);
        }
        else
            internal_exception(1, "Ref init with NULL PMC\n");
    }

/*

=item C<void init_pmc_props(PMC *init, PMC *props)>

Sets the referenced PMC to C<*init>, and associates the properties in
C<*props> with the reference.


=cut

*/

    void init_pmc_props(PMC* init, PMC* props) {
        SUPER(init, props);
    }

/*

=item C<void set_pmc(PMC *other)>

Sets the referenced PMC to C<*other>.

=item C<PMC* get_pmc()>

Get the referenced PMC.

=cut

*/

    void set_pmc(PMC* other) {
        PObj_active_destroy_CLEAR(SELF);
        SELF.init_pmc(other);
    }

    PMC* get_pmc() {
        return PMC_pmc_val(SELF);
    }

/*

=item C<void mark()>

Marks the referenced PMC as live.

=cut

*/

    void mark () {
        pobject_lives(INTERP, (PObj *) PMC_pmc_val(SELF));
    }

/*

=back

These two methods must be implemented because they are not delegated.

=over 4

=item C<INTVAL type()>

Returns the type of the PMC, not the type of the referenced PMC.

=cut

*/

    INTVAL type() {
        return SUPER();
    }

/*

=item C<STRING *name()>

Returns the name of the PMC, not the name of the referenced PMC.

=cut

*/

    STRING* name() {
        return SUPER();
    }
}

/*

=back

=head1 HISTORY

Initial revision by leo 2003.09.01.

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
