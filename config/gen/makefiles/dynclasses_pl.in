# Copyright: 2001-2005 The Perl Foundation.  All Rights Reserved.
# $Id$

=head1 NAME

tools/build/build_dynclasses.pl - Build script for dynamic PMCs 

=head1 DESCRIPTION

This file is generated by F<config/gen/makefiles.pl> from
F<config/gen/makefiles/dynclasses_pl.in>. 
This script is used for building dynamic PMCs.

=cut

use strict;

use File::Copy qw(copy);

# qq[] isn't guaranteed to work, but it's safer than "" as some platforms
# (eg FreeBSD) have ""s embedded in their substution values. q[] is used in
# some places as Win32 paths have \'s in, which qq[] treats as escape sequences.
# Config stuff
our $CC = qq[${cc} -c];
our $LD = qq[${ld}];
our $LDFLAGS = qq[${ldflags} ${ld_debug}];
our $LD_LOAD_FLAGS = qq[${ld_load_flags}];
our $PERL = q[${perl}];
our $LOAD_EXT = qq[${load_ext}];
our $O = qq[${o}];
our $LIBPARROT = qq[${build_dir}/src/extend${o}];
    # XXX: ultimately, this should be replaced with:
    #  $LIBPARROT = qq[-L../blib/lib -lparrot];
our $CFLAGS = qq[${ccflags} ${cc_shared} ${cc_debug} ${ccwarn} ${cc_hasjit} ${cg_flag} ${gc_flag} ${cc_building_dynclass_flag}];

# Here comes some stuff for Win32.
our $PATHQUOTE = '';
if ($^O eq 'MSWin32') {
    # Paths need quoting as they may contain spaces.
    $PATHQUOTE = '"';
    
    $LD_LOAD_FLAGS =~ s/(-def:)/$1..\\/;
    $LIBPARROT = '${build_dir}/parrot${a}';
}

# PMC2C Config
our $PMC2C = "$PERL $PATHQUOTE" . q[${build_dir}${slash}tools${slash}build${slash}pmc2c.pl] . $PATHQUOTE;

# Actual commands
sub compile_cmd {
    my ($target, $source) = @_;

    return
        "$CC $CFLAGS " .
        "${cc_o_out}" . $target . " " .
        "-I" . $PATHQUOTE . '${build_dir}${slash}include' . $PATHQUOTE . " " .
        "-I" . $PATHQUOTE . '${build_dir}${slash}classes' . $PATHQUOTE . " " .
        $source;
};

sub partial_link_cmd {
    my ($target, $libs, $sources) = @_;
    
    my $liblist;
    my $def = '';
    if ($^O =~ /mswin32/i) {
        # Need to put various libraries in the link line.
        $liblist = join( ' ', map { "$_.lib" } keys %$libs );
        if ($CC =~ /gcc/i) {
            $liblist =~ s/gdbm\.lib/-llibgdbm/i;
        }
        my $extraLibs = '${libs} ${icu_shared}';
        $extraLibs =~ s/blib/..\\blib/g;
        $extraLibs =~ s/\Q$(A)\E/.lib/g;
        $liblist .= ' ' . $extraLibs;
        if ($CC =~ /gcc/i) {
            $def = "$target ";
        } else {
            $def = "-def:$target ";
        }
        $def =~ s/\.dll/.def/i;
    } else {
        $liblist = join( ' ', map { "-l$_" } keys %$libs );
    }

    return
        "$LD $LDFLAGS $LD_LOAD_FLAGS ".
        "${ld_out}" . $target . " " . $def .
        join(" ", map {"$PATHQUOTE$_$PATHQUOTE"} @$sources) .
        " $liblist $PATHQUOTE$LIBPARROT$PATHQUOTE";
}

our $NOW = time();

################### MAIN PROGRAM ################

my ($mode, @pmcs) = @ARGV;

if ($mode eq 'generate') {
    # Convert X.pmc -> X.dump and X.c and also create any lib-GROUP.c files

    generate_dump($_) foreach (@pmcs);
    generate_c($_) foreach (@pmcs);

    my ($group_files, $group_libs, $pmc_group, $pmc_libs) = 
        gather_groups_and_libs(@pmcs);

    while (my ($group, $pmcs) = each %$group_files) {
        my @pmcfiles = map { "$_.pmc" } @$pmcs;
        if (needs_build("$group.c", @pmcfiles)) {
            run("$PMC2C --library $group --c " . join(" ",@pmcfiles))
              or die "pmc2c library creation failed ($?)\n";
        }
    }
} 
elsif ($mode eq 'compile') {
    my ($group_files, $group_libs, $pmc_group, $pmc_libs) = 
        gather_groups_and_libs(@pmcs);

    # Convert X.c -> X.o for all X.c
    compile($_) foreach (@pmcs);

    # lib-GROUP.c
    for my $group (keys %$group_files) {
        compile("$group", "lib-$group")
          or die "compile $group.c failed ($?)\n";
    }
} 
elsif ($mode eq 'linklibs') {
    my ($group_files, $group_libs, $pmc_group, $pmc_libs) = 
        gather_groups_and_libs(@pmcs);

    # Convert lib-GROUP.so + A.so + B.so ... -> GROUP.so
    while (my ($group, $pmcs) = each %$group_files) {
        partial_link($group, $group_libs->{$group}, [ "lib-$group", @$pmcs ] )
          or die "partial link of $group failed ($?)\n";
    }

    # Link non-grouped PMCs individually
    my @ungrouped_pmcs = grep { ! exists $pmc_group->{$_} } @pmcs;
    partial_link($_, $pmc_libs->{$_}, [ $_ ] ) foreach (@ungrouped_pmcs);
} 
elsif ($mode eq 'copy') {
    # Copy *.so -> destination, where destination is the first
    # argument, given as --destination=DIRECTORY
    shift(@pmcs) =~ /--destination=(.*)/
      or die "copy command requires destination";
    my $dest = $1;

    my ($group_files, $group_libs, $pmc_group, $pmc_libs) = 
        gather_groups_and_libs(@pmcs);
    my @ungrouped_pmcs = grep { ! exists $pmc_group->{$_} } @pmcs;

    foreach (@ungrouped_pmcs, keys %$group_files) {
        copy("$_$LOAD_EXT", $dest) or die "Copy $_$LOAD_EXT failed ($?)\n";

        # Execute permissions on libraries is especially important on
        # some platforms
        if ($^O eq 'hpux' or $^O eq 'cygwin') {
            chmod 0755, "$dest${slash}$_$LOAD_EXT";
        }

    }
}
else {
    die "invalid command '$mode'\nmust be one of generate, compile, linklibs, or copy\n";
}

sub run {
    print join(" ", @_), "\n";

    return system(@_) == 0;
}

# XXX: ordering of libs might be crucial
sub gather_groups_and_libs {
    my @pmcs = @_;

    my ( %group_files, %group_libs, %pmc_group, %pmc_libs );
    for my $pmc (@pmcs) {
        our $class;
        require "$pmc.dump";
 
        # there can be many libs
        my %libs = %{ $class->{flags}{lib} || {} };
        $pmc_libs{$pmc} = \%libs;

        # There should be at most a single group
        my $group = $class->{flags}{group}
          or next;
        ($group) = keys %$group;
        $pmc_group{$pmc} = $group;
        push @{ $group_files{$group} }, $pmc;
        $group_libs{$group} ||= {};
        foreach my $lib ( keys %libs ) {
            $group_libs{$group}->{lib} = 1;
        }
    }

    return (\%group_files, \%group_libs, \%pmc_group, \%pmc_libs);
}

sub modtime {
    my $ago = (-M shift);

    if (defined $ago) {
        return $NOW - $ago;
    } else {
        return;
    }
}

sub needs_build {
    my ($target, @sources) = @_;

    my $target_mod = modtime($target)
      or return 1;
    for my $source (@sources) {
        return 1 if modtime($source) > $target_mod;
    }

    return 0;
}

sub generate_dump {
    my ($pmc) = @_;

    if (needs_build("$pmc.dump", "$pmc.pmc")) {
        run("$PMC2C --dump $pmc.pmc")
          or die "pmc2c dump failed ($?)\n";
    }
}

sub generate_c {
    my ($pmc) = @_;

    if (needs_build("$pmc.c", "$pmc.pmc")) {
        run("$PMC2C --c $pmc.pmc")
          or die "pmc2c code generation failed ($?)\n";
    }
}

sub compile {
    my ($src_stem, $dest_stem) = @_;

    $dest_stem ||= $src_stem;
    if (needs_build("$dest_stem$O", "$src_stem.c")) {
        run(compile_cmd("$dest_stem$O", "$src_stem.c"))
          or die "compile $src_stem.c failed ($?)\n";
    }
    else {
        1;
    }
}

sub partial_link {
    my ($group, $libs, $stems) = @_;

    my @sources = map { "$_$O" } @$stems;
    if (needs_build("$group$LOAD_EXT", @sources)) {
        run(partial_link_cmd("$group$LOAD_EXT", $libs, \@sources))
          or die "partial link $group$LOAD_EXT failed ($?)\n";
    }
    else {
        1;
    }
}
