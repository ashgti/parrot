/*
Copyright (C) 2001-2010, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/nci.pmc - Native Call Interface

=head1 DESCRIPTION

The vtable functions for the native C call functions.

=head2 Methods

=over 4

=cut

*/

/* HEADERIZER HFILE: none */
/* HEADERIZER BEGIN: static */
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */

PARROT_IGNORABLE_RESULT
static nci_thunk_t /*@alt void@*/
build_func(PARROT_INTERP,
    ARGMOD(Parrot_NCI_attributes *nci_info))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2)
        FUNC_MODIFIES(*nci_info);

static void pcc_params(PARROT_INTERP,
    ARGIN(STRING *sig),
    ARGMOD(Parrot_NCI_attributes *nci_info),
    size_t sig_length)
        __attribute__nonnull__(1)
        __attribute__nonnull__(2)
        __attribute__nonnull__(3)
        FUNC_MODIFIES(*nci_info);

#define ASSERT_ARGS_build_func __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(nci_info))
#define ASSERT_ARGS_pcc_params __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(sig) \
    , PARROT_ASSERT_ARG(nci_info))
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */
/* HEADERIZER END: static */

#define ADD_DIGIT(x) digit *= 10;\
                     digit += x;

/* Structure Reference Object, contains its signature and an pointer to its defintion */
typedef struct struct_ref_t {
    char * const identifier;
    ffi_type *structure_def;
    void * pmc_obj;
} struct_ref_t;

static void
pcc_params(PARROT_INTERP, ARGIN(STRING *sig), ARGMOD(Parrot_NCI_attributes *nci_info),
                size_t sig_length)
{
    ASSERT_ARGS(pcc_params)

    /* NCI and PCC have a 1 to 1 mapping except an
       extra char in PCC for invocant and slurpy */
    size_t       buf_length = sig_length + 2 + 1;

    /* avoid malloc churn on common signatures */
    char         static_buf[16];
    char * const sig_buf = sig_length <= sizeof static_buf ?
                            static_buf :
                            (char *)mem_sys_allocate(buf_length);

    size_t j = 0;
    size_t i;

    ffi_type sig_type;
    ffi_type *sig_type_elements[12345];

    sig_type.size = sig_type.alignment = 0;
    sig_type.elements = &sig_type_elements;
    
    ffi_cif cif;
    ffi_type ret_type;
    ffi_closure *closure;

    while (i < sig_length) {
        const INTVAL c = Parrot_str_indexed(interp, sig, i);

        PARROT_ASSERT(j < buf_length - 1);
 
        switch (c) {
        /* Identifiers: 
         *  c: character (normally 8 bits)
         *  b: byte (int8)
         *  w: w_char (system dependent) 
         *  s: short (int16)
         *  l: long (int32)
         *  i: int (int32)
         *  q: long long (int64)
         *  f: float
         *  d: double
         *  D: long double (if supported. On Windows this 
         *                  is a double, but on other systems 
         *                  its a 128 bit quadruple 
         *                  precision floating point)
         *  v: void
         *  t: char*
         *  J: The Parrot Interpreter
         *  P: PMC
         *  U: Callback pointer
         *  @: Parrot slurpy
         *  .: var args identifier
         *  U: callback pointer
         *  x: Alignment identifier
         */ 
        case (INTVAL)'c':

            break;
        case (INTVAL)'b':
        case (INTVAL)'w':
        case (INTVAL)'s':
        case (INTVAL)'l':
        case (INTVAL)'i':
        case (INTVAL)'q':
        case (INTVAL)'f':
        case (INTVAL)'d':
        case (INTVAL)'D':
        case (INTVAL)'v':
        case (INTVAL)'t':
        case (INTVAL)'P':
        case (INTVAL)'.':
        case (INTVAL)'U':
        case (INTVAL)'x':
            break;
        /* Prefix: 
         *  *: Pointer to Identifer 
         *  s: Signed Identifer (Primitives only)
         *  u: Unsigned Identifier (Primitives only)
         *  &: Pass by reference parameter
         *  !: Native Type for Identifier (Primitives only)
         *  ^: UnManaged Identifier (structures and strings)
         *  <: Force Little Endian (structures only)
         *  >: Force Big Endian (structures only)
         */
        case (INTVAL)'*':
        case (INTVAL)'s':
        case (INTVAL)'u':
        case (INTVAL)'&':
        case (INTVAL)'!':
        case (INTVAL)'^':
        case (INTVAL)'>':
        case (INTVAL)'<':
            break;
        /* Infix:
         *  |: Union infix of Primitive types
         */ 
        case (INTVAL)'|':
            break;
        /* Postfix:
         *  0-9: Integer size, eg. i32, i8, i64 (only for i Primitives)
         *  {...}: Identifier for a structure value
         *  [...]: Size of an array
         */
        case (INTVAL)'0':
            ADD_DIGIT(0); 
            break;
        case (INTVAL)'1':
            ADD_DIGIT(1); 
            break;
        case (INTVAL)'2':
            ADD_DIGIT(2); 
            break;
        case (INTVAL)'3':
            ADD_DIGIT(3); 
            break;
        case (INTVAL)'4':
            ADD_DIGIT(4); 
            break;
        case (INTVAL)'5':
            ADD_DIGIT(5); 
            break;
        case (INTVAL)'6':
            ADD_DIGIT(6); 
            break;
        case (INTVAL)'7':
            ADD_DIGIT(7); 
            break;
        case (INTVAL)'8':
            ADD_DIGIT(8);
            break;
        case (INTVAL)'9':
            ADD_DIGIT(9);
            break;
        case (INTVAL)'{':
        case (INTVAL)'}':
        case (INTVAL)'[':
        case (INTVAL)']':
            break;
        /* Circumfix:
         *   (...): Creates a structure. 
         */ 
        case (INTVAL)'(':
        case (INTVAL)')':
            break; 
        default:
            Parrot_ex_throw_from_c_args(interp, NULL,
                    EXCEPTION_JIT_ERROR,
                    "Unknown param Signature %c\n", (char)c);
            break;
        } 
    }

    

    PARROT_ASSERT(j < buf_length);
    sig_buf[j++] = '\0';


    nci_info->pcc_return_signature =
        Parrot_str_new(interp, sig_buf, 1);

    nci_info->pcc_params_signature = j ?
        Parrot_str_new(interp, sig_buf + 1, j - 1) :
        CONST_STRING(interp, "");

    if (sig_buf != static_buf)
        mem_sys_free(sig_buf);
}

/* actually build the NCI thunk */

PARROT_IGNORABLE_RESULT
static nci_thunk_t
build_func(PARROT_INTERP, ARGMOD(Parrot_NCI_attributes *nci_info))
{
    ASSERT_ARGS(build_func)

    STRING * const key      = nci_info->signature;
    const size_t key_length = Parrot_str_byte_length(interp, key);

    ffi_type *ret;
    ffi_type *args;

    pcc_params(interp, key, nci_info, key_length);

    /* Arity is length of that string minus one (the return type). */
    nci_info->arity       = key_length - 1;

    /* Build call function. */
    nci_info->fb_info     = build_call_func(interp, key);
    nci_info->func        = F2DPTR(VTABLE_get_pointer(interp, nci_info->fb_info));

    return (nci_thunk_t)nci_info->func;
}


pmclass NCI auto_attrs provides invokable {
    /* NCI thunk handling attributes */
    ATTR void      *signature;              /* The signature object. */
    ATTR void      *func;                   /* Function pointer to call. */
    ATTR PMC       *fb_info;                /* Frame-builder info */
    ATTR void      *orig_func;              /* Function pointer
                                             * used to create func */
    /* Parrot Sub-ish attributes */
    ATTR void      *pcc_params_signature;
    ATTR void      *pcc_return_signature;
    ATTR INTVAL    arity;                   /* Cached arity of the NCI. */

    /* MMD fields */
    ATTR STRING    *long_signature;         /* The full signature. */
    ATTR PMC       *multi_sig;              /* type tuple array (?) */
    ATTR PMC       *library;                /* The library that this NCI is in, if any */

/*

=item C<METHOD get_multisig()>

Return the MMD signature PMC, if any or a Null PMC.

=cut

*/

    METHOD get_multisig() {
        PMC *sig;
        GET_ATTR_multi_sig(INTERP, SELF, sig);
        if (PMC_IS_NULL(sig))
            sig = PMCNULL;
        RETURN(PMC *sig);
    }

/*

=item C<METHOD set_raw_nci_ptr(void *func)>

Sets the specified function pointer and raw flag.

=cut

*/

    METHOD make_raw_nci(PMC *func) {
        VTABLE_set_pointer(interp, SELF, (void *)func);
    }

/*

=item C<void init()>

Initializes the NCI with a C<NULL> function pointer.

=cut

*/

    VTABLE void init() {
        /* Mark that we're not a raw NCI. */
        PObj_flag_CLEAR(private2, SELF);
        PObj_custom_mark_SET(SELF);
    }

/*

=item C<void set_pointer_keyed_str(STRING *key, void *func)>

Sets the specified function pointer and signature (C<*key>).

=cut

*/

    VTABLE void set_pointer(void *ptr) {
        SET_ATTR_orig_func(INTERP, SELF, ptr);
        PObj_flag_SET(private2, SELF);
    }

    VTABLE void *get_pointer() {
        return PARROT_NCI(SELF)->orig_func;
    }

    VTABLE void set_pointer_keyed_str(STRING *key, void *func) {
        Parrot_NCI_attributes * const nci_info   = PARROT_NCI(SELF);

        /* Store the original function and signature. */
        SET_ATTR_orig_func(INTERP, SELF, func);

        /* ensure that the STRING signature is constant */
        if (!PObj_constant_TEST(key)) {
            char * const key_c      = Parrot_str_to_cstring(INTERP, key);
            const size_t key_length = Parrot_str_byte_length(interp, key);
            key                     = string_make(interp, key_c, key_length,
                                        NULL, PObj_constant_FLAG);
            Parrot_str_free_cstring(key_c);
        }

        nci_info->signature = key;
    }

/*

=item C<void mark()>

Mark any referenced strings and PMCs.

=cut

*/
    VTABLE void mark() {
        if (PARROT_NCI(SELF)) {
            Parrot_NCI_attributes * const nci_info = PARROT_NCI(SELF);

            Parrot_gc_mark_PMC_alive(interp, nci_info->fb_info);
            Parrot_gc_mark_STRING_alive(interp, nci_info->signature);
            Parrot_gc_mark_STRING_alive(interp, nci_info->pcc_params_signature);
            Parrot_gc_mark_STRING_alive(interp, nci_info->pcc_params_signature);
            Parrot_gc_mark_STRING_alive(interp, nci_info->long_signature);
            Parrot_gc_mark_PMC_alive(interp, nci_info->multi_sig);
        }
    }

/*

=item C<PMC *clone()>

Creates and returns a clone of the NCI.

=cut

*/

    VTABLE PMC *clone() {
        Parrot_NCI_attributes * const nci_info_self = PARROT_NCI(SELF);
        Parrot_NCI_attributes *nci_info_ret;
        void                  *orig_func;

        PMC * const ret     = Parrot_pmc_new(INTERP, SELF->vtable->base_type);
        nci_info_ret        = PARROT_NCI(ret);

        /* FIXME if data is malloced (JIT/i386!) then we need
         * the length of data here, to memcpy it
         * ManagedStruct or Buffer?
         */
        nci_info_ret->func                  = nci_info_self->func;
        nci_info_ret->fb_info               = nci_info_self->fb_info;
        nci_info_ret->orig_func             = nci_info_self->orig_func;
        nci_info_ret->signature             = nci_info_self->signature;
        nci_info_ret->pcc_params_signature  = nci_info_self->pcc_params_signature;
        nci_info_ret->pcc_return_signature  = nci_info_self->pcc_params_signature;
        nci_info_ret->arity                 = nci_info_self->arity;
        PObj_get_FLAGS(ret)                |= (PObj_get_FLAGS(SELF) & 0x7);

        return ret;
    }

/*

=item C<INTVAL defined()>

Returns whether the NCI is defined.

=cut

*/

    VTABLE INTVAL defined() {
        Parrot_NCI_attributes * const nci_info = PARROT_NCI(SELF);
        return nci_info->orig_func != NULL;
    }

/*

=item C<opcode_t *invoke(void *next)>

Calls the associated C function, returning C<*next>. If the invocant is a
class, the PMC arguments are shifted down.

=cut

*/

    VTABLE opcode_t *invoke(void *next) {
        Parrot_NCI_attributes * const nci_info = PARROT_NCI(SELF);
        nci_thunk_t                   func;
        PMC                          *fb_info;
        char                         *sig_str;
        void                         *orig_func;
        PMC                          *cont;

        GET_ATTR_orig_func(INTERP, SELF, orig_func);
        func = PObj_flag_TEST(private2, SELF)
            ? (nci_thunk_t) D2FPTR(orig_func)
            : (nci_thunk_t) D2FPTR(nci_info->func);

        GET_ATTR_fb_info(INTERP, SELF, fb_info);

        if (!func) {
            /* build the thunk only when necessary */
            func = build_func(interp, nci_info);

            if (!func)
                Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_INVALID_OPERATION,
                    "attempt to call NULL function");
        }

        func(INTERP, SELF, fb_info);
        cont = INTERP->current_cont;

        /*
         * If the NCI function was tailcalled, the return result
         * is already passed back to the caller of this frame
         * - see  Parrot_init_ret_nci(). We therefore invoke the
         * return continuation here, which gets rid of this frame
         * and returns the real return address
         */
        if (cont && cont != NEED_CONTINUATION
        && (PObj_get_FLAGS(cont) & SUB_FLAG_TAILCALL)) {
            cont = Parrot_pcc_get_continuation(interp, CURRENT_CONTEXT(interp));
            next = VTABLE_invoke(INTERP, cont, next);
        }

        return (opcode_t *)next;
    }

/*

=item C<INTVAL get_integer()>

Returns the function pointer as an integer.

=cut

*/

    VTABLE INTVAL get_integer() {
        Parrot_NCI_attributes * const nci_info = PARROT_NCI(SELF);
        if (!nci_info->func)
            build_func(INTERP, nci_info);
        return (INTVAL)nci_info->func;
    }

/*

=item C<INTVAL get_bool()>

Returns the boolean value of the pointer.

=cut

*/

    VTABLE INTVAL get_bool() {
        Parrot_NCI_attributes * const nci_info = PARROT_NCI(SELF);
        return (0 != (INTVAL)nci_info->orig_func);
    }

/*

=item C<METHOD arity()>

Return the arity of the NCI (the number of arguments).

=cut

*/
    METHOD arity() {
        Parrot_NCI_attributes * const nci_info = PARROT_NCI(SELF);
        INTVAL arity = 0;

        if (nci_info) {
            if (!nci_info->func)
                build_func(INTERP, nci_info);
            if (nci_info->func) {
                arity = nci_info->arity;
                RETURN(INTVAL arity);
            }
        }

        Parrot_ex_throw_from_c_args(INTERP, NULL,
            EXCEPTION_INVALID_OPERATION,
            "You cannot get the arity of an undefined NCI.");
    }
}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd03_calling_conventions.pod>.

=head1 HISTORY

Initial revision by sean 2002/08/04.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
