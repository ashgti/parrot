# $Id$
# This is the main vtable data
# Lines have the following format:
# method type \tab return type name \tab type arg1 \tab type arg2
#
# Method type is either int, float, num, str, or unique if the method
# has a set of int entries, float entries, num entries, string
# entries, or is a unique method
#
# So, for instance, a function with two arguments where the second
# argument is a string PMC of some sort would look like this:
# string void frob (INTVAL foo, STRING bar)
#
# Note that we don't include the source "PMC* pmc" - that's done implicitly.
#
# "value" in non-unique methods (multimethods) is a magic name. Its type
# will be replaced appropriately.

INTVAL type()
STRING* name( )
init(INTVAL size)
void clone(PMC* dest)
void morph (INTVAL type)
INTVAL real_size ( )
void destroy ( )
PMC* mark (PMC* end_of_used_list)
keyed unique INTVAL get_integer  (  )
keyed unique FLOATVAL get_number()
keyed unique STRING* get_string()
BOOLVAL get_bool()
void* get_value()
PMC* get_pmc_keyed() # KEY* gets added here by magic.
BOOLVAL is_same(PMC* pmc2)
keyed int void set_integer(INTVAL value)
keyed float void set_number(FLOATVAL value)
keyed str void set_string(STRING* value)
void set_value (void* value)
keyed unique void set_pmc (PMC* value)
int void inc(INTVAL value,PMC* dest)
int void dec(INTVAL value,PMC* dest)
keyed num void add(PMC* value,PMC* dest)
keyed num void subtract(PMC* value,PMC* dest)
keyed num void multiply(PMC* value,PMC* dest)
keyed num void divide(PMC* value,PMC* dest)
keyed num void modulus(PMC* value,PMC* dest)
keyed str void concatenate(PMC* value,PMC* dest)
BOOLVAL is_equal(PMC* value)
void logical_or(PMC* value,PMC* dest)
void logical_and(PMC* value,PMC* dest)
void logical_not(PMC* value)
str void match(PMC* value, REGEX* re)
str void repeat(PMC* value, PMC* dest)
