#
# ncurses_life.imc
#
# Play conway's (no, not *him*. The other conway) game
# of life

# this version can load life.l files (#P format only - x,y are ignored)
# you get a lot of .l files by installing xlife
#
# parrot examples/assembly/ncurses_life.imc examples/assembly/acorn.l
#

.sub _MAIN
.include "library/ncurses.pasm"
	# get command line
	.local var argv
	argv = P5
	# First the generation count
        .const int MAX_GEN = 5000
	# kill the space ship
        .const int COLLIDE = 1

	.local int GEN_COUNT
	.local float START_TIME
	.local float CUR_TIME
	.local float TIME_DIFF
	.local float GPS
	.local int SUPRESS_PRINT
	.local pmc INITSCR
	.local pmc ENDWIN
	.local pmc DISPLAY
	.local pmc STDSCR
	.local pmc WCLEAR
	.local pmc WREFRESH
	.local pmc MVWADDCH
	.local int X_COORD
	.local int Y_COORD
	.local int CHARACTER_OFFSET
	.local pmc WATTRON
	.local pmc COLOR_PAIR
	.local pmc START_COLOR
	.local pmc INIT_PAIR
	.local pmc MVWADDSTR
	.local pmc CURS_SET
	.local int has_usleep
	.local int sizef
	.local int size
	.local int stop
	.local int sleep_lim


	# 15 * sizef is real size of world
	sizef = 5
	# if sizef > sleep_lim then sleep
	sleep_lim = 9

	# Note the time
	time START_TIME
	has_usleep = 0	# unknown yet

	# If true, we don't print
	SUPRESS_PRINT = 0
	stop = 0

	INITSCR = global "ncurses::initscr"
	ENDWIN = global "ncurses::endwin"
	WCLEAR = global "ncurses::wclear"
	WREFRESH = global "ncurses::wrefresh"
	MVWADDCH = global "ncurses::mvwaddch"
	WATTRON = global "ncurses::wattron"
	COLOR_PAIR = global "ncurses::COLOR_PAIR"
	START_COLOR = global "ncurses::start_color"
	INIT_PAIR = global "ncurses::init_pair"
	MVWADDSTR = global "ncurses::mvwaddstr"
	CURS_SET = global "ncurses::curs_set"

	P0 = INITSCR
	invoke
	STDSCR = P5

	P0 = START_COLOR
	invoke

	P0 = INIT_PAIR
	I5 = 1		# Color pair 1
	I6 = 2 		# dark green fg
	I7 = 0		# Black background
	invoke

	P0 = COLOR_PAIR
	I5 = 1
	invoke

	# We pass what's returned from COLOR_PAIR straight on
	P0 = WATTRON
	invoke

	P0 = CURS_SET
	I5 = 0
	invoke

	if sizef > 0 goto ok_s
	sizef = 1
ok_s:

	size = 15 * sizef

	$I0 = argv
	if $I0 <= 1 goto def_world
	.sym Sub load
	newsub load, .Sub, _load_file
	.pcc_begin prototyped
	.arg argv
	.arg size
	.pcc_call load
retl:
	.result S15
	.pcc_end
	length $I0, S15
	unless $I0, getout
	goto nosize2

def_world:
	set S17,  "               "
	$I0 = sizef - 1
	unless $I0 goto nosize
	S16 = ""
	repeat S16, S17, $I0
nosize:

	set S0,  "               "
	set S1,  "               "
	set S2,  "               "
        set S3,  "               "
	set S4,  "  **           "
	set S5,  "*    *         "
	set S6,  "      *        "
	set S7,  "*     *        "
	set S8,  " ******        "
	set S9,  "               "
	set S10, "               "
	set S11, "               "
	if COLLIDE goto col
	set S12, "               "
	set S13, "               "
	set S14, "               "
	goto nocol
col:
	set S12, "             * "
	set S13, "              *"
 	set S14, "            ***"
nocol:
	set S15, ""
	concat S15, S0
	concat S15, S16
	concat S15, S1
	concat S15, S16
	concat S15, S2
	concat S15, S16
	concat S15, S3
	concat S15, S16
	concat S15, S4
	concat S15, S16
	concat S15, S5
	concat S15, S16
	concat S15, S6
	concat S15, S16
	concat S15, S7
	concat S15, S16
	concat S15, S8
	concat S15, S16
	concat S15, S9
	concat S15, S16
	concat S15, S10
	concat S15, S16
	concat S15, S11
	concat S15, S16
	concat S15, S12
	concat S15, S16
	concat S15, S13
	concat S15, S16
	concat S15, S14
	concat S15, S16
	$I1 = size
	unless $I0, nosize2
	$I1 = $I1 * $I0
	repeat S16, S17, $I1
	concat S15, S16
nosize2:
	bsr dump
	GEN_COUNT = 0
	.sym Sub generate
	newsub generate, .Sub, _generate

loop:	if GEN_COUNT >= MAX_GEN goto getout
        if stop goto getout
	inc GEN_COUNT
	I31 = GEN_COUNT % 100
	if I31 goto skip
	printerr "."

skip:
	.pcc_begin prototyped
	.arg S15
	.arg size
	.pcc_call generate
ret:
	.result S15
	.result stop
	.pcc_end

	bsr dump
	branch loop

getout:
	P0 = CURS_SET
	I5 = 1
	invoke
	P0 = ENDWIN
	invoke
	time CUR_TIME
	TIME_DIFF = CUR_TIME - START_TIME

	# sleeping invalidates these data
	if sizef > sleep_lim goto no_gps
	print "\n"
	print GEN_COUNT
	print " generations in "
	print TIME_DIFF
 	print " seconds. "
	GPS = GEN_COUNT / TIME_DIFF

	print GPS
	print " generations/sec\n"
no_gps:

	interpinfo I1, 1
	print "A total of "
	print I1
	print " bytes were allocated\n"

	interpinfo I1, 2
	print "A total of "
	print I1
	print " DOD runs were made\n"

	interpinfo I1, 3
	print "A total of "
	print I1
	print " collection runs were made\n"

	interpinfo I1, 10
	print "Copying a total of "
	print I1
	print " bytes\n"

	interpinfo I1, 5
	print "There are "
	print I1
	print " active Buffer structs\n"

	interpinfo I1, 7
	print "There are "
	print I1
	print " total Buffer structs\n"


	end




# S15 has the incoming string, S0 is scratch
dump:
	if SUPRESS_PRINT goto dumpend

	saveall

	P0 = WCLEAR
	P5 = STDSCR
	invoke

	P0 = MVWADDSTR
	S5 = "Generation: "
	I5 = 0
	I6 = 0
	P5 = STDSCR
	invoke

	P0 = MVWADDSTR
	S5 = GEN_COUNT
	I5 = 0
	I6 = 13
	P5 = STDSCR
	invoke

	CHARACTER_OFFSET = 0

printloop:

	substr_r S0, S15, CHARACTER_OFFSET, 1
	if S0 != "*" goto incit
	X_COORD = CHARACTER_OFFSET % size
	Y_COORD = CHARACTER_OFFSET / size
	Y_COORD = Y_COORD + 2
	I5 = Y_COORD
	I6 = X_COORD
	I7 = 42				# Behold, the lowly star
	P5 = STDSCR
	P0 = MVWADDCH
	invoke

incit:	CHARACTER_OFFSET = CHARACTER_OFFSET + 1
        $I0 = size * size
	if  CHARACTER_OFFSET < $I0 goto printloop

	P0 = WREFRESH
	P5 = STDSCR
	invoke

	if sizef <= sleep_lim goto dumpend
	# as we gonna sleep here, lets burn some cycles to
	# check if usleep is available
	if has_usleep == 1 goto usleep
	if has_usleep == 0 goto test_usleep
sl:
	sleep 1
	goto dumpend
test_usleep:
	null P0
	dlfunc P0, P0, "usleep", "vi"
	$I0 = defined P0
	has_usleep = 1
	if $I0 goto usleep
	has_usleep = -1
	goto sl
usleep:
	null P0
	dlfunc P0, P0, "usleep", "vi"
	I5 = 20000	# sleep x0 ms
	invoke
dumpend:
	restoreall
	ret

.end

# in: world (string)
#     size
# out new world
#     stop
.pcc_sub _generate prototyped
	.param string world
	.param int size

	.sym int len
	.sym int pos
	.sym int count
	.sym int check	# pos in world
	.sym string new_world
	length len, world
	# allocate new world with all space
	repeat new_world, " ", len
	pos = 0
genloop:
	count = 0
NW:
	check = -size
	dec check
	check = check + len
	check = check + pos
	check = check % len
	# $S0 is always overwritten, so reuse it
	substr_r $S0, world, check, 1
	if $S0 != "*" goto North
	inc count
North:
	check = -size
	check = check + len
	check = check + pos
	check = check % len
	substr_r $S0, world, check, 1
	if $S0 != "*" goto NE
	inc count
NE:
	check = -size
	inc check
	check = check + len
	check = check + pos
	check = check % len
	substr_r $S0, world, check, 1
	if $S0 != "*" goto West
	inc count
West:
	check = -1
	check = check + len
	check = check + pos
	check = check % len
	substr_r $S0, world, check, 1
	if $S0 != "*" goto East
	inc count
East:
	check = 1
	check = check + len
	check = check + pos
	check = check % len
	substr_r $S0, world, check, 1
	if $S0 != "*" goto SW
	inc count
SW:
	check = size
	dec check
	check = check + len
	check = check + pos
	check = check % len
	substr_r $S0, world, check, 1
	if $S0 != "*" goto South
	inc count
South:
	check = size
	check = check + len
	check = check + pos
	check = check % len
	substr_r $S0, world, check, 1
	if $S0 != "*" goto SE
	inc count
SE:
	check = size
	inc check
	check = check + len
	check = check + pos
	check = check % len
	substr_r $S0, world, check, 1
	if $S0 != "*" goto checkl
	inc count
checkl:
	substr_r $S0, world, pos, 1
	if $S0 == "*" goto check_alive

# If eq 3, put a star in else a space
check_dead:
	if count == 3 goto star
	branch space

check_alive:
	if count < 2 goto space
	if count > 3 goto space
	branch star

space:	# is space already
	branch iter_done
star:
	substr new_world, pos, 1, "*"
iter_done:
	inc pos
	lt pos, len, genloop
done:
	.sym int stop
	stop = 0
	if  new_world != world goto dif
	   sleep 2
           stop = 1
dif:
	.pcc_begin_return
	.return new_world
	.return stop
	.pcc_end_return
.end

.pcc_sub _load_file prototyped
	.param var argv
	.param int size

	.sym string world
	null world
	.sym string file
	file = argv[1]
	.sym var io
	open io, file, "<"
	$I0 = defined io
	unless $I0 goto nok
	.sym string line
	$I0 = size * size
	repeat world, " ", $I0
	.sym int pos
	$I0 = size / 2
	$I1 = $I0 * $I0
	pos = $I0 + $I1
	.sym int len
loop:
	readline line, io
	length len, line
	unless len goto out
	substr $S0, line, 0, 1
	eq $S0, "#", loop	# ignore, TODO checl P,R ...
	chopn line, 1		# \n
	dec len
	substr world, pos, len, line
	pos = pos + size
	goto loop

out:
	close io
	print "XXX"
	print world
	print "XXX\n"
nok:
	.pcc_begin_return
	.return world
	.pcc_end_return
.end

