#
# life.pasm
#
# Play conway's (no, not *him*. The other conway) game
# of life
#
.emit

.include "library/ncurses.pasm"

.eom

.sub _MAIN
        .local int MAX_GEN
	.local int GEN_COUNT
	.local float START_TIME
	.local float CUR_TIME
	.local float TIME_DIFF
	.local float GPS
	.local int SUPRESS_PRINT
	.local pmc INITSCR
	.local pmc DISPLAY
	.local pmc STDSCR
	.local pmc WCLEAR
	.local pmc WREFRESH
	.local pmc MVWADDCH
	.local int X_COORD
	.local int Y_COORD
	.local int CHARACTER_OFFSET
	.local pmc WATTRON
	.local pmc COLOR_PAIR
	.local pmc START_COLOR
	.local pmc INIT_PAIR
	.local pmc MVWADDSTR

	# First the generation count
	MAX_GEN = 5000

	# Note the time
	time START_TIME

	# If true, we don't print
	SUPRESS_PRINT = 0

	INITSCR = global "ncurses::initscr"
	WCLEAR = global "ncurses::wclear"
	WREFRESH = global "ncurses::wrefresh"	
	MVWADDCH = global "ncurses::mvwaddch"	
	WATTRON = global "ncurses::wattron"
	COLOR_PAIR = global "ncurses::COLOR_PAIR"
	START_COLOR = global "ncurses::start_color"
	INIT_PAIR = global "ncurses::init_pair"
	MVWADDSTR = global "ncurses::mvwaddstr"

	P0 = INITSCR
	invoke
	STDSCR = P5

	P0 = START_COLOR
	invoke

	P0 = INIT_PAIR
	I5 = 1		# Color pair 1
	I6 = 5 		# Pink foreground
	I7 = 0		# Black background
	invoke 

	P0 = COLOR_PAIR
	I5 = 1
	invoke

	# We pass what's returned from COLOR_PAIR straight on
	P0 = WATTRON
	invoke

	set S0,  "               "
	set S1,  "               "
	set S2,  "               "
        set S3,  "               "
	set S4,  "               "
	set S5,  "               "
	set S6,  "    *          "
	set S7,  "  ***          "
	set S8,  "    *          "
	set S9,  "               "
	set S10, "               "
	set S11, "       *       "
	set S12, "      ***      "
	set S13, "               "
	set S14, "               "
	set S15, ""
	concat S15, S0
	concat S15, S1
	concat S15, S2
	concat S15, S3
	concat S15, S4
	concat S15, S5
	concat S15, S6
	concat S15, S7
	concat S15, S8
	concat S15, S9
	concat S15, S10
	concat S15, S11
	concat S15, S12
	concat S15, S13
	concat S15, S14
	bsr dump
	GEN_COUNT = 0

loop:	if GEN_COUNT > MAX_GEN goto getout
	inc GEN_COUNT
	I31 = GEN_COUNT % 100
	if I31 goto skip
	printerr "."

skip:

	bsr generate

	bsr dump
	branch loop

getout:	time CUR_TIME
	TIME_DIFF = CUR_TIME - START_TIME

	print "\n"
	print I2
	print " generations in "
	print TIME_DIFF
 	print " seconds. "
	GPS = TIME_DIFF / MAX_GEN

	print MAX_GEN
	print " generations/sec\n"

	interpinfo I1, 1
	print "A total of "
	print I1
	print " bytes were allocated\n"

	interpinfo I1, 2
	print "A total of "
	print I1
	print " DOD runs were made\n"

	interpinfo I1, 3
	print "A total of "
	print I1
	print " collection runs were made\n"

	interpinfo I1, 10
	print "Copying a total of "
	print I1
	print " bytes\n"

	interpinfo I1, 5
	print "There are "
	print I1
	print " active Buffer structs\n"

	interpinfo I1, 7
	print "There are "
	print I1
	print " total Buffer structs\n"


	end



# S15 has the incoming string, S0 is scratch, S1 is scratch, S2 is scratch
#
# I0 is the length of the string
# I1 is the current cell we're checking
# I2 is the count for that cell
# I3 is the offset to the neighbor
generate:
	pushi
	length I0, S15
	S1 = ""
	I1 = 0
genloop:
	I2 = 0
NW:
	I3 = -16
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	# S0 is always overwritten, so reuse it
	substr_r S0, S15, I3, 1
	if S0 != "*" goto North
	inc I2
North:
	I3 = -15
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	substr_r S0, S15, I3, 1
	if S0 != "*" goto NE
	inc I2
NE:
	I3 = -14
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	substr_r S0, S15, I3, 1
	if S0 != "*" goto West
	inc I2
West:
	I3 = -1
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	substr_r S0, S15, I3, 1
	if S0 != "*" goto East
	inc I2
East:
	I3 = 1
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	substr_r S0, S15, I3, 1
	if S0 != "*" goto SW
	inc I2
SW:
	I3 = 14
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	substr_r S0, S15, I3, 1
	if S0 != "*" goto South
	inc I2
South:
	I3 = 15
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	substr_r S0, S15, I3, 1
	if S0 != "*" goto SE
	inc I2
SE:
	I3 = 16
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	substr_r S0, S15, I3, 1
	if S0 != "*" goto check
	inc I2
check:
	substr_r S0, S15, I1, 1
	if S0 == "*" goto check_alive

# If eq 3, put a star in else a space
check_dead:
	if I2 == 3 goto star
	branch space

check_alive:
	if I2 < 2 goto space
	if I2 > 3 goto space
	branch star

space:
	concat S1, " "
	branch iter_done
star:
	concat S1, "*"
iter_done:
	inc I1
	lt I1, I0, genloop
done:
	S15 = S1
	popi
	ret

# S15 has the incoming string, S0 is scratch
dump:
	if SUPRESS_PRINT goto dumpend

	saveall
	
	P0 = WCLEAR
	P5 = STDSCR
	invoke
	
	P0 = MVWADDSTR
	S5 = "Generation: "
	I5 = 0
	I6 = 0
	P5 = STDSCR
	invoke

	P0 = MVWADDSTR
	S5 = GEN_COUNT
	I5 = 0
	I6 = 13
	P5 = STDSCR
	invoke

	CHARACTER_OFFSET = 0

printloop:
	
	substr_r S0, S15, CHARACTER_OFFSET, 1
	if S0 != "*" goto incit
	X_COORD = CHARACTER_OFFSET % 15
	Y_COORD = CHARACTER_OFFSET / 15
	Y_COORD = Y_COORD + 2
	I5 = Y_COORD
	I6 = X_COORD
	I7 = 42				# Behold, the lowly star
	P5 = STDSCR
	P0 = MVWADDCH
	invoke

incit:	CHARACTER_OFFSET = CHARACTER_OFFSET + 1
	if  CHARACTER_OFFSET < 225 goto printloop

	P0 = WREFRESH
	P5 = STDSCR
	invoke
	
	restoreall

	sleep 1
dumpend:
	ret

.end