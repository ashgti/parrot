#
# life.pasm
#
# Play conway's (no, not *him*. The other conway) game
# of life
#
#.emit


#.eom

.sub _MAIN
.include "library/ncurses.pasm"
	# First the generation count
        .const int MAX_GEN = 5000
	# kill the space ship
        .const int COLLIDE = 1

	.local int GEN_COUNT
	.local float START_TIME
	.local float CUR_TIME
	.local float TIME_DIFF
	.local float GPS
	.local int SUPRESS_PRINT
	.local pmc INITSCR
	.local pmc ENDWIN
	.local pmc DISPLAY
	.local pmc STDSCR
	.local pmc WCLEAR
	.local pmc WREFRESH
	.local pmc MVWADDCH
	.local int X_COORD
	.local int Y_COORD
	.local int CHARACTER_OFFSET
	.local pmc WATTRON
	.local pmc COLOR_PAIR
	.local pmc START_COLOR
	.local pmc INIT_PAIR
	.local pmc MVWADDSTR
	.local pmc CURS_SET
	.local int has_usleep
	.local int sizef
	.local int size
	.local int stop
	.local int sleep_lim


	# 15 * sizef is real size of world
	sizef = 5
	# if sizef > sleep_lim then sleep
	sleep_lim = 9

	# Note the time
	time START_TIME
	has_usleep = 0	# unknown yet

	# If true, we don't print
	SUPRESS_PRINT = 0

	INITSCR = global "ncurses::initscr"
	ENDWIN = global "ncurses::endwin"
	WCLEAR = global "ncurses::wclear"
	WREFRESH = global "ncurses::wrefresh"
	MVWADDCH = global "ncurses::mvwaddch"
	WATTRON = global "ncurses::wattron"
	COLOR_PAIR = global "ncurses::COLOR_PAIR"
	START_COLOR = global "ncurses::start_color"
	INIT_PAIR = global "ncurses::init_pair"
	MVWADDSTR = global "ncurses::mvwaddstr"
	CURS_SET = global "ncurses::curs_set"

	P0 = INITSCR
	invoke
	STDSCR = P5

	P0 = START_COLOR
	invoke

	P0 = INIT_PAIR
	I5 = 1		# Color pair 1
	I6 = 2 		# dark green fg
	I7 = 0		# Black background
	invoke

	P0 = COLOR_PAIR
	I5 = 1
	invoke

	# We pass what's returned from COLOR_PAIR straight on
	P0 = WATTRON
	invoke

	P0 = CURS_SET
	I5 = 0
	invoke

	S16 = ""
	size = 15
	if sizef <= 1 goto nosize
	$I0 = sizef - 1
	size = 15 * sizef
	set S17,  "               "
	repeat S16, S17, $I0
nosize:

	set S0,  "               "
	set S1,  "               "
	set S2,  "               "
        set S3,  "               "
	set S4,  "  **           "
	set S5,  "*    *         "
	set S6,  "      *        "
	set S7,  "*     *        "
	set S8,  " ******        "
	set S9,  "               "
	set S10, "               "
	set S11, "               "
	if COLLIDE goto col
	set S12, "               "
	set S13, "               "
	set S14, "               "
	goto nocol
col:
	set S12, "             * "
	set S13, "              *"
 	set S14, "            ***"
nocol:
	set S15, ""
	concat S15, S0
	concat S15, S16
	concat S15, S1
	concat S15, S16
	concat S15, S2
	concat S15, S16
	concat S15, S3
	concat S15, S16
	concat S15, S4
	concat S15, S16
	concat S15, S5
	concat S15, S16
	concat S15, S6
	concat S15, S16
	concat S15, S7
	concat S15, S16
	concat S15, S8
	concat S15, S16
	concat S15, S9
	concat S15, S16
	concat S15, S10
	concat S15, S16
	concat S15, S11
	concat S15, S16
	concat S15, S12
	concat S15, S16
	concat S15, S13
	concat S15, S16
	concat S15, S14
	concat S15, S16
	$I1 = size
	unless $I0, nosize2
	$I1 = $I1 * $I0
	repeat S16, S17, $I1
	concat S15, S16
nosize2:
	bsr dump
	GEN_COUNT = 0

loop:	if GEN_COUNT >= MAX_GEN goto getout
        if stop goto getout
	inc GEN_COUNT
	I31 = GEN_COUNT % 100
	if I31 goto skip
	printerr "."

skip:

	bsr generate

	bsr dump
	branch loop

getout:
	P0 = CURS_SET
	I5 = 1
	invoke
	P0 = ENDWIN
	invoke
	time CUR_TIME
	TIME_DIFF = CUR_TIME - START_TIME

	# sleeping invalidates these data
	if sizef > sleep_lim goto no_gps
	print "\n"
	print GEN_COUNT
	print " generations in "
	print TIME_DIFF
 	print " seconds. "
	GPS = GEN_COUNT / TIME_DIFF

	print GPS
	print " generations/sec\n"
no_gps:

	interpinfo I1, 1
	print "A total of "
	print I1
	print " bytes were allocated\n"

	interpinfo I1, 2
	print "A total of "
	print I1
	print " DOD runs were made\n"

	interpinfo I1, 3
	print "A total of "
	print I1
	print " collection runs were made\n"

	interpinfo I1, 10
	print "Copying a total of "
	print I1
	print " bytes\n"

	interpinfo I1, 5
	print "There are "
	print I1
	print " active Buffer structs\n"

	interpinfo I1, 7
	print "There are "
	print I1
	print " total Buffer structs\n"


	end



# S15 has the incoming string, S0 is scratch, S1 is scratch, S2 is scratch
#
# I0 is the length of the string
# I1 is the current cell we're checking
# I2 is the count for that cell
# I3 is the offset to the neighbor
generate:
	pushi
	length I0, S15
	# allocate new world with all space
	repeat S1, " ", I0
	I1 = 0
genloop:
	I2 = 0
NW:
	I3 = -size
	dec I3
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	# S0 is always overwritten, so reuse it
	substr_r S0, S15, I3, 1
	if S0 != "*" goto North
	inc I2
North:
	I3 = -size
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	substr_r S0, S15, I3, 1
	if S0 != "*" goto NE
	inc I2
NE:
	I3 = -size
	inc I3
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	substr_r S0, S15, I3, 1
	if S0 != "*" goto West
	inc I2
West:
	I3 = -1
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	substr_r S0, S15, I3, 1
	if S0 != "*" goto East
	inc I2
East:
	I3 = 1
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	substr_r S0, S15, I3, 1
	if S0 != "*" goto SW
	inc I2
SW:
	I3 = size
	dec I3
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	substr_r S0, S15, I3, 1
	if S0 != "*" goto South
	inc I2
South:
	I3 = size
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	substr_r S0, S15, I3, 1
	if S0 != "*" goto SE
	inc I2
SE:
	I3 = size
	inc I3
	I3 = I3 + I0
	I3 = I3 + I1
	I3 = I3 % I0
	substr_r S0, S15, I3, 1
	if S0 != "*" goto check
	inc I2
check:
	substr_r S0, S15, I1, 1
	if S0 == "*" goto check_alive

# If eq 3, put a star in else a space
check_dead:
	if I2 == 3 goto star
	branch space

check_alive:
	if I2 < 2 goto space
	if I2 > 3 goto space
	branch star

space:	# is space already
	branch iter_done
star:
	substr S1, I1, 1, "*"
iter_done:
	inc I1
	lt I1, I0, genloop
done:
	popi
	if  S1 != S15 goto dif
	   sleep 2
           stop = 1
dif:
	S15 = S1
	ret

# S15 has the incoming string, S0 is scratch
dump:
	if SUPRESS_PRINT goto dumpend

	saveall

	P0 = WCLEAR
	P5 = STDSCR
	invoke

	P0 = MVWADDSTR
	S5 = "Generation: "
	I5 = 0
	I6 = 0
	P5 = STDSCR
	invoke

	P0 = MVWADDSTR
	S5 = GEN_COUNT
	I5 = 0
	I6 = 13
	P5 = STDSCR
	invoke

	CHARACTER_OFFSET = 0

printloop:

	substr_r S0, S15, CHARACTER_OFFSET, 1
	if S0 != "*" goto incit
	X_COORD = CHARACTER_OFFSET % size
	Y_COORD = CHARACTER_OFFSET / size
	Y_COORD = Y_COORD + 2
	I5 = Y_COORD
	I6 = X_COORD
	I7 = 42				# Behold, the lowly star
	P5 = STDSCR
	P0 = MVWADDCH
	invoke

incit:	CHARACTER_OFFSET = CHARACTER_OFFSET + 1
        $I0 = size * size
	if  CHARACTER_OFFSET < $I0 goto printloop

	P0 = WREFRESH
	P5 = STDSCR
	invoke

	if sizef <= sleep_lim goto dumpend
	# as we gonna sleep here, lets burn some cycles to
	# check if usleep is available
	if has_usleep == 1 goto usleep
	if has_usleep == 0 goto test_usleep
sl:
	sleep 1
	goto dumpend
test_usleep:
	null P0
	dlfunc P0, P0, "usleep", "vi"
	$I0 = defined P0
	has_usleep = 1
	if $I0 goto usleep
	has_usleep = -1
	goto sl
usleep:
	null P0
	dlfunc P0, P0, "usleep", "vi"
	I5 = 20000	# sleep x0 ms
	invoke
dumpend:
	restoreall
	ret

.end
