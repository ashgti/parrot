;
; sun4/core.jit
;
; $Id$ 
;

Parrot_end {
    emitm_ret(NATIVECODE);
    emitm_restore_i(NATIVECODE, emitm_g(0), emitm_g(0), emitm_g(0));
}

Parrot_noop {
    emitm_nop(NATIVECODE);
}

TEMPLATE Parrot_set_x_x {
    if(MAP[1] && MAP[2]){
	jit_emit_mov_rr<_N>(NATIVECODE, MAP[1], MAP[2]);
    }
    else if(MAP[1]){
        jit_emit_load<_N>(jit_info, interpreter, 2, MAP[1]);
    }
    else if(MAP[2]){
        jit_emit_store<_N>(jit_info, interpreter, 1, MAP[2]);
    }
    else {
	jit_emit_load<_N>(jit_info, interpreter, 2, ISR1);
	jit_emit_store<_N>(jit_info, interpreter, 1, ISR1);
    }
}

Parrot_set_i_i {
    Parrot_set_x_x s/<_N>/_i/
}

Parrot_set_p_p {
    Parrot_set_x_x s/<_N>/_i/
}

Parrot_set_s_s {
    Parrot_set_x_x s/<_N>/_i/
}

Parrot_set_n_n {
    Parrot_set_x_x s/<_N>/_n/ s/ISR/FSR/
}

TEMPLATE Parrot_set_x_xc {
    if(MAP[1]){
	jit_emit_load<_N>(jit_info, interpreter, 2, MAP[1]);
    }
    else {
	jit_emit_load<_N>(jit_info, interpreter, 2, ISR1);
	jit_emit_store<_N>(jit_info, interpreter, 1, ISR1);
    }
}

Parrot_set_i_ic {
    Parrot_set_x_xc s/<_N>/_i/
}

Parrot_set_n_nc {
    Parrot_set_x_xc s/<_N>/_n/ s/ISR/FSR/
}

Parrot_set_n_i {
    /* There's no way to move a value directly between integer and floating
     * point registers so the mapped integer register must be written to memory
     */
    if(MAP[2]){
	jit_emit_store_i(jit_info, interpreter, 2, MAP[2]);
    }

    jit_emit_load_n(jit_info, interpreter, 2, FSR1);

    /* If result register is mapped convert directly into the register */
    if(MAP[1]){
	emitm_fitod(NATIVECODE, FSR1, MAP[1]);
    }
    else {
	emitm_fitod(NATIVECODE, FSR1, FSR2);
	jit_emit_store_n(jit_info, interpreter, 1, FSR2);
    }
}

Parrot_set_i_n {
    if(MAP[2]){
	emitm_fdtoi(NATIVECODE, MAP[2], FSR2);
    }
    else {
	jit_emit_load_n(jit_info, interpreter, 2, FSR1);
	emitm_fdtoi(NATIVECODE, FSR1, FSR2);
    }

    jit_emit_store_n(jit_info, interpreter, 1, FSR2);

    /* No float reg to integer reg move instruction available */
    if(MAP[1]){
	jit_emit_load_i(jit_info, interpreter, 1, MAP[1]);
    }
}

Parrot_set_i_nc {
    if(MAP[2]){
        emitm_fdtoi(NATIVECODE, MAP[2], FSR1);
    }
    else {
        jit_emit_load_n(jit_info, interpreter, 2, FSR2);
        emitm_fdtoi(NATIVECODE, FSR2, FSR1);
    }

    jit_emit_store_n(jit_info, interpreter, 1, FSR1); 

    if(MAP[1]){
        jit_emit_load_i(jit_info, interpreter, 1, MAP[1]);
    }
}

TEMPLATE Parrot_binop_x_x {
    int arg1, arg2;
    
    if (MAP[1]) {
        arg1 = MAP[1];
    }
    else {
        arg1 = ISR1;
        jit_emit_load<_N>(jit_info, interpreter, 1, ISR1);
    }

    if (MAP[2]) {
        arg2 = MAP[2];
    }
    else {
        arg2 = ISR2;
        jit_emit_load<_N>(jit_info, interpreter, 2, ISR2);
    }

    emitm_<op>(NATIVECODE, arg1, arg2, arg1);

    if(!MAP[1]){
        jit_emit_store<_N>(jit_info, interpreter, 1, ISR1);
    }
}

Parrot_add_i_i {
    Parrot_binop_x_x s/<op>/add_r/ s/<_N>/_i/
}

Parrot_sub_i_i {
    Parrot_binop_x_x s/<op>/sub_r/ s/<_N>/_i/
}

Parrot_bor_i_i {
    Parrot_binop_x_x s/<op>/or_r/ s/<_N>/_i/
}

Parrot_bxor_i_i {
    Parrot_binop_x_x s/<op>/xor_r/ s/<_N>/_i/
}

Parrot_band_i_i {
    Parrot_binop_x_x s/<op>/and_r/ s/<_N>/_i/
}

Parrot_add_n_n {
    Parrot_binop_x_x s/<op>/faddd/ s/<_N>/_n/
}

Parrot_sub_n_n {
    Parrot_binop_x_x s/<op>/fsubd/ s/<_N>/_n/
}

Parrot_mul_n_n {
    Parrot_binop_x_x s/<op>/fmuld/ s/<_N>/_n/
}

Parrot_div_n_n {
    Parrot_binop_x_x s/<op>/fdivd/ s/<_N>/_n/
}

Parrot_if_i_ic {
    if(MAP[1]){
	emitm_subcc_r(NATIVECODE, MAP[1], emitm_g(0), emitm_g(0));
    }
    else {
	jit_emit_load_i(jit_info, interpreter, 1, ISR1);
	emitm_subcc_r(NATIVECODE, ISR1, emitm_g(0), emitm_g(0));
    }

    Parrot_jit_bicc(jit_info, emitm_bne, 0, *INT_CONST[2]);
    emitm_nop(NATIVECODE);
}

Parrot_branch_ic {
    Parrot_jit_bicc(jit_info, emitm_ba, 0, *INT_CONST[1]);
    emitm_nop(NATIVECODE);
}

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil 
 * End:
 *
 * vim: expandtab shiftwidth=4:
 */
