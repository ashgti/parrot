#!perl
# Copyright (C) 2008, The Perl Foundation.
# $Id$

use strict;
use warnings;
use lib qw(t . lib ../lib ../../lib ../../../lib);

use Test::More;

use Parrot::Test tests => 10;
use Parrot::Test::Util 'create_tempfile';
use Parrot::Config;

=head1 NAME

pct/complete_workflow.t - PCT tests

=head1 SYNOPSIS

    $ prove t/compilers/pct/complete_workflow.t

=head1 DESCRIPTION

This is a test script to try out constructing a grammar from a 
grammar syntax file. After that is attempted to add acctions
from a NQP class file. After that the generated compiler is tested.
Special cases in grammars and actions should also be tested.

=cut

# Do not assume that . is in $PATH
# places to look for things
my $BUILD_DIR     = $PConfig{build_dir};
my $TEST_DIR      = "$BUILD_DIR/t/compilers/pct";
my $PARROT        = "$BUILD_DIR/parrot$PConfig{exe}";
my $PGE_LIBRARY   = "$BUILD_DIR/runtime/parrot/library/PGE";
my $PERL6GRAMMAR  = "$PGE_LIBRARY/Perl6Grammar.pbc";
my $NQP           = "$BUILD_DIR/compilers/nqp/nqp.pbc";

# set up a file with the grammar
my ($PG, $pg_fn) = create_tempfile( SUFFIX => '.pg', DIR => $TEST_DIR, UNLINK => 1 );
print $PG <<'END_PG';
# DO NOT EDIT.
# This file was generated by t/compilers/pct/complete_workflow.t

grammar TestGrammar::Grammar is PCT::Grammar;

token TOP   { 'thingy' }
END_PG

ok( $pg_fn, 'got name of grammar file' );
ok( -e $pg_fn, 'grammar file exists' );

# compile the grammar
( my $gen_grammar_fn = $pg_fn ) =~s/pg$/pir/;
my $rv = Parrot::Test::run_command(
   qq{$PARROT $PERL6GRAMMAR $pg_fn},
   STDOUT => $gen_grammar_fn,
);
is( $rv, 0, 'generated PIR successfully' ); 
ok( -e $gen_grammar_fn, 'generated parser exists' );
my $gen_grammar = slurp_file($gen_grammar_fn);
unlink $gen_grammar_fn;;


# set up a file with the actions
my ($PM, $pm_fn) = create_tempfile( SUFFIX => '.pm', DIR => $TEST_DIR, UNLINK => 1 );
print $PM <<'END_PM';
# DO NOT EDIT.
# This file was generated by t/compilers/pct/complete_workflow.t

class TestGrammar::Grammar::Actions;

method TOP($/) {
    my $past  := PAST::Stmts.new( 
                     PAST::Op.new(
                         PAST::Val.new(
                             :value( ~$/ ),
                             :returns('thingy')
                         ),
                         :pirop('say'),
                         :pasttype('pirop')
                     ) 
                 );

    make $past;
}
END_PM

ok( $pm_fn, 'got name of action file' );
ok( -e $pm_fn, 'action file exists' );
#diag( Dumper( \%PConfig ) );

# compile the actions
( my $gen_actions_fn = $pm_fn ) =~s/nqp$/pir/;
ok( -e $gen_actions_fn, 'generated parser exists' );
$rv = Parrot::Test::run_command(
   qq{$PARROT $NQP --target=pir $pm_fn},
   STDOUT => $gen_actions_fn,
);
is( $rv, 0, 'generated PIR successfully' ); 
ok( -e $gen_actions_fn, 'generated actions exist' );
my $gen_actions = slurp_file($gen_actions_fn);
unlink $gen_actions_fn;;


my $driver_pir = <<'CODE';
.namespace [ 'TestGrammar'; 'Compiler' ]

.sub 'onload' :anon :load :init
    load_bytecode 'PCT.pbc'
.end

.sub 'main' :main
    #.param pmc args
    .local pmc args
    args = new 'ResizableStringArray'
    push args, "command"
    push args, "--target=parse"
    push args, "t/compilers/pct/sample.txt"
    #push args, "thingy"

    $P0 = new ['PCT'; 'HLLCompiler']
    $P0.'language'('TestGrammar')
    $P0.'parsegrammar'('TestGrammar::Grammar')
    $P0.'parseactions'('TestGrammar::Grammar::Actions')

    $P1 = $P0.'command_line'(args)

    .return()
.end

CODE

# Add the generated code to the driver,
# so that everything is in one place
$driver_pir .= <<"CODE";
#------------------------------#
# The generated parser         #
#------------------------------#

$gen_grammar

#------------------------------#
# The generated actions        #
#------------------------------#

$gen_actions

CODE

pir_output_is( $driver_pir, <<'OUT', 'workflow, parse only' ); 
"parse" => PMC 'TestGrammar;Grammar' => "thingy" @ 0
OUT


=head1 AUTHOR

Bernhard Schmalhofer <Bernhard.Schmalhofer@gmx.de>

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
