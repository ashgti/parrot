
# This file automatically generated by build/gen_settings.pl.

# From src/settings/Array.pm

=begin

=head2 Array Methods

These methods extend the native NQP Array class to support more of the basic
functionality expected for Perl 6 Hashes.

=end

module ResizablePMCArray {


=begin

=over 4

=item @reversed := @array.reverse

Return a C<@reversed> copy of the C<@array>.

=end

    method reverse () {
        my @reversed;
        for self { @reversed.unshift($_); }
        @reversed;
    }

=begin

=item $string := @array.join($join_string)

Join C<@array> using C<$join_string>

=end

    method join ($join_string) {
        return Q:PIR{
            $P0 = find_lex '$join_string'
            $S0 = $P0
            $S1 = join $S0, self
            %r  = box $S1
        }
    }

=begin

=back

=end

}

sub join($join_string, *@list) { @list.join($join_string) }

# vim: ft=perl6
# From src/settings/Hash.pm

=begin

=head2 Hash Methods

These methods extend the native NQP Hash class to support more of the basic
functionality expected for Perl 6 Hashes.

=end

module Hash {


=begin

=over 4

=item $found := %hash.exists($key)

Return a true value if C<$key> exists in C<%hash>, or a false value otherwise.

=end

    method exists ($key) {
        return Q:PIR{
            $P1 = find_lex '$key'
            $I0 = exists self[$P1]
            %r  = box $I0
        };
    }

=begin

=item %hash.delete($key)

Delete C<$key> from C<%hash>.

=end

    method delete ($key) {
        Q:PIR{
            $P1 = find_lex '$key'
            delete self[$P1]
        };
    }


=begin

=item @keys := %hash.keys

Return all the C<@keys> in the C<%hash> as an unordered array.

=end

    method keys () {
        my @keys;
        for self { @keys.push($_.key); }
        @keys;
    }


=begin

=item @values := %hash.values

Return all the C<@values> in the C<%hash> as an unordered array.

=end

    method values () {
        my @values;
        for self { @values.push($_.value); }
        @values;
    }


=begin

=item @flattened := %hash.kv

Flatten C<%hash> into an array, alternating key and value.  This is useful
when iterating over key and value simultaneously:

    for %hash.kv -> $k, $v { ... }

=end

    method kv () {
        my @kv;
        for self { @kv.push($_.key); @kv.push($_.value); }
        @kv;
    }


=begin

=back

=end

}

=begin

=item %hash := hash(:key1(value1), :key2(value2), ...)

Coerce a list of pairs into a hash.

=end

sub hash (*%h) { return %h }

# vim: ft=perl6

# vim: set ft=perl6 nomodifiable :
