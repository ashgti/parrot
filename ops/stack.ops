/*
** stack.ops
*/

VERSION = PARROT_VERSION;

=head1 NAME

stack.ops - Stack Ops

=head1 DESCRIPTION

Operations that manipulate Parrot's register, user and integer
stacks.

=cut

###############################################################################

=head2 Register stack operations

These operations affect entire sets of registers.

=over 4

=cut

########################################

=item B<popi>()

=item B<popn>()

=item B<popp>()

=item B<pops>()

Restore all the registers of the type indicated in the name of the operation
from the most recently B<push>ed register frames.

A register frame holds only 16 registers, so we pop two frames from the
frame stack. We use the first frame to restore registers 16-31, and the
second frame to restore registers 0-15. By restoring in this order, we
ensure that a C<push> followed by a C<pop> returns the working set of
registers to their original state.

=cut

inline op popi() :base_core {
  Parrot_pop_i(interpreter, &REG_INT(16));
  Parrot_pop_i(interpreter, &REG_INT(0));
  goto NEXT();
}

inline op popn() :base_core {
  Parrot_pop_n(interpreter, &REG_NUM(16));
  Parrot_pop_n(interpreter, &REG_NUM(0));
  goto NEXT();
}

inline op pops() :base_core {
  Parrot_pop_s(interpreter, &REG_STR(16));
  Parrot_pop_s(interpreter, &REG_STR(0));
  goto NEXT();
}

inline op popp() :base_core {
  Parrot_pop_p(interpreter, &REG_PMC(16));
  Parrot_pop_p(interpreter, &REG_PMC(0));
  goto NEXT();
}

########################################

=item B<popbottomi>()

=item B<popbottomn>()

=item B<popbottomp>()

=item B<popbottoms>()

Restore registers 0-15 of the type indicated in the name of the operation
from a register frame popped off the corresponding frame stack.

=cut

inline op popbottomi() :base_core {
  Parrot_pop_i(interpreter, &REG_INT(0));
  goto NEXT();
}

inline op popbottomn() :base_core {
  Parrot_pop_n(interpreter, &REG_NUM(0));
  goto NEXT();
}

inline op popbottoms() :base_core {
  Parrot_pop_s(interpreter, &REG_STR(0));
  goto NEXT();
}

inline op popbottomp() :base_core {
  Parrot_pop_p(interpreter, &REG_PMC(0));
  goto NEXT();
}

########################################

=item B<poptopi>()

=item B<poptopn>()

=item B<poptopp>()

=item B<poptops>()

Restore registers 16-31 of the type indicated in the name of the operation
from a register frame popped off the corresponding frame stack.

=cut

inline op poptopi() :base_core {
  Parrot_pop_i(interpreter, &REG_INT(16));
  goto NEXT();
}

inline op poptopn() :base_core {
  Parrot_pop_n(interpreter, &REG_NUM(16));
  goto NEXT();
}

inline op poptops() :base_core {
  Parrot_pop_s(interpreter, &REG_STR(16));
  goto NEXT();
}

inline op poptopp() :base_core {
  Parrot_pop_p(interpreter, &REG_PMC(16));
  goto NEXT();
}


########################################

=item B<pushi>()

=item B<pushn>()

=item B<pushp>()

=item B<pushs>()

Save all the registers of the type indicated in the name of the operation
on the appropriate register frame stack.

A register frame holds only 16 registers, so we push two frames onto the
stack. The first frame holds the values from registers 0-15; the second
frame holds the values from registers 16-31.

=cut

inline op pushi() :base_core {
  Parrot_push_i(interpreter, &REG_INT(0));
  Parrot_push_i(interpreter, &REG_INT(16));
  goto NEXT();
}

inline op pushn() :base_core {
  Parrot_push_n(interpreter, &REG_NUM(0));
  Parrot_push_n(interpreter, &REG_NUM(16));
  goto NEXT();
}

inline op pushs() :base_core {
  Parrot_push_s(interpreter, &REG_STR(0));
  Parrot_push_s(interpreter, &REG_STR(16));
  goto NEXT();
}

inline op pushp() :base_core {
  Parrot_push_p(interpreter, &REG_PMC(0));
  Parrot_push_p(interpreter, &REG_PMC(16));
  goto NEXT();
}


########################################

=item B<pushtopi>()

=item B<pushtopn>()

=item B<pushtopp>()

=item B<pushtops>()

Save registers 16-31 of the type indicated in the name of the operation
on the appropriate register frame stack.

=cut

inline op pushtopi() :base_core {
  Parrot_push_i(interpreter, &REG_INT(16));
  goto NEXT();
}

inline op pushtopn() :base_core {
  Parrot_push_n(interpreter, &REG_NUM(16));
  goto NEXT();
}

inline op pushtops() :base_core {
  Parrot_push_s(interpreter, &REG_STR(16));
  goto NEXT();
}

inline op pushtopp() :base_core {
  Parrot_push_p(interpreter, &REG_PMC(16));
  goto NEXT();
}


########################################

=item B<pushbottomi>()

=item B<pushbottomn>()

=item B<pushbottomp>()

=item B<pushbottoms>()

Save registers 0-15 of the type indicated in the name of the operation
on the appropriate register frame stack.

=cut

inline op pushbottomi() :base_core {
  Parrot_push_i(interpreter, &REG_INT(0));
  goto NEXT();
}

inline op pushbottomn() :base_core {
  Parrot_push_n(interpreter, &REG_NUM(0));
  goto NEXT();
}

inline op pushbottoms() :base_core {
  Parrot_push_s(interpreter, &REG_STR(0));
  goto NEXT();
}

inline op pushbottomp() :base_core {
  Parrot_push_p(interpreter, &REG_PMC(0));
  goto NEXT();
}

########################################

=item B<saveall>()

Save all of the registers onto the appropriate frame stacks.
This op is equivalent to:

        pushi
        pushn
        pushs
        pushp

(or some other permutation of these ops).

=item B<restoreall>()

Restore all the registers from the appropriate frame stacks.
This op is equivalent to:

        popi
        popn
        pops
        popp

(or some other permutation of these ops).

=item B<savetop>()

Save registers 16-31 of all the register sets on the appropriate frame stacks.
This op is equivalent to:

        pushtopi
        pushtopn
        pushtops
        pushtopp

(or some other permutation of these ops).

=item  B<restoretop>()

Restore registers 16-31 of all the register sets from the appropriate frame
stacks. This op is equivalent to:

        poptopi
        poptopn
        poptops
        poptopp

(or some other permutation of these ops).

=cut

inline op saveall() :base_core {
  Parrot_push_i(interpreter, &REG_INT(0));
  Parrot_push_i(interpreter, &REG_INT(16));
  Parrot_push_s(interpreter, &REG_STR(0));
  Parrot_push_s(interpreter, &REG_STR(16));
  Parrot_push_n(interpreter, &REG_NUM(0));
  Parrot_push_n(interpreter, &REG_NUM(16));
  Parrot_push_p(interpreter, &REG_PMC(0));
  Parrot_push_p(interpreter, &REG_PMC(16));
  goto NEXT();
}

inline op restoreall() :base_core {
  Parrot_pop_i(interpreter, &REG_INT(16));
  Parrot_pop_i(interpreter, &REG_INT(0));
  Parrot_pop_s(interpreter, &REG_STR(16));
  Parrot_pop_s(interpreter, &REG_STR(0));
  Parrot_pop_n(interpreter, &REG_NUM(16));
  Parrot_pop_n(interpreter, &REG_NUM(0));
  Parrot_pop_p(interpreter, &REG_PMC(16));
  Parrot_pop_p(interpreter, &REG_PMC(0));
  goto NEXT();
}

inline op savetop() :base_core {
  Parrot_push_i(interpreter, &REG_INT(16));
  Parrot_push_s(interpreter, &REG_STR(16));
  Parrot_push_n(interpreter, &REG_NUM(16));
  Parrot_push_p(interpreter, &REG_PMC(16));
  goto NEXT();
}

inline op restoretop() :base_core {
  Parrot_pop_i(interpreter, &REG_INT(16));
  Parrot_pop_s(interpreter, &REG_STR(16));
  Parrot_pop_n(interpreter, &REG_NUM(16));
  Parrot_pop_p(interpreter, &REG_PMC(16));
  goto NEXT();
}

=back

=cut

###############################################################################

=head2 User stack operations

These operations affect individual registers.

=over 4

=cut


########################################

=item B<entrytype>(out INT, in INT)

Gets the type of entry $2 of the user stack and puts it in $1.

=cut

op entrytype(out INT, in INT) :base_core {
  Stack_Entry_t *entry;

  entry = stack_entry(interpreter, interpreter->ctx.user_stack, $2);
  if (!entry) {
    internal_exception(99, "Stack Depth wrong");
  }
  $1 = get_entry_type(interpreter, entry);
  goto NEXT();
}

########################################

=item B<depth>(out INT)

Puts the depth of the user stack in $1.

=cut

inline op depth(out INT) :base_core {
  $1 = stack_height(interpreter, interpreter->ctx.user_stack);
  goto NEXT();
}

#######################################

=item B<lookback>(out INT, in INT)

=item B<lookback>(out STR, in INT)

=item B<lookback>(out NUM, in INT)

=item B<lookback>(out PMC, in INT)

Finds the entry in the user stack at offset $2 from the top and put it
in register $1. Positive numbers count down from the top of the stack,
negative numbers count up from the bottom. (0 is the topmost entry, -1
is the bottom-most)

=cut

op lookback(out INT, in INT) :base_core {
  Stack_Entry_t *entry =
  	stack_entry(interpreter, interpreter->ctx.user_stack, $2);
  if (!entry)
      internal_exception(99, "Stack depth wrong");
  if (entry->entry_type != STACK_ENTRY_INT) {
    internal_exception(ERROR_BAD_STACK_TYPE, "Wrong type on stack!");
  }

  $1 = UVal_int(entry->entry);
  goto NEXT();
}

op lookback(out STR, in INT) :base_core {
  Stack_Entry_t *entry =
  	stack_entry(interpreter, interpreter->ctx.user_stack, $2);
  if (!entry)
      internal_exception(99, "Stack depth wrong");
  if (entry->entry_type != STACK_ENTRY_STRING) {
    internal_exception(ERROR_BAD_STACK_TYPE, "Wrong type on stack!");
  }

  $1 = UVal_str(entry->entry);
  goto NEXT();
}

op lookback(out NUM, in INT) :base_core {
  Stack_Entry_t *entry =
  	stack_entry(interpreter, interpreter->ctx.user_stack, $2);
  if (!entry)
      internal_exception(99, "Stack depth wrong");
  if (entry->entry_type != STACK_ENTRY_FLOAT) {
    internal_exception(ERROR_BAD_STACK_TYPE, "Wrong type on stack!");
  }

  $1 = UVal_num(entry->entry);
  goto NEXT();
}

op lookback(out PMC, in INT) :base_core {
  Stack_Entry_t *entry =
  	stack_entry(interpreter, interpreter->ctx.user_stack, $2);
  if (!entry)
      internal_exception(99, "Stack depth wrong");
  if (entry->entry_type != STACK_ENTRY_PMC) {
    internal_exception(ERROR_BAD_STACK_TYPE, "Wrong type on stack!");
  }

  $1 = UVal_pmc(entry->entry);
  goto NEXT();
}

########################################

=item B<save>(in INT)

=item B<save>(in NUM)

=item B<save>(in STR)

=item B<save>(in PMC)

Save register or constant $1 onto the user stack.

=cut

inline op save(in INT) :base_core {
  INTVAL i = $1;
  stack_push(interpreter, &interpreter->ctx.user_stack, &i, STACK_ENTRY_INT, STACK_CLEANUP_NULL);
  goto NEXT();
}

inline op save(in NUM) :base_core {
  stack_push(interpreter, &interpreter->ctx.user_stack, &($1), STACK_ENTRY_FLOAT, STACK_CLEANUP_NULL);
  goto NEXT();
}

inline op save(in PMC) :base_core {
  stack_push(interpreter, &interpreter->ctx.user_stack, $1, STACK_ENTRY_PMC, STACK_CLEANUP_NULL);
  goto NEXT();
}

inline op save(in STR) :base_core {
  stack_push(interpreter, &interpreter->ctx.user_stack, $1, STACK_ENTRY_STRING, STACK_CLEANUP_NULL);
  goto NEXT();
}

########################################

=item B<savec>(in STR)

Save a clone of register or constant $1 onto the user stack.

=cut

inline op savec(in STR) :base_core {
  stack_push(interpreter, &interpreter->ctx.user_stack, string_copy(interpreter, $1), STACK_ENTRY_STRING, STACK_CLEANUP_NULL);
  goto NEXT();
}

########################################

=item B<restore>(out INT)

=item B<restore>(out NUM)

=item B<restore>(out PMC)

=item B<restore>(out STR)

Restore register $1 from the user stack.

=cut

inline op restore(out INT) :base_core {
  (void)stack_pop(interpreter, &interpreter->ctx.user_stack, &($1),
                  STACK_ENTRY_INT);
  goto NEXT();
}

inline op restore(out NUM) :base_core {
  (void)stack_pop(interpreter, &interpreter->ctx.user_stack, &($1),
                  STACK_ENTRY_FLOAT);
  goto NEXT();
}

inline op restore(out PMC) :base_core {
  (void)stack_pop(interpreter, &interpreter->ctx.user_stack, &($1),
                  STACK_ENTRY_PMC);
  goto NEXT();
}

inline op restore(out STR) :base_core {
  (void)stack_pop(interpreter, &interpreter->ctx.user_stack, &($1),
                  STACK_ENTRY_STRING);
  goto NEXT();
}

########################################

=item B<rotate_up>(in INT)

Rotate the top $1 entries in the user stack by one. If $1 is positive,
then the stack rotates upwards: the ($1)th entry becomes the ($1-1)th
entry and so on, all the way up to the top of the stack, while the
entry formerly at the top of the stack becomes the new ($1)th entry.
If $1 is negative, the stack rotates downwards: the top entry becomes
the second entry, the second becomes the third etc., while the former
($1)th entry becomes the new top entry.

=cut

inline op rotate_up(in INT) :base_core {
  rotate_entries(interpreter, &interpreter->ctx.user_stack, $1);
  goto NEXT();
}

########################################

=item B<intsave>(in INT)

Save register or constant $1 onto the high-speed int stack.

=cut

inline op intsave(in INT) :base_core {
  intstack_push(interpreter, interpreter->ctx.intstack, $1);
  goto NEXT();
}

########################################

=item B<intrestore>(out INT)

Restore register $1 from the high-speed int stack.

=cut

inline op intrestore(out INT) :base_core {
  $1=intstack_pop(interpreter, interpreter->ctx.intstack);
  goto NEXT();
}

########################################

=item B<intdepth>(out INT)

Puts the depth of the high-speed int stack in $1.

=cut

inline op intdepth(out INT) :base_core {
  $1=intstack_depth(interpreter, interpreter->ctx.intstack);
  goto NEXT();
}

=back

=cut

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001-2004 The Perl Foundation.  All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut
