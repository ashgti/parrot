/*
** core.ops
*/

=head1 NAME

core.ops

=cut

=head1 DESCRIPTION

Parrot's core library of ops.

=cut


###############################################################################

=head2 Basic ops

These are the fundamental operations.

=over 4

=cut


########################################

=item B<end>()

Halts the interpreter.

=cut

MANUAL_OP end() {
   HALT;
}


########################################

=item B<noop>()

Does nothing other than waste an iota of time and 32 bits of bytecode space.

=cut

AUTO_OP noop() {
}


=back

=cut


###############################################################################

=head2 System environment operations

These operations allow interaction between the Parrot program and the system
environment.

=over 4

=cut


########################################

=item close(i|ic)

Close file opened on file descriptor $1.

=cut

AUTO_OP close(i|ic) {
  close($1);
}


########################################

=item err(i)

Store the system error code in $1.

=item err(s)

Store the system error message in $1.

=cut

AUTO_OP err(i) {
  $1 = errno;
}

AUTO_OP err(s) {
  char *tmp = strerror(errno);
  STRING *s = string_make(interpreter, tmp, strlen(tmp), 0, 0, 0);
  $1 = s;
}


########################################

=item B<open>(i, s|sc)

Open file named $2 with flags for writing and mode 0644 (rw-r--r--), and save
the file descriptor into $1.

=item B<open>(i, s|sc, i|ic)

Open file named $2 with flags $3 and mode 0644 (rw-r--r--), and save the file
descriptor into $1.

=item B<open>(i, s|sc, i|ic, i|ic)

Open file named $2 with flags $3 and mode $4, and save the file descriptor
into $1.

=cut

AUTO_OP open(i, s|sc) {
  STRING *s = $2;
  $1 = open(s->bufstart, O_WRONLY | O_CREAT | O_TRUNC, DEFAULT_OPEN_MODE);
}

AUTO_OP open(i, s|sc, i|ic) {
  STRING *s = $2;
  $1 = open(s->bufstart, $3, DEFAULT_OPEN_MODE);
}

AUTO_OP open(i, s|sc, i|ic, i|ic) {
  STRING *s = $2;
  $1 = open(s->bufstart, $3, $4);
}


########################################

=item B<ord>(i,s|sc)

Two-argument form returns the 0th character of string $2 in register $1.
If $2 is empty, throws an exception.

=item B<ord>(i,s|sc,i|ic)

Three-argument form returns character $3 of string $2 in register 1.
If $2 is empty, throws an exception.
If $3 is greater than the length of string $2, throws an exception
If $3 is less then zero but greater than the negative of the length, counts
backwards through the string, such that -1 is the last character, -2 is the
second-to-last character, and so on.
If $3 is less than the negative of the length, throws an exception.

=cut

AUTO_OP ord(i,s|sc) {
  $1 = string_ord($2,0);
}

AUTO_OP ord(i,s|sc,i|ic) {
  $1 = string_ord($2,$3);
}


########################################

=item B<print>(i|ic)

=item B<print>(n|nc)

=item B<print>(s|sc)

=item B<print>(p)

Print $1 to standard output.

=cut

AUTO_OP print(i|ic) {
  /* TODO: Configure for format */
  printf("%li", (long) $1);
}

AUTO_OP print(n|nc) {
  /* TODO: Configure for format */
  printf("%f", $1);
}

AUTO_OP print(s|sc) {
  STRING *s = $1;
  if (s) printf("%.*s",(int)string_length(s),(char *) s->bufstart);
}

AUTO_OP print(p) {
  PMC *p = $1;
  if (p->vtable == &Parrot_base_vtables[enum_class_PerlInt]) {
    printf("%li",(long)(p->vtable->get_integer(interpreter, p)));
  } else if (p->vtable == &Parrot_base_vtables[enum_class_PerlNum]) {
    printf("%f",(p->vtable->get_number(interpreter, p)));
  }
}


########################################

=item read(i, i|ic)

Read an INTVAL from file descriptor $2 into $1.

=item read(n, i|ic)

Read a FLOATVAL from file descriptor $2 into $1.

=item read(s, i|ic, i|ic)

Read $3 bytes from file descriptor $2 into string $1.

=cut

AUTO_OP read(i, i|ic) {
  read($2, &($1), sizeof(INTVAL));
}

AUTO_OP read(n, i|ic) {
  read($2, &($1), sizeof(FLOATVAL));
}

AUTO_OP read(s, i|ic, i|ic) {
  char *tmp;
  STRING *s;
  INTVAL len = $3;

  string_destroy($1);
  tmp = malloc(len + 1);
  read($2, tmp, len);
  s = string_make(interpreter, tmp, len, 0, 0, 0);
  $1 = s;
  free(tmp);
}


########################################

=item B<time>(i)

Puts the current system time (represented as a whole number of seconds)
in $1.

=cut

AUTO_OP time(i) {
  $1 = Parrot_intval_time();
}


########################################

=item B<time>(n)

Puts the current system time (represented as a number of seconds, with
microseconds) in $1.

=cut

AUTO_OP time(n) {
  $1 = Parrot_floatval_time();
}


########################################

=item write(i|ic, i|ic)

=item write(i|ic, n|nc)

=item write(i|ic, s|sc)

Write $2 to file descriptor $1.

=cut

AUTO_OP write(i|ic, i|ic) {
  INTVAL * i = &($2);
  write($1, i, sizeof(INTVAL));
}

AUTO_OP write(i|ic, n|nc) {
  FLOATVAL * f = &($2);
  write($1, f, sizeof(FLOATVAL));
}

AUTO_OP write(i|ic, s|sc) {
  STRING * s = $2;
  INTVAL count = string_length(s);
  write($1, s->bufstart, count);
}


=back

=cut


###############################################################################

=head2 Register loading operations

These operations load registers from constants or other registers.

=over 4

=cut


########################################

=item B<set>(i, i)

=item B<set>(i, ic)

=item B<set>(p, i)

=item B<set>(p, ic)

=item B<set>(n, n)

=item B<set>(n, nc)

=item B<set>(p, n)

=item B<set>(p, nc)

=item B<set>(n, p)

=item B<set>(s, sc)

=item B<set>(s, s)

Set $1 to $2.

=cut


AUTO_OP set(i, i|ic) {
  $1 = $2;
}

AUTO_OP set(n, n|nc) {
  $1 = $2;
}

AUTO_OP set(n, p) {
  $1 = $2->vtable->get_number(interpreter, $2);
}

AUTO_OP set(s, s|sc) {
  $1 = string_copy(interpreter, $2);
}

AUTO_OP set(p, i|ic) { 
  $1->vtable->set_integer_native(interpreter, $1, $2);
}

AUTO_OP set(p, n|nc) { 
  $1->vtable->set_number_native(interpreter, $1, $2);
}

=back

=cut


###############################################################################

=head2 Conversion operations

These operations load registers of one type with values from registers of
another type, performing the appropriate type conversion along the way.

=over 4

=cut


########################################

=item B<iton>(n, i)

Load $1 with the FLOATVAL corresponding to the INTVAL from $2.

=cut

AUTO_OP iton(n, i) {
  $1 = (FLOATVAL)$2;
}


########################################

=item B<ntoi>(i, n)

Load $1 with the INTVAL corresponding to the truncated FLOATVAL from $2.

=cut

AUTO_OP ntoi(i, n) {
  FLOATVAL number;
  number = $2;
  $1 = (INTVAL)number;
}


=back

=cut


###############################################################################

=head2 Conditional branch operations

These opertions perform a conditional relative branch. If the condition is
met, the branch happens, otherwise control falls to the next operation.

=over 4

=cut


########################################

=item B<eq>(i, i, ic)

=item B<eq>(i, ic, ic)

=item B<eq>(n, n, ic)

=item B<eq>(n, nc, ic)

=item B<eq>(s, s, ic)

=item B<eq>(s, sc, ic)

Branch if $1 is equal to $2.

=cut

AUTO_OP eq(i, i|ic, ic) {
  if ($1 == $2) {
    RETREL($3);
  }
}

AUTO_OP eq(n, n|nc, ic) {
  if ($1 == $2) {
    RETREL($3);
  }
}

AUTO_OP eq(s, s|sc, ic) {
  if (string_compare(interpreter, $1, $2) == 0) {
    RETREL($3);
  }
}


########################################

=item B<ne>(i, i, ic)

=item B<ne>(i, ic, ic)

=item B<ne>(n, n, ic)

=item B<ne>(n, nc, ic)

=item B<ne>(s, s, ic)

=item B<ne>(s, sc, ic)

Branch if $1 is not equal to $2.

=cut

AUTO_OP ne(i, i|ic, ic) {
  if ($1 != $2) {
    RETREL($3);
  }
}

AUTO_OP ne(n, n|nc, ic) {
  if ($1 != $2) {
    RETREL($3);
  }
}

AUTO_OP ne(s, s|sc, ic) {
  if (string_compare(interpreter, $1, $2) != 0) {
    RETREL($3);
  }
}


########################################

=item B<lt>(i, i, ic)

=item B<lt>(i, ic, ic)

=item B<lt>(n, n, ic)

=item B<lt>(n, nc, ic)

=item B<lt>(s, s, ic)

=item B<lt>(s, sc, ic)

Branch if $1 is less than $2.

=cut

AUTO_OP lt(i, i|ic, ic) {
  if ($1 < $2) {
    RETREL($3);
  }
}

AUTO_OP lt(n, n|nc, ic) {
  if ($1 < $2) {
    RETREL($3);
  }
}

AUTO_OP lt(s, s|sc, ic) {
  if (string_compare(interpreter, $1, $2) < 0) {
    RETREL($3);
  }
}


########################################

=item B<le>(i, i, ic)

=item B<le>(i, ic, ic)

=item B<le>(n, n, ic)

=item B<le>(n, nc, ic)

=item B<le>(s, s, ic)

=item B<le>(s, sc, ic)

Branch if $1 is less than or equal to $2.

=cut

AUTO_OP le(i, i|ic, ic) {
  if ($1 <= $2) {
    RETREL($3);
  }
}

AUTO_OP le(n, n|nc, ic) {
  if ($1 <= $2) {
    RETREL($3);
  }
}

AUTO_OP le(s, s|sc, ic) {
  if (string_compare(interpreter, $1, $2) <= 0) {
    RETREL($3);
  }
}


########################################

=item B<gt>(i, i, ic)

=item B<gt>(i, ic, ic)

=item B<gt>(n, n, ic)

=item B<gt>(n, nc, ic)

=item B<gt>(s, s, ic)

=item B<gt>(s, sc, ic)

Branch if $1 is greater than $2.

=cut

AUTO_OP gt(i, i|ic, ic) {
  if ($1 > $2) {
    RETREL($3);
  }
}

AUTO_OP gt(n, n|nc, ic) {
  if ($1 > $2) {
    RETREL($3);
  }
}

AUTO_OP gt(s, s|sc, ic) {
  if (string_compare(interpreter, $1, $2) > 0) {
    RETREL($3);
  }
}


########################################

=item B<ge>(i, i, ic)

=item B<ge>(i, ic, ic)

=item B<ge>(n, n, ic)

=item B<ge>(n, nc, ic)

=item B<ge>(s, s, ic)

=item B<ge>(s, sc, ic)

Branch if $1 is greater than or equal to $2.

=cut

AUTO_OP ge(i, i|ic, ic) {
  if ($1 >= $2) {
    RETREL($3);
  }
}

AUTO_OP ge(n, n|nc, ic) {
  if ($1 >= $2) {
    RETREL($3);
  }
}

AUTO_OP ge(s, s|sc, ic) {
  if (string_compare(interpreter, $1, $2) >= 0) {
    RETREL($3);
  }
}


########################################

=item B<if>(i, ic)

=item B<if>(p, ic)

=item B<if>(n, ic)

Check register $1. If true, branch by $2.

=cut

AUTO_OP if(i, ic) {
  if ($1 != 0) {
    RETREL($2);
  }
}

AUTO_OP if(n, ic) {
  if ($1 != 0.0) {
    RETREL($2);
  }
}

AUTO_OP if(p, ic) {
  if ($1->vtable->get_bool(interpreter, $1)) {
    RETREL($2);
  }
}


=back

=cut



###############################################################################

=head2 Arithmetic operations

These operations store the results of arithmetic on other registers and
constants into their destination register, $1.

=over 4

=cut


########################################

=item B<add>(i, i, i)

=item B<add>(i, i, ic)

=item B<add>(n, n, n)

=item B<add>(n, n, nc)

Set $1 to the sum of $2 and $3.

=cut

AUTO_OP add(i, i, i|ic) {
  $1 = $2 + $3;
}

AUTO_OP add(n, n, n|nc) {
  $1 = $2 + $3;
}


########################################

=item B<cmod>(i, i, i)

=item B<cmod>(i, i, ic)

=item B<cmod>(i, ic, i)

NOTE: This "uncorrected mod" algorithm uses the C language's built-in
mod operator (x % y), which is

    ... the remainder when x is divided by y, and thus is zero when y
    divides x exactly.
    ...
    The direction of truncation for / and the sign of the result for %
    are machine-dependent for negative operands, as is the action taken
    on overflow or underflow.
                                                         -- [1], page 41

Also:

    ... if the second operand is 0, the result is undefined. Otherwise, it
    is always true that (a/b)*b + a%b is equal to z. If both operands are
    non-negative, then the remainder is non-negative and smaller than the
    divisor; if not, it is guaranteed only that the absolute value of the
    remainder is smaller than the absolute value of the divisor.
                                                         -- [1], page 205

This op is provided for those who need it (such as speed-sensitive
applications with heavy use of mod, but using it only with positive
arguments), but a more mathematically useful mod based on ** floor(x/y)
and defined with y == 0 is provided by the mod_i op.

  [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
      Language*, Second Edition. Prentice Hall, 1988.

TODO: Doesn't the Parrot interpreter need to catch the exception?

=cut

AUTO_OP cmod(i, i|ic, i|ic) {
  $1 = $2 % $3;
}


########################################

=item B<cmod>(n, n, n)

=item B<cmod>(n, n, nc)

=item B<cmod>(n, nc, n)

NOTE: This "uncorrected mod" algorithm uses the built-in C math library's
fmod() function, which computes

    ... the remainder of dividing x by y. The return value is x - n * y,
    where n is the quotient of x / y, rounded towards zero to an
    integer.
                                    -- fmod() manpage on RedHat Linux 7.0

In addition, fmod() returns

    the remainder, unless y is zero, when the function fails and errno
    is set.

According to page 251 of [1], the result when y is zero is implementation-
defined.

This op is provided for those who need it, but a more mathematically
useful numeric mod based on floor(x/y) instead of truncate(x/y) and
defined with y == 0 is provided by the mod_n op.

  [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
      Language*, Second Edition. Prentice Hall, 1988.

TODO: Doesn't the Parrot interpreter need to catch the exception?

=cut

AUTO_OP cmod(n, n|nc, n|nc) {
  $1 = fmod($2, $3);
}


########################################

=item B<dec>(i)

=item B<dec>(n)

Decrease $1 by one.

=cut

AUTO_OP dec(i|n) {
  $1--;
}


########################################

=item B<dec>(i, ic)

=item B<dec>(n, nc)

Decrease $1 by the amount in $2.

=cut

AUTO_OP dec(i, ic) {
  $1 -= $2;
}

AUTO_OP dec(n, nc) {
  $1 -= $2;
}


########################################

=item B<div>(i, i, i)

=item B<div>(i, i, ic)

=item B<div>(i, ic, i)

=item B<div>(n, n, n)

=item B<div>(n, n, nc)

=item B<div>(n, nc, n)

Set $1 to the quotient of $2 divided by $3. In the case of INTVAL division, the
result is truncated (NOT rounded or floored).

=cut

AUTO_OP div(i, i|ic, i|ic) {
  $1 = $2 / $3;
}

AUTO_OP div(n, n|nc, n|nc) {
  $1 = $2 / $3;
}


########################################

=item B<inc>(i)

=item B<inc>(n)

Increase $1 by one.

=cut

AUTO_OP inc(i|n) {
  $1++;
}


########################################

=item B<inc>(i, ic)

=item B<inc>(n, nc)

Increase $1 by the amount in $2.

=cut

AUTO_OP inc(i, ic) {
  $1 += $2;
}

AUTO_OP inc(n, nc) {
  $1 += $2;
}


########################################

=item B<mod>(i, i, i)

=item B<mod>(i, i, ic)

=item B<mod>(i, ic, i)

NOTE: This "corrected mod" algorithm is based on the C code on page 70
of [1]. Assuming correct behavior of C's built-in mod operator (%) with
positive arguments, this algorithm implements a mathematically convenient
version of mod, defined thus:

  x mod y = x - y * floor(x / y)

For more information on this definition of mod, see section 3.4 of [2],
pages 81-85.

References:

  [1] Donald E. Knuth, *MMIXware: A RISC Computer for the Third
      Millennium* Springer, 1999.

  [2] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
      Mathematics*, Second Edition. Addison-Wesley, 1994.

=cut

AUTO_OP mod(i, i|ic, i|ic) {
  INTVAL y = $2;
  INTVAL z = $3;
  INTVAL s = 0;
  INTVAL r;

  if (z == 0) {
    r = y;
  }
  else {
    if (y < 0) { s += 2; y = -y; }
    if (z < 0) { s += 1; z = -z; }

    r = y % z;

    switch (s) {
      case 0 + 0:            break;
      case 0 + 1: r = r - z; break;
      case 2 + 0: r = z - r; break;
      case 2 + 1: r = -r;    break;
    }
  }

  $1 = r;
}


########################################

=item B<mod>(n, n, n)

=item B<mod>(n, n, nc)

=item B<mod>(n, nc, n)

NOTE: This "corrected mod" algorithm is based on the formula of [1]:

  x mod y = x - y * floor(x / y)

For more information on this definition of mod, see section 3.4 of [1],
pages 81-85.

References:

  [1] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
      Mathematics*, Second Edition. Addison-Wesley, 1994.

=cut

AUTO_OP mod(n, n|nc, n|nc) {
  $1 = $3
     ? ($2 - $3 * floor($2 / $3))
     : $2;
}


########################################

=item B<mul>(i, i, i)

=item B<mul>(i, i, ic)

=item B<mul>(n, n, n)

=item B<mul>(n, n, nc)

Set $1 to the product of $2 and $3.

=cut

AUTO_OP mul(i, i, i|ic) {
  $1 = $2 * $3;
}

AUTO_OP mul(n, n, n|nc) {
  $1 = $2 * $3;
}


########################################

=item B<pow>(n, i, i)

=item B<pow>(n, i, ic)

=item B<pow>(n, ic, i)

=item B<pow>(n, i, n)

=item B<pow>(n, i, nc)

=item B<pow>(n, ic, n)

=item B<pow>(n, n, i)

=item B<pow>(n, n, ic)

=item B<pow>(n, nc, i)

=item B<pow>(n, n, n)

=item B<pow>(n, n, nc)

=item B<pow>(n, nc, n)

Set $1 to $2 raised to the power $3.

=cut

AUTO_OP pow(n, i|ic|n|nc, i|ic|n|nc) {
   $1 = pow((FLOATVAL)$2, (FLOATVAL)$3);
}


########################################

=item B<sub>(i, i, i)

=item B<sub>(i, i, ic)

=item B<sub>(i, ic, i)

=item B<sub>(n, n, n)

=item B<sub>(n, n, nc)

=item B<sub>(n, nc, n)

Set $1 to $2 minus $3.

=cut

AUTO_OP sub(i, i|ic, i|ic) {
  $1 = $2 - $3;
}

AUTO_OP sub(n, n|nc, n|nc) {
  $1 = $2 - $3;
}


=back

=cut


###############################################################################

=head2 String operations

These operations operate on STRINGs.

=cut


########################################

=item B<chopn>(s, ic)

=item B<chopn>(s, i)

Remove $2 characters from the end of the string in $1.

TODO: Create a three-argument version of this? Don't force in-place modification.

=cut

AUTO_OP chopn(s, i|ic) {
   (void)string_chopn($1, $2);
}


########################################

=item B<concat>(s, s)

=item B<concat>(s, sc)

=item B<concat>(s, s, s)

=item B<concat>(s, s, sc)

=item B<concat>(s, sc, s)

Append the string in $2 to the string in $1.

The three argument version appends the string $3 to $2 and places the result
into $1.

=cut

AUTO_OP concat(s, s|sc) {
    $1 = string_concat(interpreter, $1, $2, 1);
}

AUTO_OP concat(s, s|sc, s|sc) {
    $1 = string_concat(interpreter, $2, $3, 1);
}


########################################

=item B<length>(i, s)

Set $1 to the length (in characters) of the string in $2.

=cut

AUTO_OP length(i, s) {
  $1 = string_length($2);
}


########################################

=item B<substr>(s, s, i, i)

=item B<substr>(s, s, i, ic)

=item B<substr>(s, s, ic, i)

=item B<substr>(s, s, ic, ic)

=item B<substr>(s, sc, i, i)

=item B<substr>(s, sc, i, ic)

=item B<substr>(s, sc, ic, i)

Set $1 to the portion of $2 starting at (zero-based) character position $3 and having
length $4.

=cut

AUTO_OP substr(s, s|sc, i|ic, i|ic) {
    $1 = string_substr(interpreter, $2, $3, $4, &$1);
}


=back

=cut


###############################################################################

=head2 Transcendental mathematical operations

These operations perform various transcendental operations such as logarithmics
and trigonometrics.

=over 4

=cut


########################################

=item B<acos>(n, i)

=item B<acos>(n, n)

Set $1 to the arc cosine (in radians) of $2.

=cut

AUTO_OP acos(n, i|n) {
   $1 = acos((FLOATVAL)$2);
}


########################################

=item B<asec>(n, i)

=item B<asec>(n, n)

Set $1 to the arc secant (in radians) of $2.

=cut

AUTO_OP asec(n, i|n) {
   $1 = acos(((FLOATVAL)1) / ((FLOATVAL)$2));
}


########################################

=item B<asin>(n, i)

=item B<asin>(n, n)

Set $1 to the arc sine (in radians) of $2.

=cut

AUTO_OP asin(n, i|n) {
   $1 = asin((FLOATVAL)$2);
}


########################################

=item B<atan>(n, i)

=item B<atan>(n, i, i)

=item B<atan>(n, i, ic)

=item B<atan>(n, ic, i)

=item B<atan>(n, i, n)

=item B<atan>(n, i, nc)

=item B<atan>(n, ic, n)

=item B<atan>(n, n)

=item B<atan>(n, n, i)

=item B<atan>(n, n, ic)

=item B<atan>(n, nc, i)

=item B<atan>(n, n, n)

=item B<atan>(n, n, nc)

=item B<atan>(n, nc, n)

The two-argument versions set $1 to the arc tangent (in radians) of $2.

The three-argument versions set $1 to the arc tangent (in radians) of
$2 / $3, taking account of the signs of the arguments in determining the
quadrant of the result.

=cut

AUTO_OP atan(n, i|n) {
   $1 = atan((FLOATVAL)$2);
}

AUTO_OP atan(n, i|ic|n|nc, i|ic|n|nc) {
   $1 = atan2((FLOATVAL)$2, (FLOATVAL)$3);
}


########################################

=item B<cos>(n, i)

=item B<cos>(n, n)

Set $1 to the cosine of $2 (given in radians).

=cut

AUTO_OP cos(n, i|n) {
   $1 = cos((FLOATVAL)$2);
}


########################################

=item B<cosh>(n, i)

=item B<cosh>(n, n)

Set $1 to the hyperbolic cosine of $2 (given in radians).

=cut

AUTO_OP cosh(n, i|n) {
   $1 = cosh((FLOATVAL)$2);
}


########################################

=item B<exp>(n, i)

=item B<exp>(n, n)

Set $1 to I<e> raised to the power $2. I<e> is the base of the natural logarithm.

=cut

AUTO_OP exp(n, i|n) {
   $1 = exp((FLOATVAL)$2);
}


########################################

=item B<ln>(n, i)

=item B<ln>(n, n)

Set $1 to the natural (base I<e>) logarithm of $2.

=cut

AUTO_OP ln(n, i|n) {
   $1 = log((FLOATVAL)$2);
}


########################################

=item B<log10>(n, i)

=item B<log10>(n, n)

Set $1 to the base 10 logarithm of $2.

=cut

AUTO_OP log10(n, i|n) {
   $1 = log10((FLOATVAL)$2);
}


########################################

=item B<log2>(n, i)

=item B<log2>(n, n)

Set $1 to the base 2 logarithm of $2.

=cut

AUTO_OP log2(n, i|n) {
   FLOATVAL temp = log((FLOATVAL)2.0);
   $1 = log((FLOATVAL)$2) / temp;
}


########################################

=item B<sec>(n, i)

=item B<sec>(n, n)

Set $1 to the secant of $2 (given in radians).

=cut


AUTO_OP sec(n, i|n) {
   $1 = ((FLOATVAL)1) / cos((FLOATVAL)$2);
}


########################################

=item B<sech>(n, i)

=item B<sech>(n, n)

Set $1 to the hyperbolic secant of $2 (given in radians).

=cut

AUTO_OP sech(n, i|n) {
   $1 = ((FLOATVAL)1) / cosh((FLOATVAL)$2);
}


########################################

=item B<sin>(n, i)

=item B<sin>(n, n)

Set $1 to the sine of $2 (given in radians).

=cut

AUTO_OP sin(n, i|n) {
   $1 = sin((FLOATVAL)$2);
}


########################################

=item B<sinh>(n, i)

=item B<sinh>(n, n)

Set $1 to the hyperbolic sine of $2 (given in radians).

=cut

AUTO_OP sinh(n, i|n) {
   $1 = sinh((FLOATVAL)$2);
}


########################################

=item B<tan>(n, i)
=item B<tan>(n, n)

Set $1 to the tangent of $2 (given in radians).

=cut

AUTO_OP tan(n, i|n) {
   $1 = tan((FLOATVAL)$2);
}


########################################

=item B<tanh>(n, i)

=item B<tanh>(n, n)

Set $1 to the hyperbolic tangent of $2 (given in radians).

=cut

AUTO_OP tanh(n, i|n) {
   $1 = tanh((FLOATVAL)$2);
}


=back

=cut


###############################################################################

=head2 Bitwise logical operations

These operations apply  bitwise logical functions to their arguments.

=over 4

=cut


########################################

=item B<and>(i, i, i)

=item B<and>(i, i, ic)

Set the bits of $1 according to the B<and> of the corresponding bits from $2 and $3.

=cut

AUTO_OP and(i, i, i|ic) {
  $1 = $2 & $3;
}


########################################

=item B<not>(i, i)

Set the bits of $1 to the B<not> of the corresponding bits from $2.

=cut

AUTO_OP not(i, i) {
  $1 = ~ $2;
}


########################################

=item B<or>(i, i, i)

=item B<or>(i, i, ic)

Set the bits of $1 according to the B<or> of the corresponding bits from $2 and $3.

=cut

AUTO_OP or(i, i, i|ic) {
  $1 = $2 | $3;
}

########################################

=item B<shl>(i, i, i)

=item B<shl>(i, i, ic)

=item B<shl>(i, ic, i)

Set $1 to the value of $2 shifted left by $3 bits.

=cut

AUTO_OP shl(i, i|ic, i|ic) {
  $1 = $2 << $3;
}


########################################

=item B<shr>(i, i, i)

=item B<shr>(i, i, ic)

=item B<shr>(i, ic, i)

Set $1 to the value of $2 shifted right by $3 bits.

=cut

AUTO_OP shr(i, i|ic, i|ic) {
  $1 = $2 >> $3;
}


########################################

=item B<xor>(i, i, i)

=item B<xor>(i, i, ic)

Set the bits of $1 according to the B<xor> of the corresponding bits from $2 and $3.

=cut

AUTO_OP xor(i, i, i|ic) {
  $1 = $2 ^ $3;
}


=back

=cut


###############################################################################

=head2 Interpreter flag modification operations

These operations modify the interpreter's internal flags, affecting its
subsequent operation.

=over 4

=cut


########################################

=item B<bounds>(ic)

If $1 is zero, turn off byte code bounds checking. Otherwise turn it on.

=cut

MANUAL_OP bounds(ic) {
  if ($1 != 0) { interpreter->flags |=  PARROT_BOUNDS_FLAG; }
  else         { interpreter->flags &= ~PARROT_BOUNDS_FLAG; }
  RESTART(*);
}


########################################

=item B<profile>(ic)

If $1 is zero, turn off profiling. Otherwise turn it on.

=cut

MANUAL_OP profile(ic) {
  if ($1 != 0) { interpreter->flags |=  PARROT_PROFILE_FLAG; }
  else         { interpreter->flags &= ~PARROT_PROFILE_FLAG; }
  RESTART(*);
}


########################################

=item B<trace>(ic)

If $1 is zero, turn off tracing. Otherwise turn it on.

=cut

MANUAL_OP trace(ic) {
  if ($1 != 0) { interpreter->flags |=  PARROT_TRACE_FLAG; }
  else         { interpreter->flags &= ~PARROT_TRACE_FLAG; }
  RESTART(*);
}

=back

=cut


###############################################################################

=head2 Register operations

These operations effect entire sets of registers.

=over 4

=cut


########################################

=item B<cleari>()

=item B<clearn>()

=item B<clearp>()

=item B<clears>()

Clear all the registers of the type indicated in the name of the operation.

INTVAL ('i') and FLOATVAL ('n') registers clear to zero.

PMC ('p') and STRING ('s') registers clear to NULL.

=cut

AUTO_OP cleari() {
  Parrot_clear_i(interpreter);
}

AUTO_OP clearn() {
  Parrot_clear_n(interpreter);
}

AUTO_OP clears() {
  Parrot_clear_s(interpreter);
}

AUTO_OP clearp() {
  Parrot_clear_p(interpreter);
}


########################################

=item B<popi>()

=item B<popn>()

=item B<popp>()

=item B<pops>()

Restore all the registers of the type indicated in the name of the operation
from the most recently B<push>ed copies.

=cut

AUTO_OP popi() {
  Parrot_pop_i(interpreter);
}

AUTO_OP popn() {
  Parrot_pop_n(interpreter);
}

AUTO_OP pops() {
  Parrot_pop_s(interpreter);
}

AUTO_OP popp() {
  Parrot_pop_p(interpreter);
}


########################################

=item B<pushi>()

=item B<pushn>()

=item B<pushp>()

=item B<pushs>()

Save all the registers of the type indicated in the name of the operation.

=cut

AUTO_OP pushi() {
  Parrot_push_i(interpreter);
}

AUTO_OP pushn() {
  Parrot_push_n(interpreter);
}

AUTO_OP pushs() {
  Parrot_push_s(interpreter);
}

AUTO_OP pushp() {
  Parrot_push_p(interpreter);
}

########################################

=item B<clonei>()

=item B<clonen>()

=item B<clonep>()

=item B<clones>()

Save all the registers of the type indicated in the name of the operation.

=cut

AUTO_OP clonei() {
  Parrot_clone_i(interpreter);
}

AUTO_OP clonen() {
  Parrot_clone_n(interpreter);
}

AUTO_OP clones() {
  Parrot_clone_s(interpreter);
}

AUTO_OP clonep() {
  Parrot_clone_p(interpreter);
}

=back

=cut


###############################################################################

=head2 Register stack operations

These operations effect individual registers.

=over 4

=cut


########################################

=item B<entrytype>(i, i|ic)

Gets the type of entry $2 of the stack and puts in in $1

=cut

AUTO_OP entrytype(i, i|ic) {
  INTVAL depth;
  struct Stack_Entry *entry;
  depth = stack_depth(interpreter, interpreter->user_stack_base);
  if (depth < $2) {
    INTERNAL_EXCEPTION(99, "Stack Depth wrong");
  }

  entry = stack_entry(interpreter, interpreter->user_stack_base, $2);
  $1 = get_entry_type(interpreter, entry);
}

########################################

=item B<save>(i)

=item B<save>(ic)

=item B<save>(n)

=item B<save>(nc)

=item B<save>(p)

=item B<save>(s)

=item B<save>(sc)

Save register or constant $1 onto the stack.

=cut

AUTO_OP save(i|ic) {
  push_generic_entry(interpreter, &interpreter->user_stack_top, &($1), STACK_ENTRY_INT, NULL);
}

AUTO_OP save(n|nc) {
  push_generic_entry(interpreter, &interpreter->user_stack_top, &($1), STACK_ENTRY_FLOAT, NULL);
}

AUTO_OP save(p) {
  push_generic_entry(interpreter, &interpreter->user_stack_top, $1, STACK_ENTRY_PMC, NULL);
}

AUTO_OP save(s|sc) {
  push_generic_entry(interpreter,  &interpreter->user_stack_top, $1, STACK_ENTRY_STRING, NULL);
}


########################################

=item B<restore>(i)

=item B<restore>(n)

=item B<restore>(p)

=item B<restore>(s)

Restore register $1 from the appropriate register stack.

=cut

AUTO_OP restore(i) {
  pop_generic_entry(interpreter, &interpreter->user_stack_top, &($1), STACK_ENTRY_INT);
}

AUTO_OP restore(n) {
  pop_generic_entry(interpreter, &interpreter->user_stack_top, &($1), STACK_ENTRY_FLOAT);
}

AUTO_OP restore(p) {
  pop_generic_entry(interpreter, &interpreter->user_stack_top, &($1), STACK_ENTRY_PMC);
}

AUTO_OP restore(s) {
  pop_generic_entry(interpreter, &interpreter->user_stack_top, &($1), STACK_ENTRY_STRING);
}


=back

=cut


###############################################################################

=head2 Control flow

The control flow opcodes check conditions and manage program flow.

=over 4


########################################

=item B<branch>(ic)

Branch forward or backward by the amount in $1.

=cut

MANUAL_OP branch(ic) {
  RETREL($1);
}


########################################

=item B<bsr>(i)

=item B<bsr>(ic)

Branch to the location specified by $1. Push the current location onto the call
stack for later returning.

=cut

MANUAL_OP bsr(i|ic) {
  push_generic_entry(interpreter, &interpreter->control_stack_top, cur_opcode + 2,  STACK_ENTRY_DESTINATION, NULL);
  RETREL($1);
}


########################################

=item B<jsr>()

Jump to the location specified by register X. Push the current
location onto the call stack for later returning.

TODO: Implement this, or delete the entry.

=cut


########################################

=item B<jump>(i)

Jump to the address held in register $1.

=cut

MANUAL_OP jump(i) {
  RETREL($1);
}

########################################

=item B<newinterp>(p, i|ic)

Create a new interpreter and store it in a PMC

=cut

AUTO_OP newinterp(p, i|ic) {
  struct Parrot_Interp *new_interp;
  struct PMC *new_pmc;
  new_interp = make_interpreter();
  new_interp->flags = $2;
  new_pmc = new_pmc_header(interpreter);
  new_pmc->data = new_interp;
  new_pmc->vtable = YOU_LOSE_VTABLE;
  $1 = new_pmc;
}


=item B<runinterp>(p, i|ic)

Take a built interpreter and run the code starting at offset $2

=cut

AUTO_OP runinterp(p, i|ic) {
  struct PackFile local_file;
  memcpy(&local_file, interpreter->code, sizeof(struct PackFile));
  local_file.byte_code = cur_opcode + $2;
  runops($1->data, &local_file);
}

########################################

=item B<new>(p, i)

Create a new PMC of class C<i>; look in F<pmc.h> for the base
vtable types.

=cut

AUTO_OP new(p, i|ic) {
    PMC* newpmc;
    if ($2 <0 || $2 >= enum_class_max) {
        abort(); /* Deserve to lose */
    }
    newpmc = pmc_new(interpreter, $2);
    $1 = newpmc;
}

########################################

=item B<ret>()

Pop the location off the top of the stack and go there.

=cut

MANUAL_OP ret() {
  opcode_t *dest;
  pop_generic_entry(interpreter, &interpreter->control_stack_top, &dest, STACK_ENTRY_DESTINATION);
  RETABS(dest);
}


########################################

=item B<rotate>(i)

=item B<rotate>(ic)

Rotate the top $1 stack entries so that the top entry becomes the bottom
entry in that range.

=cut

AUTO_OP rotate(i|ic) {
  rotate_entries(interpreter, $1);
}


=back

=cut

########################################

=item B<sleep>(i)

=item B<sleep>(ic)

Sleep for $1 seconds

=cut

AUTO_OP sleep(i|ic) {
  Parrot_sleep($1);
}

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001 Yet Another Society. All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut

