/*
** core.ops
*/

#include <math.h>


MANUAL_OP end() {
   HALT;
}

AUTO_OP noop() {
}

AUTO_OP set(i, ic) {
  $1 = $2;
}
  
AUTO_OP set(i, i) {
  $1 = $2;
}
  
AUTO_OP add(i, i, i) {
  $1 = $2 + $3;
}

AUTO_OP sub(i, i, i) {
  $1 = $2 - $3;
}

AUTO_OP mul(i, i, i) {
  $1 = $2 * $3;
}

AUTO_OP div(i, i, i) {
  $1 = $2 / $3;
}

/*
** mod_i_i_i
**
** NOTE: This "corrected mod" algorithm is based on the C code on page 70
** of [1]. Assuming correct behavior of C's built-in mod operator (%) with
** positive arguments, this algorithm implements a mathematically convenient
** version of mod, defined thus:
**
**   x mod y = x - y * floor(x / y)
**
** For more information on this definition of mod, see section 3.4 of [2],
** pages 81-85.
**
** References:
**
**   [1] Donald E. Knuth, *MMIXware: A RISC Computer for the Third
**       Millennium* Springer, 1999.
**
**   [2] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
**       Mathematics*, Second Edition. Addison-Wesley, 1994.
*/

AUTO_OP mod(i, i, i) {
  INTVAL y = $2;
  INTVAL z = $3;
  INTVAL s = 0;
  INTVAL r;

  if (z == 0) {
    r = y;
  }
  else {
    if (y < 0) { s += 2; y = -y; }
    if (z < 0) { s += 1; z = -z; }

    r = y % z;

    switch (s) {
      case 0 + 0:            break;
      case 0 + 1: r = r - z; break;
      case 2 + 0: r = z - r; break;
      case 2 + 1: r = -r;    break;
    }
  }

  $1 = r;
}

/*
** cmod_i_i_i
**
** NOTE: This "uncorrected mod" algorithm uses the C language's built-in
** mod operator (x % y), which is
**
**     ... the remainder when x is divided by y, and thus is zero when y
**     divides x exactly.
**     ...
**     The direction of truncation for / and the sign of the result for %
**     are machine-dependent for negative operands, as is the action taken
**     on overflow or underflow.
**                                                          -- [1], page 41
**
** Also:
**
**     ... if the second operand is 0, the result is undefined. Otherwise, it
**     is always true that (a/b)*b + a%b is equal to z. If both operands are
**     non-negative, then the remainder is non-negative and smaller than the
**     divisor; if not, it is guaranteed only that the absolute value of the
**     remainder is smaller than the absolute value of the divisor.
**                                                          -- [1], page 205
**
** This op is provided for those who need it (such as speed-sensitive
** applications with heavy use of mod, but using it only with positive
** arguments), but a more mathematically useful mod based on ** floor(x/y)
** and defined with y == 0 is provided by the mod_i op.
**
**   [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
**       Language*, Second Edition. Prentice Hall, 1988.
**
** TODO: Doesn't the Parrot interpreter need to catch the exception?
*/

AUTO_OP cmod(i, i, i) {
  $1 = $2 % $3;
}

AUTO_OP eq(i, i, ic) {
  if ($1 == $2) {
    RETREL($3);
  }
}

AUTO_OP eq(i, ic, ic) {
  if ($1 == $2) {
    RETREL($3);
  }
}

AUTO_OP ne(i, i, ic) {
  if ($1 != $2) {
    RETREL($3);
  }
}

AUTO_OP ne(i, ic, ic) {
  if ($1 != $2) {
    RETREL($3);
  }
}

AUTO_OP lt(i, i, ic) {
  if ($1 < $2) {
    RETREL($3);
  }
}

AUTO_OP lt(i, ic, ic) {
  if ($1 < $2) {
    RETREL($3);
  }
}

AUTO_OP le(i, i, ic) {
  if ($1 <= $2) {
    RETREL($3);
  }
}

AUTO_OP le(i, ic, ic) {
  if ($1 <= $2) {
    RETREL($3);
  }
}

AUTO_OP gt(i, i, ic) {
  if ($1 > $2) {
    RETREL($3);
  }
}

AUTO_OP gt(i, ic, ic) {
  if ($1 > $2) {
    RETREL($3);
  }
}

AUTO_OP ge(i, i, ic) {
  if ($1 >= $2) {
    RETREL($3);
  }
}

AUTO_OP ge(i, ic, ic) {
  if ($1 >= $2) {
    RETREL($3);
  }
}

AUTO_OP if(i, ic) {
  if ($1 != 0) {
    RETREL($2);
  }
}

AUTO_OP time(i) {
  $1 = time(NULL);
}

AUTO_OP print(i) {
  /* TODO: Configure for format */
  printf("%li", (long) $1);
}

AUTO_OP print(ic) {
  /* TODO: Configure for format */
  printf("%li", (long) $1);
}
 
MANUAL_OP branch(ic) {
  RETREL($1);
}

AUTO_OP inc(i) {
  $1++;
}

AUTO_OP inc(i, ic) {
  $1 += $2;
}

AUTO_OP dec(i) {
  $1--;
}

AUTO_OP dec(i, ic) {
  $1 -= $2;
}

MANUAL_OP jump(i) {
  RETREL($1);
}

AUTO_OP set(n, nc) {
  $1 = $2;
}

AUTO_OP set(n, n) {
  $1 = $2;
}
  
AUTO_OP add(n, n, n) {
  $1 = $2 + $3;
}

AUTO_OP sub(n, n, n) {
  $1 = $2 - $3;
}

AUTO_OP mul(n, n, n) {
  $1 = $2 * $3;
}

AUTO_OP div(n, n, n) {
  $1 = $2 / $3;
}

/*
** mod_n_n_n
**
** NOTE: This "corrected mod" algorithm is based on the formula of [1]:
**
**   x mod y = x - y * floor(x / y)
**
** For more information on this definition of mod, see section 3.4 of [1],
** pages 81-85.
**
** References:
**
**   [1] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
**       Mathematics*, Second Edition. Addison-Wesley, 1994.
*/

AUTO_OP mod(n, n, n) {
  $1 = $3
     ? ($2 - $3 * floor($2 / $3))
     : $2;
}

/*
** cmod_n_n_n
**
** NOTE: This "uncorrected mod" algorithm uses the built-in C math library's
** fmod() function, which computes
**
**     ... the remainder of dividing x by y. The return value is x - n * y,
**     where n is the quotient of x / y, rounded towards zero to an
**     integer.
**                                     -- fmod() manpage on RedHat Linux 7.0
**
** In addition, fmod() returns
**
**     the remainder, unless y is zero, when the function fails and errno
**     is set.
**
** According to page 251 of [1], the result when y is zero is implementation-
** defined.
**
** This op is provided for those who need it, but a more mathematically
** useful numeric mod based on floor(x/y) instead of truncate(x/y) and
** defined with y == 0 is provided by the mod_n op.
**
**   [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
**       Language*, Second Edition. Prentice Hall, 1988.
**
** TODO: Doesn't the Parrot interpreter need to catch the exception?
*/

AUTO_OP cmod(n, n, n) {
  $1 = fmod($2, $3);
}

AUTO_OP eq(n, n, ic) {
  if ($1 == $2) {
    RETREL($3);
  }
}

AUTO_OP eq(n, nc, ic) {
  if ($1 == $2) {
    RETREL($3);
  }
}

AUTO_OP ne(n, n, ic) {
  if ($1 != $2) {
    RETREL($3);
  }
}

AUTO_OP ne(n, nc, ic) {
  if ($1 != $2) {
    RETREL($3);
  }
}

AUTO_OP lt(n, n, ic) {
  if ($1 < $2) {
    RETREL($3);
  }
}

AUTO_OP lt(n, nc, ic) {
  if ($1 < $2) {
    RETREL($3);
  }
}

AUTO_OP le(n, n, ic) {
  if ($1 <= $2) {
    RETREL($3);
  }
}

AUTO_OP le(n, nc, ic) {
  if ($1 <= $2) {
    RETREL($3);
  }
}

AUTO_OP gt(n, n, ic) {
  if ($1 > $2) {
    RETREL($3);
  }
}

AUTO_OP gt(n, nc, ic) {
  if ($1 > $2) {
    RETREL($3);
  }
}

AUTO_OP ge(n, n, ic) {
  if ($1 >= $2) {
    RETREL($3);
  }
}

AUTO_OP ge(n, nc, ic) {
  if ($1 >= $2) {
    RETREL($3);
  }
}

AUTO_OP if(n, ic) {
  if ($1 != 0.0) {
    RETREL($2);
  }
}

AUTO_OP time(n) {
  $1 = (FLOATVAL)time(NULL);
}

AUTO_OP print(n) {
  /* TODO: Configure for format */
  printf("%f", $1);
}
 
AUTO_OP print(nc) {
  /* TODO: Configure for format */
  printf("%f", $1);
}

AUTO_OP inc(n) {
  $1 += 1;
}

AUTO_OP inc(n, nc) {
  $1 += $2;
}

AUTO_OP dec(n) {
  $1 -= 1;
}

AUTO_OP dec(n, nc) {
  $1 -= $2;
}

AUTO_OP iton(n, i) {
  $1 = (FLOATVAL)$2;
}

AUTO_OP ntoi(i, n) {
  FLOATVAL number;
  number = $2;
  $1 = (INTVAL)number;
}

AUTO_OP pushi() {
  Parrot_push_i(interpreter);
}

AUTO_OP pushn() {
  Parrot_push_n(interpreter);
}

AUTO_OP pushs() {
  Parrot_push_s(interpreter);
}

AUTO_OP pushp() {
  Parrot_push_p(interpreter);
}

AUTO_OP popi() {
  Parrot_pop_i(interpreter);
}

AUTO_OP popn() {
  Parrot_pop_n(interpreter);
}

AUTO_OP pops() {
  Parrot_pop_s(interpreter);
}

AUTO_OP popp() {
  Parrot_pop_p(interpreter);
}

AUTO_OP cleari() {
  Parrot_clear_i(interpreter);
}

AUTO_OP clearn() {
  Parrot_clear_n(interpreter);
}

AUTO_OP clears() {
  Parrot_clear_s(interpreter);
}

AUTO_OP clearp() {
  Parrot_clear_p(interpreter);
}

AUTO_OP set(s, sc) {
  $1 = $2;
}

AUTO_OP print(s) {
  STRING *s = $1; 
  if (s) printf("%.*s",(int)string_length(s),(char *) s->bufstart);
}

AUTO_OP print(sc) {
  STRING *s = $1;
  INTVAL l = string_length(s);
  printf("%.*s", (int)l, (char *)s->bufstart);
}

AUTO_OP length(i, s) {
  $1 = string_length($2);
}

AUTO_OP chopn(s, ic) {
   (void)string_chopn($1, $2);
}

AUTO_OP substr(s, s, i, i) {
    STRING *s = string_substr($2, $3, $4, &$1);
    $1 = s;
}

AUTO_OP concat(s, s) {
    STRING *s = string_concat($1, $2, 1);
    $1 = s;
}

AUTO_OP eq(s, s, ic) {
  if (string_compare($1, $2) == 0) {
    RETREL($3);
  }
}

AUTO_OP eq(s, sc, ic) {
  if (string_compare($1, $2) == 0) {
    RETREL($3);
  }
}

AUTO_OP ne(s, s, ic) {
  if (string_compare($1, $2) != 0) {
    RETREL($3);
  }
}

AUTO_OP ne(s, sc, ic) {
  if (string_compare($1, $2) != 0) {
    RETREL($3);
  }
}

AUTO_OP lt(s, s, ic) {
  if (string_compare($1, $2) < 0) {
    RETREL($3);
  }
}

AUTO_OP lt(s, sc, ic) {
  if (string_compare($1, $2) < 0) {
    RETREL($3);
  }
}

AUTO_OP le(s, s, ic) {
  if (string_compare($1, $2) <= 0) {
    RETREL($3);
  }
}

AUTO_OP le(s, sc, ic) {
  if (string_compare($1, $2) <= 0) {
    RETREL($3);
  }
}

AUTO_OP gt(s, s, ic) {
  if (string_compare($1, $2) > 0) {
    RETREL($3);
  }
}

AUTO_OP gt(s, sc, ic) {
  if (string_compare($1, $2) > 0) {
    RETREL($3);
  }
}

AUTO_OP ge(s, s, ic) {
  if (string_compare($1, $2) >= 0) {
    RETREL($3);
  }
}

AUTO_OP ge(s, sc, ic) {
  if (string_compare($1, $2) >= 0) {
    RETREL($3);
  }
}


/* TRANSCENDENTAL MATH FUNCTIONS */

AUTO_OP sin(n, n) {
   $1 = sin($2);
}

AUTO_OP cos(n, n) {
   $1 = cos($2);
}

AUTO_OP tan(n, n) {
   $1 = tan($2);
}

AUTO_OP sec(n, n) {
   $1 = ((FLOATVAL)1) / cos($2);
}

AUTO_OP atan(n, n) {
   $1 = atan($2);
}

AUTO_OP atan(n, n, n) {
   $1 = atan2($2, $3);
}

AUTO_OP asin(n, n) {
   $1 = asin($2);
}

AUTO_OP acos(n, n) {
   $1 = acos($2);
}

AUTO_OP asec(n, n) {
   $1 = acos(((FLOATVAL)1.0) / $2);
}

AUTO_OP cosh(n, n) {
   $1 = cosh($2);
}

AUTO_OP sinh(n, n) {
   $1 = sinh($2);
}

AUTO_OP tanh(n, n) {
   $1 = tanh($2);
}

AUTO_OP sech(n, n) {
   $1 = ((FLOATVAL)1.0) / cosh($2);
}

AUTO_OP log2(n, n) {
   FLOATVAL temp = log((FLOATVAL)2.0);
   $1 = log($2) / temp;
}

AUTO_OP log10(n, n) {
   $1 = log10($2);
}

AUTO_OP ln(n, n) {
   $1 = log($2);
}

AUTO_OP exp(n, n) {
   $1 = exp($2);
}

AUTO_OP pow(n, n, n) {
   $1 = pow($2, $3);
}

AUTO_OP sin(n, i) {
   $1 = sin((FLOATVAL)$2);
}

AUTO_OP cos(n, i) {
   $1 = cos((FLOATVAL)$2);
}

AUTO_OP tan(n, i) {
   $1 = tan((FLOATVAL)$2);
}

AUTO_OP sec(n, i) {
   $1 = ((FLOATVAL)1) / cos((FLOATVAL)$2);
}

AUTO_OP atan(n, i) {
   $1 = atan((FLOATVAL)$2);
}

AUTO_OP atan(n, n, i) {
   $1 = atan2($2, (FLOATVAL)$3);
}

AUTO_OP atan(n, i, n) {
   $1 = atan2((FLOATVAL)$2, $3);
}

AUTO_OP atan(n, i, i) {
   $1 = atan2((FLOATVAL)$2, (FLOATVAL)$3);
}

AUTO_OP asin(n, i) {
   $1 = asin((FLOATVAL)$2);
}

AUTO_OP acos(n, i) {
   $1 = acos((FLOATVAL)$2);
}

AUTO_OP asec(n, i) {
   $1 = acos(((FLOATVAL)1) / ((FLOATVAL)$2));
}

AUTO_OP cosh(n, i) {
   $1 = cosh((FLOATVAL)$2);
}

AUTO_OP sinh(n, i) {
   $1 = sinh((FLOATVAL)$2);
}

AUTO_OP tanh(n, i) {
   $1 = tanh((FLOATVAL)$2);
}

AUTO_OP sech(n, i) {
   $1 = ((FLOATVAL)1) / cosh((FLOATVAL)$2);
}

AUTO_OP log2(n, i) {
   FLOATVAL temp = log((FLOATVAL)2.0);
   $1 = log((FLOATVAL)$2) / temp;
}

AUTO_OP log10(n, i) {
   $1 = log10((FLOATVAL)$2);
}

AUTO_OP ln(n, i) {
   $1 = log((FLOATVAL)$2);
}

AUTO_OP exp(n, i) {
   $1 = exp((FLOATVAL)$2);
}

AUTO_OP pow(n, n, i) {
   $1 = pow($2, (FLOATVAL)$3);
}

AUTO_OP pow(n, i, i) {
   $1 = pow((FLOATVAL)$2, (FLOATVAL)$3);
}

AUTO_OP pow(n, i, n) {
   $1 = pow((FLOATVAL)$2, $3);
}


/* BITWISE LOGICAL OPS */

AUTO_OP and(i, i, i) {
  $1 = $2 & $3;
}

AUTO_OP not(i, i) {
  $1 = ~ $2;
}

AUTO_OP or(i, i, i) {
  $1 = $2 | $3;
}

AUTO_OP shl(i, i, ic) {
  $1 = $2 << $3;
}

AUTO_OP shr(i, i, ic) {
  $1 = $2 >> $3;
}

AUTO_OP xor(i, i, i) {
  $1 = $2 ^ $3;
}


/* INTERPRETER FLAG OPS */

MANUAL_OP bounds(ic) {
  if ($1 != 0) { interpreter->flags |=  PARROT_BOUNDS_FLAG; }
  else         { interpreter->flags &= ~PARROT_BOUNDS_FLAG; }
  RESTART(*);
}

MANUAL_OP trace(ic) {
  if ($1 != 0) { interpreter->flags |=  PARROT_TRACE_FLAG; }
  else         { interpreter->flags &= ~PARROT_TRACE_FLAG; }
  RESTART(*);
}

/* Some stack ops */

AUTO_OP save(i) {
  push_generic_entry(interpreter, &($1), STACK_ENTRY_INT, NULL);
}

AUTO_OP restore(i) {
  pop_generic_entry(interpreter, &($1), STACK_ENTRY_INT);
}

AUTO_OP save(s) {
  push_generic_entry(interpreter,  $1, STACK_ENTRY_INT, NULL);
}

AUTO_OP restore(s) {
  pop_generic_entry(interpreter, &($1), STACK_ENTRY_INT);
}

AUTO_OP save(n) {
  push_generic_entry(interpreter, &($1), STACK_ENTRY_INT, NULL);
}

AUTO_OP restore(n) {
  pop_generic_entry(interpreter, &($1), STACK_ENTRY_INT);
}

AUTO_OP save(p) {
  push_generic_entry(interpreter, $1, STACK_ENTRY_INT, NULL);
}

AUTO_OP restore(p) {
  pop_generic_entry(interpreter, &($1), STACK_ENTRY_INT);
}

/* Control flow */

MANUAL_OP bsr(ic) {
  push_generic_entry(interpreter, cur_opcode + 2,  STACK_ENTRY_DESTINATION, NULL);
  RETREL($1);
}

MANUAL_OP bsr(i) {
  push_generic_entry(interpreter, cur_opcode + 2,  STACK_ENTRY_DESTINATION, NULL);
  RETREL($1);
}

MANUAL_OP ret() {
  opcode_t *dest;
  pop_generic_entry(interpreter, &dest, STACK_ENTRY_DESTINATION);
  RETABS(dest);
} 
