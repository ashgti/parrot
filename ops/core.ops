/*
** core.ops
*/

/* This convoluted mess avoids costly runtime creation of KEY
and KEY_PAIR structures. */

#define MAKE_KEY(k,k_p,v,c,t) if (v) {\
        k_p.type = c;\
        k_p.cache.t = v;\
        k.size = 1;\
        k.keys[0] = &k_p;\
    }

VERSION = PARROT_VERSION;

=head1 NAME

core.ops

=cut

=head1 DESCRIPTION

Parrot's core library of ops.

=cut

# ' for emacs

###############################################################################

=head2 Basic ops

These are the fundamental operations.

=over 4

=cut


########################################

=item B<end>()

Halts the interpreter.

=cut

inline op end() {
  HALT();
}


########################################

=item B<noop>()

Does nothing other than waste an iota of time and 32 bits of bytecode space.

=cut

inline op noop() {
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 System environment operations

These operations allow interaction between the Parrot program and the system
environment.

=over 4

=cut

########################################

=item B<close>(inout INT)

Close file opened on file descriptor $1.

=cut

inline op close(inout INT) {
  fclose((FILE *)$1);
  goto NEXT();
}


########################################

=item B<err>(out INT)

Store the system error code in $1.

=item B<err>(out STR)

Store the system error message in $1.

=cut

inline op err(out INT) {
  $1 = errno;
  goto NEXT();
}

op err(out STR) {
  char *tmp = strerror(errno);
  STRING *s = string_make(interpreter, tmp, strlen(tmp), NULL, 0, NULL);
  $1 = s;
  goto NEXT();
}


########################################
=item B<open>(out INT, in STR)

Open file named $2 for reading and writing and save the file
descriptor into $1.

=item B<open>(out INT, in STR, in STR)

Open file named $2 with flags $3 and mode 0644 (rw-r--r--), and save the file
descriptor into $1.

=cut

inline op open(out INT, in STR) {
  $1 = (INTVAL)fopen(($2)->bufstart, "r+");
  if (!$1) {
    perror("Can't open");
    exit(1);
  }
  
  goto NEXT();
}

inline op open(out INT, in STR, in STR) {
  $1 = (INTVAL)fopen(($2)->bufstart, ($3)->bufstart);
  goto NEXT();
}

########################################

=item B<readline>(out STR, in INT)

Temporary hack op to read in a line from the file opened on the FILE *
we've evilly put in the integer register $2. If $2 is 0, 1, or 2 we
use stdin, stdout, or stderr respectively.

BE AFRAID! THIS IS *EEEEEEEVIL* pure and simple. (From the 8th
dimension, no less)

If for some reason the line's longer than 64K you get only 64K

=cut

inline op readline(out STR, in INT) {
  FILE *file;
  switch ($2) {
	case 0: file = stdin; 
                break;
	case 1: file = stdout; 
                break;
	case 2: file = stderr; 
                break;
	default: file = (FILE *)$2;
  }

  $1 = string_make(interpreter, NULL, 65535, NULL, 0, NULL);
  memset(($1)->bufstart, 0, 65535);
  fgets(($1)->bufstart, 65534, file);
  ($1)->strlen = ($1)->bufused = strlen(($1)->bufstart);
  goto NEXT();
}

########################################

=item B<ord>(out INT, in STR)

Two-argument form returns the 0th character of string $2 in register $1.
If $2 is empty, throws an exception.

=item B<ord>(out INT, in STR, in INT)

Three-argument form returns character $3 of string $2 in register 1.
If $2 is empty, throws an exception.
If $3 is greater than the length of string $2, throws an exception
If $3 is less then zero but greater than the negative of the length, counts
backwards through the string, such that -1 is the last character, -2 is the
second-to-last character, and so on.
If $3 is less than the negative of the length, throws an exception.

=cut

inline op ord (out INT, in STR) {
  $1 = string_ord($2,0);
  goto NEXT();
}

inline op ord (out INT, in STR, in INT) {
  $1 = string_ord($2,$3);
  goto NEXT();
}


########################################

=item B<print>(in INT)

=item B<print>(in NUM)

=item B<print>(in PMC)

=item B<print>(in STR)

Print $1 to standard output.

=item B<print>(in INT, in INT)

=item B<print>(in INT, in NUM)

=item B<print>(in INT, in PMC)

=cut

inline op print(in INT) {
  printf(INTVAL_FMT, (INTVAL)$1);
  goto NEXT();
}

inline op print(in NUM) {
  printf(FLOATVAL_FMT, $1);
  goto NEXT();
}

op print(in STR) {
  STRING *s = $1;
  if (s && string_length(s)) {
    printf("%.*s", (int)string_length(s), (char *) s->bufstart);
  }
  goto NEXT();
}

op print(in PMC) {
  PMC *p = $1;
  STRING *s = (p->vtable->get_string(interpreter, p));
  if (s) {
    printf("%.*s",(int)string_length(s),(char *) s->bufstart);
  }
  goto NEXT();
}


op print(in INT, in INT) {
  FILE *file;
  switch ($1) {
	case 0: file = stdin; 
                break;
	case 1: file = stdout; 
                break;
	case 2: file = stderr; 
                break;
	default: file = (FILE *)$1;
  }
  fprintf(file, INTVAL_FMT, (INTVAL)$2);
  goto NEXT();
}

op print(in INT, in NUM) {
  FILE *file;
  switch ($1) {
	case 0: file = stdin; 
                break;
	case 1: file = stdout; 
                break;
	case 2: file = stderr; 
                break;
	default: file = (FILE *)$1;
  }
  fprintf(file, FLOATVAL_FMT, $2);
  goto NEXT();
}

op print(in INT, in STR) {
  FILE *file;
  STRING *s = $2;
  switch ($1) {
	case 0: file = stdin; 
                break;
	case 1: file = stdout; 
                break;
	case 2: file = stderr; 
                break;
	default: file = (FILE *)$1;
  }
  if (s && string_length(s)) {
    fprintf(file, "%.*s",(int)string_length(s),(char *) s->bufstart);
  }
  goto NEXT();
}

op print(in INT, in PMC) {
  FILE *file;
  PMC *p = $2;
  STRING *s = (p->vtable->get_string(interpreter, p));
  switch ($1) {
	case 0: file = stdin; 
                break;
	case 1: file = stdout; 
                break;
	case 2: file = stderr; 
                break;
	default: file = (FILE *)$1;
  }
  if (s) {
    fprintf(file, "%.*s",(int)string_length(s),(char *) s->bufstart);
  }
  goto NEXT();
}


########################################

=item B<read>(out INT, in INT)

Read an INTVAL from file descriptor $2 into $1.

=item B<read>(out NUM, in INT)

Read a FLOATVAL from file descriptor $2 into $1.

=item B<read>(out STR, in INT, in INT)

Read $3 bytes from file descriptor $2 into string $1.

=cut

inline op read(out INT, in INT) {
  read($2, &($1), sizeof(INTVAL));
  goto NEXT();
}

inline op read(out NUM, in INT) {
  read($2, &($1), sizeof(FLOATVAL));
  goto NEXT();
}

op read(out STR, in INT, in INT) {
  STRING *s;
  UINTVAL len = $3;

  string_destroy($1);
  s = string_make(interpreter, NULL, len, NULL, 0, NULL);
  read($2, s->bufstart, len);
  s->bufused = s->buflen;
  $1 = s;
  goto NEXT();
}


########################################

=item B<time>(out INT)

Puts the current system time (represented as a whole number of seconds)
in $1.

=cut

inline op time(out INT) {
  $1 = Parrot_intval_time();
  goto NEXT();
}


########################################

=item B<time>(out NUM)

Puts the current system time (represented as a number of seconds, with
microseconds) in $1.

=cut

inline op time(out NUM) {
  $1 = Parrot_floatval_time();
  goto NEXT();
}


########################################

=item B<write>(in INT, in INT)

=item B<write>(in INT, in NUM)

=item B<write>(in INT, in STR)

Write $2 to file descriptor $1.

=cut

op write(in INT, in INT) {
  INTVAL i = (INTVAL)$2;
  write($1, &i, sizeof(INTVAL));
  goto NEXT();
}

op write(in INT, in NUM) {
  FLOATVAL * f = &($2);
  write($1, f, sizeof(FLOATVAL));
  goto NEXT();
}

op write(in INT, in STR) {
  STRING * s = $2;
  UINTVAL count = string_length(s);
  write($1, s->bufstart, count);
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 Register loading operations

These operations load registers from constants or other registers.

=over 4

=cut


########################################

=item B<set>(out INT, in INT)

=item B<set>(out INT, in NUM)

=item B<set>(out INT, in PMC)

=item B<set>(out INT, in STR)

=item B<set>(out NUM, in INT)

=item B<set>(out NUM, in NUM)

=item B<set>(out NUM, in PMC)

=item B<set>(out NUM, in STR)

=item B<set>(out PMC, in INT)

=item B<set>(out PMC, in NUM)

=item B<set>(out PMC, in PMC)

=item B<set>(out PMC, in STR)

=item B<set>(out STR, in INT)

=item B<set>(out STR, in NUM)

=item B<set>(out STR, in PMC)

=item B<set>(out STR, in STR)

Set $1 to $2.

=cut

inline op set(out INT, in INT) {
  $1 = $2;
  goto NEXT();
}

inline op set(out INT, in NUM) {
  $1 = (INTVAL)($2);
  goto NEXT();
}

inline op set(out NUM, in NUM) {
  $1 = $2;
  goto NEXT();
}

inline op set(out NUM, in INT) {
  $1 = (FLOATVAL)$2;
  goto NEXT();
}

inline op set(out NUM, in PMC) {
  $1 = $2->vtable->get_number(interpreter, $2);
  goto NEXT();
}

inline op set(out STR, in PMC) {
  $1 = $2->vtable->get_string(interpreter, $2);
  goto NEXT();
}

inline op set(out STR, in STR) {
  $1 = string_copy(interpreter, $2);
  goto NEXT();
}

inline op set(out PMC, in INT) { 
  $1->vtable->set_integer_native(interpreter, $1, $2);
  goto NEXT();
}

inline op set(out PMC, in NUM) { 
  $1->vtable->set_number_native(interpreter, $1, $2);
  goto NEXT();
}

inline op set(out PMC, in STR) {
  $1->vtable->set_string_native(interpreter, $1, $2);
  goto NEXT();
}

inline op set(out INT, in PMC) {
  $1 = $2->vtable->get_integer(interpreter, $2);
  goto NEXT();
}

=item B<set_keyed>(out PMC, out PMC, in PMC, in PMC)

    $1[$2] = $3[$4];

=cut

inline op set_keyed (out PMC, in PMC, in PMC, in PMC)  {
    KEY_PAIR src_key_p, dest_key_p;
    KEY src_key, dest_key;

    MAKE_KEY(src_key, src_key_p, $2, enum_key_pmc, pmc_val);
    MAKE_KEY(dest_key, dest_key_p, $4, enum_key_pmc, pmc_val);

    $1->vtable->set_pmc_keyed(interpreter, 
                    $1, $2 ? &src_key : NULL, $3, $4 ? &dest_key : NULL);
    goto NEXT();
}

=item B<clone>(out PMC, in PMC)

Copies a PMC $1 to $2.

=cut

inline op clone(out PMC, in PMC) {
  $2->vtable->clone(interpreter, $2, $1);
  goto NEXT();
}

=back

=cut


###############################################################################

=head2 Conditional branch operations

These opertions perform a conditional relative branch. If the condition is
met, the branch happens, otherwise control falls to the next operation.

=over 4

=cut


########################################

=item B<eq>(in INT, in INT)

=item B<eq>(in NUM, in NUM)

=item B<eq>(in STR, in STR)

=item B<eq>(in INT, in INT, in INT)

=item B<eq>(in NUM, in NUM, in INT)

=item B<eq>(in STR, in STR, in INT)

Branch if $1 is equal to $2.

Return address is popped off the call stack if no address is supplied.

=cut

inline op eq (in INT, in INT) {
  if ($1 == $2) {
    goto POP();
  }
  goto NEXT();
}

inline op eq (in NUM, in NUM) {
  if ($1 == $2) {
    goto POP();
  }
  goto NEXT();
}

op eq (in STR, in STR) {
  if (string_compare (interpreter, $1, $2) == 0) {
    goto POP();
  }
  goto NEXT();
}

inline op eq(in INT, in INT, in INT) {
  if ($1 == $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op eq(in NUM, in NUM, in INT) {
  if ($1 == $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op eq(in STR, in STR, in INT) {
  if (string_compare(interpreter, $1, $2) == 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}


########################################

=item B<ne>(in INT, in INT)

=item B<ne>(in NUM, in NUM)

=item B<ne>(in STR, in STR)

=item B<ne>(in INT, in INT, in INT)

=item B<ne>(in NUM, in NUM, in INT)

=item B<ne>(in STR, in STR, in INT)

Branch if $1 is not equal to $2.

Return address is popped off the call stack if no address is supplied.

=cut

inline op ne (in INT, in INT) {
  if ($1 != $2) {
    goto POP();
  }
  goto NEXT();
}

inline op ne (in NUM, in NUM) {
  if ($1 != $2) {
    goto POP();
  }
  goto NEXT();
}

op ne (in STR, in STR) {
  if (string_compare (interpreter, $1, $2) != 0) {
    goto POP();
  }
  goto NEXT();
}

inline op ne(in INT, in INT, in INT) {
  if ($1 != $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op ne(in NUM, in NUM, in INT) {
  if ($1 != $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op ne(in STR, in STR, in INT) {
  if (string_compare(interpreter, $1, $2) != 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}


########################################

=item B<lt>(in INT, in INT, in INT)

=item B<lt>(in NUM, in NUM, in INT)

=item B<lt>(in PMC, in PMC, in INT)

=item B<lt>(in STR, in STR, in INT)

Branch if $1 is less than $2.

=cut

inline op lt(in INT, in INT, in INT) {
  if ($1 < $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op lt(in NUM, in NUM, in INT) {
  if ($1 < $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op lt(in STR, in STR, in INT) {
  if (string_compare(interpreter, $1, $2) < 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}


########################################

=item B<le>(in INT, in INT, in INT)

=item B<le>(in NUM, in NUM, in INT)

=item B<le>(in STR, in STR, in INT)

Branch if $1 is less than or equal to $2.

=cut

inline op le(in INT, in INT, in INT) {
  if ($1 <= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op le(in NUM, in NUM, in INT) {
  if ($1 <= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op le(in STR, in STR, in INT) {
  if (string_compare(interpreter, $1, $2) <= 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}


########################################

=item B<gt>(in INT, in INT, in INT)

=item B<gt>(in NUM, in NUM, in INT)

=item B<gt>(in STR, in STR, in INT)

Branch if $1 is greater than $2.

=cut

inline op gt(in INT, in INT, in INT) {
  if ($1 > $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op gt(in NUM, in NUM, in INT) {
  if ($1 > $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op gt(in STR, in STR, in INT) {
  if (string_compare(interpreter, $1, $2) > 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}


########################################

=item B<ge>(in INT, in INT, in INT)

=item B<ge>(in NUM, in NUM, in INT)

=item B<ge>(in STR, in STR, in INT)

Branch if $1 is greater than or equal to $2.

=cut

inline op ge(in INT, in INT, in INT) {
  if ($1 >= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op ge(in NUM, in NUM, in INT) {
  if ($1 >= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op ge(in STR, in STR, in INT) {
  if (string_compare(interpreter, $1, $2) >= 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

########################################

=item B<if>(in INT, in INT)

=item B<if>(in NUM, in INT)

=item B<if>(in PMC, in INT)

=item B<if>(in STR, in INT)

Check register $1. If true, branch by $2.

=cut

inline op if(in INT, in INT) {
  if ($1 != 0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

inline op if(in NUM, in INT) {
  if ($1 != 0.0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op if (in STR, in INT) {
  if (string_bool($1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op if(in PMC, in INT) {
  if ($1->vtable->get_bool(interpreter, $1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}


=cut



###############################################################################

=item B<unless>(in INT, in INT)

=item B<unless>(in NUM, in INT)

=item B<unless>(in PMC, in INT)

=item B<unless>(in STR, in INT)

Check register $1. If false, branch by $2.

=cut

inline op unless(in INT, in INT) {
  if ($1 == 0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

inline op unless(in NUM, in INT) {
  if ($1 == 0.0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op unless (in STR, in INT) {
  if (!string_bool($1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op unless(in PMC, in INT) {
  if (!$1->vtable->get_bool(interpreter, $1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}

=back

=cut



###############################################################################
=head2 Arithmetic operations

These operations store the results of arithmetic on other registers and
constants into their destination register, $1.

=over 4

=cut

########################################

=item B<abs>(out INT, in INT)

=item B<abs>(out INT, in NUM)

=item B<abs>(out NUM, in INT)

=item B<abs>(out NUM, in NUM)

Set $1 to absolute value of $2.

=cut

inline op abs(out INT, in INT) {
  if ($2 < 0) {
    $1 = - (INTVAL)$2;
  }
  else {
    $1 = (INTVAL)$2;
  }
  goto NEXT();
}

inline op abs(out INT, in NUM) {
  if ($2 < 0) {
    $1 = - (INTVAL)$2;
  }
  else {
    $1 = (INTVAL)$2;
  }
  goto NEXT();
}

inline op abs(out NUM, in INT) {
  if ($2 < 0) {
    $1 = - (FLOATVAL)$2;
  }
  else {
    $1 = (FLOATVAL)$2;
  }
  goto NEXT();
}

inline op abs(out NUM, in NUM) {
  if ($2 < 0) {
    $1 = - (FLOATVAL)$2;
  }
  else {
    $1 = (FLOATVAL)$2;
  }
  goto NEXT();
}


########################################

=item B<add>(out INT, in INT, in INT)

=item B<add>(out NUM, in NUM, in NUM)

Set $1 to the sum of $2 and $3.

=cut

inline op add(out INT, in INT, in INT) {
  $1 = $2 + $3;
  goto NEXT();
}

inline op add(out NUM, in NUM, in NUM) {
  $1 = $2 + $3;
  goto NEXT();
}


########################################

=item B<cmod>(out INT, in INT, in INT)

NOTE: This "uncorrected mod" algorithm uses the C language's built-in
mod operator (x % y), which is

    ... the remainder when x is divided by y, and thus is zero
    when y divides x exactly.
    ...
    The direction of truncation for / and the sign of the result
    for % are machine-dependent for negative operands, as is the
    action taken on overflow or underflow.
                                                     -- [1], page 41

Also:

    ... if the second operand is 0, the result is undefined. 
    Otherwise, it is always true that (a/b)*b + a%b is equal to z. If
    both operands are non-negative, then the remainder is non-
    negative and smaller than the divisor; if not, it is guaranteed
    only that the absolute value of the remainder is smaller than
    the absolute value of the divisor.
                                                     -- [1], page 205

This op is provided for those who need it (such as speed-sensitive
applications with heavy use of mod, but using it only with positive
arguments), but a more mathematically useful mod based on ** floor(x/y)
and defined with y == 0 is provided by the mod_i op.

  [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
      Language*, Second Edition. Prentice Hall, 1988.

TODO: Doesn't the Parrot interpreter need to catch the exception?

=cut

inline op cmod(out INT, in INT, in INT) {
  $1 = $2 % $3;
  goto NEXT();
}


########################################

=item B<cmod>(out NUM, in NUM, in NUM)

NOTE: This "uncorrected mod" algorithm uses the built-in C math library's
fmod() function, which computes

    ... the remainder of dividing x by y. The return value is
    x - n * y, where n is the quotient of x / y, rounded towards
    zero to an integer.
                                -- fmod() manpage on RedHat Linux 7.0

In addition, fmod() returns

    the remainder, unless y is zero, when the function fails and
    errno is set.

According to page 251 of [1], the result when y is zero is implementation-
defined.

This op is provided for those who need it, but a more mathematically
useful numeric mod based on floor(x/y) instead of truncate(x/y) and
defined with y == 0 is provided by the mod_n op.

  [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
      Language*, Second Edition. Prentice Hall, 1988.

TODO: Doesn't the Parrot interpreter need to catch the exception?

=cut

inline op cmod(out NUM, in NUM, in NUM) {
  $1 = fmod($2, $3);
  goto NEXT();
}


########################################

=item B<dec>(inout INT)

=item B<dec>(inout NUM)

Decrease $1 by one.

=cut

inline op dec(inout INT) {
  $1--;
  goto NEXT();
}

inline op dec(inout NUM) {
  $1--;
  goto NEXT();
}


########################################

=item B<dec>(inout INT, in INT)

=item B<dec>(inout NUM, in INT)

Decrease $1 by the amount in $2.

=cut

inline op dec(inout INT, in INT) {
  $1 -= $2;
  goto NEXT();
}

inline op dec(inout NUM, in NUM) {
  $1 -= $2;
  goto NEXT();
}


########################################

=item B<div>(out INT, in INT, in INT)

=item B<div>(out NUM, in NUM, in NUM)

Set $1 to the quotient of $2 divided by $3. In the case of INTVAL division, the
result is truncated (NOT rounded or floored).

=cut

inline op div(out INT, in INT, in INT) {
  $1 = $2 / $3;
  goto NEXT();
}

inline op div(out NUM, in NUM, in NUM) {
  $1 = $2 / $3;
  goto NEXT();
}


########################################

=item B<inc>(inout INT)

=item B<inc>(inout NUM)

Increase $1 by one.

=cut

inline op inc(inout INT) {
  $1++;
  goto NEXT();
}

inline op inc(inout NUM) {
  $1++;
  goto NEXT();
}


########################################

=item B<inc>(inout INT, in INT)

=item B<inc>(inout NUM, in NUM)

Increase $1 by the amount in $2.

=cut

inline op inc(inout INT, in INT) {
  $1 += $2;
  goto NEXT();
}

inline op inc(inout NUM, in NUM) {
  $1 += $2;
  goto NEXT();
}


########################################

=item B<mod>(out INT, in INT, in INT)

NOTE: This "corrected mod" algorithm is based on the C code on page 70
of [1]. Assuming correct behavior of the built-in mod operator (%) with
positive arguments, this algorithm implements a mathematically convenient
version of mod, defined thus:

  x mod y = x - y * floor(x / y)

For more information on this definition of mod, see section 3.4 of [2],
pages 81-85.

References:

  [1] Donald E. Knuth, *MMIXware: A RISC Computer for the Third
      Millennium* Springer, 1999.

  [2] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
      Mathematics*, Second Edition. Addison-Wesley, 1994.

=cut

op mod(out INT, in INT, in INT) {
  INTVAL y = $2;
  INTVAL z = $3;
  INTVAL s = 0;
  INTVAL r;

  if (z == 0) {
    r = y;
  }
  else {
    if (y < 0) { s += 2; y = -y; }
    if (z < 0) { s += 1; z = -z; }

    r = y % z;

    switch (s) {
      case 0 + 0:            break;
      case 0 + 1: r = r - z; break;
      case 2 + 0: r = z - r; break;
      case 2 + 1: r = -r;    break;
    }
  }

  $1 = r;
  goto NEXT();
}


########################################

=item B<mod>(out NUM, in NUM, in NUM)

NOTE: This "corrected mod" algorithm is based on the formula of [1]:

  x mod y = x - y * floor(x / y)

For more information on this definition of mod, see section 3.4 of [1],
pages 81-85.

References:

  [1] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
      Mathematics*, Second Edition. Addison-Wesley, 1994.

=cut

op mod(out NUM, in NUM, in NUM) {
  $1 = $3
     ? ($2 - $3 * floor($2 / $3))
     : $2;
  goto NEXT();
}


########################################

=item B<mul>(out INT, in INT, in INT)

=item B<mul>(out NUM, in NUM, in NUM)

=item B<mul>(n, n, nc)

Set $1 to the product of $2 and $3.

=cut

inline op mul(out INT, in INT, in INT) {
  $1 = $2 * $3;
  goto NEXT();
}

inline op mul(out NUM, in NUM, in NUM) {
  $1 = $2 * $3;
  goto NEXT();
}


########################################

=item B<not>(out INT, in INT)

Set $1 to the negative of $2.

=cut

inline op neg(out INT, in INT) {
  $1 = -($2);
  goto NEXT();
}

inline op neg(out NUM, in NUM) {
  $1 = -($2);
  goto NEXT();
}


########################################

=item B<pow>(out NUM, in INT, in INT)

=item B<pow>(out NUM, in INT, in NUM)

=item B<pow>(out NUM, in NUM, in INT)

=item B<pow>(out NUM, in NUM, in NUM)

Set $1 to $2 raised to the power $3.

=cut

inline op pow(out NUM, in INT, in INT) {
   $1 = pow((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op pow(out NUM, in INT, in NUM) {
   $1 = pow((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op pow(out NUM, in NUM, in INT) {
   $1 = pow((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op pow(out NUM, in NUM, in NUM) {
   $1 = pow((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}


########################################

=item B<sub>(out INT, in INT, in INT)

=item B<sub>(out NUM, in NUM, in NUM)

Set $1 to $2 minus $3.

=cut

inline op sub(out INT, in INT, in INT) {
  $1 = $2 - $3;
  goto NEXT();
}

inline op sub(out NUM, in NUM, in NUM) {
  $1 = $2 - $3;
  goto NEXT();
}

inline op sub(out PMC, in PMC, in INT) {
  $2->vtable->subtract_int(interpreter, $2, $3, $1);
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 String operations

These operations operate on STRINGs.

=over 4

=cut


########################################

=item B<chopn>(inout STR, in INT)

Remove $2 characters from the end of the string in $1.

TODO: Create a three-argument version of this? Don't force in-place modification.'

=cut

inline op chopn(inout STR, in INT) {
  (void)string_chopn($1, $2);
  goto NEXT();
}


########################################

=item B<concat>(inout STR, in STR)

=item B<concat>(out STR, in STR, in STR)

Append the string in $2 to the string in $1.

The three argument version appends the string $3 to $2 and places the result
into $1.

=cut

inline op concat(inout STR, in STR) {
  $1 = string_concat(interpreter, $1, $2, 1);
  goto NEXT();
}

inline op concat(out STR, in STR, in STR) {
  $1 = string_concat(interpreter, $2, $3, 1);
  goto NEXT();
}

#######################################

=item B<repeat>(out STR, in STR, in INT)

Repeats string $2 $3 times and stores result in $1.

=cut

inline op repeat(out STR, in STR, in INT) {
  if ($3 < 0) {
      internal_exception(NEG_REPEAT, "Cannot repeat with negative arg");
  }
  $1 = string_repeat(interpreter, $2, (UINTVAL)$3, NULL);
  goto NEXT();
}

########################################

=item B<length>(out INT, in STR)

Set $1 to the length (in characters) of the string in $2.

=cut

inline op length(out INT, in STR) {
  $1 = string_length($2);
  goto NEXT();
}


########################################

=item B<substr>(out STR, in STR, in INT, in INT)

Set $1 to the portion of $2 starting at (zero-based) character position $3 and having
length $4.

=cut

inline op substr(out STR, in STR, in INT, in INT) {
  $1 = string_substr(interpreter, $2, $3, $4, &$1);
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 Transcendental mathematical operations

These operations perform various transcendental operations such as logarithmics
and trigonometrics.

=over 4

=cut


########################################

=item B<acos>(out NUM, in INT)

=item B<acos>(out NUM, in NUM)

Set $1 to the arc cosine (in radians) of $2.

=cut

inline op acos(out NUM, in INT) {
  $1 = acos((FLOATVAL)$2);
  goto NEXT();
}

inline op acos(out NUM, in NUM) {
  $1 = acos((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<asec>(out NUM, in INT)

=item B<asec>(out NUM, in NUM)

Set $1 to the arc secant (in radians) of $2.

=cut

inline op asec(out NUM, in INT) {
  $1 = acos(((FLOATVAL)1) / ((FLOATVAL)$2));
  goto NEXT();
}

inline op asec(out NUM, in NUM) {
  $1 = acos(((FLOATVAL)1) / ((FLOATVAL)$2));
  goto NEXT();
}


########################################

=item B<asin>(out NUM, in INT)

=item B<asin>(out NUM, in NUM)

Set $1 to the arc sine (in radians) of $2.

=cut

inline op asin(out NUM, in INT) {
  $1 = asin((FLOATVAL)$2);
  goto NEXT();
}

inline op asin(out NUM, in NUM) {
  $1 = asin((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<atan>(out NUM, in INT)

=item B<atan>(out NUM, in NUM)

=item B<atan>(out NUM, in INT, in INT)

=item B<atan>(out NUM, in INT, in NUM)

=item B<atan>(out NUM, in NUM, in INT)

=item B<atan>(out NUM, in NUM, in NUM)

The two-argument versions set $1 to the arc tangent (in radians) of $2.

The three-argument versions set $1 to the arc tangent (in radians) of
$2 / $3, taking account of the signs of the arguments in determining the
quadrant of the result.

=cut

inline op atan(out NUM, in INT) {
  $1 = atan((FLOATVAL)$2);
  goto NEXT();
}

inline op atan(out NUM, in NUM) {
  $1 = atan((FLOATVAL)$2);
  goto NEXT();
}

inline op atan(out NUM, in INT, in INT) {
  $1 = atan2((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op atan(out NUM, in INT, in NUM) {
  $1 = atan2((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op atan(out NUM, in NUM, in INT) {
  $1 = atan2((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op atan(out NUM, in NUM, in NUM) {
  $1 = atan2((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}


########################################

=item B<cos>(out NUM, in INT)

=item B<cos>(out NUM, in NUM)

Set $1 to the cosine of $2 (given in radians).

=cut

inline op cos(out NUM, in INT) {
  $1 = cos((FLOATVAL)$2);
  goto NEXT();
}

inline op cos(out NUM, in NUM) {
  $1 = cos((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<cosh>(out NUM, in INT)

=item B<cosh>(out NUM, in NUM)

Set $1 to the hyperbolic cosine of $2 (given in radians).

=cut

inline op cosh(out NUM, in INT) {
  $1 = cosh((FLOATVAL)$2);
  goto NEXT();
}

inline op cosh(out NUM, in NUM) {
  $1 = cosh((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<exp>(out NUM, in INT)

=item B<exp>(out NUM, in NUM)

Set $1 to I<e> raised to the power $2. I<e> is the base of the natural logarithm.

=cut

inline op exp(out NUM, in INT) {
  $1 = exp((FLOATVAL)$2);
  goto NEXT();
}

inline op exp(out NUM, in NUM) {
  $1 = exp((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<ln>(out NUM, in INT)

=item B<ln>(out NUM, in NUM)

Set $1 to the natural (base I<e>) logarithm of $2.

=cut

inline op ln(out NUM, in INT) {
  $1 = log((FLOATVAL)$2);
  goto NEXT();
}

inline op ln(out NUM, in NUM) {
  $1 = log((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<log10>(out NUM, in INT)

=item B<log10>(out NUM, in NUM)

Set $1 to the base 10 logarithm of $2.

=cut

inline op log10(out NUM, in INT) {
  $1 = log10((FLOATVAL)$2);
  goto NEXT();
}

inline op log10(out NUM, in NUM) {
  $1 = log10((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<log2>(out NUM, in INT)

=item B<log2>(out NUM, in NUM)

Set $1 to the base 2 logarithm of $2.

=cut

op log2(out NUM, in INT) {
   FLOATVAL temp = log((FLOATVAL)2.0);
  $1 = log((FLOATVAL)$2) / temp;
  goto NEXT();
}

op log2(out NUM, in NUM) {
   FLOATVAL temp = log((FLOATVAL)2.0);
  $1 = log((FLOATVAL)$2) / temp;
  goto NEXT();
}


########################################

=item B<sec>(out NUM, in INT)

=item B<sec>(out NUM, in NUM)

Set $1 to the secant of $2 (given in radians).

=cut

inline op sec(out NUM, in INT) {
  $1 = ((FLOATVAL)1) / cos((FLOATVAL)$2);
  goto NEXT();
}

inline op sec(out NUM, in NUM) {
  $1 = ((FLOATVAL)1) / cos((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<sech>(out NUM, in INT)

=item B<sech>(out NUM, in NUM)

Set $1 to the hyperbolic secant of $2 (given in radians).

=cut

inline op sech(out NUM, in INT) {
  $1 = ((FLOATVAL)1) / cosh((FLOATVAL)$2);
  goto NEXT();
}

inline op sech(out NUM, in NUM) {
  $1 = ((FLOATVAL)1) / cosh((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<sin>(out NUM, in INT)

=item B<sin>(out NUM, in NUM)

Set $1 to the sine of $2 (given in radians).

=cut

inline op sin(out NUM, in INT) {
  $1 = sin((FLOATVAL)$2);
  goto NEXT();
}

inline op sin(out NUM, in NUM) {
  $1 = sin((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<sinh>(out NUM, in INT)

=item B<sinh>(out NUM, in NUM)

Set $1 to the hyperbolic sine of $2 (given in radians).

=cut

inline op sinh(out NUM, in INT) {
  $1 = sinh((FLOATVAL)$2);
  goto NEXT();
}

inline op sinh(out NUM, in NUM) {
  $1 = sinh((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<tan>(out NUM, in INT)

=item B<tan>(out NUM, in NUM)

Set $1 to the tangent of $2 (given in radians).

=cut

inline op tan(out NUM, in INT) {
  $1 = tan((FLOATVAL)$2);
  goto NEXT();
}

inline op tan(out NUM, in NUM) {
  $1 = tan((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<tanh>(out NUM, in INT)

=item B<tanh>(out NUM, in NUM)

Set $1 to the hyperbolic tangent of $2 (given in radians).

=cut

inline op tanh(out NUM, in INT) {
  $1 = tanh((FLOATVAL)$2);
  goto NEXT();
}

inline op tanh(out NUM, in NUM) {
  $1 = tanh((FLOATVAL)$2);
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 Bitwise logical operations

These operations apply  bitwise logical functions to their arguments.

=over 4

=cut


########################################

=item B<and>(out INT, in INT, in INT)

Set the bits of $1 according to the B<and> of the corresponding bits from $2 and $3.

=cut

inline op and(out INT, in INT, in INT) {
  $1 = $2 & $3;
  goto NEXT();
}


########################################

=item B<not>(out INT, in INT)

Set the bits of $1 to the B<not> of the corresponding bits from $2.

=cut

inline op not(out INT, in INT) {
  $1 = ~ $2;
  goto NEXT();
}


########################################

=item B<or>(out INT, in INT, in INT)

Set the bits of $1 according to the B<or> of the corresponding bits from $2 and $3.

=cut

inline op or(out INT, in INT, in INT) {
  $1 = $2 | $3;
  goto NEXT();
}

########################################

=item B<shl>(out INT, in INT, in INT)

Set $1 to the value of $2 shifted left by $3 bits.

=cut

inline op shl(out INT, in INT, in INT) {
  $1 = $2 << $3;
  goto NEXT();
}


########################################

=item B<shr>(out INT, in INT, in INT)

Set $1 to the value of $2 shifted right by $3 bits.

=cut

inline op shr(out INT, in INT, in INT) {
  $1 = $2 >> $3;
  goto NEXT();
}


########################################

=item B<xor>(out INT, in INT, in INT)

Set the bits of $1 according to the B<xor> of the corresponding bits from $2 and $3.

=cut

inline op xor(out INT, in INT, in INT) {
  $1 = $2 ^ $3;
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 Interpreter flag modification operations

These operations modify the internal interpreter flags, affecting its
subsequent operation.

=over 4

=cut


########################################

=item B<debug>(in INT)

If $1 is zero, turn off debugging. Otherwise turn it on.

=cut

inline op debug(in INT) {
  if ($1 != 0) { interpreter->flags |=  PARROT_DEBUG_FLAG; }
  else         { interpreter->flags &= ~PARROT_DEBUG_FLAG; }
  restart NEXT();
}


########################################

=item B<bounds>(in INT)

If $1 is zero, turn off byte code bounds checking. Otherwise turn it on.

=cut

inline op bounds(in INT) {
  if ($1 != 0) { interpreter->flags |=  PARROT_BOUNDS_FLAG; }
  else         { interpreter->flags &= ~PARROT_BOUNDS_FLAG; }
  restart NEXT();
}


########################################

=item B<profile>(in INT)

If $1 is zero, turn off profiling. Otherwise turn it on.

=cut

inline op profile(in INT) {
  if ($1 != 0) { interpreter->flags |=  PARROT_PROFILE_FLAG; }
  else         { interpreter->flags &= ~PARROT_PROFILE_FLAG; }
  restart NEXT();
}


########################################

=item B<trace>(in INT)

If $1 is zero, turn off tracing. Otherwise turn it on.

=cut

inline op trace(in INT) {
  if ($1 != 0) { interpreter->flags |=  PARROT_TRACE_FLAG; }
  else         { interpreter->flags &= ~PARROT_TRACE_FLAG; }
  restart NEXT();
}

=back

=cut


###############################################################################

=head2 Register operations

These operations effect entire sets of registers.

=over 4

=cut


########################################

=item B<cleari>()

=item B<clearn>()

=item B<clearp>()

=item B<clears>()

Clear all the registers of the type indicated in the name of the operation.

INTVAL ('i') and FLOATVAL ('n') registers clear to zero.

PMC ('p') and STRING ('s') registers clear to NULL.

=cut

inline op cleari() {
  Parrot_clear_i(interpreter);
  goto NEXT();
}

inline op clearn() {
  Parrot_clear_n(interpreter);
  goto NEXT();
}

inline op clears() {
  Parrot_clear_s(interpreter);
  goto NEXT();
}

inline op clearp() {
  Parrot_clear_p(interpreter);
  goto NEXT();
}


########################################

=item B<popi>()

=item B<popn>()

=item B<popp>()

=item B<pops>()

Restore all the registers of the type indicated in the name of the operation
from the most recently B<push>ed copies.

=cut

inline op popi() {
  Parrot_pop_i(interpreter);
  goto NEXT();
}

inline op popn() {
  Parrot_pop_n(interpreter);
  goto NEXT();
}

inline op pops() {
  Parrot_pop_s(interpreter);
  goto NEXT();
}

inline op popp() {
  Parrot_pop_p(interpreter);
  goto NEXT();
}


########################################

=item B<pushi>()

=item B<pushn>()

=item B<pushp>()

=item B<pushs>()

Save all the registers of the type indicated in the name of the operation.

=cut

inline op pushi() {
  Parrot_push_i(interpreter);
  goto NEXT();
}

inline op pushn() {
  Parrot_push_n(interpreter);
  goto NEXT();
}

inline op pushs() {
  Parrot_push_s(interpreter);
  goto NEXT();
}

inline op pushp() {
  Parrot_push_p(interpreter);
  goto NEXT();
}

=back

=cut

###############################################################################

=head2 Register stack operations

These operations effect individual registers.

=over 4

=cut


########################################

=item B<entrytype>(out INT, in INT)

Gets the type of entry $2 of the stack and puts in in $1

=cut

op entrytype(out INT, in INT) {
  INTVAL depth;
  Stack_Entry entry;
  depth = stack_depth(interpreter, interpreter->user_stack);
  if (depth <= $2) {
    internal_exception(99, "Stack Depth wrong");
  }

  entry = stack_entry(interpreter, interpreter->user_stack, $2);
  $1 = get_entry_type(interpreter, entry);
  goto NEXT();
}

########################################

=item B<save>(in INT)

=item B<save>(in NUM)

=item B<save>(in STR)

=item B<save>(in PMC)

Save register or constant $1 onto the stack.

=cut

inline op save(in INT) {
  INTVAL i = $1;
  stack_push(interpreter, interpreter->user_stack, &i, STACK_ENTRY_INT, STACK_CLEANUP_NULL);
  goto NEXT();
}

inline op save(in NUM) {
  stack_push(interpreter, interpreter->user_stack, &($1), STACK_ENTRY_FLOAT, STACK_CLEANUP_NULL);
  goto NEXT();
}

inline op save(in PMC) {
  stack_push(interpreter, interpreter->user_stack, $1, STACK_ENTRY_PMC, STACK_CLEANUP_NULL);
  goto NEXT();
}

inline op save(in STR) {
  stack_push(interpreter, interpreter->user_stack, $1, STACK_ENTRY_STRING, STACK_CLEANUP_NULL);
  goto NEXT();
}


########################################

=item B<restore>(out INT)

=item B<restore>(out NUM)

=item B<restore>(out PMC)

=item B<restore>(out STR)

Restore register $1 from the appropriate register stack.

=cut

inline op restore(out INT) {
  (void)stack_pop(interpreter, interpreter->user_stack, &($1),
                  STACK_ENTRY_INT);
  goto NEXT();
}

inline op restore(out NUM) {
  (void)stack_pop(interpreter, interpreter->user_stack, &($1),
                  STACK_ENTRY_FLOAT);
  goto NEXT();
}

inline op restore(out PMC) {
  (void)stack_pop(interpreter, interpreter->user_stack, &($1), 
                  STACK_ENTRY_PMC);
  goto NEXT();
}

inline op restore(out STR) {
  (void)stack_pop(interpreter, interpreter->user_stack, &($1),
                  STACK_ENTRY_STRING);
  goto NEXT();
}


########################################

=item B<rotate_up>(in INT)

Rotate the top $1 entries in the user stack so that the top entry
becomes the bottom entry in that range.

=cut

inline op rotate_up(in INT) {
  rotate_entries(interpreter, interpreter->user_stack, $1);
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 Control flow

The control flow opcodes check conditions and manage program flow.

=over 4

=cut

########################################

=item B<branch>(in INT)

Branch forward or backward by the amount in $1.

=cut

inline op branch (in INT) {
  goto OFFSET($1);
}


########################################

=item B<bsr>(in INT)

Branch to the location specified by $1. Push the current location onto the call
stack for later returning.

=cut

inline op bsr (in INT) {
  stack_push(interpreter, interpreter->control_stack, expr NEXT(),  STACK_ENTRY_DESTINATION, STACK_CLEANUP_NULL);
  goto OFFSET($1);
}


########################################

=item B<jsr>()

Jump to the location specified by register X. Push the current
location onto the call stack for later returning.

TODO: Implement this, or delete the entry.

=cut


########################################

=item B<jump>(out INT)

Jump to the address held in register $1.

=cut

inline op jump(out INT) {
  goto OFFSET($1);
}

=back

=cut

###############################################################################

=head2 Symbol table ops

Ops to manipulate the symbol table

=over 4

=cut

########################################

=item B<find_global>(out PMC, in STR)

Find the global named $2 and store it in $1

=cut

op find_global(out PMC, in STR) {
/*  $1 = interpreter->perl_stash->stash_hash->vtable->get_string_index_s(interpreter, interpreter->perl_stash->stash_hash, $2);
*/
  goto NEXT();
}

=back

=cut

###############################################################################

=head2 Miscellaneous

Opcodes which need to be sorted into better categories.

=over 4

=cut

########################################

=item B<sweep>()

Trigger a dead object detection sweep

=cut

op sweep() {
  Parrot_do_dod_run(interpreter);
  goto NEXT();
}


=item B<collect>()

Trigger a GC collection

=cut

op collect() {
  Parrot_go_collect(interpreter);
  goto NEXT();
}

########################################

=item B<interpinfo>(out INT, in INT)

Fetch some piece of information about the interpreter and put it in $1

=cut

op interpinfo(out INT, in INT) {
  switch ($2) {
    case TOTAL_MEM_ALLOC: $1 = interpreter->memory_allocated;
                          break;
    case DOD_RUNS:        $1 = interpreter->dod_runs;
                          break;
    case COLLECT_RUNS:    $1 = interpreter->collect_runs;
                          break;
    case ACTIVE_PMCS:     $1 = interpreter->active_PMCs;
                          break;
    case ACTIVE_BUFFERS:  $1 = interpreter->active_Buffers;
                          break;
    case TOTAL_PMCS:      $1 = interpreter->total_PMCs;
                          break;
    case TOTAL_BUFFERS:   $1 = interpreter->total_Buffers;
                          break;
    case HEADERS_ALLOC_SINCE_COLLECT:
    $1 = interpreter->mem_allocs_since_last_collect;
    break;
    case MEM_ALLOCS_SINCE_COLLECT:
    $1 = interpreter->header_allocs_since_last_collect;
    break;
  }
  goto NEXT();
}


########################################

=item B<newinterp>(out PMC, in INT)

Create a new interpreter and store it in a PMC

=cut

op newinterp(out PMC, in INT) {
  struct Parrot_Interp *new_interp;
  struct PMC *new_pmc;
  new_interp = make_interpreter($2);
  new_pmc = new_pmc_header(interpreter);
  new_pmc->data = new_interp;
  new_pmc->vtable = YOU_LOSE_VTABLE;
  $1 = new_pmc;
  goto NEXT();
}


=item B<runinterp>(inout PMC, in INT)

Take a built interpreter and run the code starting at offset $2

=cut

op runinterp(inout PMC, in INT) {
  struct Parrot_Interp * new_interp = (struct Parrot_Interp *)$1->data;
  runops(new_interp, interpreter->code, REL_PC + $2);
  goto NEXT();
}

op enternative() {
  goto ADDRESS(( run_native(interpreter, CUR_OPCODE, interpreter->code->byte_code) ));
}

########################################

=item B<new>(out PMC, in INT)

Create a new PMC of class C<i>; look in F<pmc.h> for the base
vtable types. The assembler allows you to specify PMCs by type
name as well as by integer - you should do this for compatibility,
to avoid problems if the base types get reassigned. For example:

    new P0, PerlScalar

=cut

op new(out PMC, in INT) {
  PMC* newpmc;
  if ($2 <0 || $2 >= enum_class_max) {
    abort(); /* Deserve to lose */
  }
  newpmc = pmc_new(interpreter, $2);
  $1 = newpmc;
  goto NEXT();
}

########################################

=item B<find_type>(out INT, in STR)

Find the PMC type by name

=cut

op find_type(out INT, in STR) {
/*
    $1 = Parrot_base_classname_hash->vtable->get_integer_index_s(interpreter, Parrot_base_classname_hash, $2);
*/
    goto NEXT();
}

########################################

=item B<ret>()

Pop the location off the top of the stack and go there.

=cut

inline op ret() {
  goto POP();
}


########################################

=item B<sleep>(in INT)

Sleep for $1 seconds

=cut

inline op sleep(in INT) {
  if ($1 < 0) {
      internal_exception(NEG_SLEEP, "Cannot go back in time");
  }
  Parrot_sleep((UINTVAL)$1);
  goto NEXT();
}


#######################################

=item B<setline>(in INT)

Set the current line number we're executing code for

=cut

inline op setline(in INT) {
  interpreter->current_line = $1;
  goto NEXT();
}

=item B<getline>(out INT)

Get the current line number

=cut

inline op getline(out INT) {
  $1 = interpreter->current_line;
  goto NEXT();
}

=item B<setfile>(in STR)

Sets the current file we're executing code for

=cut

inline op setfile(in STR) {
  interpreter->current_file = $1;
  goto NEXT();
}

=item B<getfile>(out STR)

Gets the current file we're executing code for

=cut

inline op getfile(out STR) {
  $1 = interpreter->current_file;
  goto NEXT();
}

=item B<setpackage>(in STR)

Sets the current package we're executing code for

=cut

inline op setpackage(in STR) {
  interpreter->current_package = $1;
  goto NEXT();
}

=item B<getpackage>(out STR)

Gets the current package we're executing code for

=cut

inline op getpackage(out STR) {
  $1 = interpreter->current_package;
  goto NEXT();
}

=item B<warningson>(in INT)

Turns on warnings categories.  Categories already turned on will 
stay on.  Current categories and the numbers they map to are:

=over 4

=item 1: undef

=item 2: IO

=item -1: all

=back

To turn on multiple categories, OR the category numbers together.

=cut

inline op warningson(in INT) {
  PARROT_WARNINGS_on(interpreter, $1);
  goto NEXT();
}

=item B<warningsoff>(in INT)

Turns off warnings categories.  Categories already turned off will 
stay off.  See the documentation for B<warningson> for category 
numbers.

=cut

inline op warningsoff(in INT) {
  PARROT_WARNINGS_off(interpreter, $1);
  goto NEXT();
}


=back

=cut

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001 Yet Another Society. All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut

