/*
** io.ops
*/

VERSION = PARROT_VERSION;

=head1 NAME

io.ops

=cut

=head1 DESCRIPTION

Parrot's IO API 

=cut


###############################################################################

=head2 Parrot IO API Operations 


=over 4

=cut


########################################

=item B<close>(inout PMC)

Close IO object $1

=cut

inline op close(inout PMC) {
	PIO_close(interpreter, (ParrotIO*)(($1)->data));
	goto NEXT();
}

########################################

=item B<fdopen>(out PMC, in INT, in STR)

Create ParrotIO object as $1 as a copy of file descriptor $2.

XXX: integral file descriptors may not exist outside of the UNIX
     platform.  This op needs work.

=cut

inline op fdopen(out PMC, in INT, in STR) {
#ifdef IO_OS_UNIX
  /* These char * need to go away soon */
  const char * mode;
  mode = string_to_cstring(interpreter, $3);

  ParrotIO *io = PIO_fdopen(interpreter, $2, mode);
  if(io) {
    $1 = new_io_pmc(interpreter, io);
  }
  else {
    $1 = pmc_new(interpreter, enum_class_PerlUndef);
  }
#else
    $1 = pmc_new(interpreter, enum_class_PerlUndef);
#endif
  goto NEXT();
}

#########################################

=item B<open>(out PMC, in STR, in STR)

Open URL (file, address, database, in core image) named $2 with
Perl style mode string in $3 and create an IO object in $1.

=cut

inline op open(out PMC, in STR, in STR) {
  ParrotIO * io;
  /* These char * need to go away soon */
  const char * path, * mode;

  /* FIXME: potential infant mortality problem */
  path = string_to_cstring(interpreter, $2);
  mode = string_to_cstring(interpreter, $3);

  io = PIO_open(interpreter, path, mode);
  if(io) {
    $1 = new_io_pmc(interpreter, io);
  }
  else {
    $1 = pmc_new(interpreter, enum_class_PerlUndef);
  }
  goto NEXT();
}

##########################################

=item B<print>(in PMC, in STR)

Print String $2 on the IO stream object $1.

=cut

op print(in PMC, in STR) {
  ParrotIO * io;
  io = (ParrotIO*)($1->data);
  if ($2 && io) {
    PIO_write(interpreter, io, ($2)->strstart, string_length($2));
  }
  goto NEXT();
}

##########################################

=item B<printerr>(in STR)

Print $1 to interp.stderr IO stream (unbuffered)

=cut

op printerr(in STR) {
  if ($1) {
    PIO_write(interpreter, PIO_STDERR(interpreter), ($1)->strstart,
			string_length($1));
  }
  goto NEXT();
}

########################################

=item B<puts>(in STR)

=item B<puts>(in INT)

=item B<puts>(in NUM)

Print $1 to standard output stream
This will go away when print ops are all migrated to
use ParrotIO instead of STDIO. Right now ParrotIO is
not stable enough to replace STDIO.

=cut

op puts(in STR) {
  if (($1) && string_length($1)) {
    PIO_write(interpreter, PIO_STDOUT(interpreter), ($1)->strstart,
			string_length($1));
  }
  goto NEXT();
}

op puts(in INT) {
  STRING * s = string_from_int(interpreter, $1);
  if (string_length(s)) {
    PIO_write(interpreter, PIO_STDOUT(interpreter), s->strstart,
			string_length(s));
  }
  goto NEXT();
}

op puts(in NUM) {
  STRING * s = Parrot_sprintf_c(interpreter, "%Vf", $1);
  if (string_length(s)) {
    PIO_write(interpreter, PIO_STDOUT(interpreter), s->strstart,
			string_length(s));
  }
  goto NEXT();
}

########################################

=item B<read>(out STR, in INT)

Read up to N bytes from standard input stream
If stream is linebuffered, will return at EOL, for
files it will read MIN(MAX(avail, N), 65535) bytes.
Warning: This is a quick hack.

=item B<read>(out STR, in PMC, in INT)

Read up to N bytes from IO PMC stream. 
If stream is linebuffered, will return at EOL, for
files it will read MIN(MAX(avail, N), 65535) bytes.
Warning: This is a quick hack.

=cut

op read(out STR, in INT) {
  UINTVAL n;
  INTVAL nr;
  if($2 >= 65535)
    n = 65535;
  else
    n = $2; 
  $1 = string_make(interpreter, NULL, n, NULL, 0, NULL);
  memset(($1)->strstart, 0, n);
  nr = PIO_read(interpreter, PIO_STDIN(interpreter), ($1)->strstart, (size_t)n);
  if(nr > 0)
    ($1)->strlen = ($1)->bufused = nr;
  else
    ($1)->strlen = ($1)->bufused = 0;
  goto NEXT();
}

op read(out STR, in PMC, in INT) {
  UINTVAL n;
  INTVAL nr;
  if($3 >= 65535)
    n = 65535;
  else
    n = $3; 
  $1 = string_make(interpreter, NULL, n, NULL, 0, NULL);
  memset(($1)->strstart, 0, n);
  nr = PIO_read(interpreter, (ParrotIO*)($2->data), ($1)->strstart, (size_t)n);
  if(nr > 0)
    ($1)->strlen = ($1)->bufused = nr;
  else
    ($1)->strlen = ($1)->bufused = 0;
  goto NEXT();
}

##########################################

=item B<seek>(out INT, in PMC, in INT, in INT)

32bit seek:
Set file position to offset $3 on IO stream $2. 'whence' is
indicated by the value in $4.

=item B<seek>(out INT, in PMC, in INT, in INT, in INT)

64bit seek:
Set file position to offset ($3 << 32 | $4) on IO stream $2. 'whence' is
indicated by the value in $4.

=cut

op seek(out INT, in PMC, in INT, in INT) {
  ParrotIO * io;
  io = (ParrotIO*)($2->data);
  if (io) {
    $1 = (INTVAL)PIO_seek(interpreter, io, 0, $3, $4);
  }
  goto NEXT();
}

op seek(out INT, in PMC, in INT, in INT, in INT) {
  ParrotIO * io;
  io = (ParrotIO*)($2->data);
  if (io) {
    $1 = (INTVAL)PIO_seek(interpreter, io, $3, $4, $5);
  }
  goto NEXT();
}


########################################







=back

=cut


###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001-2002 Yet Another Society. All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut

