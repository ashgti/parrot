/*
** experimental.ops
*/

VERSION = PARROT_VERSION;

=head1 NAME

experimental.ops - Experimental Operations

=cut

=head1 DESCRIPTION

This file contains operations that are in an experimental state. Do not
rely upon the existence of the ops in this file when writing production code.
No decision has yet been made as to whether they are accepted as regular
Parrot ops or not. They are included here for testing purposes only!

=cut

###############################################################################

=head2 Mathematical operations

Implementations of various mathematical operations

=over 4

=cut

########################################

=item B<gcd>(out INT, in NUM, in NUM)

Greatest Common divisor of $2 and $3.

=item B<gcd>(out INT, out INT, out INT, in INT, in INT)

Given $4 and $5, it calculates $1, $2 and $3 so that

$1 = gcd($4, $5) = $2 * $4 + $3 * $5 (d = gcd(a,b) = x*a + y*b)

=cut

inline op gcd(out INT, in NUM, in NUM) :advanced_math {

  FLOATVAL q = 0;
  FLOATVAL c = 0;
  FLOATVAL temp2 = $2 < 0.0 ? -$2 : $2;
  FLOATVAL temp3 = $3 < 0.0 ? -$3 : $3;
  while (temp3 != 0) {
    q = floor( (FLOATVAL)temp2/temp3 );
    c = temp2 - temp3*q;
    temp2 = temp3;
    temp3 = c;
  }
  $1 = (INTVAL)temp2;
  goto NEXT();
}

inline op gcd(out INT, out INT, out INT, in INT, in INT) :advanced_math {
  /* r0 = q1*r1 + r2 */
  INTVAL r0 = $4 < 0 ? -$4 : $4;
  INTVAL r1 = $5 < 0 ? -$5 : $5;
  INTVAL r2 = 0;
  INTVAL q1 = 0;

  INTVAL xkm1 = 1;
  INTVAL xk = 0;
  INTVAL xkp1 = 0;

  INTVAL ykm1 = 0;
  INTVAL yk = 1;
  INTVAL ykp1 = 0;

  INTVAL n = 1;

  INTVAL x;
  INTVAL y;

  while (1) {
    q1 = r0/r1;
    r2 = r0 - q1*r1;
    if (r2 == 0) {
      break;
    }
    r0 = r1;
    r1 = r2;

    xkp1 = q1*xk + xkm1;
    xkm1 = xk;
    xk = xkp1;

    ykp1 = q1*yk + ykm1;
    ykm1 = yk;
    yk = ykp1;
  }
  $1 = r1;
  $2 = xk * pow( -1, n );
  $3 = yk * pow( -1, n+1 );

  x = $2 * $4;
  y = $3 * $5;

  /* correct the sign (can be wrong because we used abs($4) and abs($5) */
  if ( x + y == r1 ) {
    /* no correction necessary */
  }
  else if ( x + y == -r1 ) {
    $2 = -$2;
    $3 = -$3;
  }
  else if ( x - y == r1 ) {
    $3 = -$3;
  }
  else if ( -x + y == r1 ) {
    $2 = -$2;
  }

  goto NEXT();
}

=back

=cut

###############################################################################

=head2 random number operations

Implementations of various random number operations

=over 4

=cut

########################################

=item B<rand>(out NUM, in NUM)

=item B<rand>(out NUM)

=item B<rand>(out INT, in INT)

=item B<rand>(out INT)

=item B<srand>(in NUM)

Generate random numbers based on the Random PMC.

=cut

inline op rand(out NUM, in NUM) {
  FLOATVAL n = $2;
  PMC * r = pmc_new_noinit(interpreter, enum_class_Random);
  $1 = VTABLE_get_number(interpreter,r);
  $1 *= $2;
  goto NEXT();
}

inline op rand(out INT, in INT) {
  INTVAL n = $2;
  PMC * r = pmc_new_noinit(interpreter, enum_class_Random);
  FLOATVAL resultnum;
  resultnum = VTABLE_get_number(interpreter,r);
  $1 = (INTVAL)(resultnum * (FLOATVAL)n);
  goto NEXT();
}

inline op rand(out NUM) {
  PMC * r = pmc_new_noinit(interpreter, enum_class_Random);
  $1 = VTABLE_get_number(interpreter,r);
  goto NEXT();
}

inline op rand(out INT) {
  PMC *r = pmc_new_noinit(interpreter, enum_class_Random);
  $1 = VTABLE_get_integer(interpreter,r);
  goto NEXT();
}

inline op srand(in INT) {
  INTVAL i = $1;
  PMC * r = pmc_new_noinit(interpreter, enum_class_Random);
  VTABLE_set_integer_native(interpreter,r,i);
  goto NEXT();
}

=back

=cut

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001-2004 The Perl Foundation.  All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut
