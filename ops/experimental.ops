/*
** experimental.ops
*/

VERSION = PARROT_VERSION;

=head1 NAME

experimental.ops - Experimental Operations

=cut

=head1 DESCRIPTION

This file contains operations that are in an experimental state. Do not
rely upon the existence of the ops in this file when writing production code.
There is no decision yet whether they are accepted as regular parrot ops or not.
They are included here for testing purposes only!


=cut

###############################################################################

=head2 Mathematical operations

Implementations of various mathematical operations

=over 4

=cut

########################################

=item B<gcd>(out INT, in NUM, in NUM)

Greatest Common divisor of $2 and $3.

=item B<gcd>(out INT, out INT, out INT, in INT, in INT)

Given $4 and $5, it calculates $1, $2 and $3 so that

$1 = gcd($4, $5) = $2 * $4 + $3 * $5 (d = gcd(a,b) = x*a + y*b)

=cut

inline op gcd(out INT, in NUM, in NUM) :advanced_math {

  FLOATVAL q = 0;
  FLOATVAL c = 0;
  FLOATVAL temp2 = $2 < 0.0 ? -$2 : $2;
  FLOATVAL temp3 = $3 < 0.0 ? -$3 : $3;
  while (temp3 != 0) {
    q = floor( (FLOATVAL)temp2/temp3 );
    c = temp2 - temp3*q;
    temp2 = temp3;
    temp3 = c;
  }
  $1 = (INTVAL)temp2;
  goto NEXT();
}

inline op gcd(out INT, out INT, out INT, in INT, in INT) :advanced_math {
  /* r0 = q1*r1 + r2 */
  INTVAL r0 = $4 < 0 ? -$4 : $4;
  INTVAL r1 = $5 < 0 ? -$5 : $5;
  INTVAL r2 = 0;
  INTVAL q1 = 0;

  INTVAL xkm1 = 1;
  INTVAL xk = 0;
  INTVAL xkp1 = 0;

  INTVAL ykm1 = 0;
  INTVAL yk = 1;
  INTVAL ykp1 = 0;

  INTVAL n = 1;

  INTVAL x;
  INTVAL y;

  while (1) {
    q1 = r0/r1;
    r2 = r0 - q1*r1;
    if (r2 == 0) {
      break;
    }
    r0 = r1;
    r1 = r2;

    xkp1 = q1*xk + xkm1;
    xkm1 = xk;
    xk = xkp1;

    ykp1 = q1*yk + ykm1;
    ykm1 = yk;
    yk = ykp1;
  }
  $1 = r1;
  $2 = xk * pow( -1, n );
  $3 = yk * pow( -1, n+1 );

  x = $2 * $4;
  y = $3 * $5;

  /* correct the sign (can be wrong because we used abs($4) and abs($5) */
  if ( x + y == r1 ) {
    /* no correction necessary */
  }
  else if ( x + y == -r1 ) {
    $2 = -$2;
    $3 = -$3;
  }
  else if ( x - y == r1 ) {
    $3 = -$3;
  }
  else if ( -x + y == r1 ) {
    $2 = -$2;
  }

  goto NEXT();
}

=back

=cut

###############################################################################

=head2 Non-flow control comparison ops

These ops do comparisons and truth testing without doing flow control

=over 4

=cut

########################################

=item B<istrue>(out INT, in PMC)

Sets $1 to 1 or 0, depending on whether $2 is true or not

=cut

inline op istrue(out INT, in PMC) {
    $1 = VTABLE_get_bool(interpreter, $2);
    goto NEXT();
}

=item B<isgt>(out INT, in PMC, in PMC)

Sets $1 to 1 if $2 is greater than $3

=cut

inline op isgt(out INT, in PMC, in PMC) {
  $1 = (mmd_dispatch_i_pp(interpreter, $2, $3, MMD_CMP) > 0);
  goto NEXT();
}

=item B<isge>(out INT, in PMC, in PMC)

Sets $1 to 1 if $2 is greater than or equal to $3

=cut

inline op isge(out INT, in PMC, in PMC) {
  $1 = (mmd_dispatch_i_pp(interpreter, $2, $3, MMD_CMP) >= 0);
  goto NEXT();
}

=item B<isle>(out INT, in PMC, in PMC)

Sets $1 to 1 if $2 is less than or equal to $3

=cut

inline op isle(out INT, in PMC, in PMC) {
  $1 = (mmd_dispatch_i_pp(interpreter, $2, $3, MMD_CMP) <= 0);
  goto NEXT();
}

=item B<islt>(out INT, in PMC, in PMC)

Sets $1 to 1 if $2 is less than $3

=cut

inline op islt(out INT, in PMC, in PMC) {
  $1 = (mmd_dispatch_i_pp(interpreter, $2, $3, MMD_CMP) < 0);
  goto NEXT();
}

=item B<iseq>(out INT, in PMC, in PMC)

=item B<iseq>(out INT, in INT, in INT)

Sets $1 to 1 if $2 is equal to $3

=cut

inline op iseq(out INT, in PMC, in PMC) {
  $1 = mmd_dispatch_i_pp(interpreter, $2, $3, MMD_EQ);
  goto NEXT();
}

inline op iseq(out INT, in INT, in INT) {
  $1 = ($2 == $3) ? 1 : 0;
  goto NEXT();
}

=item B<isne>(out INT, in PMC, in PMC)

=item B<isne>(out INT, in INT, in INT)

Sets $1 to 1 if $2 is not equal to $3

=cut

inline op isne(out INT, in PMC, in PMC) {
  $1 = !mmd_dispatch_i_pp(interpreter, $2, $3, MMD_EQ);
  goto NEXT();
}

inline op isne(out INT, in INT, in INT) {
  $1 = ($2 == $3) ? 0 : 1;
  goto NEXT();
}

=cut

###############################################################################

=head2 random number operations

Implementations of various random number operations

=over 4

=cut

########################################

=item B<rand>(out NUM, in NUM)

=item B<rand>(out NUM)

=item B<rand>(out INT, in INT)

=item B<rand>(out INT)

=item B<srand>(in NUM)

Generate random numbers based on the Random PMC.

=cut

inline op rand(out NUM, in NUM) {
  FLOATVAL n = $2;
  PMC * r = pmc_new_noinit(interpreter, enum_class_Random);
  $1 = VTABLE_get_number(interpreter,r);
  $1 *= $2;
  goto NEXT();
}

inline op rand(out INT, in INT) {
  INTVAL n = $2;
  PMC * r = pmc_new_noinit(interpreter, enum_class_Random);
  FLOATVAL resultnum;
  resultnum = VTABLE_get_number(interpreter,r);
  $1 = (INTVAL)(resultnum * (FLOATVAL)n);
  goto NEXT();
}

inline op rand(out NUM) {
  PMC * r = pmc_new_noinit(interpreter, enum_class_Random);
  $1 = VTABLE_get_number(interpreter,r);
  goto NEXT();
}

inline op rand(out INT) {
  PMC *r = pmc_new_noinit(interpreter, enum_class_Random);
  $1 = VTABLE_get_integer(interpreter,r);
  goto NEXT();
}

inline op srand(in INT) {
  INTVAL i = $1;
  PMC * r = pmc_new_noinit(interpreter, enum_class_Random);
  VTABLE_set_integer_native(interpreter,r,i);
  goto NEXT();
}

=back

=cut

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001-2004 The Perl Foundation.  All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut
