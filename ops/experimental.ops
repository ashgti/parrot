/*
** experimental.ops
*/

VERSION = PARROT_VERSION;

=head1 NAME

experimental.ops - Experimental Operations

=cut

=head1 DESCRIPTION

This file contains operations that are in an experimental state. Do not
rely upon the existence of the ops in this file when writing production code.
No decision has yet been made as to whether they are accepted as regular
Parrot ops or not. They are included here for testing purposes only!

=cut

###############################################################################

=head2 Misc other ops

=over 4

=cut

########################################

inline op set_eh(in PMC) {
  /* use push_eh */
  push_exception(interpreter, $1);
  goto NEXT();
}


########################################

=item B<die>()

Die. Hard. Calls _exit, and won't do any process cleanup

TODO encode in existing die_hard opcode.

=cut

op die() :base_debug {
  _exit(0);
  goto NEXT();
}

op die(in INT) :base_debug {
  _exit($1);
  goto NEXT();
}

op new(out PMC, in INT, in KEY) {
  if ($2 <= 0 || $2 >= enum_class_max) {
    internal_exception(1, "Illegal PMC enum (%d) in new", (int)$2);
  }
  $1 = pmc_new_init(interpreter, $2, $3);
  goto NEXT();
}

########################################

=item B<splice>(in PMC, in PMC, in INT, in INT)

Replace $4 values at offset $3 in aggregate $1 with the PMCs in aggregate $2.
The values are put into the aggregate by a shallow copy. If the values would
be reused, they have to be B<clone>d.

=cut

inline op splice(in PMC, in PMC, in INT, in INT) {
    $1->vtable->splice(interpreter, $1, $2, $3, $4);
    goto NEXT();
}


=item B<slice>(out PMC, in PMC, in KEY)

Return a new Iterator PMC $1 for aggregate $2 and Slice PMC $3.

=item B<slice>(out PMC, in PMC, in KEY, inconst INT)

Return a new list PMC $1 for aggregate $2 and Slice PMC $3.

This is a Python opcode. Range is i <= k < j. $4 must be 1.
May change and move to python.ops.

=item B<iter>(out PMC, in PMC)

Return a new Iterator PMC $1 for aggregate $2.

=cut

inline op slice (out PMC, in PMC, in KEY) :base_core {
    $1 = $2->vtable->slice(interpreter, $2, $3, 0);
    goto NEXT();
}

inline op slice (out PMC, in PMC, in KEY, inconst INT) :python {
    $1 = $2->vtable->slice(interpreter, $2, $3, $4);
    goto NEXT();
}

inline op iter (out PMC, in PMC) :base_core {
    $1 = $2->vtable->get_iter(interpreter, $2);
    goto NEXT();
}

########################################

=item B<morph>(in PMC, in INT)

Have $1 turn itself into a PMC of type $2.

=cut

inline op morph(in PMC, in INT) {
  VTABLE_morph(interpreter, $1, $2);
  goto NEXT();
}
=cut

=item B<exec>(in STR)

Execute the passed-in command. Completely tosses the current process
image and replaces it with the command. Doesn't exit (the program
ends, after all), though it does throw an exception if something goes
wrong.

=cut

inline op exec(in STR) {
  Parrot_Exec_OS_Command(interpreter, $1);
  goto NEXT();
}

=item B<is_cclass>(out INT, in INT, in STR, in INT)

Set $1 to 1 if the codepoint of $3 at position $4 is in
the character class(es) given by $2.

=cut

inline op is_cclass(out INT, in INT, in STR, in INT) {
  $1 = Parrot_string_is_cclass(interpreter, $2, $3, $4);
  goto NEXT();
}

=item B<find_cclass>(out INT, in INT, in STR, in INT, in INT)

Set $1 to the offset of the first codepoint matching
the character class(es) given by $2 in string $3, starting
at offset $4 for up to $5 codepoints.  If no matching
character is found, set $1 to -1.

=cut

inline op find_cclass(out INT, in INT, in STR, in INT, in INT) {
  $1 = Parrot_string_find_cclass(interpreter, $2, $3, $4, $5);
  goto NEXT();
}

=item B<find_not_cclass>(out INT, in INT, in STR, in INT, in INT)

Set $1 to the offset of the first codepoint not matching
the character class(es) given by $2 in string $3, starting
at offset $4 for up to $5 codepoints.  If the substring
consists entirely of matching characters, set $1 to -1.

=cut

inline op find_not_cclass(out INT, in INT, in STR, in INT, in INT) {
  $1 = Parrot_string_find_not_cclass(interpreter, $2, $3, $4, $5);
  goto NEXT();
}

=back

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001-2004 The Perl Foundation.  All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut
