/*
** var.ops
*/

VERSION = PARROT_VERSION;

=head1 NAME

var.ops - Variable Ops

=head1 DESCRIPTION

These operations deal with both lexical and global variables,
as well as the symbol tables that contain them.

=cut

###############################################################################

=head2 Lexical variable ops

Operations to create, modify and delete lexical variables.

=over 4

=cut

########################################

=item B<new_pad>(in INT)

Create a new lexical scope pad with static nesting depth $1
and push it onto the lexical scope stack. Static depths 0
through $1 - 1, inclusive, are copied from the current static
nesting.

=item B<new_pad>(out PMC, in INT)

Create a new lexical scope pad with static nesting depth $2
and store it in $1 (do NOT push on the stack). Static depths 0
through $2 - 1, inclusive, are copied from the current static
nesting.

=cut

op new_pad(in INT) {
    PMC * pad;
    PMC * parent = scratchpad_get_current(interpreter);
    pad = scratchpad_new(interpreter, parent, $1);
    stack_push(interpreter, &CONTEXT(interpreter->ctx)->pad_stack, pad,
               STACK_ENTRY_PMC, STACK_CLEANUP_NULL);
    goto NEXT();
}

op new_pad(out PMC, in INT) {
    PMC * parent = scratchpad_get_current(interpreter);
    $1 = scratchpad_new(interpreter, parent, $2);
    goto NEXT();
}

########################################

=item B<push_pad>(in PMC)

Push the scratchpad in $1 onto the lexical scope stack.

=cut

op push_pad(in PMC) {
    stack_push(interpreter, &CONTEXT(interpreter->ctx)->pad_stack, $1,
               STACK_ENTRY_PMC, STACK_CLEANUP_NULL);
    goto NEXT();
}

########################################

=item B<pop_pad>()

Pop the current lexical scope pad off the stack

=item B<pop_pad>(out PMC)

Pop the current lexical scope pad off the stack and store
it in $1

=cut

op pop_pad() {
    stack_pop(interpreter, &CONTEXT(interpreter->ctx)->pad_stack,
              NULL, STACK_ENTRY_PMC);
    goto NEXT();
}

op pop_pad(out PMC) {
    stack_pop(interpreter, &CONTEXT(interpreter->ctx)->pad_stack,
              &$1, STACK_ENTRY_PMC);
    goto NEXT();
}

########################################

=item B<peek_pad>(out PMC)

Store the current lexical scope pad (i.e. the one at the
top of the lexical pad stack) in $1.

=cut

op peek_pad(out PMC) {
    $1 = scratchpad_get_current(interpreter);
    goto NEXT();
}

########################################

=item B<store_lex>(in STR, in PMC)

Store object $2 as lexical symbol $1.  $1 must have already been
created at some static depth.

=item B<store_lex>(in INT, in STR, in PMC)

Store object $3 as lexical $2 at depth $1.  If [$1, $2] does not
exist, it will be created.  If $1 is negative, count out from the
current lexical scope; otherwise, count in from the outermost scope.
So store_lex -1, .... will operate on the current pad. Lexicals can
be retrieved by index too: the index is generated in storage order.

=item B<store_lex>(in INT, in INT, in PMC)

Store object $3 at lexical position $2 at depth $1.  If [$1, $2] does
not exist, it will be created.  If $1 is negative, count out from the
current lexical scope; otherwise, count in from the outermost scope.
So store_lex -1, .... will operate on the current pad. Lexicals stored
by index can only be retrieved by this index.

=cut

op store_lex(in STR, in PMC) {
    PMC *pad = scratchpad_get_current(interpreter);
    if (!pad)
        real_exception(interpreter, NULL, PAD_NOT_FOUND,
		"empty lexical pad");
    scratchpad_store(interpreter, pad, $1, $2);
    goto NEXT();
}

op store_lex(in INT, in STR, in PMC) {
    PMC *pad = scratchpad_get_current(interpreter);
    if (!pad)
        real_exception(interpreter, NULL, PAD_NOT_FOUND,
		"empty lexical pad");
    scratchpad_store_by_name(interpreter, pad, $1, $2, $3);
    goto NEXT();
}

op store_lex(in INT, in INT, in PMC) {
    PMC *pad = scratchpad_get_current(interpreter);
    if (!pad)
        real_exception(interpreter, NULL, PAD_NOT_FOUND,
		"empty lexical pad");
    scratchpad_store_by_index(interpreter, pad, $1, $2, $3);
    goto NEXT();
}

########################################

=item B<find_lex>(out PMC, in STR)

Find the lexical variable named $2 (at any depth) and store it in $1.

=item B<find_lex>(out PMC, in INT, in STR)

Find the lexical variable named $3 at depth $2 and store it in $1.
If $2 is negative, then count out from the current lexical scope;
otherwise, count up from the outermost scope.

=item B<find_lex>(out PMC, in INT)

Find the lexical number $2 at the topmost pad.

=item B<find_lex>(out PMC, in INT, in INT)

Find the lexical variable at position $3 at depth $2 and store it in
$1. If $2 is negative, then count out from the current lexical scope;
otherwise, count up from the outermost scope.

=cut

op find_lex(out PMC, in STR) {
    opcode_t * next = expr NEXT();
    PMC *pad = scratchpad_get_current(interpreter);
    $1 = scratchpad_find(interpreter, pad, $2);
    if (!pad)
        real_exception(interpreter, next, PAD_NOT_FOUND,
		"empty lexical pad");
    if (!$1)
        real_exception(interpreter, next, LEX_NOT_FOUND,
            "Lexical '%Ss' not found", $2);
    goto NEXT();
}

op find_lex(out PMC, in INT) {
    opcode_t * next = expr NEXT();
    PMC *pad = scratchpad_get_current(interpreter);
    if (!pad)
        real_exception(interpreter, next, PAD_NOT_FOUND,
		"empty lexical pad");
    $1 = scratchpad_get_by_index(interpreter, pad, -1, $2);
    if (!$1)
        real_exception(interpreter, next, LEX_NOT_FOUND,
            "Lexical #'%d' not found", (int) $2);
    goto NEXT();
}

op find_lex(out PMC, in INT, in STR) {
    opcode_t * next = expr NEXT();
    PMC *pad = scratchpad_get_current(interpreter);
    if (!pad)
        real_exception(interpreter, next, PAD_NOT_FOUND,
		"empty lexical pad");
    $1 = scratchpad_get_by_name(interpreter, pad, $2, $3);
    if (!$1)
        real_exception(interpreter, next, LEX_NOT_FOUND,
            "Lexical '%Ss' not found", $3);
    goto NEXT();
}

op find_lex(out PMC, in INT, in INT) {
    opcode_t * next = expr NEXT();
    PMC *pad = scratchpad_get_current(interpreter);
    if (!pad)
        real_exception(interpreter, next, PAD_NOT_FOUND,
		"empty lexical pad");
    $1 = scratchpad_get_by_index(interpreter, pad, $2, $3);
    if (!$1)
        real_exception(interpreter, next, LEX_NOT_FOUND,
            "Lexical #'%d' not found", (int) $3);
    goto NEXT();
}

=back

=cut

###############################################################################

=head2 Global variable ops

Operations to modify global variables

=over 4

=cut

########################################

=item B<store_global>(in STR, in PMC)

Store global $2 as global symbol $1

=item B<store_global>(in STR, in STR, in PMC)

Store global $3 as global symbol $2 in namespace $1. If namespace $1 doesn't
exist it is created.

=item B<store_global>(in PMC, in STR, in PMC)

Store global $3 as global symbol $2 in namespace $1.


=cut

op store_global(in STR, in PMC) {
    Parrot_store_global(interpreter, NULL, $1, $2);
    goto NEXT();
}

op store_global(in STR, in STR, in PMC) {
    Parrot_store_global(interpreter, $1, $2, $3);
    goto NEXT();
}

op store_global(in PMC, in STR, in PMC) {
    VTABLE_set_pmc_keyed_str(interpreter, $1, $2, $3);
    goto NEXT();
}

########################################

=item B<find_global>(out PMC, in STR)

Find the global named $2 and store it in $1. If the global doesn't exist
either throws an exception or sets $1 to undef, depending on current
errors settings, s. B<errorson>.

=item B<find_global>(out PMC, in STR, in STR)

Find the global named $3 in namespace $2 and store it in $1. If the
global doesn't exist either throws an exception or sets $1 to undef,
depending on current errors settings, s. B<errorson>.

If $3 is NULL the namespace hash for namespace $2 is returned.

=item B<find_global>(out PMC, in PMC, in STR)

Find the global named $3 in the namespace specified by $2
and store it in $1. If the global doesn't exist either throws an
exception or sets $1 to undef, depending on current errors settings,
s. B<errorson>.

=cut

op find_global(out PMC, in STR) {
    opcode_t * next;
    if (!$2)
	internal_exception(1, "Tried to get null global.");

    next = expr NEXT();
    $1 = Parrot_get_global(interpreter, NULL, $2, next);
    goto NEXT();
}

op find_global(out PMC, in STR, in STR) {
    opcode_t * next;
    if (!$2)
	internal_exception(1, "Tried to get null class.");

    next = expr NEXT();
    $1 = Parrot_get_global(interpreter, $2, $3, next);
    goto NEXT();
}

op find_global(out PMC, in PMC, in STR) {
    opcode_t * next;
    if (PMC_IS_NULL($2))
	internal_exception(1, "Tried to get from null namespace.");
    if (!$3)
	internal_exception(1, "Tried to get null global.");

    next = expr NEXT();
    $1 = Parrot_get_global_p(interpreter, $2, $3);
    goto NEXT();
}

=item B<find_name>(out PMC, in STR)

Find the name $2 in lexical, global or builtin namespace and
store it in $1. If the name doesn't exist
either throws an exception or sets $1 to undef, depending on current
errors settings, s. B<errorson>.

=cut

op find_name(out PMC, in STR) {
    opcode_t * next;
    if (!$2)
	internal_exception(1, "Tried to get null name");

    next = expr NEXT();
    $1 = Parrot_get_name(interpreter, $2);
    goto NEXT();
}

=back

=cut

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001-2004 The Perl Foundation.  All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut
