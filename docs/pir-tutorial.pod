#
# Note:
#  for now, this is an article I am writting for next TPR.  So, please
#  give me hints of what's wrong, and interesting things to add, but
#  don't extend much the size of it.
#

=head1 Writing PIR

PIR (Parrot Intermediate Representation) is a way to program the 
parrot virtual machine that is easier to use than PASM (Parrot
Assembler). PASM notation is like any other assembler-like format and
can be used directly, but it is more verbose and gives too much power 
to the user. PIR abstracts common operations and conventions into a
syntax that more closely resembles a high-level language. PIR allows
the programmer to write code that more naturally expresses their
intent without worrying about setting up the exact details that PASM
requires to function properly.

This article will show the basics on programming in PIR. More advanced
topics will appear in later articles.

=head2 Getting Parrot

To test PIR (or PASM) code I need Parrot virtual machine. It is
available from L<http://parrotcode.org>. I can just download the
latest release, or checkout the current development version from the
SVN tree.

It is very easy to compile: I just run the C<Configure.pl> script, and
C<make> the animal. Then, I get the C<parrot> program in the root
directory of the Parrot package. Normally I use it directly from here,
instead of installing it into the system, making it easier to hack the
code.

=head2 Simple Operators

Let me start with a simple and typical example:

  .sub main :main
       print "hello world\n"
  .end

To run it, save the code in a C<hello.pir> file and pass it to the
parrot virtual machine:

   ./parrot hello.pir

Note that I am using a relative path to parrot given that I didn't
install it into the system.

The keyworks starting with a dot (C<.sub> and C<.end>) are PIR
macros. They are used together to define subroutines. After the
C<.sub> keyword I use the name of the subroutine. The C<:main> means
that this is the main body of the program. This way, Parrot knows what
subroutine to run. By the way, I could just use C<.sub foo :main> and
Parrot will use C<foo> as the main body as well.

In the body you can use plain PASM code together with PIR
code. Although that is not a good practice, it might be helpful.

Before entering with more details about subroutines and calling
conventions, let use some more simplified PIR syntax.

For instance, if I want to add two integer registers using PASM I
would use the Parrot C<set> opcode to put values into registers, and
the C<add> opcode to add them, like this:

   set I1, 5
   set I2, 3
   add I0, I1, I2   # I0 yields 5+3

PIR includes infix operators to these common opcodes. I could write
this same code as

   I1 = 5
   I2 = 3
   I0 = I1 + I2

There are the four arithmetic operators as you should be expecting, as
well as the six different comparison operators, which return a boolean
value:

   I1 = 5
   I2 = 3
   I0 = I1 <= I2   # I0 yields 0 (false)

I can also use the short accumution-like operators, like C<+=>.

Speaking of registers, whenever I can, I registers starting with a
dollar sign, like C<$I1>. This way I let the parrot PIR compiler to
choose and if needed, reassign another register instead of the one I
specified, making the optimizations it needs for speed.

If I preffer I can declare local variables and use my own names
instead of register names. For that I just need to declare the
variable using the C<.local> keyword:

   .local int size
   size = 5

Parrot compiler will choose one register and associate it with my
variable name. I can declare local variables for any of the four data
types available on PIR: int, string, num and pmc.

=head2 Branching

Another simplification of PASM are branches. Basically, when I want to
test a condition and jump to another place in the code, I would write
the following PASM code:

   le I1, I2, LESS_EQ

Meaning, if C<I1> is less or equal than C<I2>, jump to label
C<LESS_EQ>. In PIR I would write it in a more legible way:

   if $I1 <= $I2 goto LESS_EQ

PIR includes the C<unless> keyword as well.

=head2 Calling Functions

Subroutines can easily be created using the C<.sub> keyword shown
before. If you do not need parameters, it just as simple as I show in
the following code:

  .sub main :main
     hello()
  .end

  .sub hello
    print "Hello World\n"
  .end

Now, I want to make my C<hello> subroutine a little more useful, such
that I can greet other people. For that I will use the C<.param>
keyword to define the parameters C<hello> can handle:

  .sub main :main
     hello("leo")
     hello("chip")
  .end

  .sub hello
     .param string person
     print "Hello "
     print person
     print "\n"
  .end

If I need more parameters I just need to add more C<.param> lines. PIR
support properties for subroutines parameters but I don't want to talk
about them right now.

To return values from PIR subroutines I use the C<.return> keyword,
followed by one or more arguments, just like this:

  .return (10, 20, 30)

=head2 Factorial Example

Now, for a little more complicated example, let me show how I would
code Factorial subroutine:

  .sub main :main
     $I1 = factorial(5)
     print $I1
     print "\n"
  .end

  .sub factorial
     .param int i
     if i > 1 goto recurse
     .return (1)
  recurse:
     $I1 = i - 1
     $I2 = factorial($I1)
     $I2 *= i
     .return ($I2)
  .end


=head2 Named Arguments

As some other languages as Python and Perl support named arguments,
PIR support them as well.

Into the subroutine I need to use a C<.param> command for each named
argument as well, but using one of the two following syntaxes:

   .sub func
     .param int a :named("foo")
     .param int "bar" => b

With these lines I declare that my subroutine will receive two
integers, and that the first one is called "foo" and the second one is
called "bar". In the subroutine I will use C<a> to reffer to C<foo>'s
value, and C<b> to reffer to C<bar>'s value.

When calling the function, I need to pass the names of the
arguments. For that I can use two syntaxes as well:

  func( 10 :named("foo"), 20 :named("bar"))
  func( "bar" => 20, "foo" => 10)

Interesting it to use this same syntax when returning values from
subroutines. Into the C<.return> command I'll use:

  .return ( "bar" => 20, "foo" => 10)

and when calling the function, I will do:

  ("foo" => $I0, "bar" => $I1) = func()

And C<$I0> will yield 10, and C<$I1> will yield 20, as expected.



=cut
