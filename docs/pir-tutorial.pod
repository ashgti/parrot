#
# Note:
#  for now, this is an article I am writting for next TPR.  So, please
#  give me hints of what's wrong, and interesting things to add, but
#  don't extend much the size of it.
#

=head2 Writing PIR

PIR (Parrot Intermediate Representation) is a special format to
simplify the task of writing parrot code. PASM (Parrot Assembler)
notation is like any other Assembler-like format and can be used
directly, but gives too power to the user. Mainly, there are some
conventions that PASM coders should use, and that PIR masques. This
way, I can write code without worrying about these little details.

With this article I want to show just the basics on programming
PIR. More advanced topics will appear on later articles.

=head2 Getting Parrot

To test PIR (or PASM) code I need Parrot virtual machine. It is
available from L<http://parrotcode.org>. I can just download the
latest release, or checkout the current development version from the
SVN tree.

It is very easy to compile: I just run the C<Configure.pl> script, and
C<make> the animal. Then, I get the C<parrot> program in the root
directory of the Parrot package. Normally I use it directly from here,
instead of installing it into the system, making it easier to hack the
code.

=head2 Simple Operators

Let me start with a simple and typical example:

  .sub main :main
       print "hello world\n"
       end
  .end

To run it, save the code in a C<hello.pir> file and pass it to the
parrot virtual machine:

   ./parrot hello.pir

Note that I am using a relative path to parrot given that I didn't
install it into the system.

The keyworks starting with a dot (C<.sub> and C<.end>) are PIR
macros. They are used together to define subroutines. After the
C<.sub> keyword I use the name of the subroutine. The C<:main> means
that this is the main body of the program. This way, Parrot knows what
subroutine to run. By the way, I could just use C<.sub foo :main> and
Parrot will use C<foo> as the main body as well.

In the case of this sample program the body of C<main> is just plain
PASM.

Before entering with more details about subroutines and calling
conventions, let use some more simplified PIR syntax.

For instance, if I want to add two integer registers I can use the
Parrot C<set> opcode to put values into registers, and the C<add>
opcode to add them, like this:

   set I1, 5
   set I2, 3
   add I0, I1, I2   # I0 yields 5+3

PIR includes infix operators to these common opcodes. I could write
this same code as

   I1 = 5
   I2 = 3
   I0 = I1 + I2

There are the four arithmetic operators as you should be expecting, as
well as the six different comparison operators, which return a boolean
value:

   I1 = 5
   I2 = 3
   I0 = I1 <= I2   # I0 yields 0 (false)

I can also use the short accumution-like operators, like C<+=>.

Speaking of registers, whenever I can, I registers starting with a
dollar sign, like C<$I1>. This way I let the parrot PIR compiler to
choose and if needed, reassign another register instead of the one I
specified, making the optimizations it needs for speed.

If I preffer I can declare local variables and use my own names
instead of register names. For that I just need to declare the
variable using the C<.local> keyword:

   .local int size
   size = 5

Parrot compiler will choose one register and associate it with my
variable name. I can declare local variables for any of the four data
types available on PIR: int, string, num and pmc.

=head2 Branching

Another simplification of PASM are branches. Basically, when I want to
test a condition and jump to another place in the code, I would write
the following PASM code:

   le, I1, I2, LESS_EQ

Meaning, if C<I1> is less or equal than C<I2>, jump to label
C<LESS_EQ>. In PIR I would write it in a more legible way:

   if $I1 <= $I2 goto LESS_EQ

PIR includes the C<unless> keyword as well.

=head2 Calling Functions

Subroutines can easily be created using the C<.sub> keyword shown
before. If you do not need parameters, it just as simple as I show in
the following code:

  .sub main :main
     hello()
     end
  .end

  .sub hello
    print "Hello World\n"
  .end

Now, I want to make my C<hello> subroutine a little more useful, such
that I can greet other people. For that I will use the C<.param>
keyword to define the parameters C<hello> can handle:

  .sub main :main
     hello("leo")
     hello("chip")
  .end

  .sub hello
     .param string person
     print "Hello "
     print person
     print "\n"
  .end

If I need more parameters I just need to add more C<.param> lines. PIR
support properties for subroutines parameters but I don't want to talk
about them right now.

To return values from PIR subroutines I use the C<.return> keyword,
followed by one or more arguments, just like this:

  .return (10, 20, 30)

=head2 Named Arguments

As some other languages as Python and Perl support named arguments,
PIR support them as well.

Into the subroutine I need to use a C<.param> command for each named
argument as well, but using one of the two following syntaxes:

   .sub func
     .param int a :named("foo")
     .param int "bar" => b

With these lines I declare that my subroutine will receive two
integers, and that the first one is called "foo" and the second one is
called "bar". In the subroutine I will use C<a> to reffer to C<foo>'s
value, and C<b> to reffer to C<bar>'s value.

When calling the function, I need to pass the names of the
arguments. For that I can use two syntaxes as well:

  func( 10 :named("foo"), 20 :named("bar"))
  func( "bar" => 20, "foo" => 10)

Interesting it to use this same syntax when returning values from
subroutines. Into the C<.return> command I'll use:

  .return ( "bar" => 20, "foo" => 10)

and when calling the function, I will do:

  ("foo" => $I0, "bar" => $I1) = func()

And C<$I0> will yield 10, and C<$I1> will yield 20, as expected.


=cut
