# Copyright (C) 2008, The Perl Foundation.
# $Id$

=head1 NAME

pct_optable_guide.pod - A Guide to Using an Operator Parsing Table in PGE-based grammars.

=head1 DESCRIPTION

This document describes how to use an operator parsing table in grammars
written for the Parrot Grammar Engine.

=head1 WHY AN OPTABLE?

{{explain why you should want that}}

=head1 HOW DOES AN OPTABLE WORK?

{{explain how this works}}

=head1 HOW TO USE AN OPTABLE?

Perl 6 rules are run as ordinary subroutines, and parsing will be done
by invoking a rule's subrules. A subrule can also contain subrules.
Therefore, the generated parser is a top-down parser, starting at the
C<TOP> rule, and invoking rules that represent I<lower> parts of the
grammar.

=head2 Switching Top-down and Bottom-up parsing

An optable parses operators bottom-up, which is the other well-known
parsing approach, implemented popular parser generators such as Yacc.
At some point, when using an optable, your parser must switch from
top-down parsing to bottom-up, and after parsing the operators (and
related operands), the parser switches back from bottom-up to top-down
again.

{{explain a bit how to decide when to enter bottom-up parsing}}

{{explain how to decide what an operand is}}

In order to define the entry point of the bottom-up, operator parsing
table, you should define a rule. Below is an example that states that
an C<expression> is parsed by the operator parser:

 rule expression is optable { ... }

The C<...> indicates that this rule is a C<prototype>.

{{ explain what this is }}


In order to define what an operand is, a special rule is define, named
C<term:>.

{{ is this always called "term:" or can it be named anything? not sure }}

 proto 'term:' is precedence('=') is parsed(&simple_expression) { ... }

This rule states that whenever an operand is expected, it is parsed by
the rule named C<simple_expression>. In other words, this is the point
where the parser switches back from bottom-up to top-down.

=head2 Defining operators

In between these two rules defining the entry point and the I<exit> point
of the operator parser, operators are declared, along with their
precedence. This typically look as follows:

 proto 'infix:+' is looser('term:') { ... }

This defines the symbol C<+> as an C<infix> operator.

{{ how to express "looser"/"tighter" in words }}

=head3 Operator precedence

Operator precedence can be expressed using the following {{ ehm. what are they called? }}

=over 4

=item * looser

=item * equal

=item * tighter

=back

=head3 Where's the operator?

When operators such as C<infix:+> are defined, the bottom-up parser will
generate a C<call> instruction to a subroutine with the same name, that is,
C<infix:+>. Therefore, you need to write a subroutine for each operator
you define. The subroutine for the C<infix:+> operator could look like this:

 .sub 'infix:+'
    .param pmc a      # left operand
    .param pmc b      # right operand
    n_add $P0, a, b   # create a new PMC object with the value a+b
    .return ($P0)
 .end

Whenever an expression such as C<42 + 1> is parsed, this will result in a
call to C<infix:+> with the operands C<42> and C<1>. The C<infix:+> sub
will create a new object, and assign the result of C<42 + 1> to it, after
which this new object is returned. Note that the C<n_> prefix of the C<add>
instruction implies that a new object is created.

You might think that it's somewhat overkill to write and call a subroutine
for such a simple operation, and that this could be done simpler. Well,
you're right. If the implementation of the C<+> operator is as simple as
in this case, there's a simpler way to implement the exact same behavior.
This can be accomplished using a the C<pirop> trait, discussed below.

=head3 Infix, prefix, postfix

{{ explain that any word after a "***ix:" can be an operator, for instance
   "infix:defined" }}

=head3 Ternary operators

Most languages only have one ternary operator: C<? :>. An example is shown
below:

 $income > 100000 ? print("I'm rich!") : print("I'll keep my job for now")

To declare a ternary operator, you write:

 proto ternary:<? :> is looser('infix:+') { ... }


=head3 The C<assoc> trait

=head3 The C<pirop> trait

Some operators can be perfectly mapped to a specific Parrot instruction,
for instance the C<n_add> op that we introduced earlier. By default, an
operator is implemented as a subroutine call, which is obviously not as
efficient as a single Parrot instruction. Therefore, you can specify the
Parrot instruction using the C<pirop> trait. You can do this as follows:

 proto 'infix:+' ... is pirop('n_add') { ... }

This will not work for all Parrot ops, though. Certain instructions
leave their result in an C<I> register (one of the four types of Parrot
registers). PCT currently only supports PMC registers (C<P> registers).
Operators such as C<==> and C<!=> must therefore be implemented as
subroutine calls.

=head3 The C<pasttype> trait

Some operators have behavior that can be implemented by certain PAST
nodes. For instance, many languages define the semantics of the C<and>
operator to be the following:

 A and B

 1 evaluate A
 2 if result(1) is false return false
 3 evaluate B
 4 return result(3)

As soon as the result of A is found to be false, there is no need to
evaluate B, as the final result can never be true (as this is the C<and>
operator). So, C<B> is evaluated only if C<A> is true.

This is very similar to the PAST::Op node with the C<if> C<:pasttype>:

 if (A) {
   B
 }

Therefore, an operator such as C<and> can be implemented as an C<if>
statement. In order to specify that the C<and> operator must be handled
as a PAST::Op( :pasttype('if') ) node, you can use the C<pasttype> trait,
like so:

 proto 'infix:and' ... is pasttype('if') { ... }

The C<or> operator is similar to the semantics of a
PAST::Op( :pasttype('unless') node:

 A or B

 1 evaluate A
 2 if result(1) is true return true
 3 evaluate B
 4 return result(3)

So, C<unless> A is true, evaluate B. Hence, the C<or> operator could
be implemented like so:

 proto 'infix:or' ... is pasttype('unless') { ... }

=head3 Special characters

Some operators, such as the shift operators contain the "<" or ">" character.
As operators can be specified as, for instance, infix:<+>, defining an operator
such as "<<" will make the rule parser (the parser generator) confused.

Therefore, use so-called French quotes to do this. This looks as follows:

 proto infix:«>>»  is equiv(infix:«<<») { ... }


=head1 FAQ

=over 4

=item * Why are some operators quoted and some not?

=item * I get an error message saying: XXX

=item * How many operator tables can I use in my language?

{{ I think one only? }}

=back

=head1 SEE ALSO

=over 4

=item * L<docs\pct\gettingstarted.pod>

=item * L<docs\pct\past_building_blocks.pod>

=back

=cut
