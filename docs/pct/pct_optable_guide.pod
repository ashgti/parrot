# Copyright (C) 2008, The Perl Foundation.
# $Id$

=head1 NAME

pct_optable_guide.pod - A Guide to Using an Operator Parsing Table in PGE-based grammars.

=head1 DESCRIPTION

This document describes how to use an operator parsing table in grammars
written for the Parrot Grammar Engine.

=head1 WHY AN OPTABLE?

{{explain why you should want that}}

=head1 HOW DOES AN OPTABLE WORK?

{{explain how this works}}

=head1 HOW TO USE AN OPTABLE?

Perl 6 rules are run as ordinary subroutines, and parsing will be done
by invoking a rule's subrules. A subrule can also contain subrules.
Therefore, the generated parser is a top-down parser, starting at the
C<TOP> rule, and invoking rules that represent I<lower> parts of the
grammar.

=head2 Switching Top-down and Bottom-up parsing

An optable parses operators bottom-up, which is the other well-known
parsing approach, implemented popular parser generators such as Yacc.
At some point, when using an optable, your parser must switch from
top-down parsing to bottom-up, and after parsing the operators (and
related operands), the parser switches back from bottom-up to top-down
again.

{{explain a bit how to decide when to enter bottom-up parsing}}

{{explain how to decide what an operand is}}

In order to define the entry point of the bottom-up, operator parsing
table, you should define a rule. Below is an example that states that
an C<expression> is parsed by the operator parser:

 rule expression is optable { ... }

The C<...> indicates that this rule is a C<prototype>.

{{ explain what this is }}


In order to define what an operand is, a special rule is define, named
C<term:>.

{{ is this always called "term:" or can it be named anything? not sure }}

 proto 'term:' is precedence('=') is parsed(&simple_expression) { ... }

This rule states that whenever an operand is expected, it is parsed by
the rule named C<simple_expression>. In other words, this is the point
where the parser switches back from bottom-up to top-down.

=head2 Defining operators

In between these two rules defining the entry point and the I<exit> point
of the operator parser, operators are declared, along with their
precedence. This typically look as follows:

 proto 'infix:+' is looser('term:') { ... }

This defines the symbol C<+> as an C<infix> operator.

{{ how to express "looser"/"tighter" in words }}

=head3 Operator precedence

Operator precedence can be expressed using the following {{ ehm. what are they called? }}

=over 4

=item * looser

=item * equal

=item * tighter

=back

=head3 Where's the operator?

When operators such as C<infix:+> are defined, the bottom-up parser will
generate a C<call> instruction to a subroutine with the same name, that is,
C<infix:+>. Therefore, you need to write a subroutine for each operator
you define. The subroutine for the C<infix:+> operator could look like this:

 .sub 'infix:+'
    .param pmc a      # left operand
    .param pmc b      # right operand
    n_add $P0, a, b   # create a new PMC object with the value a+b
    .return ($P0)
 .end

Whenever an expression such as C<42 + 1> is parsed, this will result in a
call to C<infix:+> with the operands C<42> and C<1>. The C<infix:+> sub
will create a new object, and assign the result of C<42 + 1> to it, after
which this new object is returned. Note that the C<n_> prefix of the C<add>
instruction implies that a new object is created.

You might think that it's somewhat overkill to write and call a subroutine
for such a simple operation, and that this could be done simpler. Well,
you're right. If the implementation of the C<+> operator is as simple as
in this case, there's a simpler way to implement the exact same behavior.
This can be accomplished using a the C<pirop> trait, discussed below.

=head3 Infix, prefix, postfix

{{ explain that any word after a "***ix:" can be an operator, for instance
   "infix:defined" }}

=head3 Ternary operators

Most languages only have one ternary operator: C<? :>. An example is shown
below:

 $income > 100000 ? print("I'm rich!") : print("I'll keep my job for now")

To declare a ternary operator, you write:

 proto ternary:<? :> is looser('infix:+') { ... }

{{ note about automatically knowing about ? and : as two separate tokens }}

=head3 The C<assoc> trait

=head3 The C<pirop> trait

{{ make a note about "iseq" not working due to PCT not using $I0 registers }}

=head3 The C<pasttype> trait

{{ implement "and" with pasttype('if') and "or" with pasttype('unless') }}

=head3 Special characters

{{ french quotes for << and such }}


=head1 FAQ

=over 4

=item * Why are some operators quoted and some not?

=item * I get an error message saying: XXX

=item * How many operator tables can I use in my language?

{{ I think one only? }}

=back

=head1 SEE ALSO

=over 4

=item * L<docs\pct\gettingstarted.pod>

=item * L<docs\pct\past_building_blocks.pod>

=back

=cut
