# Copyright (C) 2008, The Perl Foundation.
# $Id$

=head1 NAME

pct_optable_guide.pod - A Guide to Using an Operator Parsing Table in PGE-based grammars.

=head1 DESCRIPTION

This document describes how to use an operator parsing table in grammars
written for the Parrot Grammar Engine.

=head1 WHY AN OPTABLE?

{{explain why you should want that}}

=head1 HOW DOES AN OPTABLE WORK?

{{explain how this works}}

=head1 HOW TO USE AN OPTABLE?

Perl 6 rules are run as ordinary subroutines, and parsing will be done
by invoking a rule's subrules. A subrule can also contain subrules.
Therefore, the generated parser is a top-down parser, starting at the
C<TOP> rule, and invoking rules that represent I<lower> parts of the
grammar.

=head2 Switching Top-down and Bottom-up parsing

An optable parses operators bottom-up, which is the other well-known
parsing approach, implemented popular parser generators such as Yacc.
At some point, when using an optable, your parser must switch from
top-down parsing to bottom-up, and after parsing the operators (and
related operands), the parser switches back from bottom-up to top-down
again.

{{explain a bit how to decide when to enter bottom-up parsing}}

{{explain how to decide what an operand is}}

In order to define the entry point of the bottom-up, operator parsing
table, you should define a rule. Below is an example that states that
an C<expression> is parsed by the operator parser:

 rule expression is optable { ... }

The C<...> indicates that this rule is a C<prototype>.

{{ explain what this is }}


In order to define what an operand is, a special rule is define, named
C<term:>.

{{ is this always called "term:" or can it be named anything? not sure }}

 proto 'term:' is precedence('=') is parsed(&simple_expression) { ... }

This rule states that whenever an operand is expected, it is parsed by
the rule named C<simple_expression>. In other words, this is the point
where the parser switches back from bottom-up to top-down.

=head2 Defining operators

In between these two rules defining the entry point and the I<exit> point
of the operator parser, operators are declared, along with their
precedence. This typically look as follows:

 proto 'infix:+' is looser('term:') { ... }

This defines the symbol C<+> as an C<infix> operator.

{{ how to express "looser"/"tighter" in words }}

=head3 Infix, prefix, postfix

=head3 Ternary operators

=head3 The C<assoc> trait

=head3 The C<pirop> trait

=head3 The C<pasttype> trait

=head3 Special characters

{{ french quotes for << and such }}

=cut
