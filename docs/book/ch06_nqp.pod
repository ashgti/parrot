=pod

=head1 Grammar Actions

Protofunction signatures aren't the only way to apply functions to rules
matched by a parser.  They may be the most primitive way to do so, at least if
you write them in PIR.  There's an easier way to write rules: in a language
that's almost, but Not Quite Perl.

X<NQP>
X<Not Quite Perl>
NQP (Not Quite Perl) is a small language which offers a subset of Perl 6's
syntax and semantics. Though it originated as a bootstrapping tool for the
Rakudo Perl 6 compiler, several other Parrot-based compilers use it.  It has
become a permanent member of PCT.

NQP contains the smallest subset of the Perl 6 language necessary to implement
parser transformations, plus a few syntactic convenience features. NQP's Perl 6
subset shows its Perl 5 roots, so existing Perl 5 programmers should find much
of it familiar.

=head2 NQP Basics

=for author

This section is odd; it starts by telling how NQP doesn't work instead of
telling how it does.  Differences from Perl 5 may be more appropriate later.

=end for

X<sigils>
X<scalar>
Like all flavors and versions of Perl, NQP uses special prefix symbols called
I<sigils> to distinguish variable types. The C<$> sigil represents scalars,
C<@> arrays, and C<%> for hashes.  A scalar any single value which can
interchangeably contain given a string value, an integer value, or an object
reference. Simple NQP assignments are:

 $scalar := "This is a string"
 $x      := 123
 $pi     := 3.1415      # rounding

X<bind operator>
X<operators; binding>
X<=:>
This example shows the first divergence from familar Perl 5 syntax.  Why not
use the plain C<=> sign for assignment? I<NQP doesn't have it>.  The C<:=>, or
I<bind> operator, makes one value an alias for another. In most cases you can
ignore the distinction between the two, but it's not quite the same as regular
variable assignment.

=for author

What I<is> it then, and why is it here?

=end for

Hash and array assignment is easy in Perl 5 and other languages, but it's
different in NQP:

 @small_integers := (1, 2, 3, 4);                      # WRONG!
 %leading_ladies := ("Trillian" => "Hitchhikers Guide",
                     "Leia"     => "Star Wars");       # WRONG!

I<NQP doesn't have list or hash context!> To initialize a whole list at once,
write:

 @small_integers[0] := 1;
 @small_integers[1] := 2;
 # ... And so on, and so forth ...

=for author

What does this I<mean>?  Also, the example and its description conflate "list"
and "array", which is terribly confusing in Perl 5.

=end for

It's also possible to assign a list in I<scalar context>:

 $array_but_a_scalar := (1, 2, 3, 4)

Or you could write a new function in PIR to create a new array from a variadic
argument list:

 @my_array := create_new_array(1, 2, 3, 4)

... which calls the PIR function:

=begin PIR

 .namespace []

 .sub 'create_new_array'
     .param pmc elems :slurpy
     .return(elems)
 .end

=end PIR

=head3 Calling Actions From Rules

=for editor

Needs a link to that section.

=end for

As mentioned in the chapter on grammar rules, the funny little C<{*}> symbol
calls an action. The action in question is an NQP method with the same name as
the rule that calls it. NQP rules can have two different signatures:

 method name ($/)      { ... }
 method name($/, $key) { ... }

Where does the key come from?  Consider this grammar:

 rule cavepeople {
      'Fred'  {*}    #= Caveman
    | 'Wilma' {*}    #= Cavewoman
    | 'Dino'  {*}    #= Dinosaur
 }

The C<cavepeople> rule demonstrates the result:

 method cavepeople($/, $key) {
    if $key eq 'Caveman' {
        say "We've found a caveman!";
    } elsif $key eq 'Cavewoman' {
        say "We've found a cavewoman!";
    } elsif $key eq 'Dinosaur' {
        say "A dinosaur isn't a caveperson at all!";
    }
 }

The key is a string that contains whatever any text following the C<#=> symbol.
Without a C<#=> following the rule invocation, there's no C<$key> to use in the
method.  If you attempt to use one without the other, the NQP compiler will die
with error messages about mismatched argument/parameter numbers.

=head3 The Match Object C<$/>

X<match object>
X<$/>
The match object C<$/> it's a data structure that's all business: it's both a
hash and an array. Because it's a special variable used pervasively in PCT, it
has a special shortcut syntax:

 $/{'Match_item'}   is the same as $<Match_item>
 $/[0]              is the same as $[0]

Each key in the match object's hash is the name of a matched rule.  Given a
file containing "C<X + 5>" and a rule:

 rule introductions {
    <variable> <operator> <number>
 }

The resulting match object will contain the key/value pairs:

 "variable" => "x"
 "operator" => "+"
 "number"   => "5"

When the match contains multiple values with the same name, or when rules have
quantifiers such as C<*> or C<+>, the values in the hash may be arrays.  Given
the input "A A A B B" and the rule:

 rule letters {
    <vowel>* <consonant>*
 }

The match object will contain the pairs:

 "vowel"     => ["A", "A", "A"]
 "consonant" => ["B", "B"]

X<$( ) operator>

Use the C<$( )> operator to count the number of matches in each group (by
casting it to a scalar):

 $($<vowel>) == 3

=head3 Inline PIR

=for author

Needs expansion.

=end for

X<{{ }}>
X<double curly brackets>
Sometimes NQP isn't quite flexible enough to handle transforms appropriately.
In a PGE rule, the C<{{ }}> double curly brackets demarcate inline-PIR mode.
PGE will execute any PIR code in those brackets. You can access C<$/> directly
in the grammar without having to jump into NQP.

=head3 PAST Nodes

X<PAST>
X<PAST nodes>
NQP's job is to make abstract syntax trees.  These trees are all objects -- and
as such, instances of PAST nodes.  Each PAST class represents a unique program
construct.  These constructs are common and simple, but combine to represent
complicated programming structures.

=head3 Making Trees

Every action has the ability to create a PAST node that represents that action,
as well as any children of that node. Calling C<make> on that node adds it into
the growing PAST tree that PCT maintains. Once the C<TOP> rule matches
successfully and returns, PCT optimizes and converts that tree into PIR and PBC
for execution.

=cut

# Local variables:
#   c-file-style: "parrot"
# End:
# vim: expandtab shiftwidth=4:
