=pod

=head1 Parrot Assembly Language

Z<CHP-9>

X<Parrot Assembly Language;;(see PASM)>
X<PASM (Parrot assembly language)>
PIR is the intermediate language that's used most often for implementing
libraries in Parrot, NQP is used for writing grammar actions for
high-level language compilers, PGE is used for specifying grammar rules,
and various high-level languages that target Parrot are used for most
other programming tasks. These options, though many and versatile, are
not the only ways to interface with Parrot.

Like PIR, Parrot Assembly Language (PASM) is a low-level language native
to the virtual machine. PASM is a pure assembly language, with none of
the syntactic sugar that makes PIR friendly for library development.

Its primary purpose is to act as a plain English reprepresention of the
bytecode format. In regular assemblers, assembly language mnemonics
share a one-to-one correspondence with the underlying machine code words
that they represent. A simple assembler (and, for that matter, a simple
disassembler) could be implemented as a mere lookup table.  PASM
instructions share a one-to-one correspondence to the underlying
bytecode instructions, and for this reason PASM is used by the Parrot
disassembler instead of PIR.

PASM is used as a debugging tool more often than it is used to write
extensive libraries of code. PIR or a higher-level language are
recommended for most development tasks.

X<.pasm extension>
PASM files use the F<.pasm> file extension. Parrot also has a C<-a>
command-line option to tell it to treat a file as PASM code even if it
doesn't have a F<.pasm> extension.

=head2 Basics

Z<CHP-9-SECT-2>

X<PASM (Parrot assembly language);overview>
PASM has a simple syntax that will be familiar to people who have experience
programming other assembly languages. Each statement stands on its own line
and there is no end-of-line delimiter. Statements begin with a Parrot
instruction, commonly referred to as an "opcode"N<More accurately, it should
probably be referred to as a "mnemonic">. The arguments follow, separated by
commas:

  [label] opcode dest, source, source ...

If the opcode returns a result, it is stored in the first argument.
Sometimes the first register is both a source value and the
destination of the result, this is the case when we want to modify a
value in place, without consuming a new Parrot register to hold the
value. The arguments can be either registers or constants, although the
destination argument cannot be constant.

=begin PASM

  LABEL:
      print "The answer is: "
      print 42
      print "\n"
      end                # halt the interpreter

=end PASM

X<PASM (Parrot assembly language);labels>
A label names a line of code so other instructions can refer to it.
Label names consist of letters, numbers, and underscores, exactly the
same syntax as is used for labels in PIR. Simple labels are often all
capital letters to make them stand out from the rest of the source code
more clearly. This is just a common convention and is not a rule. A label
can be in front of a line of code, or it can be on it's own line. Keeping
labels separate is usually recommended for readability, but again this is
just a suggestion and not a rule.

=begin PASM

  LABEL:
      print "Norwegian Blue\n"

=end PASM

=begin PASM

  LABEL: print "Norwegian Blue\n"

=end PASM

X<PASM (Parrot assembly language);comments>
POD (plain old documentation) is also allowed in PASM like it is in PIR.
An equals sign in the first column marks the start of a POD block, and
a C<=cut> marker signals the end of a POD block.

=begin PASM

  =head2

  This is POD documentation, and is treated like a
  comment. The PASM interpreter ignores this.

  =cut

  end

=end PASM

Besides POD, there are also ordinary 1-line comments using the # sign,
which is the same in PIR:

=begin PASM

  LABEL:                        # This is a comment
    print "Norwegian Blue\n"    # Print a color name

=end PASM


=head3 Working with Registers

Z<CHP-9-SECT-2.2>

X<PASM (Parrot assembly language);registers>
X<registers;Parrot;;(see PASM, registers)>
Parrot is a register-based virtual machine. It has 4 typed register
sets: integers, floating-point numbers, strings, and polymorphic container
objects called PMCs. Register names consist of a capital letter indicating
the register set type and the number of the register. Register numbers are
non-negative (zero and positive numbers), and do not have a pre-defined
upper limit N<At least not a restrictive limit. Parrot registers are stored
internally as an array. More registers means a larger allocated array, which
can bring penalties on some systems>. For example:

  I0   integer register #0
  N11  number or floating point register #11
  S2   string register #2
  P33  PMC register #33

We see the immediate difference here that PASM registers do not have the
C<$> dollar sign in front of them like PIR registers do. The syntactical
difference indicates that there is an underlying semantic difference:
In PIR, register numbers are just suggestions and registers are automatically
allocated; In PASM, register numbers are literal offsets into the register
array, and registers are not automatically managed. Let's take a look at a
simple PIR function:

=begin PIR

  .sub 'foo'
      $I33 = 1
  .end

=end PIR

This function allocates only one register. The register allocator counts that
there is only one register needed, and converts C<$I33> to C<I0> internally.
Now, let's look at a similar PASM subroutine:

=begin PASM

  foo:
      set I33, 1
  end

=end PASM

This function, which looks to perform the same simple operation actually is
a little different. This small snippet of code actually allocates 33
registers, even though only one of them is needed N<The number 33 here was not
a random choice. To save on initial allocations Parrot automatically allocates
space for 32 registers of each type in each context. This might not always be
the case, but for now it is.>. In PASM mode it's up to the programmer to keep
track of memory usage and not allocate more registers then are needed.

=head4 Register assignment

Z<CHP-9-SECT-2.2.1>

X<PASM (Parrot assembly language);registers;assignment>
The most basic operation on registers is assignment using the C<set>
opcode:

=begin PASM

  set I0, 42        # set integer register #0 to the integer value 42
  set N3, 3.14159   # set number register #3 to an approximation of pi
  set I1, I0        # set register I1 to what I0 contains
  set I2, N3        # truncate the floating point number to an integer

=end PASM

In PIR code the set opcode is represented by the C<=> symbol to perform the
assignment. The C<exchange> opcode swaps the contents of two registers of the
same type:

=begin PASM

  exchange I1, I0   # set register I1 to what I0 contains
                    # and set register I0 to what I1 contains

=end PASM

PMC registers contain references to PMC structures internally. So, the set
opcode doesn't copy the entire PMC, it only copies the reference to the
PMC data. Here's an example that shows a side effect of this operation:

=begin PASM

  new P0, "String"
  set P0, "Ford"
  set P1, P0
  set P1, "Zaphod"
  print P0                # prints "Zaphod"
  print P1                # prints "Zaphod"
  end

=end PASM

In this example, both C<P0> and C<P1> are both references to the same
internal data structure, so when we set C<P1> to the string literal
C<"Zaphod">, it overwrites the previous value C<"Ford">. Now, both C<P0>
and C<P1> point to the String PMC C<"Zaphod">, even though it appears that
we only set one of those two registers to that value.

Strings in Parrot are also stored as references to internal data structures
like PMCs. However, strings use Copy-On-Write (COW) optimizations. When we
call C<set S1, S0> we copy the pointer only, so both registers point to the
same string memory. We don't actually make a copy of the string until one of
two registers is modified. Here's the same example using string registers
instead of PMC registers, which demonstrate how strings use COW:

=begin PASM

  set S0, "Ford"
  set S1, S0
  set S1, "Zaphod"
  print S0                # prints "Ford"
  print S1                # prints "Zaphod"
  end

=end PASM

Here, we can clearly see the opposite result from how PMCs were handled in
the previous example. Modifying one of the two registers causes a new string
to be created, preserving the old value in C<S0> and assigning the new value
to the new string in C<S1>. The benefits here are that we don't have to worry
about stray references causing side effects in our code, and we don't waste
time copying a string until it's actually time to make a copy. Some
developers have suggested that PMCs should also use COW semantics to help
optimize copy operations in PMCs too. However, the PMC system in Parrot isn't
yet mature enough to support these kinds of semantics. One day in the future,
Parrot might change this, but it hasn't changed yet.







=cut

# Local variables:
#   c-file-style: "parrot"
# End:
# vim: expandtab shiftwidth=4:
