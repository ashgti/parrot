=pod

=head1 Parrot Assembly Language

Z<CHP-9>

X<Parrot Assembly Language;;(see PASM)>
X<PASM (Parrot assembly language)>
PIR is the intermediate language that's used most often for implementing
libraries in Parrot, NQP is used for writing grammar actions for
high-level language compilers, PGE is used for specifying grammar rules,
and various high-level languages that target Parrot are used for most
other programming tasks. These options, though many and versatile, are
not the only ways to interface with Parrot.

Like PIR, Parrot Assembly Language (PASM) is a low-level language native
to the virtual machine. PASM is a pure assembly language, with none of
the syntactic sugar that makes PIR friendly for library development.

Its primary purpose is to act as a plain English reprepresention of the
bytecode format. In regular assemblers, assembly language mnemonics
share a one-to-one correspondence with the underlying machine code words
that they represent. A simple assembler (and, for that matter, a simple
disassembler) could be implemented as a mere lookup table.  PASM
instructions share a one-to-one correspondence to the underlying
bytecode instructions, and for this reason PASM is used by the Parrot
disassembler instead of PIR.

PASM is used as a debugging tool more often than it is used to write
extensive libraries of code. PIR or a higher-level language are
recommended for most development tasks.

X<.pasm extension>
PASM files use the F<.pasm> file extension. Parrot also has a C<-a>
command-line option to tell it to treat a file as PASM code even if it
doesn't have a F<.pasm> extension.

=head2 Basics

Z<CHP-9-SECT-2>

X<PASM (Parrot assembly language);overview>
PASM has a simple syntax that will be familiar to people who have experience
programming other assembly languages. Each statement stands on its own line
and there is no end-of-line delimiter. Statements begin with a Parrot
instruction, commonly referred to as an "opcode"N<More accurately, it should
probably be referred to as a "mnemonic">. The arguments follow, separated by
commas:

  [label] opcode dest, source, source ...

If the opcode returns a result, it is stored in the first argument.
Sometimes the first register is both a source value and the
destination of the result, this is the case when we want to modify a
value in place, without consuming a new Parrot register to hold the
value. The arguments can be either registers or constants, although the
destination argument cannot be constant.

=begin PASM

  LABEL:
      print "The answer is: "
      print 42
      print "\n"
      end                # halt the interpreter

=end PASM









=cut

# Local variables:
#   c-file-style: "parrot"
# End:
# vim: expandtab shiftwidth=4:
