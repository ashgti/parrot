
=head1 Implementing Variable Types with Vtables

This is a guide to creating your own PMC (Parrot Magic Cookie) classes;
it tells you what you need to write in order to add new variable types
to Parrot.

=head2 Overview

The guts of the Parrot interpreter are, by design, ignorant (or, if you
want to be less disparaging, agnostic) of the intricacies of variable
type behaviour. The standard example is the difference between Perl
scalars and Python scalars. In Perl, if you have

    $a = "1a";
    $a++;

you end up with C<$a> being C<1b>. This is a factor of the way Perl
scalars increment themselves. In Python, on the other hand, you'd get a
runtime error. 

=over 3

=item *

To be perfect honest, this is a slightly flawed example, since it's
unlikely that there will be a distinct "Python scalar" PMC class.
The Python compiler could well type-inference variables such that
C<a> would be a C<PythonString> and C<b> would be a C<PythonNumber>.
But the point remains - incrementing a C<PythonString> is very different
from incrementing a C<PerlScalar>

=back

Since the behaviour is a function of the "type" of the PMC, it's
natural to consider the various different types of PMC as classes
in an object-oriented system whereby the interpreter calls methods on
the individual PMC objects to manipulate them. So the example above
would translate to something like:

=over 3

=item 1.

Construct a new PMC in the PerlScalar class.

=item 2.

Call a method setting its string value to C<"a1">.

=item 3.

Call a method to tell it to increment itself.

=back

And if you replace PerlScalar with PythonString, you get different
behaviour but to the fundamental guts of the interpreter, the
instructions are the same. PMCs are an abstract virtual class; the
interpreter calls a method, the PMC object does the right thing, and the
interpreter shouldn't have to care particularly what that right thing
happens to be.

Hence, adding a new data type to Parrot is a question of providing
methods which implement that data type's expected behaviour. Let's
now look at how one is supposed to do this.

=head2 Starting out

If you're adding data types to the core of Parrot, (and you've
checked with Dan and/or Simon that you're supposed to be doing so)
you should be creating a file in the F<classes/> subdirectory; this is
where all the built-in PMC classes live. (And a good source of examples
to plunder even if you're not writing a core data type.)

You should almost always start by running F<genclass.pl> found in the
F<classes/> subdirectory to generate a skeleton for the class. Let's
generate a number type for the beautifully non-existant Fooby language:

    perl -I.. genclass.pl FoobyNumber > foobynumber.c

This will produce a C file with stubs for all the methods you need to
fill in; the final function in the file, C<Parrot_FoobyNumber_init>,
allows you to set up anything you need to set up, and creates the
vtable structure containing all the methods.

Now you'll have to do something a little different depending on whether
you're writing a built-in class or an extension class. If you're writing
a built-in class, then you'll see a reference to
C<enum_class_FoobyNumber> in the C<init> function. This is something
that you need to add to the C<enum> of built-in classes located in
F<pmc.h>. If you're not writing a built-in class, you need to change the
type of the C<init> function to return C<struct _vtable>, and then
return C<temp_base_vtable> instead of assigning to the
C<Parrot_base_vtables> array.

=head2 What You Can and Cannot Do

The usual way to continue from the F<genclass.pl>-generated skeleton
is to define a structure that will hook onto the C<data>, if your data
type needs to use that, and then also define some user-defined flags.

Flags are accessed by C<< pmc->flags >>, but a number of these flags
are reserved by Parrot internally. Hence, you should start your
user-defined flags from offset C<PMC_USER_FLAG>, like this:

    #define FOOBYNUMBER_IS_BIGNUM (1<<(PMC_USER_FLAG))
    #define FOOBYNUMBER_IS_BIGINT (1<<(PMC_USER_FLAG+1))
    ...

You're quite at liberty to make these two definitions in a separate
header file, but I find it more convenient to keep everything together
in F<foobynumber.c>.

You may also use the C<cache> union in the PMC structure to remove
some extraneous dereferences in your code if that would help. 

=head2 Multimethods

One slightly (potentially) tricky element of implementing vtables
is that several of the vtable functions have variant forms depending on
the type of data that they're being called with.

Typical vtable dispatch for these "multimethod" forms will look like
this:

        ($2->vtable->add[$3->vtable->num_type])(interpreter, $1, $2,$3);

And this is where the C<num_type>, C<float_type>, and C<string_type>
fields of the vtable structure fit in.

  int_type: 0, 1, 2, 3 for "same as you", native int, bigint, object
  float_type: 0, 1, 2, 3 for "same as you", native float, bigfloat, object
  num_type: 0, 1, 2, 3, 4, 5 for "same as you", native int, bigint, native float, bigfloat, object
  string_type: 0, 1, 2, 3, 4 for "same as you", native string, unicode, other, object


=head2 Methods you need to implement

