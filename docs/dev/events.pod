=head1 TITLE

events.c - design notes

=head1 VERSION

This document describes the current state, which might not be
the final implementation.

=head1 Overview

Parrot has to deal with asynchronous events (from timers, signals,
async IO, notifications, and so on). This document describes the
current implementation.

=head1 Prelims

As there is currently no good test if a threading library is included
at link time, I changed F<config/init/hints/linux.pl> to link against
F<pthread> and fake a B<PARROT_HAS_HEADER_LIB_PTHREAD> entry for
checking in F<src/events.c>.

=head1 DESCRIPTION

On construction of the first interpreter (that one with no
B<parent_interpreter>) an B<event_thread> is started, which manages
the static global B<event_queue>.

=head2 Events

Events can be basically kind of timed events (they are due after some
elapsed time) or they are not timed. For the former thers is one API
call: B<Parrot_new_timer_event>, used by the
F<dynoplibs/myops.ops>:B<alarm> opcode for testing.

=head2 The B<event_thread>

The B<event_thread> holds the B<event_queue> mutex first. When there
is no event entry in the B<event_queue>, the B<event_thread> waits on
the event condition until an event arrives. When there is an event
with a timed entry, a timed wait is performed. (Waiting on the
condition releases the mutex, so that other threads can insert events
into the B<event_queue>.)

When an event arrives (or the timeout was reached) the B<event_thread>
pops off all events and places the queue entries into the interpreters
B<task_queue>. This also enables event checking in the interpreters
run-core.

=head2 The interpreter event checking code

We cannot interrupt the interpreter at arbitrary points and run some
different code (e.g. a PASM subroutine handling timer events). So when
an event is put into the interpreters B<task_queue> the opcode
dispatch table for the interpreter is changed.

Plain function cores get a function table with all entries filled with
the B<check_events__> opcode. This opcode pops off and finally handles
the event. The same scheme works for the CGOTO core, where the address
table is replaced. The switched core does an explicit check if events
are to be handled.

Prederefed and especially the CGP core are not handled yet. The plan
is to replace backward branches (and invoke) in the opcode image, with
the B<check_events__> opcode.

After all events are poped off and handled, the opcode dispatch table
is restored to its original, and the B<check_events__> reexecutes the
same instruction again, which is now the real one and thus normal
execution flow continues.

This scheme has zero overhead in the absence of scheduled events for
all cores execept switched and JIT.

=head1 Missing

=over 4

=item Insert timed events accoring to their abstime

=item Reinsert repeated events

=item Synchronous event API

Sync events could be placed directly into the interpreters task queue.

=item Broadcast events

When there is no interpreter argument for an event, broadcast the event
to all running interpreters or depeding on the event type, only to the
first interpreter.

=item Async IO

That depends probably on the underlying OS, i.e. if it does async IO
or we have to do it.

=item timer.pmc

Remove time handling code, use events.

=item Handle event priorities

=item Signals

=item A lot more

=back

=head1 Author

Leopold Toetsch <lt@toetsch.at>

=cut

# vim: expandtab shiftwidth=2 tw=70:

