=pod

=head1 TITLE

Parrot Glossary

=head1 ID

$Id$

=head1 SUMMARY

Short descriptions of words you might need to know that show up in
parrot development.

=head1 GLOSSARY

=for comment
Please keep me alphabetical!

=head2 Continuations

Think of continuations as an execution "context". This context includes
everything local to that execution path, not just stack. It is a
snapshot in time (minus global variables). While it is similar to C's
setjmp/longjmp, longjmp'ing only works "down" the stack. Jumping "up"
the stack (ie back to a frame that has returned) is bad. Continuations
work either way. We can do 2 important things with continuations:

=over 4

=item 1

Create and pass a continuation object to a subroutine, which may
recursively pass that object up the call chain until, at some point,
the continuation can be called/executed to handle the final
computation or return value. This is pretty much tail recursion.

=item 2

Continuations can be taken at arbitrary call depth. This freezes the
call chain (context) at that point in time. If we save that
continuation object into a variable, later we can reinstate the
complete context by its "handle". This allows neat things like
backtracking that isn't easily done in conventional stacked languages,
such as C. Since continuations represent "branches" in context, it
requires using an environment that uses some combination of heap-based
stacks, stack trees and/or stack copying.

=back

It is common in a system that supports continuations to implement
co-routines on top of them.


A continuation is a sort of super closure. When you take a 
continuation, it makes a note of the current call stack and lexical 
scratchpads, along with the current location in the code. When you 
invoke a continuation, the system drops what it's doing and puts the 
call stack and scratchpads back, and jumps to the execution point you 
were at when the continuation was taken. It is, in effect, like you 
never left that point in your code.

Note that, like with closures, it only puts the *scratchpads* back in 
scope--it doesn't do anything with the values in the variables that 
are in those scratchpads.

=for author
Melvin Smith <mrjoltcola@mindspring.com>
Dan Sugalski <dan@sidhe.org>

=head2 Co-Routines 

Co-routines are virtually identical to normal subroutines, except
while subroutine's execute from start to finish, and return,
co-routines may suspend themselves, (or be suspended asynchronously if
the language permits) and resume later. We can implement things like
"factories" with co-routines. If the co-routine never returns, every
time we call it we "resume" the routine.

A co-routine is a subroutine that can stop in the middle, but that 
you can start back up later at the point you stopped. For example:

    sub sample : coroutine {
       print "A\n";
       yield;
       print "B\n";
       return;
    }

    sample();
    print "Foo!\n";
    sample();

will print

     A
     Foo!
     B

Basically the yield keyword says "Stop here, but the next time we're 
called pick up at the next statement." If you return from a 
coroutine, the next invocation starts back at the beginning. 
Coroutines remember all their state, local variables, and suchlike 
things.

=for author
Melvin Smith <mrjoltcola@mindspring.com>
Dan Sugalski <dan@sidhe.org>

=head2 COW

COW stands for Copy On Write. This is a pure speed-hack technique that
copies strings without actually copying the string data until it's
absolutely necessary.

If you have a string A, and make a copy of it to get string B, the two
strings should be identical, at least to start. With COW, they are,
because string A and string B aren't actually two separate
strings--they're the same string, marked COW. If either string A or
string B are changed, the system notes it and only at that point does
it make a copy of the string and change the copy.

If the program never actually makes a copy, something that's fairly
common, COW saves both memory and time. 

=head2 DOD

Dead Object Detection is the code that sweeps through all the objects,
variables, and whatnot inside of Parrot and decides which ones are in
use and which ones aren't. The ones that aren't in use are then freed
back for later reuse. (After they're destroyed, if active destruction
is warranted)

See also: GC

=head2 GC

Garbage Collection is when the interpreter sweeps through all the
active objects, variables, and structures, and marks the memory
they're using as in use, and all other memory is freed up for later
reuse. 

Garbage Collection and Dead Object Detection are separate in Parrot,
since we generally chew through memory segments faster than we chew
through objects. (This is a characteristic peculiar to Perl and other
languages that do string processing. Other languages chew through
objects faster than memory)

See also: DOD

=head2 PMC

PMC stands for Parrot Magic Cookie. (Or cracker, your choice) It's the 

=head2 Vtable

A table of operations attached to some data types, such as PMCs and
strings.  Vtables are used to avoid using switches or long if chains to
handle different data types.  They're similar to method calls, except
that their names are pre-selected.

=for author
From: "Brent Dax" <brentdax@cpan.org>

=head2 Warnock's Dillemma

The dillemma you face when posting a message to a public forum about
something and not even getting an acknowledgement of its
existence. This leaves you wondering if your problem is unimportant or
previously addressed, if everyone's waiting on someone else to answer
you,  or if maybe your mail never actually made it to anyone else in
the forum.

=head1 CORRECTIONS

Please send corrections to the perl6-internals mailing list.

=cut
