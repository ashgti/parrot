=pod

=head1 TITLE

Parrot Glossary

=head1 ID

$Id$

=head1 SUMMARY

Short descriptions of words you might need to know that show up in
parrot development.

=head1 GLOSSARY

=for comment
Please keep me alphabetical!

=head2 Continuations

Think of continuations as an execution "context". This context includes
everything local to that execution path, not just stack. It is a
snapshot in time (minus global variables). While it is similar to C's
setjmp/longjmp, longjmp'ing only works "down" the stack. Jumping "up"
the stack (ie back to a frame that has returned) is bad. Continuations
work either way. We can do 2 important things with continuations:

=over 4

=item 1

Create and pass a continuation object to a subroutine, which may
recursively pass that object up the call chain until, at some point,
the continuation can be called/executed to handle the final
computation or return value. This is pretty much tail recursion.

=item 2

Continuations can be taken at arbitrary call depth. This freezes the
call chain (context) at that point in time. If we save that
continuation object into a variable, later we can reinstate the
complete context by its "handle". This allows neat things like
backtracking that isn't easily done in conventional stacked languages,
such as C. Since continuations represent "branches" in context, it
requires using an environment that uses some combination of heap-based
stacks, stack trees and/or stack copying.

=back

It is common in a system that supports continuations to implement
co-routines on top of them.


A continuation is a sort of super closure. When you take a 
continuation, it makes a note of the current call stack and lexical 
scratchpads, along with the current location in the code. When you 
invoke a continuation, the system drops what it's doing and puts the 
call stack and scratchpads back, and jumps to the execution point you 
were at when the continuation was taken. It is, in effect, like you 
never left that point in your code.

Note that, like with closures, it only puts the *scratchpads* back in 
scope--it doesn't do anything with the values in the variables that 
are in those scratchpads.

=for author
Melvin Smith <mrjoltcola@mindspring.com>
Dan Sugalski <dan@sidhe.org>

=head2 Co-Routines 

Co-routines are virtually identical to normal subroutines, except
while subroutine's execute from start to finish, and return,
co-routines may suspend themselves, (or be suspended asynchronously if
the language permits) and resume later. We can implement things like
"factories" with co-routines. If the co-routine never returns, every
time we call it we "resume" the routine.

A co-routine is a subroutine that can stop in the middle, but that 
you can start back up later at the point you stopped. For example:

    sub sample : coroutine {
       print "A\n";
       yield;
       print "B\n";
       return;
    }

    sample();
    print "Foo!\n";
    sample();

will print

     A
     Foo!
     B

Basically the yield keyword says "Stop here, but the next time we're 
called pick up at the next statement." If you return from a 
coroutine, the next invocation starts back at the beginning. 
Coroutines remember all their state, local variables, and suchlike 
things.

=for author
Melvin Smith <mrjoltcola@mindspring.com>
Dan Sugalski <dan@sidhe.org>


=head2 Vtable

A table of operations attached to some data types, such as PMCs and
strings.  Vtables are used to avoid using switches or long if chains to
handle different data types.  They're similar to method calls, except
that their names are pre-selected.

=for author
From: "Brent Dax" <brentdax@cpan.org>

=head1 CORRECTIONS

Please send corrections to the perl6-internals mailing list.

=cut
