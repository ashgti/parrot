# Copyright (C) 2001-2007, The Perl Foundation.
# $Id$

=head1 NAME

docs/pdds/draft/pdd24_events.pod - Parrot Events

=head1 ABSTRACT

This document defines the requirements and implementation strategy for
Parrot's event subsystem.

=head1 VERSION

$Revision$

=head1 DESCRIPTION

=over 4

=item - Events are objects

=item - Events are typed

=item - Events can be fatal or non-fatal

=item - Event handlers are code objects

=item - Event handlers can be final or non-final

=back

=head1 DEFINITIONS

An event is a notification that something has happened: the user has
manipulated a GUI element, an I/O request has completed, a signal has
been triggered, or a timer has expired.  Most systems these days have an
event handler (often two or three, which is something of a problem),
because handling events is so fundamental to modern GUI programming.

=head1 IMPLEMENTATION

Parrot's event handling system is integrated with the central concurrency
scheduler. When an event is created (by a GUI element, etc), it is added to
concurrency task list. By default, events have a higher priority in the task
list than asynchronous I/O operations or threaded code operations. At
predetermined points in the execution cycle (between low-level discrete
operations for safety, behind the scenes during "blocking" operations, at the
same operational lulls where GC runs are performed, etc), the task list is
queried, and tasks are dispatched.  Events are dispatched to event handlers.

Event handlers are registered with the concurrency scheduler. When dispatching
an event, the concurrency scheduler compares the type of the event to the type
of the event handler and selects the closest match. An exact type match is
always highest ranked, then a parent type, and finally a general handler
designed to handle all types. (A parent type may be something like a category
"key press" as a parent type to "key 'a' press".)

In the simple case, the concurrency scheduler runs within the single
interpreter thread. In more complex cases (particularly on multi-processor
machines), the concurrency scheduler runs in its own thread. In the
multi-threaded case, each individual thread may register an event handler with
the concurrency scheduler, and the event that matches the registered handler
will be dispatched to the thread that registered it. In the most complex case,
each thread runs a lightweight concurrency scheduler that coordinates with the
central scheduler (so, for example, the mini-scheduler can decide when to run
an event handler dispatched by the central scheduler).

An event handler may mark itself as a final event handler, removing the event
from the task list, or it may be a non-final handler, leaving the event in the
task list for another thread to collect.

Most events are non-fatal, so if a handler isn't found for them when they're
extracted from the task list, they just expire and drop out of the task list.
Events can also be fatal, in which case the interpreter will exit if a handler
isn't found (essentially the same effect as an exception). When a non-final
event handler leaves an event in the task list, it will expire if no further
relevant event handlers can be found for the event.

The operation to query the concurrency scheduler and find if it has any tasks
to process is as cheap as possible, so it may be queried at regular intervals.

=head2 Event API

An event is a PMC object that contains a type, data for the event, and a
priority.

The type of an event is only used to match the event with an event handler, but
is notionally similar to the class of an object.

The data for the event is a PMC and could be any data passed to the event
handler by the code that originates the event.

The priority of an event affects when it is processed by the task list. Higher
priority events are processed before lower priority events. Age is also a
relevant factor, when two events have the same priority, the older one is
processed first. An event handler or the scheduler may also be set to ignore
events below a certain threshold of priority. When the central scheduler
ignores an event because of its priority level, the event remains in the task
list until the priority threshold changes.

=head2 Event Handler API

An event handler contains a code object, as well as some meta information about
where it was registered. More specifically, it contains a continuation object,
capturing the full state of the interpreter where it was created. In many
cases, this has no more effect than guaranteeing that the event handler code
executes within the appropriate context of the thread that registered the
handler.

Because events are handled in mainline code, they don't have the restrictions
commonly associated with interrupt-level code. It's safe and acceptable for an
event handler to throw an exception, allocate memory, or manipulate thread or
global state safely. Event handlers can even acquire locks if they need to,
though it's not a good idea to have an event handler blocking on lock
acquisition.

=head2 Event Type Hierarchy

Parrot defines a core set of event types. Users may also define their own event
types.

=head2 Signals

Signals are a special form of event, based on the Unix signal mechanism.
Parrot presents them as mildly special, as a remnant of Perl's Unix
heritage, but under the hood they're not treated any differently from
any other event.

The Unix signaling mechanism is something of a mash, having been
extended and worked on over the years by a small legion of undergrad
programmers. At this point, signals can be divided into two
categories, those that are fatal, and those that aren't.

Fatal signals are things like 
SIGKILL, which unconditionally kills a process, or SIGSEGV, which
indicates that the process has tried to access memory that isn't part
of your process.  There's no good way for Parrot to catch these
signals, so they remain fatal and will kill your process.  On some
systems it's possible to catch some of the fatal signals, but
Parrot code itself operates at too high a level for a user program to
do anything with them--they must be handled with special-purpose code
written in C or some other low-level language.  Parrot itself may
catch them in special circumstances for its own use, but that's an
implementation detail that isn't exposed to a user program.

Non-fatal signals are things like SIGCHLD, indicating that a
child process has died, or SIGINT, indicating that the user
has hit C<^C> on the keyboard. Parrot turns these signals into events
and puts them in the event queue.  Your program's event handler for the
signal will be called as soon as Parrot gets to the event in the queue,
and your code can do what it needs to with it.

SIGALRM, the timer expiration signal, is treated specially by
Parrot. Generated by an expiring alarm() system call, this signal is
normally used to provide timeouts for system calls that would
otherwise block forever, which is very useful. The big downside to
this is that on most systems there can only be one outstanding
alarm() request, and while you can get around this somewhat with the
setitimer call (which allows up to three pending alarms) it's still
quite limited.

Since Parrot's IO system is fully asynchronous and never blocks--even
what looks like a blocking request still drains the event queue--the
alarm signal isn't needed for this. Parrot instead grabs SIGALRM for
its own use, and provides a fully generic timer system which allows
any number of timer events, each with their own callback functions
and private data, to be outstanding.

=head1 ATTACHMENTS

None.

=head1 FOOTNOTES

None.

=head1 REFERENCES

  src/events.c

  http://www.seas.upenn.edu/~lipeng/homepage/unify.html

=cut

__END__
Local Variables:
  fill-column:78
End:
