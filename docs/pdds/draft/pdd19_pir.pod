# Copyright (C) 2007, The Perl Foundation.

=head1 NAME

docs/pdds/pdd19_pir.pod - Parrot Intermediate Representation

=head1 ABSTRACT

This document describes PIR, a stable, middle-level language for both
compiler and human to target on.

=head1 VERSION

$Revision$

=head1 DESCRIPTION

This document is the Parrot Design Document for the Parrot Intermediate 
Representation (PIR).

=head1 Comments and empty lines

Comments start with B<#> and last until the following newline. These
and empty lines are ignored.

PIR allows POD blocks.

=head1 Statements

A valid PIR program consists of a sequence of I<statements>. A
I<statement> is terminated by a newline (<NL>). So, each statement has to be
on its own line.

=head2 General statement format

Any statement can start with a optional label and is terminated by a
newline:

  [label:] [instruction] <NL>

=head2 Labels

PIR code has both local and global labels. Global labels start with an
underscore, local labels shouldn't.  Optional label for the given
instruction, can stand on its own line. A label must conform to the syntax
of B<identifier> described below.

The name of a global label has to be unique, since it can be called at any
point in the program. A local label is accessible only in the compilation
unit where it's defined. A local label name must be unique within a
compilation unit, but it can be reused in other compilation units.

Examples:

  branch L1   # local label
  bsr    _L2  # global label

=head1 INSTRUCTIONS

=head2 Terms used here

=over 4

=item <identifier>

Identifiers start with a letter or underscore, then may contain additionally
letters, digits, underscores and B<::>. Identifiers don't have any limit on
length.

{{ REVIEW: identifier length limit }}

{{ REVIEW: can op-names be used as identifiers? See #24251. }}

Example:

    a
    _a
    A42
    a::b_c

=item <type>

Can be B<int>, B<float>, B<string> or B<pmc>.

{{ REFERENCE: RT#42769 }}

=item <reg>

A PASM register In, Sn, Nn, Pn, or a PIR temporary register $In, $Sn, $Nn,
$Pn, where B<n> consists of digit(s) only. B<n> must be between 1 and 99.

{{ REVIEW: n limit }}

=item <var>

A local B<identifier>, a B<reg> or a constant (when allowed). A constant
is not allowed on the left side of an assignment.

{{ REVIEW: any other places where constant is not allowed }}

=back

=head2 Constants

=over 4

=item 'char constant'

Are delimited by B<'>. They are taken to be C<ascii> encoded. No escape
sequences are processed.

=item "string constants"

Are delimited by B<">. A B<"> inside a string must be escaped by
B<\>.  Only 7-bit ASCII is accepted in string constants; to use
characters outside that range, specify an encoding in the way below.

=item <<"heredoc",  <<'heredoc'

Heredocs work like single or double quoted strings. All lines up to
the terminating delimiter are slurped into the string. The delimiter
has to be on its own line, at the beginning of the line and with no
trailing whitespace.

Assignment of a heredoc:

A heredoc as an argument:

  function(<<"END_OF_HERE", arg)
  ...
 END_OF_HERE

  .return(<<'EOS')
  ...
 EOS

  .yield(<<'EOS')
  ...
 EOS

Only one heredoc can be active per statement line.

{{ REVIEW: it would be useful to have multiple heredocs per statement,
   which allows for writing:

   function(<<'INPUT', <<'OUTPUT', 'some test')
   ...
 INPUT
   ...
 OUTPUT

}}

=item charset:"string constant"

Like above with a character set attached to the string. Valid character
sets are currently: C<ascii> (the default), C<binary>, C<unicode>
(with UTF-8 as the default encoding), and C<iso-8859-1>.

=back

=head2 String escape sequences

Inside double-quoted strings the following escape sequences are processed.

  \xhh        1..2 hex digits
  \ooo        1..3 oct digits
  \cX         control char X
  \x{h..h}    1..8 hex digits
  \uhhhh      4 hex digits
  \Uhhhhhhhh  8 hex digits
  \a, \b, \t, \n, \v, \f, \r, \e, \\

=over 4

=item encoding:charset:"string constant"

Like above with an extra encoding attached to the string. For example:

  set S0, utf8:unicode:"Â«"

The encoding and charset gets attached to the string, no further processing
is done, specifically escape sequences are not honored.

=item numeric constants

B<0x> and B<0b> denote hex and binary constants respectively.

=back

=head2 Directive instructions

=over 4

=item .pragma n_operators

Convert arithmethic infix operators to n_infix operations. The unary opcodes
C<abs>, C<not>, C<bnot>, C<bnots>, and C<neg> are also changed to use a B<n_>
prefix.

 .pragma n_operators 1
 .sub foo
   ...
   $P0 = $P1 + $P2           # n_add $P0, $P1, $P2
   $P2 = abs $P0             # n_abs $P2, $P0

=item .loadlib "lib_name"

Load the given library at B<compile time>, that is, as soon that line is
parsed.  See also the C<loadlib> opcode, which does the same at run time.

A library loaded this way is also available at runtime, as if it has been
loaded again in C<:load>, so there is no need to call C<loadlib> at runtime.

=item .HLL "hll_name", "hll_lib"

Define the HLL for the current file. If the string C<hll_lib> isn't empty
this B<compile time pragma> also loads the shared lib for the HLL, so that
integer type constants are working for creating new PMCs.

=item .HLL_map 'CoreType', 'UserType'

Whenever Parrot has to create PMCs inside C code on behalf of the running
user program it consults the current type mapping for the executing HLL
and creates a PMC of type I<'UserType'> instead of I<'CoreType'>, if such
a mapping is defined.

E.g. with this code snippet ...

  .loadlib 'dynlexpad'

  .HLL "Foo", ""
  .HLL_map 'LexPad', 'DynLexPad'

  .sub main :main
    ...

... all subroutines for language I<Foo> would use a dynamic lexpad pmc.

{{ PROPOSAL: stop using integer constants for types RT#45453 }}

=item .sub <identifier> [:<flag> ...]

Define a I<compilation unit> with the label B<identifier>. All code in a
PIR source file must be defined in a compilation unit. See
L<PIR Calling Conventions|imcc/calling_conventions> for available flags.
Optional flags are a list of B<flag>, separated by empty spaces, and empty
spaces only.

{{ PROPOSAL: remove the optional comma in flag list RT#45697 }}

Always paired with C<.end>.

=item .end

End a compilation unit. Always paired with C<.sub>.

=item .emit

Define a I<compilation unit> containing PASM code. Always paired with
C<.eom>.

=item .eom

End a I<compilation unit> containing PASM code. Always paired with
C<.emit>.

=item .local <type> <identifier> [:unique_reg]

Define a local name B<identifier> for this I<compilation unit> and of the
given B<type>. You can define multiple identifiers of the same type by
separating them with commas:

  .local int i, j

The optional C<:unique_reg> modifier will force the register allocator to
associate the identifier with a unique register for the duration of the
compilation unit.

=item .sym <type> <identifier> [:unique_reg]

Same as C<.local>.

{{ PROPOSAL: remove .sym, see RT#45405 }}

=item .lex <identifier>, <reg>

Declare a lexical variable that is an alias for a PMC register. The
PIR compiler calls this method in response to a .lex STRING, PREG
directive. For example, given this preamble:

    .lex "$a", $P0
    $P1 = new 'Integer'

    These two opcodes have an identical effect:

    $P0 = $P1
    store_lex "$a", $P1

    And these two opcodes also have an identical effect:

    $P1 = $P0
    $P1 = find_lex "$a"

=item .const <type> <identifier> = <const>

Define a constant named B<identifier> of type B<type> and assign value
B<const> to it.

=item .globalconst <type> <identifier> = <const>

As C<.const> above, but the defined constant is globally accessible.


=item .namespace <identifier>

Open a new scope block. This "namespace" is not the same as the
.namespace [ <identifier> ] syntax, which is used for storing subroutines
in a particular namespace in the global symbol table.
This directive is useful in cases such as (pseudocode):

  local x = 1;
  print(x);       # prints 1
  do              # open a new namespace/scope block
    local x = 2;  # this x hides the previous x
    print(x);     # prints 2
  end             # close the current namespace
  print(x);       # prints 1 again

All types of common language constructs such as if, for, while, repeat and such
that have nested scopes, can use this directive.

=item .endnamespace <identifier>

Closes the scope block that was opened with .namespace <identifier>.

=item .namespace [ <identifier> ; <identifier> ]

Defines the namespace from this point onwards.  By default the program is not
in any namespace.  If you specify more than one, separated by semicolons, it
creates nested namespaces, by storing the inner namespace object with a C<\0>
prefix in the outer namespace's global pad.

=item .pcc_*

Directives used for Parrot Calling Conventions. These are:

=over 4

=item .pcc_begin and .pcc_end

=item .pcc_begin_return and .pcc_end_return

=item .pcc_begin_yield and .pcc_end_yield

=item .pcc_call

=back

{{ REVIEW: Do we still want/need the "pcc_" prefix? See #45925. }}

=back

=head2 Directives for subroutine parameters and return

=over 4

=item .param <type> <identifier> [:<flag>]*

At the top of a subroutine, declare a local variable, in the manner
of B<.local>, into which parameter(s) of the current subroutine should
be stored. Available flags:
C<:slurpy>, C<:optional>, C<:opt_flag> and C<:unique_reg>.

=item .param <type> "<identifier>" => <identifier> [:<flag>]*

Define a named parameter. This is syntactic sugar for:

 .param <type> <identifier> :named("<identifier>")

=item .return <var> [:<flag> ...]

Between B<.pcc_begin_return> and B<.pcc_end_return>, specify one or
more of the return value(s) of the current subroutine.  Available
flags:
C<:flat>.

=back

=head2 Directives for making a PCC call

=over 4

=item .arg <var> [:<flag> ...]

Between B<.pcc_begin> and B<.pcc_call>, specify an argument to be
passed.  Available flags: C<:flat>.

=item .result <var> [:<flag> ...]

Between B<.pcc_call> and B<.pcc_end>, specify where one or more return
value(s) should be stored.  Available flags:
C<:slurpy>, C<:optional>, and C<:opt_flag>.

=back

=head2 Shorthand directives for PCC call and return

=over 4

=item ([<var1> [:<flag1> ...], ...]) = <var2>([<arg1> [:<flag2> ...], ...])

This is short for:

  .pcc_begin
  .pcc_arg <arg1> <flag2>
  ...
  .pcc_call <var2>
  .result <var1> <flag1>
  ...
  .pcc_end

=item <var> = <var>([arg [:<flag> ...], ...])

=item <var>([arg [:<flag> ...], ...])

=item <var>."_method"([arg [:<flag> ...], ...])

=item <var>._method([arg [:<flag> ...], ...])

Function or method call. These notations are shorthand for a longer
PCC function call with B<.pcc_*> directives. I<var> can denote a
global subroutine, a local B<identifier> or a B<reg>.

{{We should review the (currently inconsistent) specification of the
method name. Currently it can be a bare word, a quoted string or a
string register. See #45859.}}

=item .return ([<var> [:<flag> ...], ...])

Return from the current compilation unit with zero or more values.

The surrounded parentheses are mandatory. Besides making sequence
break more conspicuous, this is necessary to distinguish this syntax
from other uses of the B<.return> directive that will be probably
deprecated.

=item .return <var>(args)

=item .return <var>."somemethod"(args)

=item .return <var>.somemethod(args)

Tail call: call a function or method and return from the sub with the
function or method call return values.

Internally, the call stack doesn't increase because of a tail call, so
you can write recursive functions and not have stack overflows.

=back

=head2 Parameter Passing and Getting Flags

See L<PDD03|pdds/pdd03_calling_conventions.pod> for a description of
the meaning of the flag bits C<SLURPY>, C<OPTIONAL>, C<OPT_FLAG>,
and C<FLAT>, which correspond to the calling convention flags
C<:slurpy>, C<:optional>, C<:opt_flag>, and C<:flat>.

{{ TODO: once these flag bits are solidified by long-term use, then we
may choose to copy appropriate bits of the documentation to here. }}

=head2 Instructions

Instructions may be a valid PASM instruction or anything listed here
below:

=over 4

=item goto <identifier>

B<branch> to B<identifier> (label or subroutine name).

Examples:

  goto END

=item if <var> goto <identifier>

If B<var> evaluates as true, jump to the named B<identifier>. Translate to
B<if var, identifier>.

=item unless <var> goto <identifier>

Unless B<var> evaluates as true, jump to the named B<identifier>. Translate
to B<unless var, identifier>.

=item if null <var> goto <identifier>

If B<var> evaluates as null, jump to the named B<identifier>. Translate to
B<if_null var, identifier>.

=item unless null <var> goto <identifier>

Unless B<var> evaluates as null, jump to the named B<identifier>. Translate
to B<unless_null var, identifier>.

=item if <var1> <relop> <var2> goto <identifier>

The B<relop> can be: B<E<lt>, E<lt>=, ==, != E<gt>= E<gt>> which translate
to the PASM opcodes B<lt>, B<le>, B<eq>, B<ne>, B<ge> or B<gt>. If B<var1>
B<relop> B<var2> evaluates as true, jump to the named B<identifier>.

=item unless <var1> <relop> <var2> goto <identifier>

The B<relop> can be: B<E<lt>, E<lt>=, ==, != E<gt>= E<gt>> which translate
to the PASM opcodes B<lt>, B<le>, B<eq>, B<ne>, B<ge> or B<gt>. Unless B<var1>
B<relop> B<var2> evaluates as true, jump to the named B<identifier>.

=item <var1> = <var2>

Assign a value. Translates to B<set var1, var2>.

=item <var1> = <unary> <var2>

The B<unary>s B<!>, B<-> and B<~> generate B<not>, B<neg> and B<bnot> ops.

=item <var1> = <var2> <binary> <var3>

The B<binary>s B<+>, B<->, B<*>, B</>, B<%> and B<**> generate
B<add>, B<sub>, B<mul>, B<div>, B<mod> and B<pow> arithmetic ops.
B<binary> B<.> is B<concat> and only valid for string arguments.

B<E<lt>E<lt>> and B<E<gt>E<gt>> are arithmetic shifts B<shl> and B<shr>.
B<E<gt>E<gt>E<gt>> is the logical shift B<lsr>.

B<&&>, B<||> and B<~~> are logic B<and>, B<or> and B<xor>.

B<&>, B<|> and B<~> are binary B<band>, B<bor> and B<bxor>.

{{PROPOSAL: Change description to support logic operators (comparisons) as
implemented (and working) in imcc.y.}}

=item <var1> <op>= <var2>

This is equivalent to
B<E<lt>var1E<gt> = E<lt>var1E<gt> E<lt>opE<gt> E<lt>var2E<gt>>. Where
B<op> is called an assignment operator and can be any of the following
binary operators described earlier: B<+>, B<->, B<*>, B</>, B<%>, B<.>,
B<&>, B<|>, B<~>, B<E<lt>E<lt>>, B<E<gt>E<gt>> or B<E<gt>E<gt>E<gt>>.

=item <var> = <var> [ <var> ]

This generates either a keyed B<set> operation or B<substr var, var,
var, 1> for string arguments and an integer key.

=item <var> = <var> [ <key> ]

where C<key> is:

 <var1> .. <var2>

returns a slice defined starting at C<var1> and ending at C<var2>.

 .. <var2>

returns a slice starting at the first element, and ending at C<var2>.

 <var1> ..

returns a slice starting at C<var1> to the end of the array.

see src/pmc/slice.pmc
and t/pmc/slice.t.

=item <var> [ <var> ] = <var>

A keyed B<set> operation or the assign B<substr> op with a length of
1.

=item <var> = new '<type>'

Create a new PMC of type B<type> stored in B<var>. Translate to
B<new var, 'type'>.

=item <var1> = new '<type>', <var2>

Create a new PMC of type B<type> stored in B<var1> and using B<var2> as PMC
containing initialization data. Translate to B<new var1, 'type', var2>

=item <var1> = defined <var2>

Assign to B<var1> the value for definedness of B<var2>. Translate to
B<defined var1, var2>.

=item <var1> = defined <var2> [ <var3> ]

B<defined var1, var2[var3]> the keyed op.

=item global "string" = <var>

{{ DEPRECATED: op store_global was deprecated }}

=item <var> = global "string"

{{ DEPRECATED: op find_global was deprecated }}

=item <var1> = clone <var2>

Assing to B<var1> a clone of B<var2>. Translate to B<clone var1, var2>.

=item <var> = addr <identifier>

Assign to B<var> the address of label identified by B<identifier>. Translate
to B<set_addr var, var>.

=item <var> = null

Set B<var> to null. Translate to B<null <var>.

=item addr

Return the address of a label.

=back



=head1 MACRO LAYER

This section describes the macro layer of the PIR language.

=head3 Current Situation

The macro layer of the PIR compiler handles the following directives:

=over 4

=item * C<.include>

The C<.include> directive takes a string argument that contains the
name of the PIR file that is included.

=item * C<.macro>

The C<.macro> directive starts the definition of a macro.

=item * C<.constant>

The C<.constant> directive is a special type of macro; it allows the
user to use a symbolic name for a constant value or a register.

=back


=head3 Proposed Situation

The current macro layer has a few limitations. These are listed below.

=over 4

=item * Macro parameter list

If a macro defines no parameter list (not even the parentheses), then
the macro expansion should not specify any parenthesis. This means that
a macro defined as:

 .macro foo
 ...
 .endm

can only be expanded by writing C<.foo>. Writing C<.foo()> is an error.
If, however, the macro definition is written as:

 .macro foo()
 ...
 .endm

then writing C<.foo> is an error, and instead the user should write this
as C<.foo()>. On the one hand this behavior is consistent, but on the other
hand the error message is somewhat dubious; if the user writes C<.foo> when
the macro was defined as above (C<foo()>), then the error message indicates
that the macro needs 1 argument.

Some rationalization would be desirable.

=item * Heredoc arguments

Heredoc arguments are not allowed when expanding a macro. This means that
the following is not allowed:

   .macro foo(bar)
   ...
   .endm

   .foo(<<'EOS')
 This is a heredoc
    string.

 EOS

=item * Unique local variables

Within the macro body, the user can declare a unique label identifier using
the value of a macro parameter, like so:

  .macro foo(a)
  ...
 .label $a:
  ...
  .endm

Currently, IMCC still allows for writing C<.local> to declare a local label,
but that is deprecated. Use C<.label> instead.

However, it would be helpful if it were possible to declare unique local variables
as well. The syntax for this could be as follows:

  .macro foo(b)
  ...
  .local int $b
  ...
  .$b = 42
  print .$b # prints the value of the unique variable (42)
  print .b  # prints the name of the variable, which is the value
            # of parameter "b".
  ...
  .endm

So, the special C<$> character indicates whether the symbol is interpreted as just
the value of the parameter, or that the variable by that name is meant. Obviously,
the value of C<b> should be a string.

Defining a non-unique variable can still be done, using the normal syntax:

  .macro foo(b)
  .local int b
  .local int $b
  .endm

When invoking the macro C<foo> as follows:

  .foo("x")

there will be two variables: C<b> and C<x>. When the macro is invoked twice:

  .sub main
    .foo("x")
    .foo("y")
  .end

the resulting code that is given to the parser will read as follows:

  .sub main
    .local int b
	.local int x
	.local int b
	.local int y
  .end

Obviously, this will result in an error, as the variable C<b> is defined twice.
Of course, it would be a good idea to give the unique variable in the macro a
special prefix, like so:

    .local int local__foo__x

This allows for using multiple macros, like so:

  .macro foo(a)
  .local int $a
  .endm

  .macro bar(b)
  .local int $b
  .endm

  .sub main
    .foo("x")
	.bar("x")
  .end

This will result in code for the parser as follows:

  .sub main
    .local int local__foo__x
	.local int local__bar__x
  .end

An additional special character, not allowed for user-defined variables,
could be added to the generated name, so that a user-defined variable
cannot conflict (if the user were to declare a variable by name of
C<local__foo__x>.)

=back

=head2 Implementation

The macro layer is completely implemented in the lexical analysis phase.
The parser does not know anything about what happens in the lexical
analysis phase.

When the C<.include> directive is encountered, the specified file is opened
and the following tokens that are requested by the parser are read from
that file, instead of the original file that was given to the parser.

A macro expansion is a dot-prefixed identifier. For instance, if a macro
was defined as shown below:

 .macro foo(bar)
 ...
 .endm

this macro can be expanded by writing C<.foo(42)>. The body of the macro
will be inserted at the point where the macro expansion is written.

A C<.constant> expansion is more or less the same as a C<.macro> expansion,
except that a constant expansion cannot take any arguments, and it is only
allowed in PASM mode, or within a C<.emit> block.

{{ Is there any reason to not allow C<.constant> directives in PIR mode?
   (Except for the fact that we have C<.const> and C<.globalconst>) }}




=head1 QUESTIONS

=over 4

=item * morph

	<pmichaud>	I don't think that 'morph' as a method call is a good idea
	<pmichaud>	we need something that says "assign to value" versus "assign to container"
	<pmichaud>	we can't eliminate the existing 'morph' opcode until we have a replacement

=back

=head1 ATTACHMENTS

N/A

=head1 FOOTNOTES

N/A

=head1 REFERENCES

See C<docs/imcc/macros.pod>

=cut

__END__
Local Variables:
  fill-column:78
End:
