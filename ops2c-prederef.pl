#! /usr/bin/perl -w
#
# ops2c-prederef.pl
#
# Generate a C header and source file from the operation definitions in
# an .ops file.
#
# This variant produces opfuncs that expect the args to be predereferenced
# by the crystalizing loader and called from the crystalized runops.
#

use strict;
use Parrot::OpsFile;

sub Usage {
    print STDERR <<_EOF_;
usage: $0 input.ops [input2.ops ...]\n";
_EOF_
    exit 1;
}

#
# Process command-line argument:
#

Usage() unless @ARGV;

my $file = 'core.ops';

my $base = $file;
$base =~ s/\.ops$//;

my $incdir  = "include/parrot/oplib";
my $include = "parrot/oplib/${base}_ops_prederef.h";
my $header  = "include/$include";
my $source  = "${base}_ops_prederef.c";


#
# Read the input file:
#
$file = shift @ARGV;
die "$0: Could not read ops file '$file'!\n" unless -e $file;

my $ops = new Parrot::OpsFile $file;

for $file (@ARGV) {
    die "$0: Could not read ops file '$file'!\n" unless -e $file;
    my $temp_ops = new Parrot::OpsFile $file;
    for(@{$temp_ops->{OPS}}) {
       push @{$ops->{OPS}},$_;
    }
}
my $cur_code = 0;
for(@{$ops->{OPS}}) {
   $_->{CODE}=$cur_code++;
}

my $num_ops     = scalar $ops->ops;
my $num_entries = $num_ops + 1; # For trailing NULL


#
# Open the output files:
#

if (! -d $incdir) {
    mkdir($incdir, 0755) or die "ops2c.pl: Could not mkdir $incdir $!!\n";
}

open HEADER, ">$header"
  or die "ops2c.pl: Could not open header file '$header' for writing: $!!\n";

open SOURCE, ">$source"
  or die "ops2c.pl: Could not open source file '$source' for writing: $!!\n";


#
# Print the preamble for the HEADER and SOURCE files:
#

my $preamble = <<END_C;
/*
** !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
**
** This file is generated automatically from '$file'.
** Any changes made here will be lost!
*/


END_C

print HEADER $preamble;
print HEADER <<END_C;
#include "parrot/parrot.h"


extern INTVAL    ${base}_numops_prederef;

extern prederef_op_func_t ${base}_opfunc_prederef[$num_entries];
extern op_info_t ${base}_opinfo_prederef[$num_entries];

END_C

print SOURCE $preamble;
print SOURCE <<END_C;
#include "$include"

#define opcode_t void *
#define REL_PC ((size_t)(cur_opcode - interpreter->prederef_code))
#define CUR_OPCODE (((opcode_t *)interpreter->code->byte_code) + REL_PC)

END_C

print SOURCE $ops->preamble;


#
# Iterate over the ops, appending HEADER and SOURCE fragments:
#

my @op_funcs;
my @op_func_table;
my $index = 0;

foreach my $op ($ops->ops) {
    my $func_name  = $op->func_name . "_prederef";
    my $arg_types  = "void **, struct Parrot_Interp *";
    my $prototype  = "void ** $func_name ($arg_types)";
    my $args       = "void * cur_opcode[], struct Parrot_Interp * interpreter";
    my $definition = "void **\n$func_name ($args)";
    my $source     = $op->source(\&map_ret_abs, \&map_ret_rel, \&map_arg, \&map_res_abs, \&map_res_rel);

    print HEADER "$prototype;\n";

    push @op_func_table, sprintf("  %-50s /* %6ld */\n", "$func_name,", $index++);
    push @op_funcs, "$definition {\n$source}\n\n";
}

print SOURCE <<END_C;

/*
** Op Function Definitions:
*/

END_C

print SOURCE @op_funcs;


print SOURCE <<END_C;

INTVAL ${base}_numops_prederef = $num_ops;

/*
** Op Function Table:
*/

prederef_op_func_t ${base}_opfunc_prederef[$num_entries] = {
END_C

print SOURCE @op_func_table;

#
# Finish the SOURCE file's array initializer:
#

print SOURCE <<END_C;
  NULL
};

END_C

#
# Op Info Table:
#

print SOURCE <<END_C;

/*
** Op Info Table:
*/

op_info_t ${base}_opinfo_prederef[$num_entries] = {
END_C

$index = 0;

foreach my $op ($ops->ops) {
    my $type       = sprintf("PARROT_%s_OP", uc $op->type);
    my $name       = $op->name;
    my $full_name  = $op->full_name;
    my $func_name  = $op->func_name;
    my $body       = $op->body;
    my $arg_count  = $op->size;
    my $arg_types  = "{ " . join(", ", map { sprintf("PARROT_ARG_%s", uc $_) } $op->arg_types) . " }";

    print SOURCE <<END_C;
  { /* $index */
    $type,
    "$name",
    "$full_name",
    "$func_name",
    "", /* TODO: Put the body here */
    $arg_count,
    $arg_types
  },
END_C

  $index++;
}

print SOURCE <<END_C;
};

END_C

exit 0;


#
# map_ret_abs()
#

sub map_ret_abs
{
  my ($addr) = @_;
  return "return $addr";
}


#
# map_ret_rel()
#

sub map_ret_rel
{
  my ($offset) = @_;
  return "return cur_opcode + $offset";
}


#
# map_arg()
#

sub map_arg
{
  my ($type, $num, $self) = @_;

  my %arg_maps = (
    'op' => "cur_opcode[%ld]",

    'i'  => "(*(INTVAL *)cur_opcode[%ld])",
    'n'  => "(*(FLOATVAL *)cur_opcode[%ld])",
    'p'  => "(*(PMC **)cur_opcode[%ld])",
    's'  => "(*(STRING **)cur_opcode[%ld])",

    'ic' => "(*(INTVAL *)&cur_opcode[%ld])",
    'nc' => "(*(FLOATVAL *)cur_opcode[%ld])",
    'pc' => "%ld /* ERROR: Don't know how to handle PMC constants yet! */",
    'sc' => "(*(STRING **)cur_opcode[%ld])",
  );

  die "Unrecognized type '$type' for num '$num' in opcode @{[$self->full_name]}" unless exists $arg_maps{$type};

  return sprintf($arg_maps{$type}, $num);
}


#
# map_res_rel()
#

sub map_res_rel
{
  my ($offset) = @_;
  return "interpreter->resume_offset = REL_PC + $offset; interpreter->resume_flag = 1";
}


#
# map_res_abs()
#

sub map_res_abs
{
  my ($addr) = @_;
  return "interpreter->resume_offset = $addr; interpreter->resume_flag = 1";
}


