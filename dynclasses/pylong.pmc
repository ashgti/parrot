/*
Copyright: 2004 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/pylong.pmc - Python BigInt PMC class

=head1 DESCRIPTION

C<PyLong> provides arbitray precision integer mathematic functions.

=head2 Functions

=over 4

=item C<static void bigint_set_long(Interp*, PMC*, long value)>

=item C<static void bigint_set_double(Interp*, PMC*, double value)>

=cut

*/

#include "parrot/parrot.h"

/* cache of classes referenced */
static INTVAL dynclass_PyInt;
static INTVAL dynclass_PyLong;

pmclass PyLong extends BigInt dynpmc group python_group {

/*

=item C<void class_init()>

Class initialization. Caches the type id of various PMCs because
they will be used frequently here.

=cut

*/

    void class_init() {
        if (pass) {
            dynclass_PyInt     = Parrot_PMC_typenum(INTERP, "PyInt");
            dynclass_PyLong    = Parrot_PMC_typenum(INTERP, "PyLong");
        }
    }

/*

=item C<PMC* "__new__"(PMC *class, PMC *value, PMC *base)>

Create a new long.

=cut

*/

    METHOD PMC* __new__(PMC *class, PMC *value, PMC *base) {
        INTVAL argc = REG_INT(3);

        PMC * ret = pmc_new(INTERP, dynclass_PyLong);

        if (argc > 1) {
            if (value->vtable->base_type == dynclass_PyInt) {
                INTVAL ivalue = VTABLE_get_integer(INTERP, value);
                VTABLE_set_integer_native(INTERP, ret, ivalue);
            }
            else {
                STRING *svalue = VTABLE_get_string(INTERP, value);
                if (argc < 3)
                    VTABLE_set_string_native(INTERP, ret, svalue);
                else {
                    INTVAL key = VTABLE_get_integer(INTERP, base);
                    VTABLE_set_string_keyed_int(INTERP, ret, key, svalue);
                }
            }
        }

        return ret;
    }

/*

=item C<void add(PMC *value, PMC *dest)>

Add C<*value> to the integer and returns the result in C<*dest>.

=cut

*/

    void add (PMC* value, PMC* dest) {
MMD_PyInt: {
            INTVAL vali = VTABLE_get_integer(INTERP, value);
            mmd_dispatch_v_pip(INTERP, SELF, vali, dest, MMD_ADD_INT);
        }
    }

/*

=item C<void morph(INTVAL type)>

Morphs the scalar to the specified type.

=cut

*/

    void morph (INTVAL type) {
        if (type == enum_class_Integer) type = dynclass_PyInt;
        pmc_reuse(INTERP, SELF, type, 0);
    }

/*

=item C<void multiply(PMC *value, PMC *dest)>

Multiplies C<*value> with the integer and returns the result in C<*dest>.

=cut

*/

    void multiply (PMC* value, PMC* dest) {
MMD_PyInt: {
            INTVAL vali = VTABLE_get_integer(INTERP, value);
            mmd_dispatch_v_pip(INTERP, SELF, vali, dest, MMD_MULTIPLY_INT);
        }
    }

/*

=item C<INTVAL hash()>

Returns a unique hash for this value

=cut

*/

    INTVAL hash () {
        return VTABLE_get_integer(INTERP, SELF);
    }

}

/*

=back

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
