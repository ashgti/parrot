/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/pyfunc.pmc - Python Function

=head1 DESCRIPTION

This class implements a Python Function, i.e. a Parrot Closure.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

static INTVAL dynclass_PyList;
static INTVAL dynclass_PyTuple;
static STRING *FUNC_ARGS;
static STRING *FUNC_DEFAULTS;
static STRING *FUNC_VARARGS;
static STRING *__CALL__;

pmclass PyFunc extends Closure dynpmc group python_group {

/*

=item C<void class_init()>

Class initialization. Caches the type id of various PMCs because
they will be used frequently here.

=cut

*/

    void class_init() {
        if (pass) {
            dynclass_PyList = Parrot_PMC_typenum(INTERP, "PyList");
            dynclass_PyTuple = Parrot_PMC_typenum(INTERP, "PyTuple");
            FUNC_ARGS = const_string(INTERP, "func_args");
            FUNC_VARARGS = const_string(INTERP, "func_varargs");
            FUNC_DEFAULTS = const_string(INTERP, "func_defaults");
            __CALL__ = const_string(INTERP, "__call__");
        }
    }


/*

=item C<void init()>

Create an (empty) list of function arguments

=cut

*/

    void init () {
        PMC *func_args;
        SUPER();
        func_args = pmc_new(INTERP, dynclass_PyList);
        VTABLE_setprop(INTERP, SELF, FUNC_ARGS, func_args);
    }

/*

=item C<PMC *find_method(STRING *method_name)>

Impliement __call__ methods by redirecting to one's self, after having
resolved all of the parameters into a single positional list.  Note:
at this time, functions with a maximum of 11 arguments are supported.

TODO: error checking (e.g., missing, duplicate or extra arguments)

=cut

*/

    PMC* find_method(STRING* method_name) {
        if (0 == string_compare(INTERP, method_name, __CALL__)) {
            PMC *args = REG_PMC(5);
            PMC *keywords = REG_PMC(6);
            PMC *func_args = VTABLE_getprop(INTERP, SELF, FUNC_ARGS);
            PMC *func_defaults = VTABLE_getprop(INTERP, SELF, FUNC_DEFAULTS);
            INTVAL j;

            INTVAL n = VTABLE_elements(INTERP, func_args);
            REG_INT(3) = n;

            /* fill in defaults */
            if (func_defaults && VTABLE_defined(INTERP, func_defaults)) {
                INTVAL nd = VTABLE_elements(INTERP, func_defaults);
                for (j=n-nd; j<n && j<11; j++) {
                    REG_PMC(5+j) = VTABLE_get_pmc_keyed_int(INTERP,
                        func_defaults, j+nd-n);
                }
            }

            /* fill in positional arguments */
            if (VTABLE_get_bool(INTERP, args)) {
                INTVAL np = VTABLE_elements(INTERP, args);
                for (j=0; j<np && j<11; j++) {
                    REG_PMC(5+j) = VTABLE_get_pmc_keyed_int(INTERP, args, j);
                }
            }

            /* fill in keyword arguments */
            if (VTABLE_get_bool(INTERP, keywords)) {
                for (j=0; j<n && j<11; j++) {
                    PMC *name = VTABLE_get_pmc_keyed_int(INTERP, func_args, j);
                    if (VTABLE_exists_keyed(INTERP, keywords, name)) {
                        REG_PMC(5+j) =
                            VTABLE_get_pmc_keyed(INTERP, keywords, name);
                    }
                }
            }

            return SELF;
        }

        return SUPER(method_name);
    }

/*

=item C<void* invoke(void* next)>

Invoke a function.  Defaults are filled in first.

=cut

*/

    void* invoke(void* next) {
        PMC *func_args = VTABLE_getprop(INTERP, SELF, FUNC_ARGS);
        PMC *func_varargs = VTABLE_getprop(INTERP, SELF, FUNC_VARARGS);
        INTVAL n = VTABLE_elements(INTERP, func_args);
        INTVAL j;

        if (n > REG_INT(3)) {
            PMC *func_defaults = VTABLE_getprop(INTERP,SELF,FUNC_DEFAULTS);

            if (func_defaults && VTABLE_defined(INTERP, func_defaults)) {
                INTVAL nd = VTABLE_elements(INTERP, func_defaults);
                for (j=n-nd; j<n && j<11; j++) {
                    if (j >= REG_INT(3)) {
                        REG_PMC(5+j) = VTABLE_get_pmc_keyed_int(INTERP, 
                            func_defaults, j+nd-n);
                    }
                }

                REG_INT(3) = n;
            }
        }

        if (func_varargs && VTABLE_defined(INTERP, func_varargs)) {
            PMC *varargs = pmc_new(INTERP, dynclass_PyTuple);
            VTABLE_set_integer_native(INTERP, varargs, REG_INT(3)+1-n);
            for (j=n-1; j<REG_INT(3) && j<11; j++) {
                VTABLE_set_pmc_keyed_int(INTERP,varargs,j+1-n,REG_PMC(5+j));
            }

            if (n<11) {
                REG_PMC(5+n-1) = varargs;
                REG_INT(3) = n;
            }
        }

        return SUPER(next);
    }

/*

=item C<void set_integer_keyed_int(INTVAL key, INTVAL* value)>

Add an argument to the func_args list

=cut

*/

    void set_integer_keyed_int (INTVAL key, INTVAL value) {
        PMC *func_args = VTABLE_getprop(INTERP, SELF, FUNC_ARGS);
        VTABLE_set_integer_keyed_int(INTERP, func_args, key, value);
    }

/*

=item C<void set_string_keyed_int(INTVAL key, STRING* value)>

Add an argument to the func_args list

=cut

*/

    void set_string_keyed_int (INTVAL key, STRING* value) {
        PMC *func_args = VTABLE_getprop(INTERP, SELF, FUNC_ARGS);
        VTABLE_set_string_keyed_int(INTERP, func_args, key, value);
    }

/*

=back

=cut

*/

}

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
