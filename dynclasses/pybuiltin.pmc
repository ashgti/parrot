/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/pybuiltin.pmc - Python "builtin" Functions

=head1 DESCRIPTION

This class implements the Python "builtin" Functions.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

/* cache of classes referenced */
static INTVAL dynclass_PyObject;
static INTVAL dynclass_PyInt;
static INTVAL dynclass_PyFloat;
static INTVAL dynclass_PyList;
static INTVAL dynclass_PyString;

static STRING *HEX;
static STRING *OCT;

extern PMC* Parrot_PerlHash_get_iter(Interp* interpreter, PMC* pmc);

pmclass PyBuiltin dynpmc group python_group {
/*

=item C<void class_init()>

Class initialization. Caches the type id of various PMCs because
they will be used frequently here.

=cut

*/

    void class_init() {
        if (pass) {
            dynclass_PyObject  = Parrot_PMC_typenum(INTERP, "PyObject");
            dynclass_PyInt     = Parrot_PMC_typenum(INTERP, "PyInt");
            dynclass_PyFloat   = Parrot_PMC_typenum(INTERP, "PyFloat");
            dynclass_PyList    = Parrot_PMC_typenum(INTERP, "PyList");
            dynclass_PyString  = Parrot_PMC_typenum(INTERP, "PyString");

            HEX = const_string(INTERP, "__hex__");
            OCT = const_string(INTERP, "__oct__");
        }
    }

/*

=item C<PMC* "__load__"()>

This is unabashed hackery scaffolding.  It copies all the builtins 
functions from globals to lexicaly scoped variables.

=cut

The implementation is highly dependent on the internals of globals and 
ordered hashes, and will break should either of them change - of course,
any such breakage should show up quickly in the unit tests.

Longer term, either globals should expose an iterator by which one
can discover keys (needed to support a Python "dir" like function), or
enter_nci_method should create these as locals to begin with.

*/

    METHOD void __load__() {
        STRING *class, *name, *key;
        PMC *stash, *iter, *item, *pad, *find;
        HashBucket *b;
        INTVAL j, n;

        /* Already init'ed? */
        pad = scratchpad_get_current(interpreter);
        name = const_string(INTERP, "__name__");
        find = scratchpad_find(INTERP, pad, name);
        if (find && VTABLE_defined(INTERP, find)) return;

        /* Find all PyBuiltin "nci" methods */
        class = const_string(INTERP, "PyBuiltin");
        stash = interpreter->globals->stash_hash;
        b = hash_get_bucket(INTERP, (Hash*) PMC_struct_val(stash), class);
        if (!b) internal_exception(1, "Can't find PyBuiltins");

        /* For each, extract the key and item, and store in the scratchpad */
        stash = b->value;
        iter = Parrot_PerlHash_get_iter(INTERP, stash);
        n = VTABLE_elements(INTERP, stash);
        for (j = 0; j < n; ++j) {
            key = VTABLE_shift_string(INTERP, iter);
            item = VTABLE_get_pmc_keyed_str(INTERP, stash, key);
            scratchpad_store_by_name(INTERP, pad, 0, key, item);
        }

        /* Begin main! */
        item = pmc_new(INTERP, dynclass_PyString);
        VTABLE_set_string_native(INTERP, item,
            const_string(INTERP, "__main__"));
        scratchpad_store_by_name(INTERP, pad, 0, name, item);
    }


/*

=item C<PMC* "abs"()>

Returns the absolute value of an object

=cut

*/

    METHOD PMC* abs(PMC *object) {
        PMC * ret = pmc_new(INTERP, dynclass_PyObject);
        VTABLE_absolute(INTERP, object, ret);
        return ret;
    }

/*

=item C<PMC* "cmp"(PMC *value1, PMC *value2)>

Returns the result of comparing C<*value1> with C<*value2).

=cut

*/

    METHOD PMC* cmp(PMC *value1, PMC *value2) {
        PMC * ret = pmc_new(INTERP, dynclass_PyInt);
        VTABLE_set_integer_native(INTERP, ret,
            mmd_dispatch_i_pp(INTERP, value1, value2, MMD_CMP));
        return ret;
    }

/*

=item C<PMC* "float"()>

Returns the float value of C<value>.

=cut

*/

    METHOD PMC* float(PMC *value) {
        PMC * ret = pmc_new(INTERP, dynclass_PyFloat);
        FLOATVAL fvalue = VTABLE_get_number(INTERP, value);
        VTABLE_set_number_native(INTERP, ret, fvalue);
        return ret;
    }

/*

=item C<PMC* "hex"(PMC *value)>

Returns the hex representation of C<value>.

=cut

*/

    METHOD PMC* hex(PMC *value) {
        PMC * meth = VTABLE_find_method(INTERP, value, HEX);
        REG_INT(3) = 0;
        REG_PMC(2) = value;
        VTABLE_invoke(INTERP, meth, REG_PMC(1));
        return REG_PMC(5);
    }

/*

=item C<PMC* "int"(PMC *value)>

Returns the integer value of C<value>.

=cut

*/

    METHOD PMC* int(PMC *value) {
        PMC * ret = pmc_new(INTERP, dynclass_PyInt);
        INTVAL ivalue = VTABLE_get_integer(INTERP, value);
        VTABLE_set_integer_native(INTERP, ret, ivalue);
        return ret;
    }

/*

=item C<PMC* "oct"(PMC *value)>

Returns the octal representation of C<value>.

=cut

*/

    METHOD PMC* oct(PMC *value) {
        PMC * meth = VTABLE_find_method(INTERP, value, OCT);
        REG_INT(3) = 0;
        REG_PMC(2) = value;
        VTABLE_invoke(INTERP, meth, REG_PMC(1));
        return REG_PMC(5);
    }

/*

=item C<PMC* "range"(PMC *pstart, PMC *pend, PMC *pstep)>

Returns a list of integers ranging from C<pstart> to C<pend> with
an increment of C<pstep>

=cut

*/

    METHOD PMC* range(PMC *pstart, PMC *pend, PMC *pstep) {
        PMC *ar = pmc_new(interpreter, dynclass_PyList);
        INTVAL start = 0, end = 0, step = 1;
        int i, k, argcP;

        argcP = REG_INT(3);
        if (argcP == 1) {
            end = VTABLE_get_integer(interpreter, pstart);
        }
        else if (argcP == 2) {
            start = VTABLE_get_integer(interpreter, pstart);
            end =  VTABLE_get_integer(interpreter, pend);
        }
        else if (argcP == 3) {
            start = VTABLE_get_integer(interpreter, pstart);
            end =  VTABLE_get_integer(interpreter, pend);
            step =  VTABLE_get_integer(interpreter, pstep);
            if (step == 0)
                real_exception(interpreter, NULL, E_ValueError,
                        "range() step argument must not be zero");
        }
        else {
            /* TODO err */
        }
        if (step < 0) {
            for (i = start, k = 0; i > end; i += step, ++k)
                VTABLE_set_integer_keyed_int(interpreter, ar, k, i);
        }
        else {
            for (i = start, k = 0; i < end; i += step, ++k)
                VTABLE_set_integer_keyed_int(interpreter, ar, k, i);
        }
        return ar;
    }

/*

=back

=cut

*/

}

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
