/* TclParser.pmc
 *  Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
 *  CVS Info
 *     $Id$
 *  Overview:
 *     A container for methods related to tcl parsing.
 *  Data Structure and Algorithms:
 *  History:
 *  Notes:
 *  References:

=head1 NAME

dynclasses/tclparser.pmc - Tcl Parser

=head1 DESCRIPTION

Handle any parsing of Tcl code - putting this into a pmc with state
allows us to more easily handle [parser]

=cut

*/

#include "parrot/parrot.h"

static INTVAL TclList,StringClass,IntegerClass,TclWord;
static STRING *bs_nl, *nl, *cb, *cp, *space;
static STRING *ConcatWords, *ConcatConst, *ConcatConst, *ConcatVariable;
static STRING *ConcatChar, *ConcatCommand;

pmclass TclParser dynpmc group tcl_group {

    void class_init() {
      if (pass) {
          TclList = Parrot_PMC_typenum(INTERP, "TclList");
          StringClass = Parrot_PMC_typenum(INTERP, "String");
          IntegerClass = Parrot_PMC_typenum(INTERP, "Integer");
          bs_nl = string_from_const_cstring(INTERP, "\\\n",2);
          nl    = string_from_const_cstring(INTERP, "\n",1);
          cb    = string_from_const_cstring(INTERP, "\175",1);
          cp    = string_from_const_cstring(INTERP, ")",1);
          space = string_from_const_cstring(INTERP, " ",1);
          ConcatWords = string_from_const_cstring(INTERP, "concat_words",12);
          ConcatConst = string_from_const_cstring(INTERP, "concat_const",12);
          ConcatVariable = string_from_const_cstring(INTERP, "concat_variable",15);
          ConcatChar = string_from_const_cstring(INTERP, "concat_char",11);
          ConcatCommand = string_from_const_cstring(INTERP, "concat_command", 14);
      }
    }

/*

=item C<void init()>

Initializes the instance.

=cut

*/

    void init () {
        PMC_str_val(SELF) = string_make_empty(INTERP,enum_stringrep_one,0);
    }

/*

=item C<METHOD PMC* "parse"(PMC *code, PMC *pws, PMC *bi)

Given a string of Tcl Code, return a chunk of data we can then pass
to the expression sub.

XXX: Skip the evaluate step, and just return an invokable.

=cut

*/

    METHOD PMC* parse(PMC *code, PMC *psw, PMC *bi) {
      INTVAL start_word=0;  /* position of the start of the word */
      INTVAL word_length; /* length of the word */
      INTVAL word_trailing_length;  /* include the last char in the word? */
      INTVAL character; /* The current character */
      INTVAL last_character; /*The last character */
      INTVAL end_of_word; /* Boolean, is the word done? */
      PMC *commands; /* List of all the commands parsed */
      PMC *command;  /* The current command */
      INTVAL bs_marker = 0;
      INTVAL bs_pos;
      INTVAL bs_retval;
      INTVAL bs_diff;
      INTVAL bs_a_byte;
      INTVAL buffer_length;
      INTVAL old_length,chunk_start,escape_length,temppos;

      STRING *buffer = Parrot_PMC_get_string(INTERP, code);
      INTVAL preserve_whitespace = Parrot_PMC_get_intval(INTERP, psw);
      INTVAL block_interpolation = Parrot_PMC_get_intval(INTERP, bi);
      STRING *Tcl;
      PMC *retval,*word;
      INTVAL I0,I1,I2;
      STRING *S0, *S1;
      PMC *P0,*P1,*P2,*P3,*P4;

      /* XXX running this in class_init is apparently too soon, so run it here */
      TclWord = Parrot_PMC_typenum(INTERP, "TclWord");

      /* backslash/newline substitution */
      buffer_length = string_length(INTERP, buffer);
      bs_pos = string_str_index(INTERP, buffer, bs_nl, bs_marker);

      /* bs_loop_outer: */
      while (bs_marker <= buffer_length && bs_pos != -1) {
        bs_marker = bs_pos;

        bs_pos+=1;
        /* bs_loop_inner */
        bs_retval = 1;
        while (bs_retval) {
          bs_a_byte = string_index(INTERP,buffer,bs_pos++);
          if (bs_a_byte < 33 && bs_a_byte != 10) {
            bs_retval = 1;
          } else {
            bs_retval = 0;
          }
        }

        /* delete the items from marker to pos */
        bs_diff = bs_pos - bs_marker;
        string_replace(INTERP,buffer,bs_marker,bs_diff,space,NULL);

        buffer_length = string_length(INTERP, buffer);
        bs_pos = string_str_index(INTERP, buffer, bs_nl, bs_marker);
      }

  /* Keep track of the position of the current word */
  start_word = 0;

  commands = pmc_new(INTERP,TclList);

  /*
   * (Do this after the newline_subst since this could change the
   *  size of the buffer.)  ... don't fall off the end
   */

  buffer_length = string_length(INTERP, buffer);

begin_command:
  command = pmc_new(INTERP,TclList);

begin_word:
  word = pmc_new(INTERP,TclWord);
  end_of_word = 0;
  /* Skip any leading whitespace, unless we're preserving. */

  if (preserve_whitespace == 1) {
    goto pre_middle;
  }

space_loop:
  if (start_word >= buffer_length) {
    goto end_scope;
  }

space_loop_cont:
  I0 = string_index(INTERP, buffer, start_word);
  if (I0 < 33 && I0 != 10) {
    I1 = 1;
  } else {
    I1 = 0;
  }

  if (I1 == 0) {
    goto space_loop_end;
  }
  start_word++;
  goto space_loop;

space_loop_end:
  /* at this point, we know start_word is correct. Now to figure out where the word ends. */

  /* If the first character is special, then DTRT */
  character = string_index(INTERP, buffer, start_word);

  /* brace-encrusted block */
  if (character == 123) {
    goto handle_brace;
  }

  /* "string" */
  if (character == 34) {
    goto handle_quote;
  }

  /* #comment */
  if (character != 35) {
    goto pre_middle;
  }
  if (Parrot_PMC_get_intval(INTERP,command) == 0) {
    goto handle_comment;
  }

pre_middle:
  word_length = 0;
  word_trailing_length = 0;
  last_character = -1;

middle_word:
  I0 = start_word+word_length;
  if (I0 >= buffer_length) {
   goto end_command;
  }

middle_word_0:
  character = string_index(INTERP, buffer, I0);

  if (preserve_whitespace == 1) {
    goto middle_word_2;
  }
  if (character < 33 && character != 10) {
    I0 = 1;
  } else {
    I0 = 0;
  }
  if (I0 == 1) {
    goto end_word;
  }

  /* if this isn't a newline, skip */
  if (character != 10) {
    goto middle_word_2;
  }

middle_word_1:
  word_trailing_length=1;
  goto end_command;

middle_word_2:
  /* wait, this was a semicolon - go back and deal with it.*/
  if (character == 59) {
    goto middle_word_1;
  }

  /* If we've gotten this far and we're in a "" or brace-block, barf. */
  if (end_of_word == 1) {
    goto invalid_word;
  }

  /* [ ] */
  if (block_interpolation) {
    goto check_bs;
  }
  if (character == 91) {
    goto handle_command_block;
  }

  /* $ */
  if (character == 36) {
    goto handle_variable;
  }

check_bs:
  /* backslash */
  if (character == 92) {
    goto handle_backslash;
  }

middle_continue:
  last_character = character;
  word_length++;
  goto middle_word;

end_word:
  /*  save the word and put it into the command array */

  S0 = string_substr(INTERP, buffer, start_word, word_length, NULL, 0);
  P1 = VTABLE_find_method(INTERP, word, ConcatConst);
  Parrot_call_method(INTERP, P1, word, ConcatConst, "vS", S0);

  VTABLE_push_pmc(INTERP, command, word);

  start_word += word_length;
  start_word += word_trailing_length;
  start_word++;

  goto begin_word;

handle_comment:
  /* If the comment is all that's left, quit. */
  I0 = string_str_index(INTERP, buffer, nl, start_word);
  if (I0 == -1) {
    goto end_command;
  }

  /*  otherwise, stop at the next newline. */
  start_word = I0 + 1;
  goto begin_command;

end_command:
  /*
   * if we're preserving whitespace and we're at the end of the command,
   * we must really be done.
   */
  if (preserve_whitespace==1) {
    goto end_command_0;
  }

  /*
   * If this was an empty line, we'll have a 0 word length but
   * a trailing length of 1. skip the newline
   */

  /* unless we finished the word, in which case... */
  if (end_of_word == 1) {
    goto end_command_0;
  }

  /*
   * Because of how we grabbed the command, we could have a word_length
   * of zero, but have a word object in process.
   */
  I0 = Parrot_PMC_get_intval(INTERP, word);
  if (I0 != 0) {
    goto end_command_0;
  }

  /* If word_length is zero now, don't bother adding the word. */
  /* (unless we're preserving whitespace...) */
  if (word_length == 0) {
    goto end_command_1;
  }

end_command_0:
  S0 = string_substr(INTERP, buffer, start_word, word_length, NULL, 0);
  P1 = VTABLE_find_method(INTERP, word, ConcatConst);
  Parrot_call_method(INTERP, P1, word, ConcatConst, "vS", S0);
  VTABLE_push_pmc(INTERP, command, word);
  if (preserve_whitespace == 1) {
    goto preserve_end_scope;
  }

end_command_1:
  /* go to the next word*/

  I0 = Parrot_PMC_get_intval(INTERP, command);
  if (I0 == 0) {
    goto end_command_2;
  }
  VTABLE_push_pmc(INTERP, commands, command);

end_command_2:
  start_word += word_length;
  start_word += word_trailing_length;
  goto begin_command;

handle_brace:
  word_length = Parrot_TclParser_match_close(INTERP, SELF, buffer,start_word);
  if (word_length < 0) {
    goto bad_block;
  }
  end_of_word = 1;

  /* figure out where the new word is going to start.*/
  I1 = start_word + word_length;

  /* This gets added as a constant.*/
  start_word++;
  word_length-=2;

  S0 = string_substr(INTERP, buffer, start_word, word_length, NULL, 0);
  P1 = VTABLE_find_method(INTERP, word, ConcatConst);
  Parrot_call_method(INTERP, P1, word, ConcatConst, "vS", S0);
  start_word = I1;
  word_length = 0;
  goto middle_word;

handle_quote:
  word_length = Parrot_TclParser_match_close(INTERP, SELF, buffer,start_word);

  if (word_length < 0) {
    goto bad_block;
  }
  end_of_word = 1 ;

  /*figure out where the new word is going to start.*/
  I1 = start_word + word_length;

  /*
   * Since we could have embedded things in our string,
   * recall the parser, but tell it to preserve the whitespace in
   * this quote.
   * (There could be embedded vars, commands, etc.)
   */

  start_word++;
  word_length-=2;
  S0 = string_substr(INTERP, buffer, start_word, word_length, NULL, 0);

  /* XXX Really need to switch parse to not need PMC's passed in,
         basic types are really what we need */

  P1 = pmc_new(INTERP, StringClass);
  Parrot_PMC_set_string(INTERP, P1, S0);
  P2 = pmc_new(INTERP, IntegerClass);
  VTABLE_set_integer_native(INTERP,P2,1);
  P3 = pmc_new(INTERP, IntegerClass);
  VTABLE_set_integer_native(INTERP,P3,0);

  P0 = Parrot_TclParser_parse(INTERP, SELF, P1, P2, P3);
  P4 = VTABLE_find_method(INTERP, word, ConcatWords);
  /* XXX This method on the object currently causes a bus error */
  Parrot_call_method(INTERP, P4, word, ConcatWords, "vP", P0);
  start_word = I1;
  word_length = 0;
  goto middle_word;

handle_variable:
  /* First, save off anything we've gotten so far as a constant.*/
  old_length = word_length;
  chunk_start = start_word + word_length;
  word_length = Parrot_TclParser_match_close(INTERP, SELF, buffer,chunk_start);

  /* if there's any word so far, save it*/
  if (old_length == 0) {
    goto handle_variable_1;
  }
  S0 = string_substr(INTERP, buffer, start_word, old_length, NULL, 0);
  P1 = VTABLE_find_method(INTERP, word, ConcatConst);
  Parrot_call_method(INTERP, P1, word, ConcatConst, "vS", S0);

handle_variable_1:
  /* Are we dealing with a braced-var name? */
  if (string_index(INTERP, buffer, ++chunk_start) != 123) {
    goto handle_variable_nobrace;
  }

handle_variable_brace:
  /* Get the closing brace, but we don't have to have matched pairs here. */
  I1 = string_str_index(INTERP, buffer, cb, chunk_start);
  if (I1 > buffer_length) {
    goto invalid_variable;
  }
  /* Save the new start word for when we go to middle word.*/
  I1++;
  start_word = I1;
  word_length = 0;

  /* Name of variable is between the braces..*/
  chunk_start++;
  I2 = I1 - chunk_start - 1;
  S0 = string_substr(INTERP, buffer, chunk_start, I2, NULL, 0);
  P1 = VTABLE_find_method(INTERP, word, ConcatVariable);
  Parrot_call_method(INTERP, P1, word, ConcatVariable, "vS", S0);
  goto middle_word;

handle_variable_nobrace:
  temppos = chunk_start;

inner:
  if (++temppos >= buffer_length) {
    goto inner_done;
  }

  I0 = string_index(INTERP, buffer, temppos);
  /* A */
  if (I0 < 65) {
    goto check2;
  }
  /* Z */
  if (I0 <= 90) {
    goto inner;
  }
check2:
  /* a */
  if (I0 < 97) {
    goto check3;
  }
  /* z */
  if (I0 <=122) {
    goto inner;
  }
check3:
  /* 0 */
  if (I0 <48) {
    goto check4;
  }
  /* 9 */
  if (I0 <=57) {
    goto inner;
  }
check4:
  /* _ */
  if (I0 == 95) {
    goto inner;
  }

inner_done:
  /* Once we get here, we could also have a () to deal with..   */
  /* () */
  I1 = temppos - chunk_start;
  S0 = string_substr(INTERP, buffer, chunk_start, I1, NULL, 0);
  start_word = chunk_start + I1;
  word_length = 0;

  if (I0 != 40) {
    goto gotword;
  }
  temppos = string_str_index(INTERP, buffer, cp, start_word);
  if (temppos == -1) {
    goto bad_array;
  }
  /* $S0($S1) */
  start_word++;
  I1 = temppos - start_word;
  S1 = string_substr(INTERP, buffer, start_word, I1, NULL, 0);
  start_word = temppos + 1;
  P1 = VTABLE_find_method(INTERP, word, ConcatVariable);
  Parrot_call_method(INTERP, P1, word, ConcatVariable, "vSS", S0, S1);
  goto middle_word;

gotword:
  /* $S0 was set to the name of the variable above. */
  P1 = VTABLE_find_method(INTERP, word, ConcatVariable);
  Parrot_call_method(INTERP, P1, word, ConcatVariable, "vS", S0);

  goto middle_word;

handle_backslash:
  /* dump anything so far as a constant.*/
  if (word_length == 0)  {
    goto backslash_escape;
  }

  S0 = string_substr(INTERP, buffer, start_word, word_length, NULL, 0);
  P1 = VTABLE_find_method(INTERP, word, ConcatConst);
  Parrot_call_method(INTERP, P1, word, ConcatConst, "vS", S0);

  start_word += word_length;
  word_length =  0;

backslash_escape:
  /*
   * get the next character (start_word is now the beginning of the escape)
   * XXX Need to make sure we don't walk off the edge here.
  */

  start_word++;
  escape_length = 1;
  I0 = string_index(INTERP, buffer, start_word);
  /* add this escape as a sequence.*/
  P1 = VTABLE_find_method(INTERP, word, ConcatChar);
  if (I0 != 97) {
    goto backslash_escape_b;
  }
  Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 7);
  goto escape_done;
backslash_escape_b:
  if (I0 != 98) {
    goto backslash_escape_f;
  }
  Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 8);
  goto escape_done;
backslash_escape_f:
  if (I0 != 102) {
    goto backslash_escape_n;
  }
  Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 12);
  goto escape_done;
backslash_escape_n:
  if (I0 != 110) {
    goto backslash_escape_r;
  }
  Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 10);
  goto escape_done;
backslash_escape_r:
  if (I0 != 114) {
    goto backslash_escape_t;
  }
  Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 13);
  goto escape_done;
backslash_escape_t:
  if (I0 != 116) {
    goto backslash_escape_v;
  }
  Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 9);
  goto escape_done;
backslash_escape_v:
  if (I0 != 118) {
    goto backslash_escape_not;
  }
  Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", 11);
  goto escape_done;

/* XXX - here is where the \o, \x, \u escapes would go.
     - You have to twiddle escape_length */

backslash_escape_not:
  Parrot_call_method(INTERP, P1, word, ConcatChar, "vI", I0);

escape_done:
  /* skip the escaped char*/
  start_word = start_word + escape_length;
  goto middle_word;

handle_command_block:
  old_length = word_length;
  chunk_start = start_word + word_length;
  word_length = Parrot_TclParser_match_close(INTERP, SELF, buffer,chunk_start);

  if (word_length < 0) {
    goto bad_block;
  }

  if (old_length) {
      /* if there's any word so far, save it*/
      S0 = string_substr(INTERP, buffer, start_word, old_length, NULL, 0);
      P1 = VTABLE_find_method(INTERP, word, ConcatConst);
      Parrot_call_method(INTERP, P1, word, ConcatConst, "vS", S0);
  }

command_save:
  /* Save this as a command (skip the []'s)*/
  I0 = chunk_start + 1;
  I1 = word_length - 2;
  S0 = string_substr(INTERP, buffer, I0, I1, NULL, 0);
  P1 = VTABLE_find_method(INTERP, word, ConcatCommand);
  Parrot_call_method(INTERP, P1, word, ConcatCommand, "vS", S0);

  start_word = chunk_start + word_length;
  word_length = 0;

  goto middle_word;

  /* if we're preserving whitespace, just return the single command */

preserve_end_scope:
  return(command);

end_scope:
  /* If we have a command in progress, save it!*/
  I0 = Parrot_PMC_get_intval(INTERP, command);
  if (I0 == 0) {
    goto end_scope_2;
  }
  VTABLE_push_pmc(INTERP, commands, command);

  /* At this point, we have parsed the string into an array of commands.*/

end_scope_2:
  return(commands);

end:
  exit(1); /* XXX this needs to go away. */

 /*
  * XXX these really should generate compile-time tcl errors.
  * (perhaps even compile to code that generates an [error]?)
  * (redo this once "error" is working.)
  */

bad_array:
  printf("XXX - invalid array, no close ) found\n");
  goto end;
bad_block:
  printf("XXX - invalid word, no closing <mumble> found\n");
  goto end;
invalid_word:
  printf("XXX - invalid word, should have ended after block\n");
  goto end;
invalid_variable:
  printf("missing close-brace for variable name\n");
  goto end;

  }

  /* Given a string and a beginning position in the string, return
   * the length of the string that forms a valid tcl construct.
   * [], {}, (), "", etc.
   *
   * return -1 if an invalid initial character is found
   * return -2 if no closing character is found.
   */

  METHOD INTVAL match_close(STRING *buffer, INTVAL index) {
    INTVAL opener;
    INTVAL closer = -1;
    INTVAL peekchar;
    INTVAL count = 1;
    INTVAL state = 1;
    INTVAL position = index;
    INTVAL bufferlen;
    INTVAL hierarchical = 0;
    INTVAL retval = -1;

    bufferlen = string_length(INTERP, buffer);
    opener = string_index(INTERP, buffer, index);

    if (opener == 123) { /* {} */
      hierarchical = 1;
      closer = 125;
    } else if (opener == 91) { /* [] */
      hierarchical = 1;
      closer = 93;
    } else if (opener == 34) { /* "" */
      closer = opener;
    } else if (opener == 40) { /* () */
      hierarchical = 1;
      closer = 41;
    } else {
      return -1;
      /* invalid matching char. */
      /* XXX - generate an exception? */
    }

    /* state == 1, normal; 2, saw a backslash */

    /* loop_outer */
    while (count != 0) {
      position++;
      if (position == bufferlen) {
        return -2;
      }
      peekchar = string_index(INTERP,buffer,position);
      if (state == 2) {
        state = 1;
      } else if (peekchar == closer) {
        if (opener == closer) {
          count = 0;
        } else {
          count--;
        }
      } else if ((peekchar == opener) && hierarchical) {
        count++;
      } else if (peekchar == 92) {
        state = 2;
      }
    }

    retval = position - index + 1;
    return retval;
  }

}
