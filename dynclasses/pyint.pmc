/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/pyint.pmc - Python Integer

=head1 DESCRIPTION

C<PyInt> extends C<PyObject> to provide a Python integer.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "pyconsts.h"

static void
overflow(Interp *interpreter, PMC *self, INTVAL b, PMC *dest, int mmd)
{
    PMC *temp;
    INTVAL a = PMC_int_val(self);

    if (self == dest) {
        VTABLE_morph(interpreter, self, PyBuiltin_PyLong);
        VTABLE_set_integer_native(interpreter, self, a);
        mmd_dispatch_v_pip(interpreter, self, b, dest, mmd);
    }
    else {
        temp = pmc_new(interpreter, PyBuiltin_PyLong);
        VTABLE_set_integer_native(interpreter, temp, a);
        mmd_dispatch_v_pip(interpreter, temp, b, dest, mmd);
    }
}

static void
promote(Interp *interpreter, PMC *self, PMC *b, PMC *dest, int mmd)
{
    PMC *temp;
    INTVAL a = PMC_int_val(self);
    temp = pmc_new(interpreter, PyBuiltin_PyLong);
    VTABLE_set_integer_native(interpreter, temp, a);
    mmd_dispatch_v_ppp(interpreter, temp, b, dest, mmd);
}

pmclass PyInt extends PyObject dynpmc group python_group {

/*

=item C<PMC* "__hex__"(PMC *self)>

Returns the hex representation of C<self>.

=cut

*/

    METHOD PMC* __hex__(PMC *self) {
        PMC * ret = pmc_new(INTERP, PyBuiltin_PyString);
        STRING *s = Parrot_sprintf_c(INTERP, "%#x",
            VTABLE_get_integer(INTERP, self));
        VTABLE_set_string_native(INTERP, ret, s);
        return ret;
    }

/*

=item C<PMC* "__oct__"(PMC *self)>

Returns the octal representation of C<self>.

=cut

*/

    METHOD PMC* __oct__(PMC *self) {
        PMC * ret = pmc_new(INTERP, PyBuiltin_PyString);
        STRING *s = Parrot_sprintf_c(INTERP, "%#o",
            VTABLE_get_integer(INTERP, self));
        VTABLE_set_string_native(INTERP, ret, s);
        return ret;
    }

/*

=item C<PMC* "__pos__"(PMC *self)>

Returns the value of the prefix operator C<+>.

=cut

*/

    METHOD PMC* __pos__(PMC *self) {
        PMC * ret = pmc_new(INTERP, PyBuiltin_PyInt);
        PMC_int_val(ret) = PMC_int_val(self);
        return ret;
    }
/*

=item C<PMC* "__truediv__"(PMC *self, PMC *value)>

Divides C<self> by C<*value> and returns the result.

=cut

*/

    METHOD PMC* __truediv__(PMC *self, PMC *value) {
        FLOATVAL valf = VTABLE_get_number(INTERP, value);
        FLOATVAL d = PMC_int_val(self)/valf;
        INTVAL i = (INTVAL) d;
        PMC * ret;
        if ( (FLOATVAL)i != d ) {
            ret = pmc_new(INTERP, PyBuiltin_PyFloat);
            VTABLE_set_number_native(INTERP, ret, d);
        }
        else {
            ret = pmc_new(INTERP, PyBuiltin_PyInt);
            PMC_int_val(ret) = i;
        }
        return ret;
    }

/*

=item C<void absolute(dest)>

Sets C<dest> to the absolute value of SELF.

=cut

*/

    void absolute(PMC *dest) {
        VTABLE_set_integer_native(INTERP, dest, abs(PMC_int_val(SELF)));
    }

/*

=item C<void add(PMC *value, PMC *dest)>

Adds C<*value> to the integer and returns the result in C<*dest>.

=cut

*/

    void add (PMC* value, PMC* dest) {
MMD_PyInt: {
            INTVAL a = PMC_int_val(SELF);
            INTVAL b = PMC_int_val(value);
            INTVAL c = a + b;
            if ((c^a) >= 0 || (c^b) >= 0)
                VTABLE_set_integer_native(INTERP, dest, c);
            else
                overflow(INTERP, SELF, b, dest, MMD_ADD_INT);
            }
MMD_PyFloat: {
            INTVAL pmci = PMC_int_val(SELF);
            FLOATVAL valf = VTABLE_get_number(INTERP, value);
            VTABLE_morph(INTERP, dest, PyBuiltin_PyFloat);
            VTABLE_set_number_native(INTERP, dest, pmci + valf);
        }
MMD_PyLong: {
            promote(INTERP, SELF, value, dest, MMD_ADD);
        }
MMD_PyComplex: {
            INTVAL pmci = PMC_int_val(SELF);
            FLOATVAL valf = VTABLE_get_number_keyed_int(INTERP, value, 0);
            VTABLE_morph(INTERP, dest, PyBuiltin_PyComplex);
            VTABLE_set_number_keyed_int(INTERP, dest, 0, pmci + valf);
            valf = VTABLE_get_number_keyed_int(INTERP, value, 1);
            VTABLE_set_number_keyed_int(INTERP, dest, 1, valf);
        }
MMD_PyString: {
            real_exception(INTERP, NULL, E_TypeError,
               "TypeError: unsupported operand type(s) for +: 'int' and 'str'");
        }
    }

/*

=item C<void add_int(INTVAL b, PMC* dest)>

Adds C<b> to the integer and returns the result in C<*dest>.

=cut

*/

    void add_int (INTVAL b, PMC* dest) {
        INTVAL a = PMC_int_val(SELF);
        INTVAL c = a + b;
        if ((c^a) >= 0 || (c^b) >= 0)
            VTABLE_set_integer_native(INTERP, dest, c);
        else
            overflow(INTERP, SELF, b, dest, MMD_ADD_INT);
    }

/*

=item C<void bitwise_and(INTVAL value, PMC *dest)>

Calculates the bitwise C<AND> of the integer and C<*value> and returns
the result in C<*dest>.

=cut

*/

    void bitwise_and (PMC *value, PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest,
            PMC_int_val(SELF) & VTABLE_get_integer(INTERP, value)
        );
    }

/*

=item C<void bitwise_and_int(INTVAL value, PMC *dest)>

Calculates the bitwise C<AND> of the integer and C<*value> and returns
the result in C<*dest>.

=cut

*/

    void bitwise_and_int (INTVAL value, PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest,
            PMC_int_val(SELF) & value
        );
    }

/*

=item C<void bitwise_not(PMC *dest)>

Calculates the bitwise C<NOT> of the integer and returns the result in
C<*dest>.

=cut

*/

    void bitwise_not (PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest, ~PMC_int_val(SELF));
    }

/*

=item C<void bitwise_or(PMC *value, PMC *dest)>

Calculates the bitwise C<OR> of the integer and C<*value> and returns
the result in C<*dest>.

=cut

*/

    void bitwise_or (PMC* value, PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest,
            PMC_int_val(SELF) |
            VTABLE_get_integer(INTERP, value)
        );
    }

/*

=item C<void bitwise_or_int(INTVAL value, PMC *dest)>

Calculates the bitwise C<OR> of the integer and C<value> and returns
the result in C<*dest>.

=cut

*/

    void bitwise_or_int (INTVAL value, PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest,
            PMC_int_val(SELF) | value
        );
    }

/*

=item C<void bitwise_shl(PMC *value, PMC *dest)>

Calculates the bitwise shift left (C<<<<<>>>) of the integer by
C<*value> and returns the result in C<*dest>.

=cut

*/

    void bitwise_shl (PMC* value, PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest,
            PMC_int_val(SELF) <<
            VTABLE_get_integer(INTERP, value)
        );
    }

/*

=item C<void bitwise_shl_int(INTVAL value, PMC *dest)>

Calculates the bitwise shift left (C<<<<<>>>) of the integer by
C<value> and returns the result in C<*dest>.

=cut

*/

    void bitwise_shl_int (INTVAL value, PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest,
            PMC_int_val(SELF) << value
        );
    }

/*

=item C<void bitwise_shr(PMC *value, PMC *dest)>

Calculates the bitwise shift right (C<<<>>>>>) of the integer by
C<*value> and returns the result in C<*dest>.

=cut

*/

    void bitwise_shr (PMC* value, PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest,
            PMC_int_val(SELF) >>
            VTABLE_get_integer(INTERP, value)
        );
    }

/*

=item C<void bitwise_shr_int(INTVAL value, PMC *dest)>

Calculates the bitwise shift right (C<<<>>>>>) of the integer by
C<value> and returns the result in C<*dest>.

=cut

*/

    void bitwise_shr_int (INTVAL value, PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest,
            PMC_int_val(SELF) >> value
        );
    }

/*

=item C<void bitwise_xor(PMC *value, PMC *dest)>

Calculates the bitwise C<XOR> of the integer and C<*value> and returns
the result in C<*dest>.

=cut

*/

    void bitwise_xor (PMC* value, PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest,
            PMC_int_val(SELF) ^
            VTABLE_get_integer(INTERP, value)
        );
    }

/*

=item C<void bitwise_xor_int(INTVAL value, PMC *dest)>

Calculates the bitwise C<XOR> of the integer and C<value> and returns
the result in C<*dest>.

=cut

*/

    void bitwise_xor_int (INTVAL value, PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest,
            PMC_int_val(SELF) ^ value
        );
    }

/*

=item C<INTVAL cmp(PMC *value)>

Returns the result of comparing the integer with C<*value>.

=cut

*/

    INTVAL cmp(PMC* value) {
MMD_PyFloat: {
            FLOATVAL diff;
            diff = (FLOATVAL)PMC_int_val(SELF)
                - VTABLE_get_number(INTERP, value);
            return diff > 0 ? 1 : diff < 0 ? -1 : 0;
        }
MMD_PyInt: {
            INTVAL diff = PMC_int_val(SELF)
                - VTABLE_get_integer(INTERP, value);
            return diff > 0 ? 1 : diff < 0 ? -1 : 0;
        }
MMD_PyClass: {
            /* XXX: redispatch if proxy? */
            INTVAL diff = PMC_int_val(SELF)
                - VTABLE_get_integer(INTERP, value);
            return diff > 0 ? 1 : diff < 0 ? -1 : 0;
        }
MMD_PyLong: {
            PMC *temp;
            INTVAL a = PMC_int_val(SELF);
            temp = pmc_new(INTERP, PyBuiltin_PyLong);
            VTABLE_set_integer_native(INTERP, temp, a);
            return mmd_dispatch_i_pp(INTERP, temp, value, MMD_CMP);
        }
MMD_DEFAULT: {
            return -1;
        }
    }

/*

=item C<void divide(PMC *value, PMC *dest)>

Divides the integer by the C<*value> returns the result in C<*dest>.

=cut

*/

    void divide (PMC* value, PMC* dest) {
MMD_PyInt: {
            INTVAL pmci = PMC_int_val(SELF);
            INTVAL vali = VTABLE_get_integer(INTERP, value);
            INTVAL xdivy = pmci / vali;
            INTVAL xmody = pmci - xdivy * vali;
            if (xmody && ((vali ^ xmody) < 0) /* i.e. and signs differ */) {
                    --xdivy;
            }
            VTABLE_set_integer_native(INTERP, dest, xdivy);
        }
MMD_PyLong: {
            promote(INTERP, SELF, value, dest, MMD_DIVIDE);
        }
MMD_PyFloat: {
            INTVAL pmci = PMC_int_val(SELF);
            FLOATVAL valf = VTABLE_get_number(INTERP, value);
            /* XXX: Morph? */
            VTABLE_set_number_native(INTERP, dest, pmci / valf);
        }
    }

/*

=item C<void divide_float(FLOAT value, PMC *dest)>

Divides the integer by C<value> and returns the result in C<*dest>.

=cut

*/

    void divide_float (FLOATVAL value, PMC* dest) {
        FLOATVAL pmcn = VTABLE_get_number(INTERP, SELF);
        VTABLE_morph(INTERP, dest, PyBuiltin_PyFloat);
        VTABLE_set_number_native(INTERP, dest, pmcn / value);
    }

/*

=item C<void divide_int(INTVAL value, PMC *dest)>

Divides the integer by C<value> and returns the result in C<*dest>.

=cut

*/

    void divide_int (INTVAL value, PMC* dest) {
        INTVAL pmci = PMC_int_val(SELF);
        INTVAL xdivy = pmci / value;
        INTVAL xmody = pmci - xdivy * value;
        if (xmody && ((value ^ xmody) < 0) /* i.e. and signs differ */) {
                --xdivy;
        }
        VTABLE_set_integer_native(INTERP, dest, xdivy);
    }

/*

=item C<void floor_divide(PMC *value, PMC *dest)>

Divides the integer by the C<*value> returns the result in C<*dest>.

=cut

*/

    void floor_divide (PMC* value, PMC* dest) {
MMD_PyLong: {
            promote(INTERP, SELF, value, dest, MMD_FLOOR_DIVIDE);
        }
MMD_DEFAULT: {
            mmd_dispatch_v_ppp(INTERP, SELF, value, dest, MMD_DIVIDE);
        }
    }

/*

=item C<void floor_divide_int(PMC *value, PMC *dest)>

Divides the integer by the C<*value> returns the result in C<*dest>.

=cut

*/

    void floor_divide_int (INTVAL value, PMC* dest) {
MMD_DEFAULT: {
            mmd_dispatch_v_pip(INTERP, SELF, value, dest, MMD_DIVIDE_INT);
        }
    }

/*

=item C<INTVAL get_bool()>

Returns the boolean value of the integer.

=cut

*/

    INTVAL get_bool () {
        return PMC_int_val(SELF) != 0;
    }

/*

=item C<PMC *get_class()>

Return the class of this object.

=cut

*/

    PMC* get_class() {
        return PyBuiltin_PyInt_class;
    }

/*

=item C<INTVAL get_integer()>

Returns the integer value of the integer.

=cut

*/

    INTVAL get_integer () {
        return PMC_int_val(SELF);
    }

/*

=item C<FLOATVAL get_number()>

Returns the float value of the integer.

=cut

*/

    FLOATVAL get_number () {
        return (FLOATVAL) PMC_int_val(SELF);
    }

/*

=item C<STRING *get_string()>

Returns the string value of the integer.

=cut

*/

    STRING* get_string () {
        return string_from_int(INTERP, PMC_int_val(SELF));
    }

/*

=item C<INTVAL hash()>

Returns a unique hash for this value

=cut

*/

    INTVAL hash () {
        return VTABLE_get_integer(INTERP, SELF);
    }

/*

=item C<PMC* "__new__"(PMC *class, PMC *source)>

Create a new integer

=cut

*/

    METHOD PMC* __new__(PMC *class, PMC *source, PMC *base) {
        INTVAL argc = REG_INT(3);

        PMC * ret = pmc_new(INTERP, PyBuiltin_PyInt);

        /* XXX: quick hack: class method called directly */
        if (argc == 3 && source->vtable->base_type == PyBuiltin_PyProxyType)
            source = REG_PMC(7);

        if (argc > 1) {
            if (source->vtable->base_type == PyBuiltin_PyString) {
                INTVAL key = 0;
                if (argc > 2) key = VTABLE_get_integer(INTERP, base);
                VTABLE_morph(INTERP, ret, PyBuiltin_PyLong);
                VTABLE_set_string_keyed_int(INTERP, ret, key,
                    VTABLE_get_string(INTERP, source));
                mmd_dispatch_v_pip(INTERP, ret, 1, ret, MMD_DIVIDE_INT);
            }
            else {
                INTVAL ivalue = VTABLE_get_integer(INTERP, source);
                VTABLE_set_integer_native(INTERP, ret, ivalue);
            }
        }

        return ret;
    }

/*

=item C<INTVAL is_same(PMC *value)>

Returns whether the PMC is numerically equal to C<value>.

=cut

*/

    INTVAL is_same (PMC* value) {
        if (value->vtable != SELF->vtable) return 0;
        return (INTVAL)(PMC_int_val(SELF) ==
            VTABLE_get_integer(INTERP, value));
    }

/*

=item C<INTVAL is_equal (PMC* value)>

The C<==> operation.

=cut

*/

    INTVAL is_equal (PMC* value) {
MMD_PyNone: {
            return 0;
        }
MMD_PyLong: {
            PMC *temp = pmc_new(INTERP, PyBuiltin_PyLong);
            VTABLE_set_integer_native(INTERP, temp, PMC_int_val(SELF));
            return mmd_dispatch_i_pp(INTERP, temp, value, MMD_EQ);
        }
MMD_DEFAULT: {
            return (INTVAL)(PMC_int_val(SELF) ==
                VTABLE_get_integer(INTERP, value));
        }
    }

/*

=item C<void logical_not(PMC *value)>

Calculates the logical negation of the integer and returns the result in
C<*value>.

=cut

*/

    void logical_not (PMC* value) {
        VTABLE_set_integer_native(INTERP, value, !PMC_int_val(SELF));
    }

/*

=item C<void modulus(PMC *value, PMC *dest)>

Calculates the value of the integer C-style C<mod> C<*value> and returns
the result in C<*dest>.

=cut

*/

    void modulus (PMC* value, PMC* dest) {
MMD_PyInt: {
            INTVAL pmci = PMC_int_val(SELF);
            INTVAL vali = VTABLE_get_integer(INTERP, value);
            INTVAL xdivy = pmci / vali;
            INTVAL xmody = pmci - xdivy * vali;
            if (xmody && ((vali ^ xmody) < 0) /* i.e. and signs differ */) {
                xmody += vali;
            }
            VTABLE_set_integer_native(INTERP, dest, xmody);
        }
MMD_PyLong: {
            promote(INTERP, SELF, value, dest, MMD_MOD);
        }
    }

/*

=item C<void modulus_int(INTVAL value, PMC *dest) >

Calculates the value of the integer C-style C<mod> C<value> and returns
the result in C<*dest>.

=cut

*/

    void modulus_int (INTVAL value, PMC* dest) {
        INTVAL pmci = PMC_int_val(SELF);
        INTVAL xdivy = pmci / value;
        INTVAL xmody = pmci - xdivy * value;
        if (xmody && ((value ^ xmody) < 0) /* i.e. and signs differ */) {
            xmody += value;
        }
        VTABLE_set_integer_native(INTERP, dest, xmody);
    }

/*

=item C<void multiply(PMC *value, PMC *dest)>

Multiplies C<*value> with the integer and returns the result in C<*dest>.

=cut

*/

    void multiply (PMC* value, PMC* dest) {
MMD_PyInt: {
            INTVAL a = PMC_int_val(SELF);
            INTVAL b = PMC_int_val(value);
            double cf = (double)a * (double)b;
            INTVAL c = a * b;
            if ((double) c == cf)
                VTABLE_set_integer_native(INTERP, dest, c);
            else
                overflow(INTERP, SELF, b, dest, MMD_MULTIPLY_INT);
        }
MMD_PyLong: {
            promote(INTERP, SELF, value, dest, MMD_MULTIPLY);
        }
MMD_PyFloat: {
            INTVAL pmci = PMC_int_val(SELF);
            FLOATVAL valf = VTABLE_get_number(INTERP, value);
            /* XXX: Morph? */
            VTABLE_set_number_native(INTERP, dest, pmci * valf);
        }
    }

/*

=item C<void multiply_int(INTVAL value, PMC *dest)>

Multiplies C<*value> with the integer and returns the result in C<*dest>.

=cut

*/

    void multiply_int (INTVAL b, PMC* dest) {
        INTVAL a = PMC_int_val(SELF);
        double cf = (double)a * (double)b;
        INTVAL c = a * b;
        if ((double) c == cf)
            VTABLE_set_integer_native(INTERP, dest, c);
        else
            overflow(INTERP, SELF, b, dest, MMD_MULTIPLY_INT);
    }

/*

=item C<void neg(PMC *dest)>

Set C<dest> to the negated value of C<SELF>.

=cut

*/

    void neg (PMC* dest) {
        if (dest == SELF)
            PMC_int_val(SELF) = -PMC_int_val(SELF);
        else
            VTABLE_set_integer_native(INTERP, dest, -PMC_int_val(SELF));
    }

/*

=item C<PMC* pow(PMC *value, PMC *dest)>

Raises C<SELF> to the power of C<*value> and returns the result.

=cut

*/

    void pow (PMC *value, PMC *dest) {
MMD_PyInt: {
            INTVAL vali = VTABLE_get_integer(INTERP, value);
            mmd_dispatch_v_pip(INTERP, SELF, vali, dest, MMD_POW_INT);
        }
MMD_PyFloat: {
            FLOATVAL valf = VTABLE_get_number(INTERP, value);
            mmd_dispatch_v_pnp(INTERP, SELF, valf, dest, MMD_POW_FLOAT);
        }
    }

/*

=item C<PMC* pow_float(FLOATVAL value, PMC *dest)>

Raises C<SELF> to the power of C<*value> and returns the result.

=cut

*/

    void pow_float (FLOATVAL value, PMC *dest) {
        FLOATVAL pmcf = VTABLE_get_number(INTERP, SELF);
        VTABLE_morph(INTERP, dest, PyBuiltin_PyFloat);
        VTABLE_set_number_native(INTERP, dest, (FLOATVAL) pow(pmcf, value) );
    }

/*

=item C<PMC* pow_int(INTVAL *value, PMC *dest)>

Raises C<SELF> to the power of C<*value> and returns the result.

=cut

*/

    void pow_int (INTVAL value, PMC *dest) {
        if (value < 0)
            mmd_dispatch_v_pnp(INTERP, SELF, 
                (FLOATVAL)value, dest, MMD_POW_FLOAT);
        else {
            int i;
            INTVAL pmci = PMC_int_val(SELF);
            VTABLE_morph(INTERP, dest, PyBuiltin_PyInt);
            PMC_int_val(dest) = 1;
            for (i=1; i<=value; i++) {
                mmd_dispatch_v_pip(INTERP, dest, pmci, dest, MMD_MULTIPLY_INT);
            }
        }
    }

/*

=item C<void set_integer_native(INTVAL value)>

Sets the value of the integer to the value of the C<PyInt> C<*value>.

=cut

*/

    void set_integer_native (INTVAL value) {
        PMC_int_val(SELF) = value;
    }

/*

=item C<void set_integer_same(PMC *value)>

Sets the value of the integer to the value of the C<PyInt> C<*value>.

=cut

*/

    void set_integer_same (PMC * value) {
        PMC_int_val(SELF) = PMC_int_val(value);
    }

/*

=item C<void set_pmc(PMC *value)>

Sets the PMC C<*value>, calling the appropriate C<set_*> method
according to the type of C<*value>.

=cut

*/

    void set_pmc (PMC* value) {
        if (SELF->vtable->base_type == value->vtable->base_type) {
            DYNSELF.set_integer_same(value);
        }
        else {
            DYNSELF.morph(value->vtable->base_type);
            DYNSELF.set_pmc(value);
        }
    }

/*

=item C<void subtract(PMC *value, PMC *dest)>

Subtracts C<*value> from the integer and returns the result in C<*dest>.

=cut

*/

    void subtract (PMC* value, PMC* dest) {
MMD_PyInt: {
            INTVAL pmci = PMC_int_val(SELF);
            INTVAL vali = VTABLE_get_integer(INTERP, value);
            VTABLE_set_integer_native(INTERP, dest, pmci - vali);
        }
MMD_PyFloat: {
            INTVAL pmci = PMC_int_val(SELF);
            FLOATVAL valf = VTABLE_get_number(INTERP, value);
            /* XXX: Morph? */
            VTABLE_set_number_native(INTERP, dest, pmci - valf);
        }
    }

/*

=item C<void subtract_int(INTVAL value, PMC *dest)>

Subtracts C<value> from the integer and returns the result in C<*dest>.

=cut

*/

    void subtract_int (INTVAL value, PMC* dest) {
        VTABLE_set_integer_native(INTERP, dest,
            PMC_int_val(SELF) - value
        );
    }

/*

=back

=cut

*/

}

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
