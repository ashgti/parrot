/*
Copyright: 2001-2003 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

classes/pyclass.pmc - Python Class

=head1 DESCRIPTION

These are the vtable functions for the Python Class base class (i.e., 
methods you would expect to see on python objects).

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

/* cache of classes referenced */
static INTVAL dynclass_PyType;
static STRING *CLASS;
static STRING *ITER;
static STRING *NAME;
static STRING *REPR;
static STRING *STR;

pmclass PyClass dynpmc group python_group {

/*

=item C<void class_init()>

Class initialization. Caches the type id of various PMCs because
they will be used frequently here.

=cut

*/

    void class_init() {
        if (pass) {
            dynclass_PyType = Parrot_PMC_typenum(INTERP, "PyType");
            CLASS = const_string(INTERP, "__class__");
            ITER = const_string(INTERP, "__iter__");
            NAME = const_string(INTERP, "__name__");
            REPR = const_string(INTERP, "__repr__");
            STR  = const_string(INTERP, "__str__");
        }
    }

/*

=item C<void destroy()>

Destroys the object.

=cut

*/

    void destroy () {
    }

/*

=item C<PMC *find_method(STRING *method_name)>

Looks up the method for C<*method_name> and returns it.

=cut

*/

    PMC* find_method(STRING* method_name) {
        PMC *class;

        PMC *method = VTABLE_getprop(INTERP, SELF, method_name);
        if (method && VTABLE_defined(INTERP, method)) return method;

        class = VTABLE_getprop(INTERP, SELF, CLASS);
        if (class) {
            return VTABLE_find_method(INTERP, class, method_name);
        }

        return 0;
    }

/*

=item C<PMC* get_attr_str(STRING *name)>

Return attribute named C<name>.

=cut

*/

    PMC* get_attr_str(STRING* idx) {
        PMC *class;

        PMC *attr = VTABLE_getprop(INTERP, SELF, idx);
        if (attr && VTABLE_defined(INTERP, attr)) return attr;

        class = VTABLE_getprop(INTERP, SELF, CLASS);
        if (class) {
            attr = VTABLE_get_attr_str(INTERP, class, idx);
        }

        if (!attr || !VTABLE_defined(INTERP, attr)) {
            STRING *message;
            message = Parrot_sprintf_c(INTERP, "AttributeError: %s",
                string_to_cstring(INTERP, idx));
            real_exception(INTERP, NULL, E_AttributeError,
                string_to_cstring(INTERP, message));
        }

        return attr;
    }

/*

=item C<PMC *get_class()>

Return the class of this object.

=cut

*/

    PMC* get_class() {
        PMC *ret = VTABLE_getprop(INTERP, SELF, CLASS);
        return ret;
    }

/*

=item C<PMC *get_iter()>

Return an iterator for this object.

=cut

*/

    PMC* get_iter() {
        PMC *iter = VTABLE_find_method(INTERP, SELF, ITER);
        if (!iter || !VTABLE_defined(INTERP, iter))
           real_exception(INTERP, NULL, E_TypeError,
                   "TypeError: iteration over non-sequence");
        return (PMC*) Parrot_run_meth_fromc_args(INTERP, iter, SELF,
            REPR, "P");
    }

/*

=item C<STRING *get_repr()>

Return the representation of this object.

=cut

*/

    STRING* get_repr() {
        PMC *repr = VTABLE_find_method(INTERP, SELF, REPR);

        if (repr) {
            PMC *ret;
            ret = Parrot_run_meth_fromc_args(INTERP, repr, SELF, REPR, "P");
            return VTABLE_get_string(INTERP, ret);
        }
        else {
            STRING *res;

            res = string_from_cstring(INTERP, "<", 0);
            res = string_append(INTERP, res,
                VTABLE_name(INTERP, VTABLE_get_class(INTERP, SELF)), 0);
            res = string_append(INTERP, res,
                const_string(INTERP, " instance at "), 0);
            res = string_append(INTERP, res,
                Parrot_sprintf_c(INTERP, "%#x", (INTVAL) SELF), 0);
            res = string_append(INTERP, res,
                const_string(INTERP, ">"), 0);

            return res;
        }
    }

/*

=item C<STRING *get_string()>

Return the object in string form.

=cut

*/

    STRING* get_string() {
        PMC *repr = VTABLE_find_method(INTERP, SELF, STR);
        if (repr) {
            PMC *ret;
            ret = Parrot_run_meth_fromc_args(INTERP, repr, SELF, REPR, "P");
            return VTABLE_get_string(INTERP, ret);
        }
        else {
            return VTABLE_get_repr(INTERP, SELF);
        }
    }

/*

=item C<STRING *name()>

Returns the name of this class.

*/


    STRING* name() {
        return VTABLE_name(INTERP, VTABLE_get_class(INTERP, SELF));
    }

/*

=back

=cut

*/

}

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
