/*
Copyright: 2005 The Perl Foundation.  All Rights Reserved.
$Id:$

=head1 NAME

dynclasses/dynlexpad.pmc - DynLexPad PMC

=head1 DESCRIPTION

DynLexPad provides a more dynamic lexpad that allows the addition of lexicals at runtime.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass DynLexPad dynpmc does lexpad need_ext {

    void init() {
        real_exception(INTERP, NULL, INVALID_OPERATION,
                "don't create me like this");
    }

/*

=item C<init_pmc(PMC *lexinfo)>

Initialize the LexPad PMC and remember the associate
lexinfo.

=item C<void set_pointer(void *)>

Initialize the LexPad PMC and remember the associate context.

=item C<INTVAL elements()>

Returns the number of elements in the hash.

=item C<INTVAL exists_keyed(PMC *name)>

=item C<INTVAL exists_keyed_str(STRING *name)>

Returns whether a lexical C<name> exists in the hash.

=item C<PMC *get_pmc_keyed_str(STRING *name)>

=item C<PMC *get_pmc_keyed(PMC *name)>

Return the lexical with the given name, or NULL (not PMCNULL), if the
lexical doesn't exist.

=item C<void set_pmc_keyed(PMC *name, PMC *value)>

=item C<void set_pmc_keyed_str(STRING *name, PMC *value)>

Set the lexical with the given name to value. If the lexical name
doesn't exist, it is created.

=item C<METHOD PMC* get_lexinfo()>

Return the LexInfo PMC, if any or a Null PMC.

=cut

*/
    void init_pmc(PMC* lexinfo) {
        if (VTABLE_elements(INTERP, lexinfo)) {
            PMC_pmc_val(SELF) =
                pmc_new_init(INTERP, enum_class_LexPad, lexinfo);
        }
        else
            PMC_pmc_val(SELF) = NULL;
        new_pmc_hash(INTERP, SELF);
        PObj_custom_mark_destroy_SETALL(SELF);
    }

    void set_pointer(void* ctx) {
        PMC *std_pad = PMC_pmc_val(SELF);
        if (std_pad)
            VTABLE_set_pointer(INTERP, std_pad, ctx);
    }

    void destroy () {
        if (PMC_struct_val(SELF)) {
            hash_destroy(INTERP, (Hash*) PMC_struct_val(SELF));
            PMC_struct_val(SELF) = NULL;
        }
    }
/*

=item C<void mark()>

Marks the lexpad hash as live.

=cut

*/

    void mark () {
        PMC *std_pad = PMC_pmc_val(SELF);
        if (std_pad)
            pobject_lives(INTERP, (PObj *)std_pad);
        if (PMC_struct_val(SELF))
            mark_hash(INTERP, PMC_struct_val(SELF));
    }

    PMC* get_pmc_keyed_str (STRING* name) {
        HashBucket *b = hash_get_bucket(INTERP,
            (Hash*) PMC_struct_val(SELF), name);
        if (!b) {
            PMC *std_pad = PMC_pmc_val(SELF);
            if (std_pad)
                return VTABLE_get_pmc_keyed_str(INTERP, std_pad, name);
            return PMCNULL;
        }
        return b->value;
    }

    INTVAL exists_keyed_str(STRING* name) {
        PMC *std_pad;
        if (hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF), name))
            return 1;
        std_pad = PMC_pmc_val(SELF);
        if (std_pad)
            return VTABLE_exists_keyed_str(INTERP, std_pad, name);
        return 0;
    }

    INTVAL exists_keyed(PMC* name) {
        STRING *s = key_string(INTERP, name);
        return SELF.exists_keyed_str(s);
    }

    PMC* get_pmc_keyed(PMC* name) {
        STRING *s = key_string(INTERP, name);
        return SELF.get_pmc_keyed_str(s);
    }

    void set_pmc_keyed_str (STRING* name, PMC* value) {
        PMC *std_pad = PMC_pmc_val(SELF);
        if (std_pad && VTABLE_exists_keyed_str(INTERP, std_pad, name)) {
            VTABLE_set_pmc_keyed_str(INTERP, std_pad, name, value);
        }
        hash_put(INTERP, PMC_struct_val(SELF), name, value);
    }

    void set_pmc_keyed(PMC* name, PMC* value) {
        STRING *s = key_string(INTERP, name);
        SELF.set_pmc_keyed_str(s, value);
    }

}


/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd20_lecical_vars.pod>, F<classes/lexpad.pmc>, F<classes/lexinfo.pmc>.

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
