/* basic_opcodes.c
 *
 * Just some basic opcodes
 *
 */

#include "parrot.h"

// SET Ix, CONSTANT
AUTO_OP set_i_ic {
  INT_REG(P1) = P2;
}
  
// SET Ix, Ix
AUTO_OP set_i {
  INT_REG(P1) = INT_REG(P2);
}
  
// ADD Ix, Iy, Iz  
AUTO_OP add_i {
  INT_REG(P1) = INT_REG(P2) +
                           INT_REG(P3);
}

// SUB Ix, Iy, Iz  
AUTO_OP sub_i {
  INT_REG(P1) = INT_REG(P2) -
                           INT_REG(P3);
}

// MUL Ix, Iy, Iz  
AUTO_OP mul_i {
  INT_REG(P1) = INT_REG(P2) *
                           INT_REG(P3);
}

// DIV Ix, Iy, Iz  
AUTO_OP div_i {
  INT_REG(P1) = INT_REG(P2) /
                           INT_REG(P3);
}

// MOD Ix, Iy, Iz  
AUTO_OP mod_i {
  INT_REG(P1) = INT_REG(P2) %
                           INT_REG(P3);
}

// EQ Ix, Iy, EQ_BRANCH, NE_BRANCH
MANUAL_OP eq_i_ic {
  if (INT_REG(P1) == INT_REG(P2)) {
    RETURN(P3);
  } else {
    RETURN(P4);
  }
}

// NE Ix, Iy, NE_BRANCH, EQ_BRANCH
MANUAL_OP ne_i_ic {
  if (INT_REG(P1) != INT_REG(P2)) {
    RETURN(P3);
  } else {
    RETURN(P4);
  }
}

// LT Ix, Iy, LT_BRANCH, GE_BRANCH
MANUAL_OP lt_i_ic {
  if (INT_REG(P1) < INT_REG(P2)) {
    RETURN(P3);
  } else {
    RETURN(P4);
  }
}

// LE Ix, Iy, LE_BRANCH, GT_BRANCH
MANUAL_OP le_i_ic {
  if (INT_REG(P1) <= INT_REG(P2)) {
    RETURN(P3);
  } else {
    RETURN(P4);
  }
}

// GT Ix, Iy, GT_BRANCH, LE_BRANCH
MANUAL_OP gt_i_ic {
  if (INT_REG(P1) > INT_REG(P2)) {
    RETURN(P3);
  } else {
    RETURN(P4);
  }
}

// GE Ix, Iy, GE_BRANCH, LT_BRANCH
MANUAL_OP ge_i_ic {
  if (INT_REG(P1) >= INT_REG(P2)) {
    RETURN(P3);
  } else {
    RETURN(P4);
  }
}

// IF IXx, TRUE_BRANCH, FALSE_BRANCH
MANUAL_OP if_i_ic {
  if (INT_REG(P1)) {
    RETURN(P2);
  } else {
    RETURN(P3);
  }
}

// TIME Ix
AUTO_OP time_i {
  INT_REG(P1) = time(NULL);
}

// PRINT Ix
AUTO_OP print_i {
  printf("I reg %li is %li\n", P1, INT_REG(P1));
}
 
// BRANCH CONSTANT
MANUAL_OP branch_ic {
  RETURN(P1);
}

// END
MANUAL_OP end {
   RETURN(0);
}

// INC Ix
AUTO_OP inc_i {
  INT_REG(P1)++;
}

// INC Ix, nnn
AUTO_OP inc_i_ic {
  INT_REG(P1) += P2;
}

// DEC Ix
AUTO_OP dec_i {
  INT_REG(P1)--;
}

// DEC Ix, nnn
AUTO_OP dec_i_ic {
  INT_REG(P1) -= P2;
}

// JUMP Ix
MANUAL_OP jump_i {
  RETURN(INT_REG(P1));
}

// SET Nx, CONSTANT
AUTO_OP set_n_nc {
  NUM_REG(P1) = P2;
}
  
// ADD Nx, Ny, Nz  
AUTO_OP add_n {
  NUM_REG(P1) = NUM_REG(P2) +
                           NUM_REG(P3);
}

// SUB Nx, Ny, Iz  
AUTO_OP sub_n {
  NUM_REG(P1) = NUM_REG(P2) -
                           NUM_REG(P3);
}

// MUL Nx, Ny, Iz  
AUTO_OP mul_n {
  NUM_REG(P1) = NUM_REG(P2) *
                           NUM_REG(P3);
}

// DIV Nx, Ny, Iz  
AUTO_OP div_n {
  NUM_REG(P1) = NUM_REG(P2) /
                           NUM_REG(P3);
}

// EQ Nx, Ny, EQ_BRANCH, NE_BRANCH
MANUAL_OP eq_n_ic {
  if (NUM_REG(P1) == NUM_REG(P2)) {
    RETURN(P3);
  } else {
    RETURN(P4);
  }
}

// IF Nx, TRUE_BRANCH, FALSE_BRANCH
MANUAL_OP if_n_ic {
  if (NUM_REG(P1)) {
    RETURN(P2);
  } else {
    RETURN(P3);
  }
}

// TIME Nx
AUTO_OP time_n {
  NUM_REG(P1) = time(NULL);
}

// PRINT Nx
AUTO_OP print_n {
  printf("N reg %li is %Lf\n", P1, NUM_REG(P1));
}
 
// INC Nx
AUTO_OP inc_n {
  NUM_REG(P1) += 1;
}

// INC Nx, nnn
AUTO_OP inc_n_nc {
  (NV)NUM_REG(P1) += P2;
}

// DEC Nx
AUTO_OP dec_n {
  NUM_REG(P1) -= 1;
}

// DEC Nx, nnn
AUTO_OP dec_n_nc {
  NUM_REG(P1) += P2;
}

// ITON Nx, Iy
AUTO_OP iton_n_i {
//  IV number;
//  number = INT_REG(P2);
  NUM_REG(P1) = INT_REG(P2);
}

// NTOI Ix, Ny
AUTO_OP ntoi_i_n {
  NV number;
  number = NUM_REG(P2);
  INT_REG(P1) = number;
}

// PUSH_I
AUTO_OP push_i {
  Parrot_push_i(interpreter);
}

// PUSH_N
AUTO_OP push_n {
  Parrot_push_n(interpreter);
}

// PUSH_S
AUTO_OP push_s {
  Parrot_push_s(interpreter);
}

// PUSH_P
AUTO_OP push_p {
  Parrot_push_p(interpreter);
}

// POP_I
AUTO_OP pop_i {
  Parrot_pop_i(interpreter);
}

// POP_N
AUTO_OP pop_n {
  Parrot_pop_n(interpreter);
}

// POP_S
AUTO_OP pop_s {
  Parrot_pop_s(interpreter);
}

// POP_P
AUTO_OP pop_p {
  Parrot_pop_p(interpreter);
}

// CLEAR_I
AUTO_OP clear_i
  Parrot_clear_i(interpreter);
}

// CLEAR_N
AUTO_OP clear_n {
  Parrot_clear_n(interpreter);
}

// CLEAR_S
AUTO_OP clear_s {
  Parrot_clear_s(interpreter);
}

// CLEAR_P
AUTO_OP clear_p {
  Parrot_clear_p(interpreter);
}

// SET Sx, CONSTANT
AUTO_OP set_s_sc {
  STR_REG(P1) = Parrot_string_constants[P2];
}

// PRINT Sx
AUTO_OP print_s {
  STRING *s = STR_REG(P1); 
   printf("S reg %li is %.*s\n", P1, (int) string_length(s), (char *) s->bufstart);
}

// LEN Ix, Sx
AUTO_OP length_i_s {
  INT_REG(P1) = string_length(STR_REG(P2));
}

// CHOPN Sx, CONSTANT
AUTO_OP chopn_s_ic {
   string_chopn(STR_REG(P1), P2);
}

// SUBSTR Sx, Sx, Ix, Ix
AUTO_OP substr_s_s_i {
    STRING *s = string_substr(STR_REG(P2), INT_REG(P3), INT_REG(P4), &STR_REG(P1));
    STR_REG(P1) = s;
}

// NOOP
AUTO_OP noop {
}
