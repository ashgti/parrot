/* basic_opcodes.c
 *
 * Just some basic opcodes
 *
 */

#include "parrot.h"
#include "math.h"

// SET Ix, CONSTANT
AUTO_OP set_i_ic {
  INT_REG(P1) = P2;
}
  
// SET Ix, Ix
AUTO_OP set_i {
  INT_REG(P1) = INT_REG(P2);
}
  
// ADD Ix, Iy, Iz  
AUTO_OP add_i {
  INT_REG(P1) = INT_REG(P2) +
                           INT_REG(P3);
}

// SUB Ix, Iy, Iz  
AUTO_OP sub_i {
  INT_REG(P1) = INT_REG(P2) -
                           INT_REG(P3);
}

// MUL Ix, Iy, Iz  
AUTO_OP mul_i {
  INT_REG(P1) = INT_REG(P2) *
                           INT_REG(P3);
}

// DIV Ix, Iy, Iz  
AUTO_OP div_i {
  INT_REG(P1) = INT_REG(P2) /
                           INT_REG(P3);
}

// MOD Ix, Iy, Iz  
AUTO_OP mod_i {
  INT_REG(P1) = INT_REG(P2) %
                           INT_REG(P3);
}

// EQ Ix, Iy, EQ_BRANCH, NE_BRANCH
MANUAL_OP eq_i_ic {
  if (INT_REG(P1) == INT_REG(P2)) {
    RETURN(P3);
  } else {
    RETURN(P4);
  }
}

// NE Ix, Iy, NE_BRANCH, EQ_BRANCH
MANUAL_OP ne_i_ic {
  if (INT_REG(P1) != INT_REG(P2)) {
    RETURN(P3);
  } else {
    RETURN(P4);
  }
}

// LT Ix, Iy, LT_BRANCH, GE_BRANCH
MANUAL_OP lt_i_ic {
  if (INT_REG(P1) < INT_REG(P2)) {
    RETURN(P3);
  } else {
    RETURN(P4);
  }
}

// LE Ix, Iy, LE_BRANCH, GT_BRANCH
MANUAL_OP le_i_ic {
  if (INT_REG(P1) <= INT_REG(P2)) {
    RETURN(P3);
  } else {
    RETURN(P4);
  }
}

// GT Ix, Iy, GT_BRANCH, LE_BRANCH
MANUAL_OP gt_i_ic {
  if (INT_REG(P1) > INT_REG(P2)) {
    RETURN(P3);
  } else {
    RETURN(P4);
  }
}

// GE Ix, Iy, GE_BRANCH, LT_BRANCH
MANUAL_OP ge_i_ic {
  if (INT_REG(P1) >= INT_REG(P2)) {
    RETURN(P3);
  } else {
    RETURN(P4);
  }
}

// IF IXx, TRUE_BRANCH, FALSE_BRANCH
MANUAL_OP if_i_ic {
  if (INT_REG(P1)) {
    RETURN(P2);
  } else {
    RETURN(P3);
  }
}

// TIME Ix
AUTO_OP time_i {
  INT_REG(P1) = time(NULL);
}

// PRINT Ix
AUTO_OP print_i {
  printf("I reg %li is %li\n", P1, INT_REG(P1));
}
 
// BRANCH CONSTANT
MANUAL_OP branch_ic {
  RETURN(P1);
}

// END
MANUAL_OP end {
   RETURN(0);
}

// INC Ix
AUTO_OP inc_i {
  INT_REG(P1)++;
}

// INC Ix, nnn
AUTO_OP inc_i_ic {
  INT_REG(P1) += P2;
}

// DEC Ix
AUTO_OP dec_i {
  INT_REG(P1)--;
}

// DEC Ix, nnn
AUTO_OP dec_i_ic {
  INT_REG(P1) -= P2;
}

// JUMP Ix
MANUAL_OP jump_i {
  RETURN(INT_REG(P1));
}

// SET Nx, CONSTANT
AUTO_OP set_n_nc {
  NUM_REG(P1) = P2;
}
  
// ADD Nx, Ny, Nz  
AUTO_OP add_n {
  NUM_REG(P1) = NUM_REG(P2) +
                           NUM_REG(P3);
}

// SUB Nx, Ny, Iz  
AUTO_OP sub_n {
  NUM_REG(P1) = NUM_REG(P2) -
                           NUM_REG(P3);
}

// MUL Nx, Ny, Iz  
AUTO_OP mul_n {
  NUM_REG(P1) = NUM_REG(P2) *
                           NUM_REG(P3);
}

// DIV Nx, Ny, Iz  
AUTO_OP div_n {
  NUM_REG(P1) = NUM_REG(P2) /
                           NUM_REG(P3);
}

// EQ Nx, Ny, EQ_BRANCH, NE_BRANCH
MANUAL_OP eq_n_ic {
  if (NUM_REG(P1) == NUM_REG(P2)) {
    RETURN(P3);
  } else {
    RETURN(P4);
  }
}

// IF Nx, TRUE_BRANCH, FALSE_BRANCH
MANUAL_OP if_n_ic {
  if (NUM_REG(P1)) {
    RETURN(P2);
  } else {
    RETURN(P3);
  }
}

// TIME Nx
AUTO_OP time_n {
  NUM_REG(P1) = time(NULL);
}

// PRINT Nx
AUTO_OP print_n {
  printf("N reg %li is %f\n", P1, NUM_REG(P1));
}
 
// INC Nx
AUTO_OP inc_n {
  NUM_REG(P1) += 1;
}

// INC Nx, nnn
AUTO_OP inc_n_nc {
  NUM_REG(P1) += P2;
}

// DEC Nx
AUTO_OP dec_n {
  NUM_REG(P1) -= 1;
}

// DEC Nx, nnn
AUTO_OP dec_n_nc {
  NUM_REG(P1) += P2;
}

// ITON Nx, Iy
AUTO_OP iton_n_i {
//  IV number;
//  number = INT_REG(P2);
  NUM_REG(P1) = INT_REG(P2);
}

// NTOI Ix, Ny
AUTO_OP ntoi_i_n {
  NV number;
  number = NUM_REG(P2);
  INT_REG(P1) = number;
}

// PUSH_I
AUTO_OP push_i {
  Parrot_push_i(interpreter);
}

// PUSH_N
AUTO_OP push_n {
  Parrot_push_n(interpreter);
}

// PUSH_S
AUTO_OP push_s {
  Parrot_push_s(interpreter);
}

// PUSH_P
AUTO_OP push_p {
  Parrot_push_p(interpreter);
}

// POP_I
AUTO_OP pop_i {
  Parrot_pop_i(interpreter);
}

// POP_N
AUTO_OP pop_n {
  Parrot_pop_n(interpreter);
}

// POP_S
AUTO_OP pop_s {
  Parrot_pop_s(interpreter);
}

// POP_P
AUTO_OP pop_p {
  Parrot_pop_p(interpreter);
}

// CLEAR_I
AUTO_OP clear_i
  Parrot_clear_i(interpreter);
}

// CLEAR_N
AUTO_OP clear_n {
  Parrot_clear_n(interpreter);
}

// CLEAR_S
AUTO_OP clear_s {
  Parrot_clear_s(interpreter);
}

// CLEAR_P
AUTO_OP clear_p {
  Parrot_clear_p(interpreter);
}

// SET Sx, CONSTANT
AUTO_OP set_s_sc {
  STR_REG(P1) = Parrot_string_constants[P2];
}

// PRINT Sx
AUTO_OP print_s {
  STRING *s = STR_REG(P1); 
   printf("S reg %li is %.*s\n", P1, (int) string_length(s), (char *) s->bufstart);
}

// LEN Ix, Sx
AUTO_OP length_i_s {
  INT_REG(P1) = string_length(STR_REG(P2));
}

// CHOPN Sx, CONSTANT
AUTO_OP chopn_s_ic {
   string_chopn(STR_REG(P1), P2);
}

// SUBSTR Sx, Sx, Ix, Ix
AUTO_OP substr_s_s_i {
    STRING *s = string_substr(STR_REG(P2), INT_REG(P3), INT_REG(P4), &STR_REG(P1));
    STR_REG(P1) = s;
}

// NOOP
AUTO_OP noop {
}

// TRANSCENDENTAL MATH FUNCTIONS

// sin_n_n
AUTO_OP sin_n_n {
   NUM_REG(P1) = sin(NUM_REG(P2));
}

// cos_n_n
AUTO_OP cos_n_n {
   NUM_REG(P1) = cos(NUM_REG(P2));
}

// tan_n_n
AUTO_OP tan_n_n {
   NUM_REG(P1) = tan(NUM_REG(P2));
}

// sec_n_n
AUTO_OP sec_n_n {
   NUM_REG(P1) = ((NV)1) / cos(NUM_REG(P2));
}

// atan_n_n
AUTO_OP atan_n_n {
   NUM_REG(P1) = atan(NUM_REG(P2));
}

// atan2_n_n_n
AUTO_OP atan2_n_n_n {
   NUM_REG(P1) = atan2(NUM_REG(P2), NUM_REG(P3));
}

// asin_n_n
AUTO_OP asin_n_n {
   NUM_REG(P1) = asin(NUM_REG(P2));
}

// acos_n_n
AUTO_OP acos_n_n {
   NUM_REG(P1) = acos(NUM_REG(P2));
}

// asec_n_n
AUTO_OP asec_n_n {
   NUM_REG(P1) = acos(((NV)1) / NUM_REG(P2));
}

// cosh_n_n
AUTO_OP cosh_n_n {
   NUM_REG(P1) = cosh(NUM_REG(P2));
}

// sinh_n_n
AUTO_OP sinh_n_n {
   NUM_REG(P1) = sinh(NUM_REG(P2));
}

// tanh_n_n
AUTO_OP tanh_n_n {
   NUM_REG(P1) = tanh(NUM_REG(P2));
}

// sech_n_n
AUTO_OP sech_n_n {
   NUM_REG(P1) = ((NV)1) / cosh(NUM_REG(P2));
}

// log2_n_n
AUTO_OP log2_n_n {
   NUM_REG(P1) = log(NUM_REG(P2)) / log((NV)2);
}

// log10_n_n
AUTO_OP log10_n_n {
   NUM_REG(P1) = log10(NUM_REG(P2));
}

// ln_n_n
AUTO_OP ln_n_n {
   NUM_REG(P1) = log(NUM_REG(P2));
}

// exp_n_n
AUTO_OP exp_n_n {
   NUM_REG(P1) = exp(NUM_REG(P2));
}

// pow_n_n_n
AUTO_OP pow_n_n_n {
   NUM_REG(P1) = pow(NUM_REG(P2), NUM_REG(P3));
}

// sin_n_i
AUTO_OP sin_n_i {
   NUM_REG(P1) = sin(INT_REG(P2));
}

// cos_n_i
AUTO_OP cos_n_i {
   NUM_REG(P1) = cos(INT_REG(P2));
}

// tan_n_i
AUTO_OP tan_n_i {
   NUM_REG(P1) = tan(INT_REG(P2));
}

// sec_n_i
AUTO_OP sec_n_i {
   NUM_REG(P1) = ((NV)1) / cos(INT_REG(P2));
}

// atan_n_i
AUTO_OP atan_n_i {
   NUM_REG(P1) = atan(INT_REG(P2));
}

// atan2_n_n_i
AUTO_OP atan2_n_n_i {
   NUM_REG(P1) = atan2(NUM_REG(P2), INT_REG(P3));
}

// atan2_n_i_n
AUTO_OP atan2_n_i_n {
   NUM_REG(P1) = atan2(INT_REG(P2), NUM_REG(P3));
}

// atan2_n_i_i
AUTO_OP atan2_n_i_i {
   NUM_REG(P1) = atan2(INT_REG(P2), INT_REG(P3));
}

// asin_n_i
AUTO_OP asin_n_i {
   NUM_REG(P1) = asin(INT_REG(P2));
}

// acos_n_i
AUTO_OP acos_n_i {
   NUM_REG(P1) = acos(INT_REG(P2));
}

// asec_n_i
AUTO_OP asec_n_i {
   NUM_REG(P1) = acos(((NV)1) / ((NV)INT_REG(P2)));
}

// cosh_n_i
AUTO_OP cosh_n_i {
   NUM_REG(P1) = cosh(INT_REG(P2));
}

// sinh_n_i
AUTO_OP sinh_n_i {
   NUM_REG(P1) = sinh(INT_REG(P2));
}

// tanh_n_i
AUTO_OP tanh_n_i {
   NUM_REG(P1) = tanh(INT_REG(P2));
}

// sech_n_i
AUTO_OP sech_n_i {
   NUM_REG(P1) = ((NV)1) / cosh(INT_REG(P2));
}

// log2_n_i
AUTO_OP log2_n_i {
   NUM_REG(P1) = log(INT_REG(P2)) / log((NV)2);
}

// log10_n_i
AUTO_OP log10_n_i {
   NUM_REG(P1) = log10(INT_REG(P2));
}

// ln_n_i
AUTO_OP ln_n_i {
   NUM_REG(P1) = log(INT_REG(P2));
}

// exp_n_i
AUTO_OP exp_n_i {
   NUM_REG(P1) = exp(INT_REG(P2));
}

// pow_n_n_i
AUTO_OP pow_n_n_i {
   NUM_REG(P1) = pow(NUM_REG(P2), INT_REG(P3));
}

// pow_n_i_i
AUTO_OP pow_n_i_i {
   NUM_REG(P1) = pow(INT_REG(P2), INT_REG(P3));
}

// pow_n_n_i
AUTO_OP pow_n_i_n {
   NUM_REG(P1) = pow(INT_REG(P2), NUM_REG(P3));
}

// AND_i
AUTO_OP and_i {
  INT_REG(P1) = INT_REG(P2) & INT_REG(P3);
}

// NOT_i
AUTO_OP not_i {
  INT_REG(P1) = ! INT_REG(P2);
}

// OR_i
AUTO_OP or_i {
  INT_REG(P1) = INT_REG(P2) | INT_REG(P3);
}

// SHL_i_ic
AUTO_OP shl_i_ic {
  INT_REG(P1) = INT_REG(P2) << P3;
}

// SHR_i_ic
AUTO_OP shr_i_ic {
  INT_REG(P1) = INT_REG(P2) >> P3;
}

// XOR_i
AUTO_OP xor_i {
  INT_REG(P1) = INT_REG(P2) ^ INT_REG(P3);
}
