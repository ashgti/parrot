/* basic_opcodes.c
 *
 * Just some basic opcodes
 *
 */

#include "parrot/parrot.h"
#include <math.h>

/* DEFINES to make true mod work right */

#define OPP_SIGNS(x,y)     ((((x)<0)&&((y)>0))||(((x)>0)&&((y)<0)))
#define REM_INC(x,y)       (((x)%(y))?1:0)
#define INT_FLOOR_DIV(x,y) (OPP_SIGNS(x,y)?(-((-x)/(y)+REM_INC((-x),(y)))):((x)/(y)))
#define INT_MOD(x,y)       (((y)==0)?(x):((x)-(y)*INT_FLOOR_DIV((x),(y))))

/* SET Ix, CONSTANT */
AUTO_OP set_i_ic {
  INT_REG(P1) = INT_CONST(P2);
}
  
/* SET Ix, Ix */
AUTO_OP set_i {
  INT_REG(P1) = INT_REG(P2);
}
  
/* ADD Ix, Iy, Iz   */
AUTO_OP add_i {
  INT_REG(P1) = INT_REG(P2) +
                           INT_REG(P3);
}

/* SUB Ix, Iy, Iz   */
AUTO_OP sub_i {
  INT_REG(P1) = INT_REG(P2) -
                           INT_REG(P3);
}

/* MUL Ix, Iy, Iz   */
AUTO_OP mul_i {
  INT_REG(P1) = INT_REG(P2) *
                           INT_REG(P3);
}

/* DIV Ix, Iy, Iz   */
AUTO_OP div_i {
  INT_REG(P1) = INT_REG(P2) /
                           INT_REG(P3);
}

/*
** mod_i
**
** NOTE: This "corrected mod" algorithm is based on the C code on page 70
** of [1]. Assuming correct behavior of C's built-in mod operator (%) with
** positive arguments, this algorithm implements a mathematically convenient
** version of mod, defined thus:
**
**   x mod y = x - y * floor(x / y)
**
** For more information on this definition of mod, see section 3.4 of [2],
** pages 81-85.
**
** References:
**
**   [1] Donald E. Knuth, *MMIXware: A RISC Computer for the Third
**       Millennium* Springer, 1999.
**
**   [2] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
**       Mathematics*, Second Edition. Addison-Wesley, 1994.
*/

/* MOD Ix, Iy, Iz   */
AUTO_OP mod_i {
  INTVAL y = INT_REG(P2);
  INTVAL z = INT_REG(P3);
  INTVAL s = 0;
  INTVAL r;

  if (z == 0) {
    r = y;
  }
  else {
    if (y < 0) { s += 2; y = -y; }
    if (z < 0) { s += 1; z = -z; }

    r = y % z;

    switch (s) {
      case 0 + 0:            break;
      case 0 + 1: r = r - z; break;
      case 2 + 0: r = z - r; break;
      case 2 + 1: r = -r;    break;
    }
  }

  INT_REG(P1) = r;
}

/*
** cmod_i
**
** NOTE: This "uncorrected mod" algorithm uses the C language's built-in
** mod operator (x % y), which is
**
**     ... the remainder when x is divided by y, and thus is zero when y
**     divides x exactly.
**     ...
**     The direction of truncation for / and the sign of the result for %
**     are machine-dependent for negative operands, as is the action taken
**     on overflow or underflow.
**                                                          -- [1], page 41
**
** Also:
**
**     ... if the second operand is 0, the result is undefined. Otherwise, it
**     is always true that (a/b)*b + a%b is equal to z. If both operands are
**     non-negative, then the remainder is non-negative and smaller than the
**     divisor; if not, it is guaranteed only that the absolute value of the
**     remainder is smaller than the absolute value of the divisor.
**                                                          -- [1], page 205
**
** This op is provided for those who need it (such as speed-sensitive
** applications with heavy use of mod, but using it only with positive
** arguments), but a more mathematically useful mod based on ** floor(x/y)
** and defined with y == 0 is provided by the mod_i op.
**
**   [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
**       Language*, Second Edition. Prentice Hall, 1988.
**
** TODO: Doesn't the Parrot interpreter need to catch the exception?
*/

/* CMOD Ix, Iy, Iz   */
AUTO_OP cmod_i {

  INT_REG(P1) = INT_REG(P2) % INT_REG(P3);
}

/* EQ Ix, Iy, EQ_BRANCH */
MANUAL_OP eq_i_ic {
  if (INT_REG(P1) == INT_REG(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* EQ Ix, CONSTANT, EQ_BRANCH */
MANUAL_OP eq_ic_ic {
  if (INT_REG(P1) == INT_CONST(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* NE Ix, Iy, NE_BRANCH */
MANUAL_OP ne_i_ic {
  if (INT_REG(P1) != INT_REG(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* NE Ix, CONSTANT, NE_BRANCH */
MANUAL_OP ne_ic_ic {
  if (INT_REG(P1) != INT_CONST(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* LT Ix, Iy, LT_BRANCH */
MANUAL_OP lt_i_ic {
  if (INT_REG(P1) < INT_REG(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* LT Ix, CONSTANT, LT_BRANCH */
MANUAL_OP lt_ic_ic {
  if (INT_REG(P1) < INT_CONST(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* LE Ix, Iy, LE_BRANCH */
MANUAL_OP le_i_ic {
  if (INT_REG(P1) <= INT_REG(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* LE Ix, CONSTANT, LE_BRANCH */
MANUAL_OP le_ic_ic {
  if (INT_REG(P1) <= INT_CONST(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* GT Ix, Iy, GT_BRANCH */
MANUAL_OP gt_i_ic {
  if (INT_REG(P1) > INT_REG(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* GT Ix, CONSTANT, GT_BRANCH */
MANUAL_OP gt_ic_ic {
  if (INT_REG(P1) > INT_CONST(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* GE Ix, Iy, GE_BRANCH */
MANUAL_OP ge_i_ic {
  if (INT_REG(P1) >= INT_REG(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* GE Ix, CONSTANT, GE_BRANCH */
MANUAL_OP ge_ic_ic {
  if (INT_REG(P1) >= INT_CONST(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* IF IXx, TRUE_BRANCH */
MANUAL_OP if_i_ic {
  if (INT_REG(P1)) {
    RETURN(INT_CONST(P2));
  }
}

/* TIME Ix */
AUTO_OP time_i {
  INT_REG(P1) = time(NULL);
}

/* PRINT Ix */
AUTO_OP print_i {
  printf("%li", (long) INT_REG(P1));
}

/* PRINT ic */
AUTO_OP print_ic {
  printf("%li", (long) INT_CONST(P1));
}

 
/* BRANCH CONSTANT */
MANUAL_OP branch_ic {
  RETURN(INT_CONST(P1));
}

/* END */
MANUAL_OP end {
   RETURN(0);
}

/* INC Ix */
AUTO_OP inc_i {
  INT_REG(P1)++;
}

/* INC Ix, nnn */
AUTO_OP inc_i_ic {
  INT_REG(P1) += INT_CONST(P2);
}

/* DEC Ix */
AUTO_OP dec_i {
  INT_REG(P1)--;
}

/* DEC Ix, nnn */
AUTO_OP dec_i_ic {
  INT_REG(P1) -= INT_CONST(P2);
}

/* JUMP Ix */
MANUAL_OP jump_i {
  RETURN(INT_REG(P1));
}

/* SET Nx, CONSTANT */
AUTO_OP set_n_nc {
  NUM_REG(P1) = NUM_CONST(P2);
} 

/* SET Nx, Nx */
AUTO_OP set_n {
  NUM_REG(P1) = NUM_REG(P2);
}
  
/* ADD Nx, Ny, Nz   */
AUTO_OP add_n {
  NUM_REG(P1) = NUM_REG(P2) +
                           NUM_REG(P3);
}

/* SUB Nx, Ny, Iz   */
AUTO_OP sub_n {
  NUM_REG(P1) = NUM_REG(P2) -
                           NUM_REG(P3);
}

/* MUL Nx, Ny, Iz   */
AUTO_OP mul_n {
  NUM_REG(P1) = NUM_REG(P2) *
                           NUM_REG(P3);
}

/* DIV Nx, Ny, Iz   */
AUTO_OP div_n {
  NUM_REG(P1) = NUM_REG(P2) /
                           NUM_REG(P3);
}

/*
** mod_n
**
** NOTE: This "corrected mod" algorithm is based on the formula of [1]:
**
**   x mod y = x - y * floor(x / y)
**
** For more information on this definition of mod, see section 3.4 of [1],
** pages 81-85.
**
** References:
**
**   [1] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
**       Mathematics*, Second Edition. Addison-Wesley, 1994.
*/

/* MOD Nx, Ny, Nz   */
AUTO_OP mod_n {

  NUM_REG(P1) = NUM_REG(P3)
    ? (NUM_REG(P2) - NUM_REG(P3) * floor(NUM_REG(P2) / NUM_REG(P3)))
    : NUM_REG(P2);
}

/*
** cmod_n
**
** NOTE: This "uncorrected mod" algorithm uses the built-in C math library's
** fmod() function, which computes
**
**     ... the remainder of dividing x by y. The return value is x - n * y,
**     where n is the quotient of x / y, rounded towards zero to an
**     integer.
**                                     -- fmod() manpage on RedHat Linux 7.0
**
** In addition, fmod() returns
**
**     the remainder, unless y is zero, when the function fails and errno
**     is set.
**
** According to page 251 of [1], the result when y is zero is implementation-
** defined.
**
** This op is provided for those who need it, but a more mathematically
** useful numeric mod based on floor(x/y) instead of truncate(x/y) and
** defined with y == 0 is provided by the mod_n op.
**
**   [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
**       Language*, Second Edition. Prentice Hall, 1988.
**
** TODO: Doesn't the Parrot interpreter need to catch the exception?
*/

/* CMOD Nx, Ny, Nz   */
AUTO_OP cmod_n {
  NUM_REG(P1) = fmod(NUM_REG(P2), NUM_REG(P3));
}

/* EQ Nx, Ny, EQ_BRANCH */
MANUAL_OP eq_n_ic {
  if (NUM_REG(P1) == NUM_REG(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* EQ Nx, CONSTANT, EQ_BRANCH */
MANUAL_OP eq_nc_ic {
  if (NUM_REG(P1) == NUM_CONST(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* NE Nx, Ny, NE_BRANCH */
MANUAL_OP ne_n_ic {
  if (NUM_REG(P1) != NUM_REG(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* NE Nx, CONSTANT, NE_BRANCH */
MANUAL_OP ne_nc_ic {
  if (NUM_REG(P1) != NUM_CONST(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* LT Nx, Ny, LT_BRANCH */
MANUAL_OP lt_n_ic {
  if (NUM_REG(P1) < NUM_REG(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* LT Nx, CONSTANT, LT_BRANCH */
MANUAL_OP lt_nc_ic {
  if (NUM_REG(P1) < NUM_CONST(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* LE Nx, Ny, LE_BRANCH */
MANUAL_OP le_n_ic {
  if (NUM_REG(P1) <= NUM_REG(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* LE Nx, CONSTANT, LE_BRANCH */
MANUAL_OP le_nc_ic {
  if (NUM_REG(P1) <= NUM_CONST(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* GT Nx, Ny, GT_BRANCH */
MANUAL_OP gt_n_ic {
  if (NUM_REG(P1) > NUM_REG(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* GT Nx, CONSTANT, GT_BRANCH */
MANUAL_OP gt_nc_ic {
  if (NUM_REG(P1) > NUM_CONST(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* GE Nx, Ny, GE_BRANCH */
MANUAL_OP ge_n_ic {
  if (NUM_REG(P1) >= NUM_REG(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* GE Nx, CONSTANT, GE_BRANCH */
MANUAL_OP ge_nc_ic {
  if (NUM_REG(P1) >= NUM_CONST(P2)) {
    RETURN(INT_CONST(P3));
  }
}

/* IF Nx, TRUE_BRANCH */
MANUAL_OP if_n_ic {
  if (NUM_REG(P1)) {
    RETURN(INT_CONST(P2));
  }
}

/* TIME Nx */
AUTO_OP time_n {
  NUM_REG(P1) = time(NULL);
}

/* PRINT Nx */
AUTO_OP print_n {
  printf("%f", NUM_REG(P1));
}
 
/* PRINT nc */
AUTO_OP print_nc {
  printf("%f", NUM_CONST(P1));
}

/* INC Nx */
AUTO_OP inc_n {
  NUM_REG(P1) += 1;
}

/* INC Nx, nnn */
AUTO_OP inc_n_nc {
  NUM_REG(P1) += NUM_CONST(P2);
}

/* DEC Nx */
AUTO_OP dec_n {
  NUM_REG(P1) -= 1;
}

/* DEC Nx, nnn */
AUTO_OP dec_n_nc {
  NUM_REG(P1) -= NUM_CONST(P2);
}

/* ITON Nx, Iy */
AUTO_OP iton_n_i {
/*  INTVAL number; */
/*  number = INT_REG(P2); */
  NUM_REG(P1) = INT_REG(P2);
}

/* NTOI Ix, Ny */
AUTO_OP ntoi_i_n {
  FLOATVAL number;
  number = NUM_REG(P2);
  INT_REG(P1) = number;
}

/* PUSH_I */
AUTO_OP push_i {
  Parrot_push_i(interpreter);
}

/* PUSH_N */
AUTO_OP push_n {
  Parrot_push_n(interpreter);
}

/* PUSH_S */
AUTO_OP push_s {
  Parrot_push_s(interpreter);
}

/* PUSH_P */
AUTO_OP push_p {
  Parrot_push_p(interpreter);
}

/* POP_I */
AUTO_OP pop_i {
  Parrot_pop_i(interpreter);
}

/* POP_N */
AUTO_OP pop_n {
  Parrot_pop_n(interpreter);
}

/* POP_S */
AUTO_OP pop_s {
  Parrot_pop_s(interpreter);
}

/* POP_P */
AUTO_OP pop_p {
  Parrot_pop_p(interpreter);
}

/* CLEAR_I */
AUTO_OP clear_i
  Parrot_clear_i(interpreter);
}

/* CLEAR_N */
AUTO_OP clear_n {
  Parrot_clear_n(interpreter);
}

/* CLEAR_S */
AUTO_OP clear_s {
  Parrot_clear_s(interpreter);
}

/* CLEAR_P */
AUTO_OP clear_p {
  Parrot_clear_p(interpreter);
}

/* SET Sx, CONSTANT */
AUTO_OP set_s_sc {
  STR_REG(P1) = STR_CONST(P2);
}

/* PRINT Sx */
AUTO_OP print_s {
  STRING *s = STR_REG(P1); 
  if (s) printf("%.*s",(int)string_length(s),(char *) s->bufstart);
}

/* PRINT sc */
AUTO_OP print_sc {
  STRING *s = STR_CONST(P1);
  INTVAL l = string_length(s);
  printf("%.*s",(int)l, (char *)s->bufstart);
}


/* LEN Ix, Sx */
AUTO_OP length_i_s {
  INT_REG(P1) = string_length(STR_REG(P2));
}

/* CHOPN Sx, CONSTANT */
AUTO_OP chopn_s_ic {
   string_chopn(STR_REG(P1), INT_CONST(P2));
}

/* SUBSTR Sx, Sx, Ix, Ix */
AUTO_OP substr_s_s_i {
    STRING *s = string_substr(STR_REG(P2), INT_REG(P3), INT_REG(P4), &STR_REG(P1));
    STR_REG(P1) = s;
}

/* CONCAT Sx, Sx */
AUTO_OP concat_s {
    STRING *s = string_concat(STR_REG(P1), STR_REG(P2), 1);
    STR_REG(P1) = s;
}

/* NOOP */
AUTO_OP noop {
}

/* TRANSCENDENTAL MATH FUNCTIONS */

/* sin_n_n */
AUTO_OP sin_n_n {
   NUM_REG(P1) = sin(NUM_REG(P2));
}

/* cos_n_n */
AUTO_OP cos_n_n {
   NUM_REG(P1) = cos(NUM_REG(P2));
}

/* tan_n_n */
AUTO_OP tan_n_n {
   NUM_REG(P1) = tan(NUM_REG(P2));
}

/* sec_n_n */
AUTO_OP sec_n_n {
   NUM_REG(P1) = ((FLOATVAL)1) / cos(NUM_REG(P2));
}

/* atan_n_n */
AUTO_OP atan_n_n {
   NUM_REG(P1) = atan(NUM_REG(P2));
}

/* atan2_n_n_n */
AUTO_OP atan2_n_n_n {
   NUM_REG(P1) = atan2(NUM_REG(P2), NUM_REG(P3));
}

/* asin_n_n */
AUTO_OP asin_n_n {
   NUM_REG(P1) = asin(NUM_REG(P2));
}

/* acos_n_n */
AUTO_OP acos_n_n {
   NUM_REG(P1) = acos(NUM_REG(P2));
}

/* asec_n_n */
AUTO_OP asec_n_n {
   NUM_REG(P1) = acos(((FLOATVAL)1) / NUM_REG(P2));
}

/* cosh_n_n */
AUTO_OP cosh_n_n {
   NUM_REG(P1) = cosh(NUM_REG(P2));
}

/* sinh_n_n */
AUTO_OP sinh_n_n {
   NUM_REG(P1) = sinh(NUM_REG(P2));
}

/* tanh_n_n */
AUTO_OP tanh_n_n {
   NUM_REG(P1) = tanh(NUM_REG(P2));
}

/* sech_n_n */
AUTO_OP sech_n_n {
   NUM_REG(P1) = ((FLOATVAL)1) / cosh(NUM_REG(P2));
}

/* log2_n_n */
AUTO_OP log2_n_n {
   NUM_REG(P1) = log(NUM_REG(P2)) / log((FLOATVAL)2);
}

/* log10_n_n */
AUTO_OP log10_n_n {
   NUM_REG(P1) = log10(NUM_REG(P2));
}

/* ln_n_n */
AUTO_OP ln_n_n {
   NUM_REG(P1) = log(NUM_REG(P2));
}

/* exp_n_n */
AUTO_OP exp_n_n {
   NUM_REG(P1) = exp(NUM_REG(P2));
}

/* pow_n_n_n */
AUTO_OP pow_n_n_n {
   NUM_REG(P1) = pow(NUM_REG(P2), NUM_REG(P3));
}

/* sin_n_i */
AUTO_OP sin_n_i {
   NUM_REG(P1) = sin((FLOATVAL)INT_REG(P2));
}

/* cos_n_i */
AUTO_OP cos_n_i {
   NUM_REG(P1) = cos((FLOATVAL)INT_REG(P2));
}

/* tan_n_i */
AUTO_OP tan_n_i {
   NUM_REG(P1) = tan((FLOATVAL)INT_REG(P2));
}

/* sec_n_i */
AUTO_OP sec_n_i {
   NUM_REG(P1) = ((FLOATVAL)1) / cos((FLOATVAL)INT_REG(P2));
}

/* atan_n_i */
AUTO_OP atan_n_i {
   NUM_REG(P1) = atan((FLOATVAL)INT_REG(P2));
}

/* atan2_n_n_i */
AUTO_OP atan2_n_n_i {
   NUM_REG(P1) = atan2(NUM_REG(P2), (FLOATVAL)INT_REG(P3));
}

/* atan2_n_i_n */
AUTO_OP atan2_n_i_n {
   NUM_REG(P1) = atan2((FLOATVAL)INT_REG(P2), NUM_REG(P3));
}

/* atan2_n_i_i */
AUTO_OP atan2_n_i_i {
   NUM_REG(P1) = atan2((FLOATVAL)INT_REG(P2), (FLOATVAL)INT_REG(P3));
}

/* asin_n_i */
AUTO_OP asin_n_i {
   NUM_REG(P1) = asin((FLOATVAL)INT_REG(P2));
}

/* acos_n_i */
AUTO_OP acos_n_i {
   NUM_REG(P1) = acos((FLOATVAL)INT_REG(P2));
}

/* asec_n_i */
AUTO_OP asec_n_i {
   NUM_REG(P1) = acos(((FLOATVAL)1) / ((FLOATVAL)INT_REG(P2)));
}

/* cosh_n_i */
AUTO_OP cosh_n_i {
   NUM_REG(P1) = cosh((FLOATVAL)INT_REG(P2));
}

/* sinh_n_i */
AUTO_OP sinh_n_i {
   NUM_REG(P1) = sinh((FLOATVAL)INT_REG(P2));
}

/* tanh_n_i */
AUTO_OP tanh_n_i {
   NUM_REG(P1) = tanh((FLOATVAL)INT_REG(P2));
}

/* sech_n_i */
AUTO_OP sech_n_i {
   NUM_REG(P1) = ((FLOATVAL)1) / cosh((FLOATVAL)INT_REG(P2));
}

/* log2_n_i */
AUTO_OP log2_n_i {
   NUM_REG(P1) = log((FLOATVAL)INT_REG(P2)) / log((FLOATVAL)2);
}

/* log10_n_i */
AUTO_OP log10_n_i {
   NUM_REG(P1) = log10((FLOATVAL)INT_REG(P2));
}

/* ln_n_i */
AUTO_OP ln_n_i {
   NUM_REG(P1) = log((FLOATVAL)INT_REG(P2));
}

/* exp_n_i */
AUTO_OP exp_n_i {
   NUM_REG(P1) = exp((FLOATVAL)INT_REG(P2));
}

/* pow_n_n_i */
AUTO_OP pow_n_n_i {
   NUM_REG(P1) = pow(NUM_REG(P2), (FLOATVAL)INT_REG(P3));
}

/* pow_n_i_i */
AUTO_OP pow_n_i_i {
   NUM_REG(P1) = pow((FLOATVAL)INT_REG(P2), (FLOATVAL)INT_REG(P3));
}

/* pow_n_n_i */
AUTO_OP pow_n_i_n {
   NUM_REG(P1) = pow((FLOATVAL)INT_REG(P2), NUM_REG(P3));
}

/* AND_i */
AUTO_OP and_i {
  INT_REG(P1) = INT_REG(P2) & INT_REG(P3);
}

/* NOT_i */
AUTO_OP not_i {
  INT_REG(P1) = ~ INT_REG(P2);
}

/* OR_i */
AUTO_OP or_i {
  INT_REG(P1) = INT_REG(P2) | INT_REG(P3);
}

/* SHL_i_ic */
AUTO_OP shl_i_ic {
  INT_REG(P1) = INT_REG(P2) << INT_CONST(P3);
}

/* SHR_i_ic */
AUTO_OP shr_i_ic {
  INT_REG(P1) = INT_REG(P2) >> INT_CONST(P3);
}

/* XOR_i */
AUTO_OP xor_i {
  INT_REG(P1) = INT_REG(P2) ^ INT_REG(P3);
}

/* BOUNDS_ic */
AUTO_OP bounds_ic {
  if (P1) { interpreter->flags |=  PARROT_BOUNDS_FLAG; }
  else    { interpreter->flags &= ~PARROT_BOUNDS_FLAG; }
  RESUME(3); /* After the end op which must follow bounds */
  RETURN(2);
}

/* TRACE_ic */
AUTO_OP trace_ic {
  if (P1) { interpreter->flags |=  PARROT_TRACE_FLAG; }
  else    { interpreter->flags &= ~PARROT_TRACE_FLAG; }
  RESUME(3); /* After the end op which must follow trace */
  RETURN(2);
}

