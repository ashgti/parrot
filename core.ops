/*
** core.ops
*/

VERSION = 0.3;

=head1 NAME

core.ops

=cut

=head1 DESCRIPTION

Parrot's core library of ops.

=cut


###############################################################################

=head2 Basic ops

These are the fundamental operations.

=over 4

=cut


########################################

=item B<end>()

Halts the interpreter.

=cut

inline op end() {
  HALT();
}


########################################

=item B<noop>()

Does nothing other than waste an iota of time and 32 bits of bytecode space.

=cut

inline op noop() {
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 System environment operations

These operations allow interaction between the Parrot program and the system
environment.

=over 4

=cut


########################################

=item close(i|ic)

Close file opened on file descriptor $1.

=cut

inline op close(i|ic) {
  close($1);
  goto NEXT();
}


########################################

=item err(i)

Store the system error code in $1.

=item err(s)

Store the system error message in $1.

=cut

inline op err(i) {
  $1 = errno;
  goto NEXT();
}

op err(s) {
  char *tmp = strerror(errno);
  STRING *s = string_make(interpreter, tmp, strlen(tmp), 0, 0, 0);
  $1 = s;
  goto NEXT();
}


########################################

=item B<open>(i, s|sc)

Open file named $2 with flags for writing and mode 0644 (rw-r--r--), and save
the file descriptor into $1.

=item B<open>(i, s|sc, i|ic)

Open file named $2 with flags $3 and mode 0644 (rw-r--r--), and save the file
descriptor into $1.

=item B<open>(i, s|sc, i|ic, i|ic)

Open file named $2 with flags $3 and mode $4, and save the file descriptor
into $1.

=cut

inline op open(i, s|sc) {
  $1 = open(($2)->bufstart, O_WRONLY | O_CREAT | O_TRUNC, DEFAULT_OPEN_MODE);
  goto NEXT();
}

inline op open(i, s|sc, i|ic) {
  $1 = open(($2)->bufstart, $3, DEFAULT_OPEN_MODE);
  goto NEXT();
}

inline op open(i, s|sc, i|ic, i|ic) {
  $1 = open(($2)->bufstart, $3, $4);
  goto NEXT();
}


########################################

=item B<ord>(i,s|sc)

Two-argument form returns the 0th character of string $2 in register $1.
If $2 is empty, throws an exception.

=item B<ord>(i,s|sc,i|ic)

Three-argument form returns character $3 of string $2 in register 1.
If $2 is empty, throws an exception.
If $3 is greater than the length of string $2, throws an exception
If $3 is less then zero but greater than the negative of the length, counts
backwards through the string, such that -1 is the last character, -2 is the
second-to-last character, and so on.
If $3 is less than the negative of the length, throws an exception.

=cut

inline op ord(i,s|sc) {
  $1 = string_ord($2,0);
  goto NEXT();
}

inline op ord(i,s|sc,i|ic) {
  $1 = string_ord($2,$3);
  goto NEXT();
}


########################################

=item B<print>(i|ic)

=item B<print>(n|nc)

=item B<print>(s|sc)

=item B<print>(p)

Print $1 to standard output.

=cut

inline op print(i|ic) {
  /* TODO: Configure for format */
  printf("%li", (long) $1);
  goto NEXT();
}

inline op print(n|nc) {
  /* TODO: Configure for format */
  printf("%f", $1);
  goto NEXT();
}

op print(s|sc) {
  STRING *s = $1;
  if (s && string_length(s)) {
    printf("%.*s",(int)string_length(s),(char *) s->bufstart);
  }
  goto NEXT();
}

op print(p) {
  PMC *p = $1;
  STRING *s = (p->vtable->get_string(interpreter, p));
  if (s) {
    printf("%.*s",(int)string_length(s),(char *) s->bufstart);
  }
  goto NEXT();
}


########################################

=item read(i, i|ic)

Read an INTVAL from file descriptor $2 into $1.

=item read(n, i|ic)

Read a FLOATVAL from file descriptor $2 into $1.

=item read(s, i|ic, i|ic)

Read $3 bytes from file descriptor $2 into string $1.

=cut

inline op read(i, i|ic) {
  read($2, &($1), sizeof(INTVAL));
  goto NEXT();
}

inline op read(n, i|ic) {
  read($2, &($1), sizeof(FLOATVAL));
  goto NEXT();
}

op read(s, i|ic, i|ic) {
  char *tmp;
  STRING *s;
  INTVAL len = $3;

  string_destroy($1);
  tmp = malloc(len + 1);
  read($2, tmp, len);
  s = string_make(interpreter, tmp, len, 0, 0, 0);
  $1 = s;
  free(tmp);
  goto NEXT();
}


########################################

=item B<time>(i)

Puts the current system time (represented as a whole number of seconds)
in $1.

=cut

inline op time(i) {
  $1 = Parrot_intval_time();
  goto NEXT();
}


########################################

=item B<time>(n)

Puts the current system time (represented as a number of seconds, with
microseconds) in $1.

=cut

inline op time(n) {
  $1 = Parrot_floatval_time();
  goto NEXT();
}


########################################

=item write(i|ic, i|ic)

=item write(i|ic, n|nc)

=item write(i|ic, s|sc)

Write $2 to file descriptor $1.

=cut

op write(i|ic, i|ic) {
  INTVAL * i = &($2);
  write($1, i, sizeof(INTVAL));
  goto NEXT();
}

op write(i|ic, n|nc) {
  FLOATVAL * f = &($2);
  write($1, f, sizeof(FLOATVAL));
  goto NEXT();
}

op write(i|ic, s|sc) {
  STRING * s = $2;
  INTVAL count = string_length(s);
  write($1, s->bufstart, count);
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 Register loading operations

These operations load registers from constants or other registers.

=over 4

=cut


########################################

=item B<set>(i, i)

=item B<set>(i, ic)

=item B<set>(p, i)

=item B<set>(p, ic)

=item B<set>(n, n)

=item B<set>(n, nc)

=item B<set>(p, n)

=item B<set>(p, nc)

=item B<set>(n, p)

=item B<set>(s, sc)

=item B<set>(s, s)

=item B<set>(p, s)

=item B<set>(p, sc)

=item B<set>(i, p)

=item B<clone>(p, p)

Set $1 to $2.

=item B<set>(i, p, i|ic)

=item B<set>(n, p, i|ic)

=item B<set>(s, p, i|ic)

=item B<set>(p, i|ic, i|ic)

=item B<set>(p, n|nc, i|ic)

=item B<set>(p, s|sc, i|ic)

Set $1 to $2.

=cut


inline op set(i, i|ic) {
  $1 = $2;
  goto NEXT();
}

inline op set(n, n|nc) {
  $1 = $2;
  goto NEXT();
}

inline op set(n, p) {
  $1 = $2->vtable->get_number(interpreter, $2);
  goto NEXT();
}

inline op set(s, s|sc) {
  $1 = string_copy(interpreter, $2);
  goto NEXT();
}

inline op set(p, i|ic) { 
  $1->vtable->set_integer_native(interpreter, $1, $2);
  goto NEXT();
}

inline op set(p, n|nc) { 
  $1->vtable->set_number_native(interpreter, $1, $2);
  goto NEXT();
}

inline op set(p, s|sc) {
  $1->vtable->set_string_native(interpreter, $1, $2);
  goto NEXT();
}

inline op set(i, p) {
  $1 = $2->vtable->get_integer(interpreter, $2);
  goto NEXT();
}

inline op clone(p, p) {
  $2->vtable->clone(interpreter, $2, $1);
  goto NEXT();
}

inline op set(p, i|ic, i|ic) {
  $1->vtable->set_integer_index(interpreter, $1, $2, $3);
  goto NEXT();
}

inline op set(p, n|nc, i|ic) {
  $1->vtable->set_number_index(interpreter, $1, $2, $3);
  goto NEXT();
}

inline op set(p, s|sc, i|ic) {
  $1->vtable->set_string_index(interpreter, $1, $2, $3);
  goto NEXT();
}

inline op set(i, p, i|ic) {
  $1 = $2->vtable->get_integer_index(interpreter, $2, $3);
  goto NEXT();
}

inline op set(n, p, i|ic) {
  $1 = $2->vtable->get_number_index(interpreter, $2, $3);
  goto NEXT();
}

inline op set(s, p, i|ic) {
  $1 = $2->vtable->get_string_index(interpreter, $2, $3);
  goto NEXT();
}

=back

=cut


###############################################################################

=head2 Conversion operations

These operations load registers of one type with values from registers of
another type, performing the appropriate type conversion along the way.

=over 4

=cut


########################################

=item B<iton>(n, i)

Load $1 with the FLOATVAL corresponding to the INTVAL from $2.

=cut

inline op iton(n, i) {
  $1 = (FLOATVAL)$2;
  goto NEXT();
}


########################################

=item B<ntoi>(i, n)

Load $1 with the INTVAL corresponding to the truncated FLOATVAL from $2.

=cut

op ntoi(i, n) {
  FLOATVAL number;
  number = $2;
  $1 = (INTVAL)number;
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 Conditional branch operations

These opertions perform a conditional relative branch. If the condition is
met, the branch happens, otherwise control falls to the next operation.

=over 4

=cut


########################################

=item B<eq>(i|ic, i|ic)

=item B<eq>(n|nc, n|nc)

=item B<eq>(s|sc, s|sc)

=item B<eq>(i|ic, i|ic, ic)

=item B<eq>(n|nc, n|nc, ic)

=item B<eq>(s|sc, s|sc, ic)

Branch if $1 is equal to $2.

Return address is popped off the call stack if no address is supplied.

=cut

inline op eq (i, i|ic) {
  if ($1 == $2) {
    goto POP();
  }
  goto NEXT();
}

inline op eq (ic, i|ic) {
  if ($1 == $2) {
    goto POP();
  }
  goto NEXT();
}

inline op eq (n, n|nc) {
  if ($1 == $2) {
    goto POP();
  }
  goto NEXT();
}

inline op eq (nc, n|nc) {
  if ($1 == $2) {
    goto POP();
  }
  goto NEXT();
}

op eq (s, s|sc) {
  if (string_compare (interpreter, $1, $2) == 0) {
    goto POP();
  }
  goto NEXT();
}

op eq (sc, s|sc) {
  if (string_compare (interpreter, $1, $2) == 0) {
    goto POP();
  }
  goto NEXT();
}

inline op eq(i, i|ic, ic) {
  if ($1 == $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op eq (ic, i|ic, ic) {
  if ($1 == $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op eq(n, n|nc, ic) {
  if ($1 == $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op eq (nc, n|nc, ic) {
  if ($1 == $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op eq(s, s|sc, ic) {
  if (string_compare(interpreter, $1, $2) == 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op eq (sc, s|sc, ic) {
  if (string_compare (interpreter, $1, $2) == 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}


########################################

=item B<ne>(i|ic, i|ic)

=item B<ne>(n|nc, n|nc)

=item B<ne>(s|sc, s|sc)

=item B<ne>(i|ic, i|ic, ic)

=item B<ne>(n|nc, n|nc, ic)

=item B<ne>(s|sc, s|sc, ic)

Branch if $1 is not equal to $2.

Return address is popped off the call stack if no address is supplied.

=cut

inline op ne (i, i|ic) {
  if ($1 != $2) {
    goto POP();
  }
  goto NEXT();
}

inline op ne (ic, i|ic) {
  if ($1 != $2) {
    goto POP();
  }
  goto NEXT();
}

inline op ne (n, n|nc) {
  if ($1 != $2) {
    goto POP();
  }
  goto NEXT();
}

inline op ne (nc, n|nc) {
  if ($1 != $2) {
    goto POP();
  }
  goto NEXT();
}

op ne (s, s|sc) {
  if (string_compare (interpreter, $1, $2) != 0) {
    goto POP();
  }
  goto NEXT();
}

op ne (sc, s|sc) {
  if (string_compare (interpreter, $1, $2) != 0) {
    goto POP();
  }
  goto NEXT();
}

inline op ne(i, i|ic, ic) {
  if ($1 != $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op ne (ic, i|ic, ic) {
  if ($1 != $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op ne(n, n|nc, ic) {
  if ($1 != $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op ne (nc, n|nc, ic) {
  if ($1 != $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op ne(s, s|sc, ic) {
  if (string_compare(interpreter, $1, $2) != 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op ne (sc, s|sc, ic) {
  if (string_compare (interpreter, $1, $2) != 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}


########################################

=item B<lt>(i, i, ic)

=item B<lt>(i, ic, ic)

=item B<lt>(n, n, ic)

=item B<lt>(n, nc, ic)

=item B<lt>(s, s, ic)

=item B<lt>(s, sc, ic)

Branch if $1 is less than $2.

=cut

inline op lt(i, i|ic, ic) {
  if ($1 < $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op lt(n, n|nc, ic) {
  if ($1 < $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op lt(s, s|sc, ic) {
  if (string_compare(interpreter, $1, $2) < 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}


########################################

=item B<le>(i, i, ic)

=item B<le>(i, ic, ic)

=item B<le>(n, n, ic)

=item B<le>(n, nc, ic)

=item B<le>(s, s, ic)

=item B<le>(s, sc, ic)

Branch if $1 is less than or equal to $2.

=cut

inline op le(i, i|ic, ic) {
  if ($1 <= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op le(n, n|nc, ic) {
  if ($1 <= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op le(s, s|sc, ic) {
  if (string_compare(interpreter, $1, $2) <= 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}


########################################

=item B<gt>(i, i, ic)

=item B<gt>(i, ic, ic)

=item B<gt>(n, n, ic)

=item B<gt>(n, nc, ic)

=item B<gt>(s, s, ic)

=item B<gt>(s, sc, ic)

Branch if $1 is greater than $2.

=cut

inline op gt(i, i|ic, ic) {
  if ($1 > $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op gt(n, n|nc, ic) {
  if ($1 > $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op gt(s, s|sc, ic) {
  if (string_compare(interpreter, $1, $2) > 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}


########################################

=item B<ge>(i, i, ic)

=item B<ge>(i, ic, ic)

=item B<ge>(n, n, ic)

=item B<ge>(n, nc, ic)

=item B<ge>(s, s, ic)

=item B<ge>(s, sc, ic)

Branch if $1 is greater than or equal to $2.

=cut

inline op ge(i, i|ic, ic) {
  if ($1 >= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op ge(n, n|nc, ic) {
  if ($1 >= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op ge(s, s|sc, ic) {
  if (string_compare(interpreter, $1, $2) >= 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}


########################################

=item B<if>(i, ic)

=item B<if>(p, ic)

=item B<if>(n, ic)

=item B<if>(s, ic)

Check register $1. If true, branch by $2.

=cut

inline op if(i, ic) {
  if ($1 != 0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

inline op if(n, ic) {
  if ($1 != 0.0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op if (s, ic) {
  if (string_bool(interpreter, $1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op if(p, ic) {
  if ($1->vtable->get_bool(interpreter, $1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}


=back

=cut



###############################################################################

=head2 Arithmetic operations

These operations store the results of arithmetic on other registers and
constants into their destination register, $1.

=over 4

=cut
########################################

=item B<abs>(i|n, i|ic|n|nc)

Set $1 to absolute value of $2.

=cut

inline op abs(i, i|ic|n|nc) {
  if ($2 < 0) {
    $1 = - (INTVAL)$2;
  }
  else {
    $1 = (INTVAL)$2;
  }
  goto NEXT();
}

inline op abs(n, n|nc|i|ic) {
  if ($2 < 0) {
    $1 = - (FLOATVAL)$2;
  }
  else {
    $1 = (FLOATVAL)$2;
  }
  goto NEXT();
}


########################################

=item B<add>(i, i, i)

=item B<add>(i, i, ic)

=item B<add>(n, n, n)

=item B<add>(n, n, nc)

Set $1 to the sum of $2 and $3.

=cut

inline op add(i, i, i|ic) {
  $1 = $2 + $3;
  goto NEXT();
}

inline op add(n, n, n|nc) {
  $1 = $2 + $3;
  goto NEXT();
}


########################################

=item B<cmod>(i, i, i)

=item B<cmod>(i, i, ic)

=item B<cmod>(i, ic, i)

NOTE: This "uncorrected mod" algorithm uses the C language's built-in
mod operator (x % y), which is

    ... the remainder when x is divided by y, and thus is zero when y
    divides x exactly.
    ...
    The direction of truncation for / and the sign of the result for %
    are machine-dependent for negative operands, as is the action taken
    on overflow or underflow.
                                                         -- [1], page 41

Also:

    ... if the second operand is 0, the result is undefined. Otherwise, it
    is always true that (a/b)*b + a%b is equal to z. If both operands are
    non-negative, then the remainder is non-negative and smaller than the
    divisor; if not, it is guaranteed only that the absolute value of the
    remainder is smaller than the absolute value of the divisor.
                                                         -- [1], page 205

This op is provided for those who need it (such as speed-sensitive
applications with heavy use of mod, but using it only with positive
arguments), but a more mathematically useful mod based on ** floor(x/y)
and defined with y == 0 is provided by the mod_i op.

  [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
      Language*, Second Edition. Prentice Hall, 1988.

TODO: Doesn't the Parrot interpreter need to catch the exception?

=cut

inline op cmod(i, i|ic, i|ic) {
  $1 = $2 % $3;
  goto NEXT();
}


########################################

=item B<cmod>(n, n, n)

=item B<cmod>(n, n, nc)

=item B<cmod>(n, nc, n)

NOTE: This "uncorrected mod" algorithm uses the built-in C math library's
fmod() function, which computes

    ... the remainder of dividing x by y. The return value is x - n * y,
    where n is the quotient of x / y, rounded towards zero to an
    integer.
                                    -- fmod() manpage on RedHat Linux 7.0

In addition, fmod() returns

    the remainder, unless y is zero, when the function fails and errno
    is set.

According to page 251 of [1], the result when y is zero is implementation-
defined.

This op is provided for those who need it, but a more mathematically
useful numeric mod based on floor(x/y) instead of truncate(x/y) and
defined with y == 0 is provided by the mod_n op.

  [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
      Language*, Second Edition. Prentice Hall, 1988.

TODO: Doesn't the Parrot interpreter need to catch the exception?

=cut

inline op cmod(n, n|nc, n|nc) {
  $1 = fmod($2, $3);
  goto NEXT();
}


########################################

=item B<dec>(i)

=item B<dec>(n)

Decrease $1 by one.

=cut

inline op dec(i|n) {
  $1--;
  goto NEXT();
}


########################################

=item B<dec>(i, ic)

=item B<dec>(n, nc)

Decrease $1 by the amount in $2.

=cut

inline op dec(i, ic) {
  $1 -= $2;
  goto NEXT();
}

inline op dec(n, nc) {
  $1 -= $2;
  goto NEXT();
}


########################################

=item B<div>(i, i, i)

=item B<div>(i, i, ic)

=item B<div>(i, ic, i)

=item B<div>(n, n, n)

=item B<div>(n, n, nc)

=item B<div>(n, nc, n)

Set $1 to the quotient of $2 divided by $3. In the case of INTVAL division, the
result is truncated (NOT rounded or floored).

=cut

inline op div(i, i|ic, i|ic) {
  $1 = $2 / $3;
  goto NEXT();
}

inline op div(n, n|nc, n|nc) {
  $1 = $2 / $3;
  goto NEXT();
}


########################################

=item B<inc>(i)

=item B<inc>(n)

Increase $1 by one.

=cut

inline op inc(i|n) {
  $1++;
  goto NEXT();
}


########################################

=item B<inc>(i, ic)

=item B<inc>(n, nc)

Increase $1 by the amount in $2.

=cut

inline op inc(i, ic) {
  $1 += $2;
  goto NEXT();
}

inline op inc(n, nc) {
  $1 += $2;
  goto NEXT();
}


########################################

=item B<mod>(i, i, i)

=item B<mod>(i, i, ic)

=item B<mod>(i, ic, i)

NOTE: This "corrected mod" algorithm is based on the C code on page 70
of [1]. Assuming correct behavior of C's built-in mod operator (%) with
positive arguments, this algorithm implements a mathematically convenient
version of mod, defined thus:

  x mod y = x - y * floor(x / y)

For more information on this definition of mod, see section 3.4 of [2],
pages 81-85.

References:

  [1] Donald E. Knuth, *MMIXware: A RISC Computer for the Third
      Millennium* Springer, 1999.

  [2] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
      Mathematics*, Second Edition. Addison-Wesley, 1994.

=cut

op mod(i, i|ic, i|ic) {
  INTVAL y = $2;
  INTVAL z = $3;
  INTVAL s = 0;
  INTVAL r;

  if (z == 0) {
    r = y;
  }
  else {
    if (y < 0) { s += 2; y = -y; }
    if (z < 0) { s += 1; z = -z; }

    r = y % z;

    switch (s) {
      case 0 + 0:            break;
      case 0 + 1: r = r - z; break;
      case 2 + 0: r = z - r; break;
      case 2 + 1: r = -r;    break;
    }
  }

  $1 = r;
  goto NEXT();
}


########################################

=item B<mod>(n, n, n)

=item B<mod>(n, n, nc)

=item B<mod>(n, nc, n)

NOTE: This "corrected mod" algorithm is based on the formula of [1]:

  x mod y = x - y * floor(x / y)

For more information on this definition of mod, see section 3.4 of [1],
pages 81-85.

References:

  [1] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
      Mathematics*, Second Edition. Addison-Wesley, 1994.

=cut

op mod(n, n|nc, n|nc) {
  $1 = $3
     ? ($2 - $3 * floor($2 / $3))
     : $2;
  goto NEXT();
}


########################################

=item B<mul>(i, i, i)

=item B<mul>(i, i, ic)

=item B<mul>(n, n, n)

=item B<mul>(n, n, nc)

Set $1 to the product of $2 and $3.

=cut

inline op mul(i, i, i|ic) {
  $1 = $2 * $3;
  goto NEXT();
}

inline op mul(n, n, n|nc) {
  $1 = $2 * $3;
  goto NEXT();
}


########################################

=item B<pow>(n, i, i)

=item B<pow>(n, i, ic)

=item B<pow>(n, ic, i)

=item B<pow>(n, i, n)

=item B<pow>(n, i, nc)

=item B<pow>(n, ic, n)

=item B<pow>(n, n, i)

=item B<pow>(n, n, ic)

=item B<pow>(n, nc, i)

=item B<pow>(n, n, n)

=item B<pow>(n, n, nc)

=item B<pow>(n, nc, n)

Set $1 to $2 raised to the power $3.

=cut

inline op pow(n, i|ic|n|nc, i|ic|n|nc) {
   $1 = pow((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}


########################################

=item B<sub>(i, i, i)

=item B<sub>(i, i, ic)

=item B<sub>(i, ic, i)

=item B<sub>(n, n, n)

=item B<sub>(n, n, nc)

=item B<sub>(n, nc, n)

Set $1 to $2 minus $3.

=cut

inline op sub(i, i|ic, i|ic) {
  $1 = $2 - $3;
  goto NEXT();
}

inline op sub(n, n|nc, n|nc) {
  $1 = $2 - $3;
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 String operations

These operations operate on STRINGs.

=cut


########################################

=item B<chopn>(s, ic)

=item B<chopn>(s, i)

Remove $2 characters from the end of the string in $1.

TODO: Create a three-argument version of this? Don't force in-place modification.

=cut

inline op chopn(s, i|ic) {
  (void)string_chopn($1, $2);
  goto NEXT();
}


########################################

=item B<concat>(s, s)

=item B<concat>(s, sc)

=item B<concat>(s, s, s)

=item B<concat>(s, s, sc)

=item B<concat>(s, sc, s)

Append the string in $2 to the string in $1.

The three argument version appends the string $3 to $2 and places the result
into $1.

=cut

inline op concat(s, s|sc) {
  $1 = string_concat(interpreter, $1, $2, 1);
  goto NEXT();
}

inline op concat(s, s|sc, s|sc) {
  $1 = string_concat(interpreter, $2, $3, 1);
  goto NEXT();
}


########################################

=item B<length>(i, s)

Set $1 to the length (in characters) of the string in $2.

=cut

inline op length(i, s) {
  $1 = string_length($2);
  goto NEXT();
}


########################################

=item B<substr>(s, s, i, i)

=item B<substr>(s, s, i, ic)

=item B<substr>(s, s, ic, i)

=item B<substr>(s, s, ic, ic)

=item B<substr>(s, sc, i, i)

=item B<substr>(s, sc, i, ic)

=item B<substr>(s, sc, ic, i)

Set $1 to the portion of $2 starting at (zero-based) character position $3 and having
length $4.

=cut

inline op substr(s, s|sc, i|ic, i|ic) {
  $1 = string_substr(interpreter, $2, $3, $4, &$1);
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 Transcendental mathematical operations

These operations perform various transcendental operations such as logarithmics
and trigonometrics.

=over 4

=cut


########################################

=item B<acos>(n, i)

=item B<acos>(n, n)

Set $1 to the arc cosine (in radians) of $2.

=cut

inline op acos(n, i|n) {
  $1 = acos((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<asec>(n, i)

=item B<asec>(n, n)

Set $1 to the arc secant (in radians) of $2.

=cut

inline op asec(n, i|n) {
  $1 = acos(((FLOATVAL)1) / ((FLOATVAL)$2));
  goto NEXT();
}


########################################

=item B<asin>(n, i)

=item B<asin>(n, n)

Set $1 to the arc sine (in radians) of $2.

=cut

inline op asin(n, i|n) {
  $1 = asin((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<atan>(n, i)

=item B<atan>(n, i, i)

=item B<atan>(n, i, ic)

=item B<atan>(n, ic, i)

=item B<atan>(n, i, n)

=item B<atan>(n, i, nc)

=item B<atan>(n, ic, n)

=item B<atan>(n, n)

=item B<atan>(n, n, i)

=item B<atan>(n, n, ic)

=item B<atan>(n, nc, i)

=item B<atan>(n, n, n)

=item B<atan>(n, n, nc)

=item B<atan>(n, nc, n)

The two-argument versions set $1 to the arc tangent (in radians) of $2.

The three-argument versions set $1 to the arc tangent (in radians) of
$2 / $3, taking account of the signs of the arguments in determining the
quadrant of the result.

=cut

inline op atan(n, i|n) {
  $1 = atan((FLOATVAL)$2);
  goto NEXT();
}

inline op atan(n, i|ic|n|nc, i|ic|n|nc) {
  $1 = atan2((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}


########################################

=item B<cos>(n, i)

=item B<cos>(n, n)

Set $1 to the cosine of $2 (given in radians).

=cut

inline op cos(n, i|n) {
  $1 = cos((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<cosh>(n, i)

=item B<cosh>(n, n)

Set $1 to the hyperbolic cosine of $2 (given in radians).

=cut

inline op cosh(n, i|n) {
  $1 = cosh((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<exp>(n, i)

=item B<exp>(n, n)

Set $1 to I<e> raised to the power $2. I<e> is the base of the natural logarithm.

=cut

inline op exp(n, i|n) {
  $1 = exp((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<ln>(n, i)

=item B<ln>(n, n)

Set $1 to the natural (base I<e>) logarithm of $2.

=cut

inline op ln(n, i|n) {
  $1 = log((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<log10>(n, i)

=item B<log10>(n, n)

Set $1 to the base 10 logarithm of $2.

=cut

inline op log10(n, i|n) {
  $1 = log10((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<log2>(n, i)

=item B<log2>(n, n)

Set $1 to the base 2 logarithm of $2.

=cut

op log2(n, i|n) {
   FLOATVAL temp = log((FLOATVAL)2.0);
  $1 = log((FLOATVAL)$2) / temp;
  goto NEXT();
}


########################################

=item B<sec>(n, i)

=item B<sec>(n, n)

Set $1 to the secant of $2 (given in radians).

=cut


inline op sec(n, i|n) {
  $1 = ((FLOATVAL)1) / cos((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<sech>(n, i)

=item B<sech>(n, n)

Set $1 to the hyperbolic secant of $2 (given in radians).

=cut

inline op sech(n, i|n) {
  $1 = ((FLOATVAL)1) / cosh((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<sin>(n, i)

=item B<sin>(n, n)

Set $1 to the sine of $2 (given in radians).

=cut

inline op sin(n, i|n) {
  $1 = sin((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<sinh>(n, i)

=item B<sinh>(n, n)

Set $1 to the hyperbolic sine of $2 (given in radians).

=cut

inline op sinh(n, i|n) {
  $1 = sinh((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<tan>(n, i)
=item B<tan>(n, n)

Set $1 to the tangent of $2 (given in radians).

=cut

inline op tan(n, i|n) {
  $1 = tan((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<tanh>(n, i)

=item B<tanh>(n, n)

Set $1 to the hyperbolic tangent of $2 (given in radians).

=cut

inline op tanh(n, i|n) {
  $1 = tanh((FLOATVAL)$2);
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 Bitwise logical operations

These operations apply  bitwise logical functions to their arguments.

=over 4

=cut


########################################

=item B<and>(i, i, i)

=item B<and>(i, i, ic)

Set the bits of $1 according to the B<and> of the corresponding bits from $2 and $3.

=cut

inline op and(i, i, i|ic) {
  $1 = $2 & $3;
  goto NEXT();
}


########################################

=item B<not>(i, i)

Set the bits of $1 to the B<not> of the corresponding bits from $2.

=cut

inline op not(i, i) {
  $1 = ~ $2;
  goto NEXT();
}


########################################

=item B<or>(i, i, i)

=item B<or>(i, i, ic)

Set the bits of $1 according to the B<or> of the corresponding bits from $2 and $3.

=cut

inline op or(i, i, i|ic) {
  $1 = $2 | $3;
  goto NEXT();
}

########################################

=item B<shl>(i, i, i)

=item B<shl>(i, i, ic)

=item B<shl>(i, ic, i)

Set $1 to the value of $2 shifted left by $3 bits.

=cut

inline op shl(i, i|ic, i|ic) {
  $1 = $2 << $3;
  goto NEXT();
}


########################################

=item B<shr>(i, i, i)

=item B<shr>(i, i, ic)

=item B<shr>(i, ic, i)

Set $1 to the value of $2 shifted right by $3 bits.

=cut

inline op shr(i, i|ic, i|ic) {
  $1 = $2 >> $3;
  goto NEXT();
}


########################################

=item B<xor>(i, i, i)

=item B<xor>(i, i, ic)

Set the bits of $1 according to the B<xor> of the corresponding bits from $2 and $3.

=cut

inline op xor(i, i, i|ic) {
  $1 = $2 ^ $3;
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 Interpreter flag modification operations

These operations modify the interpreter's internal flags, affecting its
subsequent operation.

=over 4

=cut


########################################

=item B<bounds>(ic)

If $1 is zero, turn off byte code bounds checking. Otherwise turn it on.

=cut

inline op bounds(ic) {
  if ($1 != 0) { interpreter->flags |=  PARROT_BOUNDS_FLAG; }
  else         { interpreter->flags &= ~PARROT_BOUNDS_FLAG; }
  restart NEXT();
}


########################################

=item B<profile>(ic)

If $1 is zero, turn off profiling. Otherwise turn it on.

=cut

inline op profile(ic) {
  if ($1 != 0) { interpreter->flags |=  PARROT_PROFILE_FLAG; }
  else         { interpreter->flags &= ~PARROT_PROFILE_FLAG; }
  restart NEXT();
}


########################################

=item B<trace>(ic)

If $1 is zero, turn off tracing. Otherwise turn it on.

=cut

inline op trace(ic) {
  if ($1 != 0) { interpreter->flags |=  PARROT_TRACE_FLAG; }
  else         { interpreter->flags &= ~PARROT_TRACE_FLAG; }
  restart NEXT();
}

=back

=cut


###############################################################################

=head2 Register operations

These operations effect entire sets of registers.

=over 4

=cut


########################################

=item B<cleari>()

=item B<clearn>()

=item B<clearp>()

=item B<clears>()

Clear all the registers of the type indicated in the name of the operation.

INTVAL ('i') and FLOATVAL ('n') registers clear to zero.

PMC ('p') and STRING ('s') registers clear to NULL.

=cut

inline op cleari() {
  Parrot_clear_i(interpreter);
  goto NEXT();
}

inline op clearn() {
  Parrot_clear_n(interpreter);
  goto NEXT();
}

inline op clears() {
  Parrot_clear_s(interpreter);
  goto NEXT();
}

inline op clearp() {
  Parrot_clear_p(interpreter);
  goto NEXT();
}


########################################

=item B<popi>()

=item B<popn>()

=item B<popp>()

=item B<pops>()

Restore all the registers of the type indicated in the name of the operation
from the most recently B<push>ed copies.

=cut

inline op popi() {
  Parrot_pop_i(interpreter);
  goto NEXT();
}

inline op popn() {
  Parrot_pop_n(interpreter);
  goto NEXT();
}

inline op pops() {
  Parrot_pop_s(interpreter);
  goto NEXT();
}

inline op popp() {
  Parrot_pop_p(interpreter);
  goto NEXT();
}


########################################

=item B<pushi>()

=item B<pushn>()

=item B<pushp>()

=item B<pushs>()

Save all the registers of the type indicated in the name of the operation.

=cut

inline op pushi() {
  Parrot_push_i(interpreter);
  goto NEXT();
}

inline op pushn() {
  Parrot_push_n(interpreter);
  goto NEXT();
}

inline op pushs() {
  Parrot_push_s(interpreter);
  goto NEXT();
}

inline op pushp() {
  Parrot_push_p(interpreter);
  goto NEXT();
}

########################################

=item B<clonei>()

=item B<clonen>()

=item B<clonep>()

=item B<clones>()

Save all the registers of the type indicated in the name of the operation.

=cut

inline op clonei() {
  Parrot_clone_i(interpreter);
  goto NEXT();
}

inline op clonen() {
  Parrot_clone_n(interpreter);
  goto NEXT();
}

inline op clones() {
  Parrot_clone_s(interpreter);
  goto NEXT();
}

inline op clonep() {
  Parrot_clone_p(interpreter);
  goto NEXT();
}

=back

=cut


###############################################################################

=head2 Register stack operations

These operations effect individual registers.

=over 4

=cut


########################################

=item B<entrytype>(i, i|ic)

Gets the type of entry $2 of the stack and puts in in $1

=cut

op entrytype(i, i|ic) {
  INTVAL depth;
  struct Stack_Entry *entry;
  depth = stack_depth(interpreter, interpreter->user_stack_base);
  if (depth <= $2) {
    INTERNAL_EXCEPTION(99, "Stack Depth wrong");
  }

  entry = stack_entry(interpreter, interpreter->user_stack_base, $2);
  $1 = get_entry_type(interpreter, entry);
  goto NEXT();
}

########################################

=item B<save>(i)

=item B<save>(ic)

=item B<save>(n)

=item B<save>(nc)

=item B<save>(p)

=item B<save>(s)

=item B<save>(sc)

Save register or constant $1 onto the stack.

=cut

inline op save(i|ic) {
  push_generic_entry(interpreter, &interpreter->user_stack_top, &($1), STACK_ENTRY_INT, NULL);
  goto NEXT();
}

inline op save(n|nc) {
  push_generic_entry(interpreter, &interpreter->user_stack_top, &($1), STACK_ENTRY_FLOAT, NULL);
  goto NEXT();
}

inline op save(p) {
  push_generic_entry(interpreter, &interpreter->user_stack_top, $1, STACK_ENTRY_PMC, NULL);
  goto NEXT();
}

inline op save(s|sc) {
  push_generic_entry(interpreter,  &interpreter->user_stack_top, $1, STACK_ENTRY_STRING, NULL);
  goto NEXT();
}


########################################

=item B<restore>(i)

=item B<restore>(n)

=item B<restore>(p)

=item B<restore>(s)

Restore register $1 from the appropriate register stack.

=cut

inline op restore(i) {
  pop_generic_entry(interpreter, &interpreter->user_stack_top, &($1), STACK_ENTRY_INT);
  goto NEXT();
}

inline op restore(n) {
  pop_generic_entry(interpreter, &interpreter->user_stack_top, &($1), STACK_ENTRY_FLOAT);
  goto NEXT();
}

inline op restore(p) {
  pop_generic_entry(interpreter, &interpreter->user_stack_top, &($1), STACK_ENTRY_PMC);
  goto NEXT();
}

inline op restore(s) {
  pop_generic_entry(interpreter, &interpreter->user_stack_top, &($1), STACK_ENTRY_STRING);
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 Control flow

The control flow opcodes check conditions and manage program flow.

=over 4


########################################

=item B<branch>(ic)

Branch forward or backward by the amount in $1.

=cut

inline op branch (ic) {
  goto OFFSET($1);
}


########################################

=item B<bsr>(i)

=item B<bsr>(ic)

Branch to the location specified by $1. Push the current location onto the call
stack for later returning.

=cut

inline op bsr (i|ic) {
  push_generic_entry(interpreter, &interpreter->control_stack_top, CUR_OPCODE + 2,  STACK_ENTRY_DESTINATION, NULL);
  goto OFFSET($1);
}


########################################

=item B<jsr>()

Jump to the location specified by register X. Push the current
location onto the call stack for later returning.

TODO: Implement this, or delete the entry.

=cut


########################################

=item B<jump>(i)

Jump to the address held in register $1.

=cut

inline op jump(i) {
  goto OFFSET($1);
}

########################################

=item B<newinterp>(p, i|ic)

Create a new interpreter and store it in a PMC

=cut

op newinterp(p, i|ic) {
  struct Parrot_Interp *new_interp;
  struct PMC *new_pmc;
  new_interp = make_interpreter($2);
  new_pmc = new_pmc_header(interpreter);
  new_pmc->data = new_interp;
  new_pmc->vtable = YOU_LOSE_VTABLE;
  $1 = new_pmc;
  goto NEXT();
}


=item B<runinterp>(p, i|ic)

Take a built interpreter and run the code starting at offset $2

=cut

op runinterp(p, i|ic) {
  struct Parrot_Interp * new_interp = (struct Parrot_Interp *)$1->data;
  runops(new_interp, interpreter->code, REL_PC + $2);
  goto NEXT();
}

########################################

=item B<new>(p, i)

Create a new PMC of class C<i>; look in F<pmc.h> for the base
vtable types. The assembler allows you to specify PMCs by type
name as well as by integer - you should do this for compatibility,
to avoid problems if the base types get reassigned. For example:

    new P0, PerlScalar

=cut

op new(p, i|ic) {
  PMC* newpmc;
  if ($2 <0 || $2 >= enum_class_max) {
    abort(); /* Deserve to lose */
  }
  newpmc = pmc_new(interpreter, $2);
  $1 = newpmc;
  goto NEXT();
}

########################################

=item B<ret>()

Pop the location off the top of the stack and go there.

=cut

inline op ret() {
  goto POP();
}


########################################

=item B<rotate_up>(i)

=item B<rotate_up>(ic)

Rotate the top $1 entries in the user stack so that the top entry
becomes the bottom entry in that range.

=cut

inline op rotate_up(i|ic) {
  rotate_entries(interpreter, interpreter->user_stack_base, interpreter->user_stack_top, $1);
  goto NEXT();
}


=back

=cut

########################################

=item B<sleep>(i)

=item B<sleep>(ic)

Sleep for $1 seconds

=cut

inline op sleep(i|ic) {
  Parrot_sleep($1);
  goto NEXT();
}


#######################################

=item B<setline>(i)

=item B<setline>(ic)

Set the current line number we're executing code for

=cut

inline op setline(i|ic) {
  interpreter->current_line = $1;
  goto NEXT();
}

=item B<getline>(i)

Get the current line number

=cut

inline op getline(i) {
  $1 = interpreter->current_line;
  goto NEXT();
}

=item B<setfile>(s|sc)

Sets the current file we're executing code for

=cut

inline op setfile(s|sc) {
  interpreter->current_file = $1;
  goto NEXT();
}

=item B<getfile>(s)

Gets the current file we're executing code for

=cut

inline op getfile(s) {
  $1 = interpreter->current_file;
  goto NEXT();
}

=item B<setpackage>(s|sc)

Sets the current package we're executing code for

=cut

inline op setpackage(s|sc) {
  interpreter->current_package = $1;
  goto NEXT();
}

=item B<getpackage>(s)

Gets the current package we're executing code for

=cut

inline op getpackage(s) {
  $1 = interpreter->current_package;
  goto NEXT();
}

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001 Yet Another Society. All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut

