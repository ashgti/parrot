/*
** core.ops
*/

/* This (now even more) convoluted mess avoids costly runtime creation
 * of KEY structures, and can be used in an expression.
 *
 * Usage: MAKE_KEY(KEY k, (INTVAL|FLOATVAL|DPOINTER*|STRING*|PMC*) v,
 *                 KEY_TYPE c, (int_val|num_val|struct_val|string_val|pmc_val)); 
 */

#define MAKE_KEY(k,v,c,t) (k.atom.type = c, k.atom.val.t = v, k.next = NULL, k.flags = BUFFER_sysmem_FLAG, &k)

VERSION = PARROT_VERSION;

=head1 NAME

core.ops

=cut

=head1 DESCRIPTION

Parrot's core library of ops.

=cut

# ' for emacs

###############################################################################

=head2 Basic ops

These are the fundamental operations.

=over 4

=cut


########################################

=item B<end>()

Halts the interpreter.

=cut

inline op end() {
  HALT();
}


########################################

=item B<noop>()

Does nothing other than waste an iota of time and 32 bits of bytecode space.

=cut

inline op noop() {
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 System environment operations

These operations allow interaction between the Parrot program and the system
environment.

=over 4

=cut

########################################

=item B<close>(inout INT)

Close file opened on file descriptor $1.

=cut

inline op close(inout INT) {
  fclose((FILE *)$1);
  goto NEXT();
}


########################################

=item B<err>(out INT)

Store the system error code in $1.

=item B<err>(out STR)

Store the system error message in $1.

=cut

inline op err(out INT) {
  $1 = errno;
  goto NEXT();
}

op err(out STR) {
  char *tmp = strerror(errno);
  $1 = string_make(interpreter, tmp, strlen(tmp), NULL, 0, NULL);
  goto NEXT();
}


########################################
=item B<open>(out INT, in STR)

Open file named $2 for reading and writing and save the file
descriptor into $1.

=item B<open>(out INT, in STR, in STR)

Open file named $2 with flags $3 and mode 0644 (rw-r--r--), and save the file
descriptor into $1.

=cut

inline op open(out INT, in STR) {
  $1 = (INTVAL)fopen(string_to_cstring(interpreter, ($2)), "r+");
  if (!$1) {
    perror("Can't open");
    exit(1);
  }
  
  goto NEXT();
}

inline op open(out INT, in STR, in STR) {
  $1 = (INTVAL)fopen(string_to_cstring(interpreter, ($2)), string_to_cstring(interpreter, ($3)));
  goto NEXT();
}

########################################

=item B<readline>(out STR, in INT)

Temporary hack op to read in a line from the file opened on the FILE *
we've evilly put in the integer register $2. If $2 is 0, 1, or 2 we
use stdin, stdout, or stderr respectively.

BE AFRAID! THIS IS *EEEEEEEVIL* pure and simple. (From the 8th
dimension, no less)

If for some reason the line's longer than 64K you get only 64K

=cut

inline op readline(out STR, in INT) {
  FILE *file;
  switch ($2) {
	case 0: file = stdin; 
                break;
	case 1: file = stdout; 
                break;
	case 2: file = stderr; 
                break;
	default: file = (FILE *)$2;
  }

  $1 = string_make(interpreter, NULL, 65535, NULL, 0, NULL);
  memset(($1)->bufstart, 0, 65535);
  fgets(($1)->bufstart, 65534, file);
  ($1)->strlen = ($1)->bufused = strlen(($1)->bufstart);
  goto NEXT();
}

########################################

=item B<ord>(out INT, in STR)

Two-argument form returns the 0th character of string $2 in register $1.
If $2 is empty, throws an exception.

=item B<ord>(out INT, in STR, in INT)

Three-argument form returns character $3 of string $2 in register $1.
If $2 is empty, throws an exception.
If $3 is greater than the length of string $2, throws an exception.
If $3 is less then zero but greater than the negative of the length, counts
backwards through the string, such that -1 is the last character, -2 is the
second-to-last character, and so on.
If $3 is less than the negative of the length, throws an exception.

=cut

inline op ord (out INT, in STR) {
  $1 = string_ord($2,0);
  goto NEXT();
}

inline op ord (out INT, in STR, in INT) {
  $1 = string_ord($2,$3);
  goto NEXT();
}


########################################

=item B<print>(in INT)

=item B<print>(in NUM)

=item B<print>(in PMC)

=item B<print>(in STR)

Print $1 to standard output.

=item B<print>(in INT, in INT)

=item B<print>(in INT, in NUM)

=item B<print>(in INT, in STR)

=item B<print>(in INT, in PMC)

Print $2 to the file specified by file descriptor $1; for $1 equal to
0, 1 or 2, we use stdin, stdout or stderr respectively.

=cut

inline op print(in INT) {
  printf(INTVAL_FMT, (INTVAL)$1);
  goto NEXT();
}

inline op print(in NUM) {
  printf(FLOATVAL_FMT, $1);
  goto NEXT();
}

op print(in STR) {
  STRING *s = $1;
  if (s && string_length(s)) {
    printf("%s", string_to_cstring(interpreter, (s)));
  }
  goto NEXT();
}

op print(in PMC) {
  PMC *p = $1;
  STRING *s = (p->vtable->get_string(interpreter, p));
  if (s) {
    printf("%s", string_to_cstring(interpreter, (s)));
  }
  goto NEXT();
}


op print(in INT, in INT) {
  FILE *file;
  switch ($1) {
	case 0: file = stdin; 
                break;
	case 1: file = stdout; 
                break;
	case 2: file = stderr; 
                break;
	default: file = (FILE *)$1;
  }
  fprintf(file, INTVAL_FMT, (INTVAL)$2);
  goto NEXT();
}

op print(in INT, in NUM) {
  FILE *file;
  switch ($1) {
	case 0: file = stdin; 
                break;
	case 1: file = stdout; 
                break;
	case 2: file = stderr; 
                break;
	default: file = (FILE *)$1;
  }
  fprintf(file, FLOATVAL_FMT, $2);
  goto NEXT();
}

op print(in INT, in STR) {
  FILE *file;
  STRING *s = $2;
  switch ($1) {
	case 0: file = stdin; 
                break;
	case 1: file = stdout; 
                break;
	case 2: file = stderr; 
                break;
	default: file = (FILE *)$1;
  }
  if (s && string_length(s)) {
    fprintf(file, "%s", string_to_cstring(interpreter, (s)));
  }
  goto NEXT();
}

op print(in INT, in PMC) {
  FILE *file;
  PMC *p = $2;
  STRING *s = (p->vtable->get_string(interpreter, p));
  switch ($1) {
	case 0: file = stdin; 
                break;
	case 1: file = stdout; 
                break;
	case 2: file = stderr; 
                break;
	default: file = (FILE *)$1;
  }
  if (s) {
    fprintf(file, "%s", string_to_cstring(interpreter, (s)));
  }
  goto NEXT();
}


########################################

=item B<read>(out INT, in INT)

Read an INTVAL from file descriptor $2 into $1.

=item B<read>(out NUM, in INT)

Read a FLOATVAL from file descriptor $2 into $1.

=item B<read>(out STR, in INT, in INT)

Read $3 bytes from file descriptor $2 into string $1.

=cut

inline op read(out INT, in INT) {
  read($2, &($1), sizeof(INTVAL));
  goto NEXT();
}

inline op read(out NUM, in INT) {
  read($2, &($1), sizeof(FLOATVAL));
  goto NEXT();
}

op read(out STR, in INT, in INT) {
  STRING *s;
  UINTVAL len = $3;

  s = string_make(interpreter, NULL, len, NULL, 0, NULL);
  read($2, s->bufstart, len);
  s->bufused = len;
  $1 = s;
  goto NEXT();
}


########################################

=item B<time>(out INT)

Puts the current system time (represented as a whole number of seconds)
in $1.

=cut

inline op time(out INT) {
  $1 = Parrot_intval_time();
  goto NEXT();
}


########################################

=item B<time>(out NUM)

Puts the current system time (represented as a number of seconds, with
microseconds) in $1.

=cut

inline op time(out NUM) {
  $1 = Parrot_floatval_time();
  goto NEXT();
}


########################################

=item B<write>(in INT, in INT)

=item B<write>(in INT, in NUM)

=item B<write>(in INT, in STR)

Write $2 to file descriptor $1.

=cut

op write(in INT, in INT) {
  INTVAL i = (INTVAL)$2;
  write($1, &i, sizeof(INTVAL));
  goto NEXT();
}

op write(in INT, in NUM) {
  FLOATVAL * f = &($2);
  write($1, f, sizeof(FLOATVAL));
  goto NEXT();
}

op write(in INT, in STR) {
  STRING * s = $2;
  UINTVAL count = string_length(s);
  write($1, s->bufstart, count);
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 Register loading operations

These operations load registers from constants or other registers.

=over 4

=cut

########################################

=item B<clone>(out STR, in STR)

Make a clone of $2, and put it in $1. Doesn't affect what was in
$1. Removes the constant flag on the copy, if there was one.

=cut

inline op clone(out STR, in STR) {
  $1 = string_copy(interpreter, $2);
  goto NEXT();
}


########################################

=item B<set_addr>(out INT, in INT)

Sets register $1 to the current address plus the offset $2.

=cut

inline op set_addr(out INT, in INT) {
  $1 = (INTVAL) (CUR_OPCODE + $2);
  goto NEXT();
}


########################################

=item B<set>(out INT, in INT)

=item B<set>(out INT, in NUM)

=item B<set>(out INT, in PMC)

=item B<set>(out INT, in STR)

=item B<set>(out NUM, in INT)

=item B<set>(out NUM, in NUM)

=item B<set>(out NUM, in PMC)

=item B<set>(out NUM, in STR)

=item B<set>(out PMC, in INT)

=item B<set>(out PMC, in NUM)

=item B<set>(out PMC, in PMC)

=item B<set>(out PMC, in STR)

=item B<set>(out STR, in INT)

=item B<set>(out STR, in NUM)

=item B<set>(out STR, in PMC)

=item B<set>(out STR, in STR)

Set $1 to $2.

=cut

inline op set(out INT, in INT) {
  $1 = $2;
  goto NEXT();
}

inline op set(out INT, in NUM) {
  $1 = (INTVAL)($2);
  goto NEXT();
}

inline op set(out INT, in STR) {
  $1 = string_to_int($2);
  goto NEXT();
}

inline op set(out NUM, in NUM) {
  $1 = $2;
  goto NEXT();
}

inline op set(out NUM, in INT) {
  $1 = (FLOATVAL)$2;
  goto NEXT();
}

inline op set(out NUM, in STR) {
  $1 = string_to_num($2);
  goto NEXT();
}

inline op set(out NUM, in PMC) {
  $1 = $2->vtable->get_number(interpreter, $2);
  goto NEXT();
}

inline op set(out STR, in PMC) {
  $1 = $2->vtable->get_string(interpreter, $2);
  goto NEXT();
}

inline op set(out STR, invar STR) {
  $1 = $2;
  goto NEXT();
}

inline op set(out STR, inconst STR) {
  $1 = string_copy(interpreter, $2);
  goto NEXT();
}

inline op set(out STR, in INT) {
  $1 = string_from_int(interpreter, $2);
  goto NEXT();
}

inline op set(out STR, in NUM) {
  $1 = string_from_num(interpreter, $2);
  goto NEXT();
}

inline op set(out PMC, in PMC) {
  $1 = $2;
  goto NEXT();
}

inline op set(out PMC, in INT) { 
  $1->vtable->set_integer_native(interpreter, $1, $2);
  goto NEXT();
}

inline op set(out PMC, in NUM) { 
  $1->vtable->set_number_native(interpreter, $1, $2);
  goto NEXT();
}

inline op set(out PMC, in STR) {
  $1->vtable->set_string_native(interpreter, $1, $2);
  goto NEXT();
}

inline op set(out INT, in PMC) {
  $1 = $2->vtable->get_integer(interpreter, $2);
  goto NEXT();
}

=item B<set>(out PMC, out PMC, in PMC, in PMC)

Set the entry of $1 accessed by $2 to the entry of $3 accessed by
$4, ie:

    $1[$2] = $3[$4];

=cut

inline op set (out PMC, in PMC, in PMC, in PMC)  {
    KEY src_key, dest_key;
    MAKE_KEY(src_key, $2, enum_key_pmc, pmc_val);
    MAKE_KEY(dest_key, $4, enum_key_pmc, pmc_val);
    $1->vtable->set_pmc_keyed(interpreter, 
                    $1, $2 ? &src_key : NULL, $3, $4 ? &dest_key : NULL);
    goto NEXT();
}

=head2 Keyed set operations: Px[ Ix|KEY ] = Bx

=item B<set_keyed_integer>(out PMC, in INT, in INT)

=item B<set_keyed_integer>(out PMC, in INT, in NUM)

=item B<set_keyed_integer>(out PMC, in INT, in STR)

=item B<set_keyed_integer>(out PMC, in INT, in PMC)

=cut

inline op set_keyed_integer (out PMC, in INT, in INT)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_int, int_val);
    $1->vtable->set_integer_keyed(interpreter, $1, &key, $3);
    goto NEXT();
}

inline op set_keyed_integer (out PMC, in INT, in NUM)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_int, int_val);
    $1->vtable->set_number_keyed(interpreter, $1, &key, $3);
    goto NEXT();
}

inline op set_keyed_integer (out PMC, in INT, in STR)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_int, int_val);
    $1->vtable->set_string_keyed(interpreter, $1, &key, $3);
    goto NEXT();
}

inline op set_keyed_integer (out PMC, in INT, in PMC)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_int, int_val);
    $1->vtable->set_pmc_keyed(interpreter, $1, &key, $3, NULL);
    goto NEXT();
}

=item B<set_keyed_integer>(out PMC, in KEY, in INT)

=item B<set_keyed_integer>(out PMC, in KEY, in NUM)

=item B<set_keyed_integer>(out PMC, in KEY, in STR)

=item B<set_keyed_integer>(out PMC, in KEY, in PMC)

=cut

inline op set_keyed_integer (out PMC, in KEY, in INT)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_int, int_val);
    $1->vtable->set_integer_keyed(interpreter, $1, &key, $3);
    goto NEXT();
}

inline op set_keyed_integer (out PMC, in KEY, in NUM)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_int, int_val);
    $1->vtable->set_number_keyed(interpreter, $1, &key, $3);
    goto NEXT();
}

inline op set_keyed_integer (out PMC, in KEY, in STR)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_int, int_val);
    $1->vtable->set_string_keyed(interpreter, $1, &key, $3);
    goto NEXT();
}

inline op set_keyed_integer (out PMC, in KEY, in PMC)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_int, int_val);
    $1->vtable->set_pmc_keyed(interpreter, $1, &key, $3, NULL);
    goto NEXT();
}

=head2 Keyed set operations: Ax = Px[ Ix|KEY ]

=cut

=item B<set_keyed_integer>(out INT, in PMC, in INT)

=item B<set_keyed_integer>(out NUM, in PMC, in INT)

=item B<set_keyed_integer>(out STR, in PMC, in INT)

=item B<set_keyed_integer>(out PMC, in PMC, in INT)

=cut

inline op set_keyed_integer (out INT, in PMC, in INT)  {
    KEY key;
    MAKE_KEY(key, $3, enum_key_int, int_val);
    $1 = $2->vtable->get_integer_keyed(interpreter, $2, &key);
    goto NEXT();
}

inline op set_keyed_integer (out NUM, in PMC, in INT)  {
    KEY key;
    MAKE_KEY(key, $3, enum_key_int, int_val);
    $1 = $2->vtable->get_number_keyed(interpreter, $2, &key);
    goto NEXT();
}

inline op set_keyed_integer (out STR, in PMC, in INT)  {
    KEY key;
    MAKE_KEY(key, $3, enum_key_int, int_val);
    $1 = $2->vtable->get_string_keyed(interpreter, $2, &key);
    goto NEXT();
}

inline op set_keyed_integer (out PMC, in PMC, in INT) {
    KEY key;
    MAKE_KEY(key, $3, enum_key_int, int_val);
    $1 = $2->vtable->get_pmc_keyed(interpreter, $2, &key);
    goto NEXT();
}

=item B<set_keyed_integer>(out INT, in PMC, in KEY)

=item B<set_keyed_integer>(out NUM, in PMC, in KEY)

=item B<set_keyed_integer>(out STR, in PMC, in KEY)

=item B<set_keyed_integer>(out PMC, in PMC, in KEY)

=cut

inline op set_keyed_integer (out INT, in PMC, in KEY)  {
    KEY key;
    MAKE_KEY(key, $3, enum_key_int, int_val);
    $1 = $2->vtable->get_integer_keyed(interpreter, $2, &key);
    goto NEXT();
}

inline op set_keyed_integer (out NUM, in PMC, in KEY)  {
    KEY key;
    MAKE_KEY(key, $3, enum_key_int, int_val);
    $1 = $2->vtable->get_number_keyed(interpreter, $2, &key);
    goto NEXT();
}

inline op set_keyed_integer (out STR, in PMC, in KEY)  {
    KEY key;
    MAKE_KEY(key, $3, enum_key_int, int_val);
    $1 = $2->vtable->get_string_keyed(interpreter, $2, &key);
    goto NEXT();
}

inline op set_keyed_integer (out PMC, in PMC, in KEY) {
    KEY key;
    MAKE_KEY(key, $3, enum_key_int, int_val);
    $1 = $2->vtable->get_pmc_keyed(interpreter, $2, &key);
    goto NEXT();
}

=head2 Keyed set operations: Px[Sx] = Bx

=item B<set_keyed>(out PMC, in STR, in INT)

=item B<set_keyed>(out PMC, in STR, in NUM)

=item B<set_keyed>(out PMC, in STR, in STR)

=item B<set_keyed>(out PMC, in STR, in PMC)

=cut

inline op set_keyed (out PMC, in STR, in INT)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_string, struct_val);
    $1->vtable->set_integer_keyed(interpreter, $1, &key, $3);
    goto NEXT();
}

inline op set_keyed (out PMC, in STR, in NUM)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_string, struct_val);
    $1->vtable->set_number_keyed(interpreter, $1, &key, $3);
    goto NEXT();
}

inline op set_keyed (out PMC, in STR, in STR)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_string, struct_val);
    $1->vtable->set_string_keyed(interpreter, $1, &key, $3);
    goto NEXT();
}

inline op set_keyed (out PMC, in STR, in PMC)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_string, struct_val);
    $1->vtable->set_pmc_keyed(interpreter, $1, NULL, $3, &key);
    goto NEXT();
}

=head2 Keyed set operations: Ax = Px[Sx]

=item B<set_keyed>(out INT, in PMC, in STR)

=item B<set_keyed>(out NUM, in PMC, in STR)

=item B<set_keyed>(out STR, in PMC, in STR)

=item B<set_keyed>(out PMC, in PMC, in STR)

=cut

inline op set_keyed (out INT, in PMC, in STR)  {
    KEY key;
    MAKE_KEY(key, $3, enum_key_string, struct_val);
    $1 = $2->vtable->get_integer_keyed(interpreter, $2, &key);
    goto NEXT();
}

inline op set_keyed (out NUM, in PMC, in STR)  {
    KEY key;
    MAKE_KEY(key, $3, enum_key_string, struct_val);
    $1 = $2->vtable->get_number_keyed(interpreter, $2, &key);
    goto NEXT();
}

inline op set_keyed (out STR, in PMC, in STR)  {
    KEY key;
    MAKE_KEY(key, $3, enum_key_string, struct_val);
    $1 = $2->vtable->get_string_keyed(interpreter, $2, &key);
    goto NEXT();
}

inline op set_keyed (out PMC, in PMC, in STR)  {
    KEY key;
    MAKE_KEY(key, $3, enum_key_string, struct_val);
    $1 = $2->vtable->get_pmc_keyed(interpreter, $2, &key);
    goto NEXT();
}

=head2 Keyed set operations: Px[Nx] = Bx

=item B<set_keyed>(out PMC, in NUM, in INT)

=item B<set_keyed>(out PMC, in NUM, in NUM)

=item B<set_keyed>(out PMC, in NUM, in STR)

=item B<set_keyed>(out PMC, in NUM, in PMC)

=cut

inline op set_keyed (out PMC, in NUM, in INT)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_num, num_val);
    $1->vtable->set_integer_keyed(interpreter, $1, &key, $3);
    goto NEXT();
}

inline op set_keyed (out PMC, in NUM, in NUM)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_num, num_val);
    $1->vtable->set_number_keyed(interpreter, $1, &key, $3);
    goto NEXT();
}

inline op set_keyed (out PMC, in NUM, in STR)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_num, num_val);
    $1->vtable->set_string_keyed(interpreter, $1, &key, $3);
    goto NEXT();
}

inline op set_keyed (out PMC, in NUM, in PMC)  {
    KEY key;
    MAKE_KEY(key, $2, enum_key_num, num_val);
    $1->vtable->set_pmc_keyed(interpreter, $1, NULL, $3, &key);
    goto NEXT();
}

=head2 Keyed set operations: Ax = Px[Nx]

=item B<set_keyed>(out INT, in PMC, in NUM)

=item B<set_keyed>(out NUM, in PMC, in NUM)

=item B<set_keyed>(out STR, in PMC, in NUM)

=item B<set_keyed>(out PMC, in PMC, in NUM)

=cut

inline op set_keyed (out INT, in PMC, in NUM)  {
    KEY key;
    MAKE_KEY(key, $3, enum_key_num, num_val);
    $1 = $2->vtable->get_integer_keyed(interpreter, $2, &key);
    goto NEXT();
}

inline op set_keyed (out NUM, in PMC, in NUM)  {
    KEY key;
    MAKE_KEY(key, $3, enum_key_num, num_val);
    $1 = $2->vtable->get_number_keyed(interpreter, $2, &key);
    goto NEXT();
}

inline op set_keyed (out STR, in PMC, in NUM)  {
    KEY key;
    MAKE_KEY(key, $3, enum_key_num, num_val);
    $1 = $2->vtable->get_string_keyed(interpreter, $2, &key);
    goto NEXT();
}

inline op set_keyed (out PMC, in PMC, in NUM)  {
    KEY key;
    MAKE_KEY(key, $3, enum_key_num, num_val);
    $1 = $2->vtable->get_pmc_keyed(interpreter, $2, &key);
    goto NEXT();
}


=item B<clone>(out PMC, in PMC)

Copies a PMC $1 to $2.

=cut

inline op clone(out PMC, in PMC) {
  $1 = $2->vtable->clone(interpreter, $2);
  goto NEXT();
}

=back

=cut


###############################################################################

=head2 Conditional branch operations

These operations perform a conditional relative branch. If the condition is
met, the branch happens, otherwise control falls to the next operation.

=over 4

=cut


########################################

=item B<eq>(in INT, in INT)

=item B<eq>(in NUM, in NUM)

=item B<eq>(in STR, in STR)

=item B<eq>(in PMC, in PMC)

=item B<eq>(in INT, in INT, inconst INT)

=item B<eq>(in NUM, in NUM, inconst INT)

=item B<eq>(in STR, in STR, inconst INT)

=item B<eq>(in PMC, in PMC, inconst INT)

Branch if $1 is equal to $2.

Return address is popped off the call stack if no address is supplied.

=cut

inline op eq (in INT, in INT) {
  if ($1 == $2) {
    goto POP();
  }
  goto NEXT();
}

inline op eq (in NUM, in NUM) {
  if ($1 == $2) {
    goto POP();
  }
  goto NEXT();
}

op eq (in STR, in STR) {
  if (string_compare (interpreter, $1, $2) == 0) {
    goto POP();
  }
  goto NEXT();
}

op eq (in PMC, in PMC) {
  if ($1->vtable->is_equal(interpreter, $1, $2)) {
    goto POP();
  }
  goto NEXT();
}

inline op eq(in INT, in INT, inconst INT) {
  if ($1 == $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op eq(in NUM, in NUM, inconst INT) {
  if ($1 == $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op eq(in STR, in STR, inconst INT) {
  if (string_compare(interpreter, $1, $2) == 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op eq (in PMC, in PMC, inconst INT) {
  if ($1->vtable->is_equal(interpreter, $1, $2)) {
    goto OFFSET($3);
  }
  goto NEXT();
}

########################################

=item B<ne>(in INT, in INT)

=item B<ne>(in NUM, in NUM)

=item B<ne>(in STR, in STR)

=item B<ne>(in PMC, in PMC)

=item B<ne>(in INT, in INT, inconst INT)

=item B<ne>(in NUM, in NUM, inconst INT)

=item B<ne>(in STR, in STR, inconst INT)

=item B<ne>(in PMC, in PMC, inconst INT)

Branch if $1 is not equal to $2.

Return address is popped off the call stack if no address is supplied.

=cut

inline op ne (in INT, in INT) {
  if ($1 != $2) {
    goto POP();
  }
  goto NEXT();
}

inline op ne (in NUM, in NUM) {
  if ($1 != $2) {
    goto POP();
  }
  goto NEXT();
}

op ne (in STR, in STR) {
  if (string_compare (interpreter, $1, $2) != 0) {
    goto POP();
  }
  goto NEXT();
}

op ne (in PMC, in PMC) {
  if (! $1->vtable->is_equal(interpreter, $1, $2)) {
    goto POP();
  }
  goto NEXT();
}

inline op ne(in INT, in INT, inconst INT) {
  if ($1 != $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op ne(in NUM, in NUM, inconst INT) {
  if ($1 != $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op ne(in STR, in STR, inconst INT) {
  if (string_compare(interpreter, $1, $2) != 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op ne(in PMC, in PMC, inconst INT) {
  if (! $1->vtable->is_equal(interpreter, $1, $2)) {
    goto OFFSET($3);
  }
  goto NEXT();
}

########################################

=item B<lt>(in INT, in INT, inconst INT)

=item B<lt>(in NUM, in NUM, inconst INT)

=item B<lt>(in STR, in STR, inconst INT)

=item B<lt>(in PMC, in PMC, inconst INT)

Branch if $1 is less than $2.

=cut

inline op lt(in INT, in INT, inconst INT) {
  if ($1 < $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op lt(in NUM, in NUM, inconst INT) {
  if ($1 < $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op lt(in STR, in STR, inconst INT) {
  if (string_compare(interpreter, $1, $2) < 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op lt (in PMC, in PMC, inconst INT) {
  if ($1->vtable->cmp(interpreter, $1, $2) < 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

########################################

=item B<le>(in INT, in INT, inconst INT)

=item B<le>(in NUM, in NUM, inconst INT)

=item B<le>(in STR, in STR, inconst INT)

=item B<le>(in PMC, in PMC, inconst INT)

Branch if $1 is less than or equal to $2.

=cut

inline op le(in INT, in INT, inconst INT) {
  if ($1 <= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op le(in NUM, in NUM, inconst INT) {
  if ($1 <= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op le(in STR, in STR, inconst INT) {
  if (string_compare(interpreter, $1, $2) <= 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op le(in PMC, in PMC, inconst INT) {
  if ($1->vtable->cmp(interpreter, $1, $2) <= 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

########################################

=item B<gt>(in INT, in INT, inconst INT)

=item B<gt>(in NUM, in NUM, inconst INT)

=item B<gt>(in STR, in STR, inconst INT)

=item B<gt>(in PMC, in PMC, inconst INT)

Branch if $1 is greater than $2.

=cut

inline op gt(in INT, in INT, inconst INT) {
  if ($1 > $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op gt(in NUM, in NUM, inconst INT) {
  if ($1 > $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op gt(in STR, in STR, inconst INT) {
  if (string_compare(interpreter, $1, $2) > 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op gt(in PMC, in PMC, inconst INT) {
  if ($1->vtable->cmp(interpreter, $1, $2) > 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

########################################

=item B<ge>(in INT, in INT, inconst INT)

=item B<ge>(in NUM, in NUM, inconst INT)

=item B<ge>(in STR, in STR, inconst INT)

=item B<ge>(in PMC, in PMC, inconst INT)

Branch if $1 is greater than or equal to $2.

=cut

inline op ge(in INT, in INT, inconst INT) {
  if ($1 >= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op ge(in NUM, in NUM, inconst INT) {
  if ($1 >= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op ge(in STR, in STR, inconst INT) {
  if (string_compare(interpreter, $1, $2) >= 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op ge(in PMC, in PMC, inconst INT) {
  if ($1->vtable->cmp(interpreter, $1, $2) >= 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

########################################

=item B<if>(in INT, inconst INT)

=item B<if>(in NUM, inconst INT)

=item B<if>(in PMC, inconst INT)

=item B<if>(in STR, inconst INT)

Check register $1. If true, branch by $2.

=cut

inline op if(in INT, inconst INT) {
  if ($1 != 0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

inline op if(in NUM, inconst INT) {
  if ($1 != 0.0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op if (in STR, inconst INT) {
  if (string_bool($1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op if(in PMC, inconst INT) {
  if ($1->vtable->get_bool(interpreter, $1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}


###############################################################################

=item B<unless>(in INT, inconst INT)

=item B<unless>(in NUM, inconst INT)

=item B<unless>(in PMC, inconst INT)

=item B<unless>(in STR, inconst INT)

Check register $1. If false, branch by $2.

=cut

inline op unless(in INT, inconst INT) {
  if ($1 == 0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

inline op unless(in NUM, inconst INT) {
  if ($1 == 0.0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op unless (in STR, inconst INT) {
  if (!string_bool($1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op unless(in PMC, inconst INT) {
  if (!$1->vtable->get_bool(interpreter, $1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}

=back

=cut



###############################################################################
=head2 Arithmetic operations

These operations store the results of arithmetic on other registers and
constants into their destination register, $1.

=over 4

=cut

########################################

=item B<abs>(out INT, in INT)

=item B<abs>(out INT, in NUM)

=item B<abs>(out NUM, in INT)

=item B<abs>(out NUM, in NUM)

Set $1 to absolute value of $2.

=cut

inline op abs(out INT, in INT) {
  if ($2 < 0) {
    $1 = - (INTVAL)$2;
  }
  else {
    $1 = (INTVAL)$2;
  }
  goto NEXT();
}

inline op abs(out INT, in NUM) {
  if ($2 < 0) {
    $1 = - (INTVAL)$2;
  }
  else {
    $1 = (INTVAL)$2;
  }
  goto NEXT();
}

inline op abs(out NUM, in INT) {
  if ($2 < 0) {
    $1 = - (FLOATVAL)$2;
  }
  else {
    $1 = (FLOATVAL)$2;
  }
  goto NEXT();
}

inline op abs(out NUM, in NUM) {
  if ($2 < 0) {
    $1 = - (FLOATVAL)$2;
  }
  else {
    $1 = (FLOATVAL)$2;
  }
  goto NEXT();
}


########################################

=item B<add>(inout INT, in INT)

=item B<add>(inout NUM, in NUM)

=item B<add>(inout PMC, in INT)

=item B<add>(inout PMC, in NUM)

=item B<add>(inout PMC, in PMC)

Increase $1 by the amount in $2.

=item B<add>(out INT, in INT, in INT)

=item B<add>(out NUM, in NUM, in NUM)

=item B<add>(out PMC, in PMC, in INT)

=item B<add>(out PMC, in PMC, in PMC)

Set $1 to the sum of $2 and $3.

=cut

inline op add(inout INT, in INT) {
  $1 += $2;
  goto NEXT();
}

inline op add(inout NUM, in NUM) {
  $1 += $2;
  goto NEXT();
}

inline op add(inout PMC, in INT) {
  $1->vtable->add_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op add(inout PMC, in NUM) {
  $1->vtable->add_float(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op add(inout PMC, in PMC) {
  $1->vtable->add(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op add(out INT, in INT, in INT) {
  $1 = $2 + $3;
  goto NEXT();
}

inline op add(out NUM, in NUM, in NUM) {
  $1 = $2 + $3;
  goto NEXT();
}

inline op add(out PMC, in PMC, in INT) {
  $2->vtable->add_int(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op add (out PMC, in PMC, in PMC) {
  $2->vtable->add(interpreter, $2, $3, $1);
  goto NEXT();
}


########################################

=item B<cmod>(out INT, in INT, in INT)

NOTE: This "uncorrected mod" algorithm uses the C language's built-in
mod operator (x % y), which is

    ... the remainder when x is divided by y, and thus is zero
    when y divides x exactly.
    ...
    The direction of truncation for / and the sign of the result
    for % are machine-dependent for negative operands, as is the
    action taken on overflow or underflow.
                                                     -- [1], page 41

Also:

    ... if the second operand is 0, the result is undefined. 
    Otherwise, it is always true that (a/b)*b + a%b is equal to z. If
    both operands are non-negative, then the remainder is non-
    negative and smaller than the divisor; if not, it is guaranteed
    only that the absolute value of the remainder is smaller than
    the absolute value of the divisor.
                                                     -- [1], page 205

This op is provided for those who need it (such as speed-sensitive
applications with heavy use of mod, but using it only with positive
arguments), but a more mathematically useful mod based on ** floor(x/y)
and defined with y == 0 is provided by the mod op.

  [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
      Language*, Second Edition. Prentice Hall, 1988.

TODO: Doesn't the Parrot interpreter need to catch the exception?

=cut

inline op cmod(out INT, in INT, in INT) {
  $1 = $2 % $3;
  goto NEXT();
}


########################################

=item B<cmod>(out NUM, in NUM, in NUM)

NOTE: This "uncorrected mod" algorithm uses the built-in C math library's
fmod() function, which computes

    ... the remainder of dividing x by y. The return value is
    x - n * y, where n is the quotient of x / y, rounded towards
    zero to an integer.
                                -- fmod() manpage on RedHat Linux 7.0

In addition, fmod() returns

    the remainder, unless y is zero, when the function fails and
    errno is set.

According to page 251 of [1], the result when y is zero is implementation-
defined.

This op is provided for those who need it, but a more mathematically
useful numeric mod based on floor(x/y) instead of truncate(x/y) and
defined with y == 0 is provided by the mod op.

  [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
      Language*, Second Edition. Prentice Hall, 1988.

TODO: Doesn't the Parrot interpreter need to catch the exception?

=cut

inline op cmod(out NUM, in NUM, in NUM) {
  $1 = fmod($2, $3);
  goto NEXT();
}


########################################

=item B<dec>(inout INT)

=item B<dec>(inout NUM)

=item B<dec>(inout PMC)

Decrease $1 by one.

=cut

inline op dec(inout INT) {
  $1--;
  goto NEXT();
}

inline op dec(inout NUM) {
  $1--;
  goto NEXT();
}

inline op dec(inout PMC) {
  $1->vtable->decrement(interpreter, $1);
  goto NEXT();
}

########################################

=item B<div>(out INT, in INT, in INT)

=item B<div>(out NUM, in NUM, in NUM)

=item B<div>(out PMC, in PMC, in PMC)

Set $1 to the quotient of $2 divided by $3. In the case of INTVAL division, the
result is truncated (NOT rounded or floored).

=cut

inline op div(out INT, in INT, in INT) {
  $1 = $2 / $3;
  goto NEXT();
}

inline op div(out NUM, in NUM, in NUM) {
  $1 = $2 / $3;
  goto NEXT();
}

inline op div (out PMC, out PMC, out PMC) {
  $2->vtable->divide(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<inc>(inout INT)

=item B<inc>(inout NUM)

=item B<inc>(inout PMC)

Increase $1 by one.

=cut

inline op inc(inout INT) {
  $1++;
  goto NEXT();
}

inline op inc(inout NUM) {
  $1++;
  goto NEXT();
}

inline op inc(inout PMC) {
  $1->vtable->increment(interpreter, $1);
  goto NEXT();
}


########################################

=item B<mod>(out INT, in INT, in INT)

NOTE: This "corrected mod" algorithm is based on the C code on page 70
of [1]. Assuming correct behavior of the built-in mod operator (%) with
positive arguments, this algorithm implements a mathematically convenient
version of mod, defined thus:

  x mod y = x - y * floor(x / y)

For more information on this definition of mod, see section 3.4 of [2],
pages 81-85.

References:

  [1] Donald E. Knuth, *MMIXware: A RISC Computer for the Third
      Millennium* Springer, 1999.

  [2] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
      Mathematics*, Second Edition. Addison-Wesley, 1994.

=item B<mod>(out PMC, in PMC, in PMC)

Sets $1 to the modulus of $2 and $3.

=cut

op mod(out INT, in INT, in INT) {
  INTVAL y = $2;
  INTVAL z = $3;
  INTVAL s = 0;
  INTVAL r;

  if (z == 0) {
    r = y;
  }
  else {
    if (y < 0) { s += 2; y = -y; }
    if (z < 0) { s += 1; z = -z; }

    r = y % z;

    switch (s) {
      case 0 + 0:            break;
      case 0 + 1: r = r - z; break;
      case 2 + 0: r = z - r; break;
      case 2 + 1: r = -r;    break;
    }
  }

  $1 = r;
  goto NEXT();
}

inline op mod (out PMC, out PMC, out PMC) {
  $2->vtable->modulus(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<mod>(out NUM, in NUM, in NUM)

NOTE: This "corrected mod" algorithm is based on the formula of [1]:

  x mod y = x - y * floor(x / y)

For more information on this definition of mod, see section 3.4 of [1],
pages 81-85.

References:

  [1] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
      Mathematics*, Second Edition. Addison-Wesley, 1994.

=cut

op mod(out NUM, in NUM, in NUM) {
  $1 = $3
     ? ($2 - $3 * floor($2 / $3))
     : $2;
  goto NEXT();
}


########################################

=item B<mul>(inout INT, in INT)

=item B<mul>(inout NUM, in NUM)

=item B<mul>(inout PMC, in PMC)

Set $1 to the product of $1 and $2.

=item B<mul>(out INT, in INT, in INT)

=item B<mul>(out NUM, in NUM, in NUM)

=item B<mul>(out PMC, in PMC, in PMC)

Set $1 to the product of $2 and $3.

=cut

inline op mul(inout INT, in INT) {
  $1 *= $2;
  goto NEXT();
}

inline op mul(inout NUM, in NUM) {
  $1 *= $2;
  goto NEXT();
}

inline op mul (inout PMC, out PMC) {
  $1->vtable->multiply(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op mul(out INT, in INT, in INT) {
  $1 = $2 * $3;
  goto NEXT();
}

inline op mul(out NUM, in NUM, in NUM) {
  $1 = $2 * $3;
  goto NEXT();
}

inline op mul (out PMC, out PMC, out PMC) {
  $2->vtable->multiply(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<neg>(inout INT)

=item B<neg>(inout NUM)

Set $1 to it's negative.

=item B<neg>(out INT, in INT)

=item B<neg>(out NUM, in NUM)

=item B<neg>(out PMC, in PMC)

Set $1 to the negative of $2.

=cut

inline op neg(inout INT) {
  $1 = -($1);
  goto NEXT();
}

inline op neg(inout NUM) {
  $1 = -($1);
  goto NEXT();
}

inline op neg(out INT, in INT) {
  $1 = -($2);
  goto NEXT();
}

inline op neg(out NUM, in NUM) {
  $1 = -($2);
  goto NEXT();
}

inline op neg(out PMC, in PMC) {
  $2->vtable->neg(interpreter, $2, $1);
  goto NEXT();
}

########################################

=item B<pow>(out NUM, in INT, in INT)

=item B<pow>(out NUM, in INT, in NUM)

=item B<pow>(out NUM, in NUM, in INT)

=item B<pow>(out NUM, in NUM, in NUM)

Set $1 to $2 raised to the power $3.

=cut

inline op pow(out NUM, in INT, in INT) {
   $1 = pow((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op pow(out NUM, in INT, in NUM) {
   $1 = pow((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op pow(out NUM, in NUM, in INT) {
   $1 = pow((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op pow(out NUM, in NUM, in NUM) {
   $1 = pow((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}


########################################

=item B<sub>(inout INT, in INT)

=item B<sub>(inout NUM, in NUM)

=item B<sub>(inout PMC, in INT)

=item B<sub>(inout PMC, in NUM)

=item B<sub>(inout PMC, in PMC)

Decrease $1 by the amount in $2.

=item B<sub>(out INT, in INT, in INT)

=item B<sub>(out NUM, in NUM, in NUM)

=item B<sub>(out PMC, in PMC, in INT)

=item B<sub>(out PMC, in PMC, in PMC)

Set $1 to $2 minus $3.

=cut

inline op sub(inout INT, in INT) {
  $1 -= $2;
  goto NEXT();
}

inline op sub(inout NUM, in NUM) {
  $1 -= $2;
  goto NEXT();
}

inline op sub(inout PMC, in INT) {
  $1->vtable->subtract_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op sub(inout PMC, in NUM) {
  $1->vtable->subtract_float(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op sub(inout PMC, in PMC) {
  $1->vtable->subtract(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op sub(out INT, in INT, in INT) {
  $1 = $2 - $3;
  goto NEXT();
}

inline op sub(out NUM, in NUM, in NUM) {
  $1 = $2 - $3;
  goto NEXT();
}

inline op sub(out PMC, in PMC, in INT) {
  $2->vtable->subtract_int(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op sub (out PMC, out PMC, out PMC) {
  $2->vtable->subtract(interpreter, $2, $3, $1);
  goto NEXT();
}

=back

=cut


###############################################################################

=head2 String operations

These operations operate on STRINGs.

=over 4

=cut


########################################

=item B<chopn>(inout STR, in INT)

=item B<chopn>(out STR, in STR, in INT)

Remove $2 characters from the end of the string in $1.  The 3-arg version
removes $3 characters from the end of the string in $2 and returns the result
in $1

=cut

inline op chopn(inout STR, in INT) {
  (void)string_chopn($1, $2);
  goto NEXT();
}

inline op chopn(out STR, in STR, in INT) {
  $1 = string_copy(interpreter, $2);
  (void)string_chopn($1,$3);
  goto NEXT();
}

########################################

=item B<concat>(inout STR, in STR)

=item B<concat>(out STR, in STR, in STR)

=item B<concat>(out PMC, in PMC, in PMC)

Append the string in $2 to the string in $1.

The three argument version appends the string $3 to $2 and places the result
into $1.

=cut

inline op concat(inout STR, in STR) {
  $1 = string_append(interpreter, $1, $2, 1);
  goto NEXT();
}

inline op concat(out STR, in STR, in STR) {
  $1 = string_concat(interpreter, $2, $3, 1);
  goto NEXT();
}

inline op concat (out PMC, out PMC, out PMC) {
  $2->vtable->concatenate(interpreter, $2, $3, $1);
  goto NEXT();
}

#######################################

=item B<repeat>(out STR, in STR, in INT)

=item B<repeat>(out PMC, in PMC, in PMC)

Repeats string $2 $3 times and stores result in $1.

=cut

inline op repeat(out STR, in STR, in INT) {
  if ($3 < 0) {
      internal_exception(NEG_REPEAT, "Cannot repeat with negative arg");
  }
  $1 = string_repeat(interpreter, $2, (UINTVAL)$3, NULL);
  goto NEXT();
}

inline op repeat (out PMC, in PMC, in PMC) {
  $2->vtable->repeat(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<length>(out INT, in STR)

Set $1 to the length (in characters) of the string in $2.

=cut

inline op length(out INT, in STR) {
  $1 = string_length($2);
  goto NEXT();
}


########################################

=item B<substr>(out STR, in STR, in INT, in INT)

=item B<substr>(out STR, in STR, in INT, in INT, in STR)

=item B<substr>(inout STR, in INT, in INT, in STR)

Set $1 to the portion of $2 starting at (zero-based) character position
$3 and having length $4.

Optionally pass in string $5 for replacement. If the length of $5 is
different from the length specified in $4, then $2 will grow or shrink
accordingly. If $3 is one character position larger than the length of
$2, then $5 is appended to $2 (and the empty string is returned);
this is essentially the same as

  concat $2, $5

Finally, if $3 is negative, then it is taken to count backwards from
the end of the string (ie an offset of -1 corresponds to the last
character).

The third form is optimized for replace only, ignoring the replaced
substring and does not waste a register to do the string replace.

=cut

inline op substr(out STR, in STR, in INT, in INT) {
  $1 = string_substr(interpreter, $2, $3, $4, &$1);
  goto NEXT();
}

inline op substr(out STR, inout STR, in INT, in INT, in STR) {
  $1 = string_replace(interpreter, $2, $3, $4, $5, &$1);
  goto NEXT();
}

inline op substr(inout STR, in INT, in INT, in STR) {
  (void)string_replace(interpreter, $1, $2, $3, $4, NULL);
  goto NEXT();
}


=cut

########################################

=item B<index>(out INT, in STR, in STR)

=item B<index>(out INT, in STR, in STR, in INT)

The index function searches for one string within
another, but without the wildcard-like behavior of
a full regular-expression pattern match.  It
returns the position of the first occurrence of
$3 in $2 at or after $4.  If $4 is omitted, starts 
searching from the beginning of the string.  
The return value is based at "0".
If the substring is not found, returns "-1".

=cut

inline op index(out INT, in STR, in STR) {
    STRING *s = $2;
    STRING *p = $3;
    INTVAL i,j,ls,lp;
    const char *cs, *cp;
    
    ls = string_length(s);
    lp = string_length(p);
    if (s && ls && lp) {
        cs = string_to_cstring(interpreter, (s));
        cp = string_to_cstring(interpreter, (p));
        for(i = 0; i <= ls - lp; i++) {
            for(j = 0; j < lp; j++)
                if (cs[i + j] != cp[j])
                    break;
            if (j == lp) {
                $1 = i;
                goto NEXT();
            }
        }
    }
    $1 = -1;
    goto NEXT();
}

inline op index(out INT, in STR, in STR, in INT) {
    STRING *s = $2;
    STRING *p = $3;
    INTVAL i,j,ls,lp;
    const char *cs, *cp;
    
    ls = string_length(s);
    lp = string_length(p);
    if (s && ls && lp) {
        cs = string_to_cstring(interpreter, (s));
        cp = string_to_cstring(interpreter, (p));
        for(i = $4; i <= ls - lp; i++) {
            for(j = 0; j < lp; j++)
                if (cs[i + j] != cp[j])
                    break;
            if (j == lp) {
                $1 = i;
                goto NEXT();
            }
        }
    }
    $1 = -1;
    goto NEXT();
}

=cut


########################################

=item B<pack>(inout STR, in INT, in INT)

=item B<pack>(inout STR, in INT, in NUM)

=item B<pack>(inout STR, in INT, in STR)

=item B<pack>(inout STR, in INT, in INT, in INT)

=item B<pack>(inout STR, in INT, in NUM, in INT)

=item B<pack>(inout STR, in INT, in STR, in INT)

Concat $2 bytes from $3 at the end of $1 or replace them at $4 if provided.

BE AFRAID, THIS IS A QUICK HACK, USE IT AT YOUR OWN RISK.

=cut

inline op pack(inout STR, in INT, in INT) {
    char *c = (char *)&$3;
    STRING *s;

    s = string_make(interpreter, c, (UINTVAL)$2, NULL, 0, NULL);
    $1 = string_concat(interpreter, $1, s, 1);

    goto NEXT();
}

inline op pack(inout STR, in INT, in NUM) {
    char *c = (char *)&$3;
    STRING *s;

    s = string_make(interpreter, c, (UINTVAL)$2, NULL, 0, NULL);
    $1 = string_concat(interpreter, $1, s, 1);

    goto NEXT();
}

inline op pack(inout STR, in INT, in STR) {
    STRING *t,*s = $3;
    UINTVAL len = (UINTVAL)$2;
    char buf[3];

    if (s->buflen < len) {
        t = string_make(interpreter, buf, (UINTVAL)(len - s->buflen), NULL, 0, NULL); 
        $1 = string_concat(interpreter, $1, s, 1);
    } else {
        t = string_make(interpreter, s->bufstart, (UINTVAL)len, NULL, 0, NULL); 
    }
    $1 = string_concat(interpreter, $1, t, 1);

    goto NEXT();
}


inline op pack(inout STR, in INT, in INT, in INT) {
    char *c = (char *)&$3, *n;
    STRING *s;
    INTVAL ln;
    const char *t;
    int i;
    
    s = string_make(interpreter, c, (UINTVAL)$2, NULL, 0, NULL);
    ln = string_length($1);
    if (ln < $4 + $2)
    {
       $1->buflen = $1->strlen;
       string_grow(interpreter, $1, $4 + $2 - ln);
       $1->bufused = $1->strlen = $1->buflen;
    }

    /* XXX this is EVIL, use string_replace */
    n = $1->bufstart;
    t = string_to_cstring(interpreter, s);
    for (i = $4; i < $4 + $2; i++)
        n[i] = t[i - $4]; 
    

    goto NEXT();
}

=back

=cut

###############################################################################

=head2 Transcendental mathematical operations

These operations perform various transcendental operations such as logarithmics
and trigonometrics.

=over 4

=cut


########################################

=item B<acos>(out NUM, in INT)

=item B<acos>(out NUM, in NUM)

Set $1 to the arc cosine (in radians) of $2.

=cut

inline op acos(out NUM, in INT) {
  $1 = acos((FLOATVAL)$2);
  goto NEXT();
}

inline op acos(out NUM, in NUM) {
  $1 = acos((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<asec>(out NUM, in INT)

=item B<asec>(out NUM, in NUM)

Set $1 to the arc secant (in radians) of $2.

=cut

inline op asec(out NUM, in INT) {
  $1 = acos(((FLOATVAL)1) / ((FLOATVAL)$2));
  goto NEXT();
}

inline op asec(out NUM, in NUM) {
  $1 = acos(((FLOATVAL)1) / ((FLOATVAL)$2));
  goto NEXT();
}


########################################

=item B<asin>(out NUM, in INT)

=item B<asin>(out NUM, in NUM)

Set $1 to the arc sine (in radians) of $2.

=cut

inline op asin(out NUM, in INT) {
  $1 = asin((FLOATVAL)$2);
  goto NEXT();
}

inline op asin(out NUM, in NUM) {
  $1 = asin((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<atan>(out NUM, in INT)

=item B<atan>(out NUM, in NUM)

=item B<atan>(out NUM, in INT, in INT)

=item B<atan>(out NUM, in INT, in NUM)

=item B<atan>(out NUM, in NUM, in INT)

=item B<atan>(out NUM, in NUM, in NUM)

The two-argument versions set $1 to the arc tangent (in radians) of $2.

The three-argument versions set $1 to the arc tangent (in radians) of
$2 / $3, taking account of the signs of the arguments in determining the
quadrant of the result.

=cut

inline op atan(out NUM, in INT) {
  $1 = atan((FLOATVAL)$2);
  goto NEXT();
}

inline op atan(out NUM, in NUM) {
  $1 = atan((FLOATVAL)$2);
  goto NEXT();
}

inline op atan(out NUM, in INT, in INT) {
  $1 = atan2((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op atan(out NUM, in INT, in NUM) {
  $1 = atan2((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op atan(out NUM, in NUM, in INT) {
  $1 = atan2((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op atan(out NUM, in NUM, in NUM) {
  $1 = atan2((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}


########################################

=item B<cos>(out NUM, in INT)

=item B<cos>(out NUM, in NUM)

Set $1 to the cosine of $2 (given in radians).

=cut

inline op cos(out NUM, in INT) {
  $1 = cos((FLOATVAL)$2);
  goto NEXT();
}

inline op cos(out NUM, in NUM) {
  $1 = cos((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<cosh>(out NUM, in INT)

=item B<cosh>(out NUM, in NUM)

Set $1 to the hyperbolic cosine of $2 (given in radians).

=cut

inline op cosh(out NUM, in INT) {
  $1 = cosh((FLOATVAL)$2);
  goto NEXT();
}

inline op cosh(out NUM, in NUM) {
  $1 = cosh((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<exp>(out NUM, in INT)

=item B<exp>(out NUM, in NUM)

Set $1 to I<e> raised to the power $2. I<e> is the base of the natural logarithm.

=cut

inline op exp(out NUM, in INT) {
  $1 = exp((FLOATVAL)$2);
  goto NEXT();
}

inline op exp(out NUM, in NUM) {
  $1 = exp((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<ln>(out NUM, in INT)

=item B<ln>(out NUM, in NUM)

Set $1 to the natural (base I<e>) logarithm of $2.

=cut

inline op ln(out NUM, in INT) {
  $1 = log((FLOATVAL)$2);
  goto NEXT();
}

inline op ln(out NUM, in NUM) {
  $1 = log((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<log10>(out NUM, in INT)

=item B<log10>(out NUM, in NUM)

Set $1 to the base 10 logarithm of $2.

=cut

inline op log10(out NUM, in INT) {
  $1 = log10((FLOATVAL)$2);
  goto NEXT();
}

inline op log10(out NUM, in NUM) {
  $1 = log10((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<log2>(out NUM, in INT)

=item B<log2>(out NUM, in NUM)

Set $1 to the base 2 logarithm of $2.

=cut

op log2(out NUM, in INT) {
   FLOATVAL temp = log((FLOATVAL)2.0);
  $1 = log((FLOATVAL)$2) / temp;
  goto NEXT();
}

op log2(out NUM, in NUM) {
   FLOATVAL temp = log((FLOATVAL)2.0);
  $1 = log((FLOATVAL)$2) / temp;
  goto NEXT();
}


########################################

=item B<sec>(out NUM, in INT)

=item B<sec>(out NUM, in NUM)

Set $1 to the secant of $2 (given in radians).

=cut

inline op sec(out NUM, in INT) {
  $1 = ((FLOATVAL)1) / cos((FLOATVAL)$2);
  goto NEXT();
}

inline op sec(out NUM, in NUM) {
  $1 = ((FLOATVAL)1) / cos((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<sech>(out NUM, in INT)

=item B<sech>(out NUM, in NUM)

Set $1 to the hyperbolic secant of $2 (given in radians).

=cut

inline op sech(out NUM, in INT) {
  $1 = ((FLOATVAL)1) / cosh((FLOATVAL)$2);
  goto NEXT();
}

inline op sech(out NUM, in NUM) {
  $1 = ((FLOATVAL)1) / cosh((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<sin>(out NUM, in INT)

=item B<sin>(out NUM, in NUM)

Set $1 to the sine of $2 (given in radians).

=cut

inline op sin(out NUM, in INT) {
  $1 = sin((FLOATVAL)$2);
  goto NEXT();
}

inline op sin(out NUM, in NUM) {
  $1 = sin((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<sinh>(out NUM, in INT)

=item B<sinh>(out NUM, in NUM)

Set $1 to the hyperbolic sine of $2 (given in radians).

=cut

inline op sinh(out NUM, in INT) {
  $1 = sinh((FLOATVAL)$2);
  goto NEXT();
}

inline op sinh(out NUM, in NUM) {
  $1 = sinh((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<tan>(out NUM, in INT)

=item B<tan>(out NUM, in NUM)

Set $1 to the tangent of $2 (given in radians).

=cut

inline op tan(out NUM, in INT) {
  $1 = tan((FLOATVAL)$2);
  goto NEXT();
}

inline op tan(out NUM, in NUM) {
  $1 = tan((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<tanh>(out NUM, in INT)

=item B<tanh>(out NUM, in NUM)

Set $1 to the hyperbolic tangent of $2 (given in radians).

=cut

inline op tanh(out NUM, in INT) {
  $1 = tanh((FLOATVAL)$2);
  goto NEXT();
}

inline op tanh(out NUM, in NUM) {
  $1 = tanh((FLOATVAL)$2);
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 Bitwise logical operations

These operations apply  bitwise logical functions to their arguments.

=over 4

=cut


########################################

=item B<band>(inout INT, in INT)

=item B<band>(inout PMC, in INT)

=item B<band>(inout PMC, in PMC)

Set the bits of $1 according to the B<and> of the corresponding bits from $1 and $2.

=item B<band>(out INT, in INT, in INT)

=item B<band>(out PMC, in PMC, in INT)

=item B<band>(out PMC, in PMC, in PMC)

Set the bits of $1 according to the B<and> of the corresponding bits from $2 and $3.

=cut

inline op band(inout INT, in INT) {
  $1 &= $2;
  goto NEXT();
}

inline op band(inout PMC, in INT) {
  $1->vtable->bitwise_and_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op band(inout PMC, in PMC) {
  $1->vtable->bitwise_and(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op band(out INT, in INT, in INT) {
  $1 = $2 & $3;
  goto NEXT();
}

inline op band(out PMC, in PMC, in INT) {
  $2->vtable->bitwise_and_int(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op band(out PMC, in PMC, in PMC) {
  $2->vtable->bitwise_and(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<bnot>(out INT, in INT)

=item B<bnot>(out PMC, in PMC)

Set the bits of $1 to the B<not> of the corresponding bits from $2.

=cut

inline op bnot(out INT, in INT) {
  $1 = ~ $2;
  goto NEXT();
}

inline op bnot(out PMC, in PMC) {
  $2->vtable->bitwise_not(interpreter, $2, $1);
  goto NEXT();
}

########################################

=item B<bor>(inout INT, in INT)

=item B<bor>(inout PMC, in INT)

=item B<bor>(inout PMC, in PMC)

Set the bits of $1 according to the B<or> of the corresponding bits from $1 and $2.

=item B<bor>(out INT, in INT, in INT)

=item B<bor>(out PMC, in PMC, in INT)

=item B<bor>(out PMC, in PMC, in PMC)

Set the bits of $1 according to the B<or> of the corresponding bits from $2 and $3.

=cut

inline op bor(inout INT, in INT) {
  $1 |= $2;
  goto NEXT();
}

inline op bor(inout PMC, in INT) {
  $1->vtable->bitwise_or_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op bor(inout PMC, in PMC) {
  $1->vtable->bitwise_or(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op bor(out INT, in INT, in INT) {
  $1 = $2 | $3;
  goto NEXT();
}

inline op bor(out PMC, in PMC, in INT) {
  $2->vtable->bitwise_or_int(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op bor(out PMC, in PMC, in PMC) {
  $2->vtable->bitwise_or(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<shl>(out INT, in INT, in INT)

=item B<shl>(out PMC, in PMC, in PMC)

Set $1 to the value of $2 shifted left by $3 bits.

=cut

inline op shl(out INT, in INT, in INT) {
  $1 = $2 << $3;
  goto NEXT();
}

inline op shl(out PMC, in PMC, in PMC) {
  $2->vtable->bitwise_shl(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<shr>(out INT, in INT, in INT)

=item B<shr>(out PMC, in PMC, in PMC)

Set $1 to the value of $2 shifted right by $3 bits.

=cut

inline op shr(out INT, in INT, in INT) {
  $1 = $2 >> $3;
  goto NEXT();
}

inline op shr(out PMC, in PMC, in PMC) {
  $2->vtable->bitwise_shr(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<bxor>(inout INT, in INT)

=item B<bxor>(inout PMC, in INT)

=item B<bxor>(inout PMC, in PMC)

Set the bits of $1 according to the B<xor> of the corresponding bits from $1 and $2.

=item B<bxor>(out INT, in INT, in INT)

=item B<bxor>(out PMC, in PMC, in INT)

=item B<bxor>(out PMC, in PMC, in PMC)

Set the bits of $1 according to the B<xor> of the corresponding bits from $2 and $3.

=cut

inline op bxor(inout INT, in INT) {
  $1 ^= $2;
  goto NEXT();
}

inline op bxor(inout PMC, in INT) {
  $1->vtable->bitwise_xor_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op bxor(inout PMC, in PMC) {
  $1->vtable->bitwise_xor(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op bxor(out INT, in INT, in INT) {
  $1 = $2 ^ $3;
  goto NEXT();
}

inline op bxor(out PMC, in PMC, in INT) {
  $2->vtable->bitwise_xor_int(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op bxor(out PMC, in PMC, in PMC) {
  $2->vtable->bitwise_xor(interpreter, $2, $3, $1);
  goto NEXT();
}

=back

=cut


###############################################################################

=head2 Logical operations

These operations apply logical functions to their arguments.

=over 4

=cut


########################################

=item B<and>(out INT, in INT, in INT)

=item B<and>(out PMC, in PMC, in PMC)

Short-circuiting logical and.  Returns $2 if it's false, else returns $3.

=cut

inline op and(out INT, in INT, in INT) {
  $1 = $2 ? $3 : $2;
  goto NEXT();
}

inline op and(out PMC, in PMC, in PMC) {
  $2->vtable->logical_and(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<not>(out INT, in INT)

=item B<not>(out PMC, in PMC)

Set the boolean state of $1 to the opposite of the boolean state from $2.

=cut

inline op not(out INT, in INT) {
  $1 = ! $2;
  goto NEXT();
}

inline op not(out PMC, in PMC) {
  $2->vtable->logical_not(interpreter, $2, $1);
  goto NEXT();
}

########################################

=item B<or>(out INT, in INT, in INT)

=item B<or>(out PMC, in PMC, in PMC)

Short-circuiting logical or.  Returns $2 if it's true, else returns $3.

=cut

inline op or(out INT, in INT, in INT) {
  $1 = $2 ? $2 : $3;
  goto NEXT();
}

inline op or(out PMC, in PMC, in PMC) {
  $2->vtable->logical_or(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<xor>(out INT, in INT, in INT)

=item B<xor>(out PMC, in PMC, in PMC)

Logical xor.  Returns $2 if it's true and $3 isn't,
returns $3 if it's true and $2 isn't, else returns false.

=cut

inline op xor(out INT, in INT, in INT) {
  $1 = ($2 && ! $3) ? $2 : ($3 && ! $2) ? $3 : 0;
  goto NEXT();
}

inline op xor(out PMC, in PMC, in PMC) {
  $2->vtable->logical_xor(interpreter, $2, $3, $1);
  goto NEXT();
}

=cut

=item B<defined>(out INT, in PMC)

Test for PMC definedness.

=cut

inline op defined(out INT, in PMC) {
  $1 = $2->vtable->defined(interpreter, $2);
  goto NEXT();
}

=back

=cut

###############################################################################

=head2 Interpreter flag modification operations

These operations modify the internal interpreter flags, affecting its
subsequent operation.

=over 4

=cut


########################################

=item B<debug>(in INT)

If $1 is zero, turn off debugging. Otherwise turn it on.

=cut

inline op debug(in INT) {
  if ($1 != 0) { Interp_flags_SET(interpreter,   PARROT_DEBUG_FLAG); }
  else         { Interp_flags_CLEAR(interpreter, PARROT_DEBUG_FLAG); }
  restart NEXT();
}


########################################

=item B<bounds>(in INT)

If $1 is zero, turn off byte code bounds checking. Otherwise turn it on.

=cut

inline op bounds(in INT) {
  if ($1 != 0) { Interp_flags_SET(interpreter,   PARROT_BOUNDS_FLAG); }
  else         { Interp_flags_CLEAR(interpreter, PARROT_BOUNDS_FLAG); }
  restart NEXT();
}


########################################

=item B<profile>(in INT)

If $1 is zero, turn off profiling. Otherwise turn it on.

=cut

inline op profile(in INT) {
  if ($1 != 0) { Interp_flags_SET(interpreter,   PARROT_PROFILE_FLAG); }
  else         { Interp_flags_CLEAR(interpreter, PARROT_PROFILE_FLAG); }
  restart NEXT();
}


########################################

=item B<trace>(in INT)

If $1 is zero, turn off tracing. Otherwise turn it on.

=cut

inline op trace(in INT) {
  if ($1 != 0) { Interp_flags_SET(interpreter,   PARROT_TRACE_FLAG); }
  else         { Interp_flags_CLEAR(interpreter, PARROT_TRACE_FLAG); }
  restart NEXT();
}

=back

=cut


###############################################################################

=head2 Register operations

These operations effect entire sets of registers.

=over 4

=cut


########################################

=item B<cleari>()

=item B<clearn>()

=item B<clearp>()

=item B<clears>()

Clear all the registers of the type indicated in the name of the operation.

INTVAL ('i') and FLOATVAL ('n') registers clear to zero.

PMC ('p') and STRING ('s') registers clear to NULL.

=cut

inline op cleari() {
  Parrot_clear_i(interpreter);
  goto NEXT();
}

inline op clearn() {
  Parrot_clear_n(interpreter);
  goto NEXT();
}

inline op clears() {
  Parrot_clear_s(interpreter);
  goto NEXT();
}

inline op clearp() {
  Parrot_clear_p(interpreter);
  goto NEXT();
}


########################################

=item B<popi>()

=item B<popn>()

=item B<popp>()

=item B<pops>()

Restore all the registers of the type indicated in the name of the operation
from the most recently B<push>ed copies.

=cut

inline op popi() {
  Parrot_pop_i(interpreter);
  goto NEXT();
}

inline op popn() {
  Parrot_pop_n(interpreter);
  goto NEXT();
}

inline op pops() {
  Parrot_pop_s(interpreter);
  goto NEXT();
}

inline op popp() {
  Parrot_pop_p(interpreter);
  goto NEXT();
}


########################################

=item B<pushi>()

=item B<pushn>()

=item B<pushp>()

=item B<pushs>()

Save all the registers of the type indicated in the name of the operation.

=cut

inline op pushi() {
  Parrot_push_i(interpreter);
  goto NEXT();
}

inline op pushn() {
  Parrot_push_n(interpreter);
  goto NEXT();
}

inline op pushs() {
  Parrot_push_s(interpreter);
  goto NEXT();
}

inline op pushp() {
  Parrot_push_p(interpreter);
  goto NEXT();
}

=back

=cut

###############################################################################

=head2 Register stack operations

These operations affect individual registers.

=over 4

=cut


########################################

=item B<entrytype>(out INT, in INT)

Gets the type of entry $2 of the user stack and puts it in $1.

=cut

op entrytype(out INT, in INT) {
  Stack_Entry_t *entry;

  entry = stack_entry(interpreter, interpreter->ctx.user_stack, $2);
  if (!entry) {
    internal_exception(99, "Stack Depth wrong");
  }
  $1 = get_entry_type(interpreter, entry);
  goto NEXT();
}

########################################

=item B<depth>(out INT)

Puts the depth of the user stack in $1.

=cut

inline op depth(out INT) {
  $1 = stack_height(interpreter, interpreter->ctx.user_stack);
  goto NEXT();
}


#######################################

=item B<lookback>(out INT, in INT)

=item B<lookback>(out STR, in INT)

=item B<lookback>(out NUM, in INT)

=item B<lookback>(out PMC, in INT)

Finds the entry in the user stack at offset $2 from the top and put it
in register $1. Positive numbers count down from the top of the stack,
negative numbers count up from the bottom. (0 is the topmost entry, -1
is the bottom-most)

=cut

op lookback(out INT, in INT) {
  Stack_Entry_t *entry;
  INTVAL depth = $2;
  INTVAL total_depth;
  /* If they're counting up from the bottom, figure out where we'd be
     if we counted down from the top */
  if (depth < 0) {
    total_depth = stack_height(interpreter, interpreter->ctx.user_stack);
    depth = total_depth + depth;
    if (depth < 0) {
      internal_exception(99, "Stack depth wrong");
    }
  }
  entry = stack_entry(interpreter, interpreter->ctx.user_stack, depth);
  if (entry->entry_type != STACK_ENTRY_INT) {
    internal_exception(ERROR_BAD_STACK_TYPE, "Wrong type on stack!");
  }

  $1 = entry->entry.int_val;
  goto NEXT();
}

op lookback(out STR, in INT) {
  Stack_Entry_t *entry;
  INTVAL depth = $2;
  INTVAL total_depth;
  /* If they're counting up from the bottom, figure out where we'd be
     if we counted down from the top */
  if (depth < 0) {
    total_depth = stack_height(interpreter, interpreter->ctx.user_stack);
    depth = total_depth + depth;
    if (depth < 0) {
      internal_exception(99, "Stack depth wrong");
    }
  }
  entry = stack_entry(interpreter, interpreter->ctx.user_stack, depth);
  if (entry->entry_type != STACK_ENTRY_STRING) {
    internal_exception(ERROR_BAD_STACK_TYPE, "Wrong type on stack!");
  }

  $1 = entry->entry.string_val;
  goto NEXT();
}

op lookback(out NUM, in INT) {
  Stack_Entry_t *entry;
  INTVAL depth = $2;
  INTVAL total_depth;
  /* If they're counting up from the bottom, figure out where we'd be
     if we counted down from the top */
  if (depth < 0) {
    total_depth = stack_height(interpreter, interpreter->ctx.user_stack);
    depth = total_depth + depth;
    if (depth < 0) {
      internal_exception(99, "Stack depth wrong");
    }
  }
  entry = stack_entry(interpreter, interpreter->ctx.user_stack, depth);
  if (entry->entry_type != STACK_ENTRY_FLOAT) {
    internal_exception(ERROR_BAD_STACK_TYPE, "Wrong type on stack!");
  }

  $1 = entry->entry.num_val;
  goto NEXT();
}

op lookback(out PMC, in INT) {
  Stack_Entry_t *entry;
  INTVAL depth = $2;
  INTVAL total_depth;
  /* If they're counting up from the bottom, figure out where we'd be
     if we counted down from the top */
  if (depth < 0) {
    total_depth = stack_height(interpreter, interpreter->ctx.user_stack);
    depth = total_depth + depth;
    if (depth < 0) {
      internal_exception(99, "Stack depth wrong");
    }
  }
  entry = stack_entry(interpreter, interpreter->ctx.user_stack, depth);
  if (entry->entry_type != STACK_ENTRY_PMC) {
    internal_exception(ERROR_BAD_STACK_TYPE, "Wrong type on stack!");
  }

  $1 = entry->entry.pmc_val;
  goto NEXT();
}

########################################

=item B<save>(in INT)

=item B<save>(in NUM)

=item B<save>(in STR)

=item B<save>(in PMC)

Save register or constant $1 onto the user stack.

=cut

inline op save(in INT) {
  INTVAL i = $1;
  stack_push(interpreter, &interpreter->ctx.user_stack, &i, STACK_ENTRY_INT, STACK_CLEANUP_NULL);
  goto NEXT();
}

inline op save(in NUM) {
  stack_push(interpreter, &interpreter->ctx.user_stack, &($1), STACK_ENTRY_FLOAT, STACK_CLEANUP_NULL);
  goto NEXT();
}

inline op save(in PMC) {
  stack_push(interpreter, &interpreter->ctx.user_stack, $1, STACK_ENTRY_PMC, STACK_CLEANUP_NULL);
  goto NEXT();
}

inline op save(in STR) {
  stack_push(interpreter, &interpreter->ctx.user_stack, $1, STACK_ENTRY_STRING, STACK_CLEANUP_NULL);
  goto NEXT();
}


########################################

=item B<savec>(in STR)

=item B<savec>(in PMC)

Save a clone of register or constant $1 onto the user stack.

=cut

inline op savec(in STR) {
  stack_push(interpreter, &interpreter->ctx.user_stack, string_copy(interpreter, $1), STACK_ENTRY_STRING, STACK_CLEANUP_NULL);
  goto NEXT();
}


########################################

=item B<restore>(out INT)

=item B<restore>(out NUM)

=item B<restore>(out PMC)

=item B<restore>(out STR)

Restore register $1 from the user stack.

=cut

inline op restore(out INT) {
  (void)stack_pop(interpreter, &interpreter->ctx.user_stack, &($1),
                  STACK_ENTRY_INT);
  goto NEXT();
}

inline op restore(out NUM) {
  (void)stack_pop(interpreter, &interpreter->ctx.user_stack, &($1),
                  STACK_ENTRY_FLOAT);
  goto NEXT();
}

inline op restore(out PMC) {
  (void)stack_pop(interpreter, &interpreter->ctx.user_stack, &($1), 
                  STACK_ENTRY_PMC);
  goto NEXT();
}

inline op restore(out STR) {
  (void)stack_pop(interpreter, &interpreter->ctx.user_stack, &($1),
                  STACK_ENTRY_STRING);
  goto NEXT();
}


########################################

=item B<rotate_up>(in INT)

Rotate the top $1 entries in the user stack by one. If $1 is positive,
then the stack rotates upwards: the ($1)th entry becomes the ($1-1)th
entry and so on, all the way up to the top of the stack, while the
entry formerly at the top of the stack becomes the new ($1)th entry.
If $1 is negative, the stack rotates downwards: the top entry becomes
the second entry, the second becomes the third etc., while the former
($1)th entry becomes the new top entry.

=cut

inline op rotate_up(in INT) {
  rotate_entries(interpreter, interpreter->ctx.user_stack, $1);
  goto NEXT();
}

########################################

=item B<intsave>(in INT)

Save register or constant $1 onto the high-speed int stack.

=cut

inline op intsave(in INT) {
  intstack_push(interpreter, interpreter->ctx.intstack, $1);
  goto NEXT();
}

########################################

=item B<intrestore>(out INT)

Restore register $1 from the high-speed int stack.

=cut

inline op intrestore(out INT) {
  $1=intstack_pop(interpreter, interpreter->ctx.intstack);
  goto NEXT();
}

########################################

=item B<intdepth>(out INT)

Puts the depth of the high-speed int stack in $1.

=cut

inline op intdepth(out INT) {
  $1=intstack_depth(interpreter, interpreter->ctx.intstack);
  goto NEXT();
}

=back

=cut

########################################

=item B<saveall>()

Save all the registers.

=item B<restoreall>()

Restore all the registers.

=cut

inline op saveall() {
  Parrot_push_i(interpreter);
  Parrot_push_n(interpreter);
  Parrot_push_s(interpreter);
  Parrot_push_p(interpreter);
  goto NEXT();
}

inline op restoreall() {
  Parrot_pop_i(interpreter);
  Parrot_pop_n(interpreter);
  Parrot_pop_s(interpreter);
  Parrot_pop_p(interpreter);
  goto NEXT();
}

=back

=cut

###############################################################################

=head2 Control flow

The control flow opcodes check conditions and manage program flow.

=over 4

=cut

########################################

=item B<branch>(in INT)

Branch forward or backward by the amount in $1.

=cut

inline op branch (in INT) {
  goto OFFSET($1);
}


########################################

=item B<bsr>(in INT)

Branch to the location specified by $1. Push the current location onto the call
stack for later returning.

=cut

inline op bsr (in INT) {
  stack_push(interpreter, &interpreter->ctx.control_stack, expr NEXT(),  STACK_ENTRY_DESTINATION, STACK_CLEANUP_NULL);
  goto OFFSET($1);
}


########################################

=item B<jsr>(in INT)

Jump to the location specified by register $1. Push the current
location onto the call stack for later returning.

=cut

inline op jsr(in INT) {
  stack_push(interpreter, &interpreter->ctx.control_stack, expr NEXT(),  STACK_ENTRY_DESTINATION, STACK_CLEANUP_NULL);
  goto ADDRESS($1);
}


########################################

=item B<jump>(in INT)

Jump to the address held in register $1.

=cut

inline op jump(in INT) {
  goto ADDRESS($1);
}

=back

=cut

###############################################################################

=head2 Symbol table ops

Ops to manipulate the symbol table

=over 4

=cut

########################################

=item B<store_global>(in PMC, in STR)

Store global $1 as global symbol $2

=item B<find_global>(out PMC, in STR)

Find the global named $2 and store it in $1

=cut

op store_global(in PMC, in STR) {
    KEY key;
    PMC * globals = interpreter->perl_stash->stash_hash;
    MAKE_KEY(key, $2, enum_key_string, struct_val);
    globals->vtable->set_pmc_keyed(interpreter, globals, NULL, $1, &key);
    goto NEXT();
}

op find_global(out PMC, in STR) {
    KEY key;
    PMC * globals = interpreter->perl_stash->stash_hash;
    MAKE_KEY(key, $2, enum_key_string, struct_val);
    $1 = globals->vtable->get_pmc_keyed(interpreter, globals, &key);
    goto NEXT();
}

=back

=cut

###############################################################################

=head2 Miscellaneous

Opcodes which need to be sorted into better categories.

=over 4

=cut

########################################

=item B<sweep>()

Trigger a dead object detection (DOD) sweep.

=cut

op sweep() {
  Parrot_do_dod_run(interpreter);
  goto NEXT();
}


=item B<collect>()

Trigger a garbage collection.

=cut

op collect() {
  Parrot_go_collect(interpreter);
  goto NEXT();
}

=item B<sweepoff>()

Disable DOD sweeps. (Nestable)

=cut

op sweepoff() {
  interpreter->DOD_block_level++;
  goto NEXT();
}

=item B<sweepon>()

Re-enable DOD sweeps.

=cut

op sweepon() {
  if (interpreter->DOD_block_level) {
    interpreter->DOD_block_level--;
  }
  goto NEXT();
}

=item B<collectoff>()

Disable GC runs (nestable).

=cut

op collectoff() {
  interpreter->GC_block_level++;
  goto NEXT();
}

=item B<collecton>()

Re-enable GC.

=cut

op collecton() {
  if (interpreter->GC_block_level) {
    interpreter->GC_block_level--;
  }
  goto NEXT();
}

########################################

=item B<interpinfo>(out INT, in INT)

Fetch some piece of information about the interpreter and put it in $1.
Possible values for $2 are:

=over 4

=item 1 The total amount of allocatable memory allocated. This figure
does not include memory used for headers or for the interpreter's internal
structures.

=item 2 The number of dead object detection runs performed.

=item 3 The number of garbage collection runs performed.

=item 4 The number of active PMCs.

=item 5 The number of active buffers.

=item 6 The total number of PMCs allocated.

=item 7 The total number of buffers allocated.

=item 8 The number of headers (PMC or buffer) that have been allocated
since the last DOD run.

=item 9 The amount of memory allocated since the last GC run.

=item 10 The total amount of memory copied during garbage collections.

=back

=cut

op interpinfo(out INT, in INT) {
  switch ($2) {
    case TOTAL_MEM_ALLOC: $1 = interpreter->memory_allocated;
                          break;
    case DOD_RUNS:        $1 = interpreter->dod_runs;
                          break;
    case COLLECT_RUNS:    $1 = interpreter->collect_runs;
                          break;
    case ACTIVE_PMCS:     $1 = interpreter->active_PMCs;
                          break;
    case ACTIVE_BUFFERS:  $1 = interpreter->active_Buffers;
                          break;
    case TOTAL_PMCS:      $1 = interpreter->total_PMCs;
                          break;
    case TOTAL_BUFFERS:   $1 = interpreter->total_Buffers;
                          break;
    case HEADERS_ALLOC_SINCE_COLLECT:
    $1 = interpreter->header_allocs_since_last_collect;
    break;
    case MEM_ALLOCS_SINCE_COLLECT:
    $1 = interpreter->mem_allocs_since_last_collect;
    break;
    case TOTAL_COPIED: $1 = interpreter->memory_collected;
		       break;
  }
  goto NEXT();
}

########################################

=item B<stringinfo>(out INT, in STR, in INT)

Extract some information about string $2 and store it in $1.
Possible values for $3 are:

=over 4

=item 1 The location of the string buffer header.

=item 2 The location of the start of the string.

=item 3 The length of the string buffer (in bytes).

=item 4 The flags attached to the string (if any).

=item 5 The amount of the string buffer used (in bytes).

=item 6 The length of the string (in characters).

=back

=cut

inline op stringinfo(out INT, in STR, in INT) {
  switch ($3) {
    case STRINGINFO_HEADER:   $1 = (UINTVAL)$2;
                              break;
    case STRINGINFO_BUFSTART: $1 = (UINTVAL)$2->bufstart;
                              break;
    case STRINGINFO_BUFLEN:   $1 = $2->buflen;
                              break;
    case STRINGINFO_FLAGS:    $1 = $2->flags;
                              break;
    case STRINGINFO_BUFUSED:  $1 = $2->bufused;
                              break;
    case STRINGINFO_STRLEN:   $1 = $2->strlen;
                              break;
  }
  goto NEXT();
}


########################################

=item B<newinterp>(out PMC, in INT)

Create a new interpreter and store it in a PMC.

=cut

op newinterp(out PMC, in INT) {
  struct Parrot_Interp *new_interp;
  struct PMC *new_pmc;
  new_interp = make_interpreter((Interp_flags)$2);
  new_pmc = new_pmc_header(interpreter);
  new_pmc->data = new_interp;
  new_pmc->vtable = YOU_LOSE_VTABLE;
  $1 = new_pmc;
  goto NEXT();
}


=item B<runinterp>(inout PMC, in INT)

Take a built interpreter and run the code starting at offset $2.

=cut

op runinterp(inout PMC, in INT) {
  struct Parrot_Interp * new_interp = (struct Parrot_Interp *)$1->data;
  runops(new_interp, interpreter->code, REL_PC + $2);
  goto NEXT();
}

op enternative() {
  goto ADDRESS(( run_native(interpreter, CUR_OPCODE, interpreter->code->byte_code) ));
}

########################################

=item B<new>(out PMC, in INT)

=item B<new>(out PMC, in INT, in INT)

Create a new PMC of class $2; look in F<pmc.h> for the base
vtable types. The assembler allows you to specify PMCs by type
name as well as by integer - you should do this for compatibility,
to avoid problems if the base types get reassigned. For example:

  new P0, .PerlScalar

Optionally a size may be passed to the constructor which may or
may not be used by the particular class. For example:

  new P0, .PerlStruct, 64

=cut

op new(out PMC, in INT) {
  PMC* newpmc;
  if ($2 <0 || $2 >= enum_class_max) {
    abort(); /* Deserve to lose */
  }
  newpmc = pmc_new(interpreter, $2);
  $1 = newpmc;
  goto NEXT();
}

op new(out PMC, in INT, in INT) {
  PMC* newpmc;
  if ($2 <0 || $2 >= enum_class_max) {
    abort(); /* Deserve to lose */
  }
  newpmc = pmc_new_sized(interpreter, $2, $3);
  $1 = newpmc;
  goto NEXT();
}

=item B<destroy>(in PMC)

Destroy the PMC.

=cut

op destroy(in PMC) {

  if ($1->flags & PMC_active_destroy_FLAG) {
	$1->vtable->destroy(interpreter, $1);
  }
  /* Should just assign undef, but we don't have one yet */
  $1->vtable = YOU_LOSE_VTABLE;
  $1->flags = PMC_live_FLAG;
  goto NEXT();
}


=item B<typeof>(out STR, in PMC)

=item B<typeof>(out INT, in PMC)

Return the type of PMC in $2.

=cut

inline op typeof (out STR, in PMC) {
  PMC *p = $2;
  $1 = (p->vtable->name(interpreter, p));
  goto NEXT();
}

inline op typeof (out INT, in PMC) {
  PMC *p = $2;
  $1 = (p->vtable->type(interpreter, p));
  goto NEXT();
}

########################################

=item B<find_type>(out INT, in STR)

Find the PMC type by name.

=cut

op find_type(out INT, in STR) {
    KEY key;
    MAKE_KEY(key, $2, enum_key_string, string_val);
    $1 = Parrot_base_classname_hash->vtable->get_integer_keyed(interpreter, Parrot_base_classname_hash, &key);

    goto NEXT();
}

########################################

=item B<ret>()

Pop the location off the top of the call stack and go there.

=cut

inline op ret() {
  goto POP();
}


########################################

=item B<sleep>(in INT)

Sleep for $1 seconds.

=cut

inline op sleep(in INT) {
  if ($1 < 0) {
      internal_exception(NEG_SLEEP, "Cannot go back in time");
  }
  Parrot_sleep((UINTVAL)$1);
  goto NEXT();
}


#######################################

=item B<setline>(in INT)

Set the line number for which we're currently executing code.

=cut

inline op setline(in INT) {
  interpreter->current_line = $1;
  goto NEXT();
}

=item B<getline>(out INT)

Get the current line number.

=cut

inline op getline(out INT) {
  $1 = interpreter->current_line;
  goto NEXT();
}

=item B<setfile>(in STR)

Set the name of the file for which we're currently executing code.

=cut

inline op setfile(in STR) {
  interpreter->current_file = $1;
  goto NEXT();
}

=item B<getfile>(out STR)

Get the name of the current file.

=cut

inline op getfile(out STR) {
  $1 = interpreter->current_file;
  goto NEXT();
}

=item B<setpackage>(in STR)

Set the name of the package for which we're currently executing code.

=cut

inline op setpackage(in STR) {
  interpreter->current_package = $1;
  goto NEXT();
}

=item B<getpackage>(out STR)

Get the name of the current package.

=cut

inline op getpackage(out STR) {
  $1 = interpreter->current_package;
  goto NEXT();
}

=item B<loadext>(in STR, in STR)

Load in an extension. $1 is the name of the extension library, $2 is the
initialization routine for it.

=item B<loadlib>(in PMC, in STR)

Load a dynamic link library named $2 and store it in $1.

=item B<callnative>(out PMC, in PMC, in STR)

Call a native routine given a library handle.
$2 contains the handle returned from loadlib, $3 is the
unmangled name of the extension API routine.
Warning: This is probably unportable right now since
some systems need pre-pended _ on symbol names,
and potentially others might have to be linked statically.

=item B<callnative>(out PMC, in PMC, in PMC, in STR)

Same as the 3 argument version except that $3 is a PMC
representing an "object." For methods (not static routines)
this would be the this/self pointer.

=cut

inline op loadext(in STR, in STR) {
  PMC * pmc;
  void * p;
  void (*func)(void);
  string_to_cstring(interpreter, ($2));
  string_to_cstring(interpreter, ($1));
  p = Parrot_dlopen($1->bufstart);
  if(p == NULL) {
     const char * err = Parrot_dlerror();
     fprintf(stderr, "%s\n", err);
     PANIC("Failed to load native library");
  }
  func = D2FPTR(Parrot_dlsym(p, $2->bufstart));
  if (NULL == func) {
    PANIC("Failed to find symbol in native library");
  }
  (*func)();
  goto NEXT();
}

inline op loadlib(out PMC, in STR) {
  PMC * pmc;
  void * p;
  const char * s = string_to_cstring(interpreter, ($2));
  p = Parrot_dlopen(s);
  if(p == NULL) {
     const char * err = Parrot_dlerror();
     fprintf(stderr, "%s\n", err);
     PANIC("Failed to load native library");
  }
  pmc = new_pmc_header(interpreter);
  pmc->data = (void *)p;
  $1 = pmc;
  goto NEXT();
}


inline op callnative(out PMC, in PMC, in STR) {
  /* 
   * These are just for fun, ideally we can cache the routine
   * for calling without dylsym() everytime. These will
   * do for a starting point.
   */
  PMC * fun;
  int ret;
  const char * name = string_to_cstring(interpreter, ($3));
  void (*p)(Interp *, PMC *) = (void (*)(Interp *, PMC *))D2FPTR(Parrot_dlsym(
                                                ($2)->data, name));
  if(p == NULL) {
     const char * err = Parrot_dlerror();
     if(err != NULL) {
         fprintf(stderr, "%s\n", err);
         PANIC("Failed to link native method");
     }
  }

  fun = new_pmc_header(interpreter);
  fun->data = F2DPTR(p);
  $1 = fun;

  /* Now that it is cached, call it */
  (*p)(interpreter, NULL);
  goto NEXT();
}

inline op callnative(out PMC, in PMC, in PMC, in STR) {
  /* 
   * These are just for fun, ideally we can cache the routine
   * for calling without dylsym() everytime. These will
   * do for a starting point.
   */
  PMC * fun;
  int ret;
  const char * name = string_to_cstring(interpreter, ($4));
  void (*p)(Interp *, PMC *) = (void (*)(Interp *, PMC *))D2FPTR(Parrot_dlsym(
                                                ($2)->data, name));
  if(p == NULL) {
     const char * err = Parrot_dlerror();
     if(err != NULL) {
         fprintf(stderr, "%s\n", err);
         PANIC("Failed to link native method");
     }
  }
  fun = new_pmc_header(interpreter);
  fun->data = F2DPTR(p);
  $1 = fun;
  /* Now that it is cached, call it */
  (*p)(interpreter, $3->data);
  goto NEXT();
}

inline op call() {
  /* This op will be a vtable entry */
  struct Parrot_Sub * sub = (struct Parrot_Sub*)interpreter->ctx.pmc_reg.registers[0]->data;
  stack_push(interpreter, &interpreter->ctx.control_stack, expr NEXT(),  STACK_ENTRY_DESTINATION, STACK_CLEANUP_NULL);
  goto ADDRESS(sub->init);
}

inline op callco() {
  /* This op will be a vtable entry */
  struct Parrot_Coroutine * co = (struct Parrot_Coroutine*)interpreter->ctx.pmc_reg.registers[0]->data;
  /* FIXME: Here we need to switch in the co-routines context and save the
   * interpreter's context.
   */
  stack_push(interpreter, &interpreter->ctx.control_stack, expr NEXT(),  STACK_ENTRY_DESTINATION, STACK_CLEANUP_NULL);
  /* Resuming co-routine or fresh call? */
  if(!co->resume) {
     goto ADDRESS(co->init);
  }
  else {
     goto ADDRESS(co->resume);
  }
}

inline op yield() {
  opcode_t *dest;
  struct Parrot_Coroutine * co = (struct Parrot_Coroutine*)interpreter->ctx.pmc_reg.registers[0]->data;
  /* suspend the co-routine */
  co->resume = expr NEXT();
  stack_pop(interpreter, &interpreter->ctx.control_stack, &dest, STACK_ENTRY_DESTINATION);
  goto ADDRESS(dest);
}

inline op capturecc(out PMC) {
  struct Parrot_Continuation * cc;
  $1 = new_pmc_header(interpreter);
  /*
   * Capture continuation -after- setting $1 since it captures
   * register state.
   */
  cc = new_continuation(interpreter, expr NEXT());
  $1->vtable = YOU_LOSE_VTABLE;
  $1->data = (void*)cc;
  goto NEXT();
}

inline op callcc(in PMC) {
  if($1) {
    struct Parrot_Continuation * cc = (struct Parrot_Continuation*)$1->data;
    if(cc) {
      restore_context(interpreter, &cc->ctx);
      goto ADDRESS(cc->continuation);
    }
    else {
      abort();
    }
  }
  else {
    abort();
  }
}

=item B<warningson>(in INT)

Turns on warnings categories.  Categories already turned on will 
stay on.  Current categories and the numbers they map to are:

=over 4

=item 1: undef

=item 2: IO

=item -1: all

=back

To turn on multiple categories, OR the category numbers together.

=cut

inline op warningson(in INT) {
  PARROT_WARNINGS_on(interpreter, $1);
  goto NEXT();
}

=item B<warningsoff>(in INT)

Turns off warnings categories.  Categories already turned off will 
stay off.  See the documentation for B<warningson> for category 
numbers.

=cut

inline op warningsoff(in INT) {
  PARROT_WARNINGS_off(interpreter, $1);
  goto NEXT();
}


=back

=cut

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001 Yet Another Society. All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut
