/*
** core.ops
*/

#include "parrot/method_util.h"

VERSION = PARROT_VERSION;

=head1 NAME

core.ops

=cut

=head1 DESCRIPTION

Parrot's core library of ops.

=cut

# ' for emacs

###############################################################################

=head2 Basic ops

These are the fundamental operations.

=over 4

=cut


########################################

=item B<end>()

Halts the interpreter.

=cut

inline op end() {
  HALT();
}


########################################

=item B<noop>()

Does nothing other than waste an iota of time and 32 bits of bytecode space.

=item B<cpu_ret>()

Emit a cpu return instruction. This is used to return from CGP core
to JIT code.

=cut

inline op noop() {
  goto NEXT();
}

inline op cpu_ret() {
#ifdef __GNUC__
# ifdef I386
   asm("ret");
# endif
#endif
  goto NEXT();
}

=back

=cut


###############################################################################

=head2 System environment operations

These operations allow interaction between the Parrot program and the system
environment.

=over 4

=cut


########################################

=item B<err>(out INT)

Store the system error code in $1.

=item B<err>(out STR)

Store the system error message in $1.

=cut

inline op err(out INT) {
  $1 = errno;
  goto NEXT();
}

op err(out STR) {
  char *tmp = strerror(errno);
  $1 = string_make(interpreter, tmp, strlen(tmp), NULL, 0, NULL);
  goto NEXT();
}


########################################

########################################

=item B<ord>(out INT, in STR)

Two-argument form returns the 0th character of string $2 in register $1.
If $2 is empty, throws an exception.

=item B<ord>(out INT, in STR, in INT)

Three-argument form returns character $3 of string $2 in register $1.
If $2 is empty, throws an exception.
If $3 is greater than the length of string $2, throws an exception.
If $3 is less then zero but greater than the negative of the length, counts
backwards through the string, such that -1 is the last character, -2 is the
second-to-last character, and so on.
If $3 is less than the negative of the length, throws an exception.

=cut

inline op ord (out INT, in STR) {
  $1 = string_ord($2,0);
  goto NEXT();
}

inline op ord (out INT, in STR, in INT) {
  $1 = string_ord($2,$3);
  goto NEXT();
}

=item B<chr>(out STR, in INT)

Returns the character represented by the $2 number in the ASCII
character set.

=cut

inline op chr (out STR, in INT) {
  STRING *s;
  s = string_make(interpreter, &$1, (UINTVAL)1, NULL, 0, NULL);
  *(char *)s->strstart = $2;
  s->strlen = 1;
  $1 = s;
  goto NEXT();
}


########################################

=item B<read>(out INT, in INT)

Read an INTVAL from file descriptor $2 into $1.

=item B<read>(out NUM, in INT)

Read a FLOATVAL from file descriptor $2 into $1.

=item B<read>(out STR, in INT, in INT)

Read $3 bytes from file descriptor $2 into string $1.

=cut

inline op read(out INT, in INT) {
  read($2, &($1), sizeof(INTVAL));
  goto NEXT();
}

inline op read(out NUM, in INT) {
  read($2, &($1), sizeof(FLOATVAL));
  goto NEXT();
}

op read(out STR, in INT, in INT) {
  STRING *s;
  UINTVAL len = $3;

  s = string_make(interpreter, NULL, len, NULL, 0, NULL);
  read($2, s->strstart, len);
  s->bufused = len;
  $1 = s;
  goto NEXT();
}


########################################

=item B<time>(out INT)

Puts the current system time (represented as a whole number of seconds)
in $1.

=cut

inline op time(out INT) {
  $1 = Parrot_intval_time();
  goto NEXT();
}


########################################

=item B<time>(out NUM)

Puts the current system time (represented as a number of seconds, with
microseconds) in $1.

=cut

inline op time(out NUM) {
  $1 = Parrot_floatval_time();
  goto NEXT();
}


########################################

=item B<write>(in INT, in INT)

=item B<write>(in INT, in NUM)

=item B<write>(in INT, in STR)

Write $2 to file descriptor $1.

=cut

op write(in INT, in INT) {
  INTVAL i = (INTVAL)$2;
  write($1, &i, sizeof(INTVAL));
  goto NEXT();
}

op write(in INT, in NUM) {
  FLOATVAL * f = &($2);
  write($1, f, sizeof(FLOATVAL));
  goto NEXT();
}

op write(in INT, in STR) {
  STRING * s = $2;
  UINTVAL count = string_length(s);
  write($1, s->strstart, count);
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 Register loading operations

These operations load registers from constants or other registers.

=over 4

=cut

########################################

=item B<clone>(out STR, in STR)

Make a clone of $2, and put it in $1. Doesn't affect what was in
$1. Removes the constant flag on the copy, if there was one.

=cut

inline op clone(out STR, in STR) {
  $1 = string_copy(interpreter, $2);
  goto NEXT();
}


########################################

=item B<set_addr>(out INT, in INT)

Sets register $1 to the current address plus the offset $2.

=cut

inline op set_addr(out INT, in INT) {
  $1 = PTR2OPCODE_T(CUR_OPCODE + $2);
  goto NEXT();
}

########################################

=item B<exchange>(inout INT, inout INT)

=item B<exchange>(inout NUM, inout NUM)

=item B<exchange>(inout PMC, inout PMC)

=item B<exchange>(inout STR, inout STR)

Exchange the contents of registers $1 and $2

=cut

op exchange(inout INT, inout INT) {
   INTVAL temp;
   temp = $1;
   $1 = $2;
   $2 = temp;
   goto NEXT();
}

op exchange(inout PMC, inout PMC) {
   PMC *temp;
   temp = $1;
   $1 = $2;
   $2 = temp;
   goto NEXT();
}

op exchange(inout NUM, inout NUM) {
   FLOATVAL temp;
   temp = $1;
   $1 = $2;
   $2 = temp;
   goto NEXT();
}

op exchange(inout STR, inout STR) {
   STRING *temp;
   temp = $1;
   $1 = $2;
   $2 = temp;
   goto NEXT();
}

########################################

=item B<set>(out INT, in INT)

=item B<set>(out INT, in NUM)

=item B<set>(out INT, in PMC)

=item B<set>(out INT, in STR)

=item B<set>(out NUM, in INT)

=item B<set>(out NUM, in NUM)

=item B<set>(out NUM, in PMC)

=item B<set>(out NUM, in STR)

=item B<set>(inout PMC, in INT)

=item B<set>(inout PMC, in NUM)

=item B<set>(out PMC, in PMC)

=item B<set>(inout PMC, in STR)

=item B<set>(out STR, in INT)

=item B<set>(out STR, in NUM)

=item B<set>(out STR, in PMC)

=item B<set>(out STR, in STR)

Set $1 to $2.

=cut

inline op set(out INT, in INT) {
  $1 = $2;
  goto NEXT();
}

inline op set(out INT, in NUM) {
  $1 = (INTVAL)($2);
  goto NEXT();
}

inline op set(out INT, in STR) {
  $1 = string_to_int($2);
  goto NEXT();
}

inline op set(out NUM, in NUM) {
  $1 = $2;
  goto NEXT();
}

inline op set(out NUM, in INT) {
  $1 = (FLOATVAL)$2;
  goto NEXT();
}

inline op set(out NUM, in STR) {
  $1 = string_to_num($2);
  goto NEXT();
}

inline op set(out NUM, in PMC) {
  $1 = $2->vtable->get_number(interpreter, $2);
  goto NEXT();
}

inline op set(out STR, in PMC) {
  $1 = $2->vtable->get_string(interpreter, $2);
  goto NEXT();
}

inline op set(out STR, invar STR) {
  $1 = $2;
  goto NEXT();
}

inline op set(out STR, inconst STR) {
  $1 = string_copy(interpreter, $2);
  goto NEXT();
}

inline op set(out STR, in INT) {
  $1 = string_from_int(interpreter, $2);
  goto NEXT();
}

inline op set(out STR, in NUM) {
  $1 = string_from_num(interpreter, $2);
  goto NEXT();
}

inline op set(out PMC, in PMC) {
  $1 = $2;
  goto NEXT();
}

inline op set(inout PMC, in INT) {
  $1->vtable->set_integer_native(interpreter, $1, $2);
  goto NEXT();
}

inline op set(inout PMC, in NUM) {
  $1->vtable->set_number_native(interpreter, $1, $2);
  goto NEXT();
}

inline op set(inout PMC, in STR) {
  $1->vtable->set_string_native(interpreter, $1, $2);
  goto NEXT();
}

inline op set(out INT, in PMC) {
  $1 = $2->vtable->get_integer(interpreter, $2);
  goto NEXT();
}

########################################

=head2 PMC assignment operations: Px = x

=item B<assign>(inout PMC, in INT)

=item B<assign>(inout PMC, in NUM)

=item B<assign>(inout PMC, in PMC)

=item B<assign>(inout PMC, in STR)

=cut

inline op assign(inout PMC, in PMC) {
  $1->vtable->set_pmc(interpreter, $1, $2);
  goto NEXT();
}

inline op assign(inout PMC, in INT) {
  $1->vtable->set_integer_native(interpreter, $1, $2);
  goto NEXT();
}

inline op assign(inout PMC, in NUM) {
  $1->vtable->set_number_native(interpreter, $1, $2);
  goto NEXT();
}

inline op assign(inout PMC, in STR) {
  $1->vtable->set_string_native(interpreter, $1, $2);
  goto NEXT();
}

########################################

=head2 Keyed set operations: Px[ INTKEY ] = Bx

=item B<set>(inout PMC, in INTKEY, in INT)

=item B<set>(inout PMC, in INTKEY, in NUM)

=item B<set>(inout PMC, in INTKEY, in STR)

=item B<set>(inout PMC, in INTKEY, in PMC)

=cut

inline op set (inout PMC, in INTKEY, in INT)  {
    INTVAL key = $2;
    $1->vtable->set_integer_keyed_int(interpreter, $1, &key, $3);
    goto NEXT();
}

inline op set (inout PMC, in INTKEY, in NUM)  {
    INTVAL key = $2;
    $1->vtable->set_number_keyed_int(interpreter, $1, &key, $3);
    goto NEXT();
}

inline op set (inout PMC, in INTKEY, in STR)  {
    INTVAL key = $2;
    $1->vtable->set_string_keyed_int(interpreter, $1, &key, $3);
    goto NEXT();
}

inline op set (inout PMC, in INTKEY, in PMC)  {
    INTVAL key = $2;
    $1->vtable->set_pmc_keyed_int(interpreter, $1, &key, $3, NULL);
    goto NEXT();
}

=head2 Keyed get operations: Ax = Px[ INTKEY ]

=cut

=item B<set>(out INT, in PMC, in INTKEY)

=item B<set>(out NUM, in PMC, in INTKEY)

=item B<set>(out STR, in PMC, in INTKEY)

=item B<set>(inout PMC, in PMC, in INTKEY)

=cut

inline op set (out INT, in PMC, in INTKEY)  {
    INTVAL key = $3;
    $1 = $2->vtable->get_integer_keyed_int(interpreter, $2, &key);
    goto NEXT();
}

inline op set (out NUM, in PMC, in INTKEY)  {
    INTVAL key = $3;
    $1 = $2->vtable->get_number_keyed_int(interpreter, $2, &key);
    goto NEXT();
}

inline op set (out STR, in PMC, in INTKEY)  {
    INTVAL key = $3;
    $1 = $2->vtable->get_string_keyed_int(interpreter, $2, &key);
    goto NEXT();
}

inline op set (inout PMC, in PMC, in INTKEY) {
    INTVAL key = $3;
    $1 = $2->vtable->get_pmc_keyed_int(interpreter, $2, &key);
    goto NEXT();
}


=head2 Keyed set operations: Px[ KEY ] = Bx

=item B<set>(inout PMC, in KEY, in INT)

=item B<set>(inout PMC, in KEY, in NUM)

=item B<set>(inout PMC, in KEY, in STR)

=item B<set>(inout PMC, in KEY, in PMC)

=cut

inline op set (inout PMC, in KEY, in INT)  {
    $1->vtable->set_integer_keyed(interpreter, $1, $2, $3);
    goto NEXT();
}

inline op set (inout PMC, in KEY, in NUM)  {
    $1->vtable->set_number_keyed(interpreter, $1, $2, $3);
    goto NEXT();
}

inline op set (inout PMC, in KEY, in STR)  {
    $1->vtable->set_string_keyed(interpreter, $1, $2, $3);
    goto NEXT();
}

inline op set (inout PMC, in KEY, in PMC)  {
    $1->vtable->set_pmc_keyed(interpreter, $1, $2, $3, NULL);
    goto NEXT();
}

=head2 Keyed get operations: Ax = Px[ KEY ]

=item B<set>(out INT, in PMC, in KEY)

=item B<set>(out NUM, in PMC, in KEY)

=item B<set>(out STR, in PMC, in KEY)

=item B<set>(inout PMC, in PMC, in KEY)

=cut

inline op set (out INT, in PMC, in KEY)  {
    $1 = $2->vtable->get_integer_keyed(interpreter, $2, $3);
    goto NEXT();
}

inline op set (out NUM, in PMC, in KEY)  {
    $1 = $2->vtable->get_number_keyed(interpreter, $2, $3);
    goto NEXT();
}

inline op set (out STR, in PMC, in KEY)  {
    $1 = $2->vtable->get_string_keyed(interpreter, $2, $3);
    goto NEXT();
}

inline op set (inout PMC, in PMC, in KEY)  {
    $1 = $2->vtable->get_pmc_keyed(interpreter, $2, $3);
    goto NEXT();
}

=head2 Keyed set operations: Px[ KEY ] = Px[ KEY ]

=item B<set>(inout PMC, in KEY, in PMC, in KEY)

=cut

inline op set (inout PMC, in KEY, in PMC, in KEY)  {
    $1->vtable->set_pmc_keyed(interpreter, $1, $2, $3, $4);
    goto NEXT();
}

=item B<clone>(out PMC, in PMC)

Makes a copy of the PMC in $2 and puts it in $1.

=cut

inline op clone(out PMC, in PMC) {
  /* P6C emits clone P0, P0 */
  if (&$1 != &$2) {
      $1 = pmc_new_noinit(interpreter, $2->vtable->base_type);
      $2->vtable->clone(interpreter, $2, $1);
  }
  goto NEXT();
}

=back

=cut


###############################################################################

=head2 Conditional branch operations

These operations perform a conditional relative branch. If the condition is
met, the branch happens, otherwise control falls to the next operation.

=over 4

=cut


########################################

=item B<eq>(in INT, in INT, inconst INT)

=item B<eq>(in NUM, in NUM, inconst INT)

=item B<eq>(in STR, in STR, inconst INT)

=item B<eq>(in PMC, in PMC, inconst INT)

=item B<eq>(in PMC, in INT, inconst INT)

Branch if $1 is equal to $2.

=cut

inline op eq(in INT, in INT, inconst INT) {
  if ($1 == $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op eq(in NUM, in NUM, inconst INT) {
  if ($1 == $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op eq(in STR, in STR, inconst INT) {
  if (string_compare(interpreter, $1, $2) == 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op eq (in PMC, in PMC, inconst INT) {
  if ($1->vtable->is_equal(interpreter, $1, $2)) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op eq (in PMC, in INT, inconst INT) {
  if ($1->vtable->get_integer(interpreter, $1) == $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

########################################

=item B<ne>(in INT, in INT, inconst INT)

=item B<ne>(in NUM, in NUM, inconst INT)

=item B<ne>(in STR, in STR, inconst INT)

=item B<ne>(in PMC, in PMC, inconst INT)

Branch if $1 is not equal to $2.

=cut

inline op ne(in INT, in INT, inconst INT) {
  if ($1 != $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op ne(in NUM, in NUM, inconst INT) {
  if ($1 != $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op ne(in STR, in STR, inconst INT) {
  if (string_compare(interpreter, $1, $2) != 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op ne(in PMC, in PMC, inconst INT) {
  if (! $1->vtable->is_equal(interpreter, $1, $2)) {
    goto OFFSET($3);
  }
  goto NEXT();
}

########################################

=item B<lt>(in INT, in INT, inconst INT)

=item B<lt>(in NUM, in NUM, inconst INT)

=item B<lt>(in STR, in STR, inconst INT)

=item B<lt>(in PMC, in PMC, inconst INT)

=item B<lt>(in PMC, in INT, inconst INT)

Branch if $1 is less than $2.

=cut

inline op lt(in INT, in INT, inconst INT) {
  if ($1 < $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op lt(in NUM, in NUM, inconst INT) {
  if ($1 < $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op lt(in STR, in STR, inconst INT) {
  if (string_compare(interpreter, $1, $2) < 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op lt (in PMC, in PMC, inconst INT) {
  if ($1->vtable->cmp(interpreter, $1, $2) < 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op lt (in PMC, in INT, inconst INT) {
  if ($1->vtable->get_integer(interpreter, $1) < $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

########################################

=item B<le>(in INT, in INT, inconst INT)

=item B<le>(in NUM, in NUM, inconst INT)

=item B<le>(in STR, in STR, inconst INT)

=item B<le>(in PMC, in PMC, inconst INT)

=item B<le>(in PMC, in INT, inconst INT)

Branch if $1 is less than or equal to $2.

=cut

inline op le(in INT, in INT, inconst INT) {
  if ($1 <= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op le(in NUM, in NUM, inconst INT) {
  if ($1 <= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op le(in STR, in STR, inconst INT) {
  if (string_compare(interpreter, $1, $2) <= 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op le(in PMC, in PMC, inconst INT) {
  if ($1->vtable->cmp(interpreter, $1, $2) <= 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op le(in PMC, in INT, inconst INT) {
  if ($1->vtable->get_integer(interpreter, $1) <= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

########################################

=item B<gt>(in INT, in INT, inconst INT)

=item B<gt>(in NUM, in NUM, inconst INT)

=item B<gt>(in STR, in STR, inconst INT)

=item B<gt>(in PMC, in PMC, inconst INT)

Branch if $1 is greater than $2.

=cut

inline op gt(in INT, in INT, inconst INT) {
  if ($1 > $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op gt(in NUM, in NUM, inconst INT) {
  if ($1 > $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op gt(in STR, in STR, inconst INT) {
  if (string_compare(interpreter, $1, $2) > 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op gt(in PMC, in PMC, inconst INT) {
  if ($1->vtable->cmp(interpreter, $1, $2) > 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

########################################

=item B<ge>(in INT, in INT, inconst INT)

=item B<ge>(in NUM, in NUM, inconst INT)

=item B<ge>(in STR, in STR, inconst INT)

=item B<ge>(in PMC, in PMC, inconst INT)

Branch if $1 is greater than or equal to $2.

=cut

inline op ge(in INT, in INT, inconst INT) {
  if ($1 >= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

inline op ge(in NUM, in NUM, inconst INT) {
  if ($1 >= $2) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op ge(in STR, in STR, inconst INT) {
  if (string_compare(interpreter, $1, $2) >= 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

op ge(in PMC, in PMC, inconst INT) {
  if ($1->vtable->cmp(interpreter, $1, $2) >= 0) {
    goto OFFSET($3);
  }
  goto NEXT();
}

########################################

=item B<if>(in INT, inconst INT)

=item B<if>(in NUM, inconst INT)

=item B<if>(in PMC, inconst INT)

=item B<if>(in STR, inconst INT)

Check register $1. If true, branch by $2.

=cut

inline op if(in INT, inconst INT) {
  if ($1 != 0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

inline op if(in NUM, inconst INT) {
  if ($1 != 0.0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op if (in STR, inconst INT) {
  if (string_bool($1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op if(in PMC, inconst INT) {
  if ($1->vtable->get_bool(interpreter, $1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}


###############################################################################

=item B<unless>(in INT, inconst INT)

=item B<unless>(in NUM, inconst INT)

=item B<unless>(in PMC, inconst INT)

=item B<unless>(in STR, inconst INT)

Check register $1. If false, branch by $2.

=cut

inline op unless(in INT, inconst INT) {
  if ($1 == 0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

inline op unless(in NUM, inconst INT) {
  if ($1 == 0.0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op unless (in STR, inconst INT) {
  if (!string_bool($1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op unless(in PMC, inconst INT) {
  if (!$1->vtable->get_bool(interpreter, $1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}

=back

=cut



###############################################################################
=head2 Arithmetic operations

These operations store the results of arithmetic on other registers and
constants into their destination register, $1.

=over 4

=cut

########################################

=item B<abs>(inout INT)

=item B<abs>(inout NUM)

Set $1 to it's absolute value.

=item B<abs>(out INT, in INT)

=item B<abs>(out INT, in NUM)

=item B<abs>(out NUM, in INT)

=item B<abs>(out NUM, in NUM)

Set $1 to absolute value of $2.

=cut

inline op abs( inout INT) {
  $1 = abs( $1 );
  goto NEXT();
}

inline op abs(inout NUM) {
  $1 = fabs( $1 );
  goto NEXT();
}

inline op abs(out INT, in INT) {
  if ($2 < 0) {
    $1 = - (INTVAL)$2;
  }
  else {
    $1 = (INTVAL)$2;
  }
  goto NEXT();
}

inline op abs(out INT, in NUM) {
  if ($2 < 0) {
    $1 = - (INTVAL)$2;
  }
  else {
    $1 = (INTVAL)$2;
  }
  goto NEXT();
}

inline op abs(out NUM, in INT) {
  if ($2 < 0) {
    $1 = - (FLOATVAL)$2;
  }
  else {
    $1 = (FLOATVAL)$2;
  }
  goto NEXT();
}

inline op abs(out NUM, in NUM) {
  if ($2 < 0) {
    $1 = - (FLOATVAL)$2;
  }
  else {
    $1 = (FLOATVAL)$2;
  }
  goto NEXT();
}


########################################

=item B<add>(inout INT, in INT)

=item B<add>(inout NUM, in INT)

=item B<add>(inout NUM, in NUM)

=item B<add>(inout PMC, in INT)

=item B<add>(inout PMC, in NUM)

=item B<add>(inout PMC, in PMC)

Increase $1 by the amount in $2.

=item B<add>(out INT, in INT, in INT)

=item B<add>(out NUM, in NUM, in INT)

=item B<add>(out NUM, in NUM, in NUM)

=item B<add>(inout PMC, in PMC, in INT)

=item B<add>(inout PMC, in PMC, in NUM)

=item B<add>(inout PMC, in PMC, in PMC)

Set $1 to the sum of $2 and $3.

=cut

inline op add(inout INT, in INT) {
  $1 += $2;
  goto NEXT();
}

inline op add(inout NUM, in INT) {
  $1 += $2;
  goto NEXT();
}

inline op add(inout NUM, in NUM) {
  $1 += $2;
  goto NEXT();
}

inline op add(inout PMC, in INT) {
  $1->vtable->add_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op add(inout PMC, in NUM) {
  $1->vtable->add_float(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op add(inout PMC, in PMC) {
  $1->vtable->add(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op add(out INT, in INT, in INT) {
  $1 = $2 + $3;
  goto NEXT();
}

inline op add(out NUM, in NUM, in INT) {
  $1 = $2 + $3;
  goto NEXT();
}

inline op add(out NUM, in NUM, in NUM) {
  $1 = $2 + $3;
  goto NEXT();
}

inline op add(inout PMC, in PMC, in INT) {
  $2->vtable->add_int(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op add(inout PMC, in PMC, in NUM) {
  $2->vtable->add_float(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op add (inout PMC, in PMC, in PMC) {
  $2->vtable->add(interpreter, $2, $3, $1);
  goto NEXT();
}


########################################

=item B<cmod>(out INT, in INT, in INT)

NOTE: This "uncorrected mod" algorithm uses the C language's built-in
mod operator (x % y), which is

    ... the remainder when x is divided by y, and thus is zero
    when y divides x exactly.
    ...
    The direction of truncation for / and the sign of the result
    for % are machine-dependent for negative operands, as is the
    action taken on overflow or underflow.
                                                     -- [1], page 41

Also:

    ... if the second operand is 0, the result is undefined.
    Otherwise, it is always true that (a/b)*b + a%b is equal to z. If
    both operands are non-negative, then the remainder is non-
    negative and smaller than the divisor; if not, it is guaranteed
    only that the absolute value of the remainder is smaller than
    the absolute value of the divisor.
                                                     -- [1], page 205

This op is provided for those who need it (such as speed-sensitive
applications with heavy use of mod, but using it only with positive
arguments), but a more mathematically useful mod based on ** floor(x/y)
and defined with y == 0 is provided by the mod op.

  [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
      Language*, Second Edition. Prentice Hall, 1988.

TODO: Doesn't the Parrot interpreter need to catch the exception?

=cut

inline op cmod(out INT, in INT, in INT) {
  $1 = $2 % $3;
  goto NEXT();
}


inline op cmod(out PMC, in PMC, in PMC) {
  $2->vtable->modulus(interpreter, $2, $3, $1);
  goto NEXT();
}


########################################

=item B<cmod>(out NUM, in NUM, in NUM)

NOTE: This "uncorrected mod" algorithm uses the built-in C math library's
fmod() function, which computes

    ... the remainder of dividing x by y. The return value is
    x - n * y, where n is the quotient of x / y, rounded towards
    zero to an integer.
                                -- fmod() manpage on RedHat Linux 7.0

In addition, fmod() returns

    the remainder, unless y is zero, when the function fails and
    errno is set.

According to page 251 of [1], the result when y is zero is implementation-
defined.

This op is provided for those who need it, but a more mathematically
useful numeric mod based on floor(x/y) instead of truncate(x/y) and
defined with y == 0 is provided by the mod op.

  [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
      Language*, Second Edition. Prentice Hall, 1988.

TODO: Doesn't the Parrot interpreter need to catch the exception?

=cut

inline op cmod(out NUM, in NUM, in NUM) {
  $1 = fmod($2, $3);
  goto NEXT();
}


########################################

=item B<dec>(inout INT)

=item B<dec>(inout NUM)

=item B<dec>(inout PMC)

Decrease $1 by one.

=cut

inline op dec(inout INT) {
  $1--;
  goto NEXT();
}

inline op dec(inout NUM) {
  $1--;
  goto NEXT();
}

inline op dec(inout PMC) {
  $1->vtable->decrement(interpreter, $1);
  goto NEXT();
}

########################################

=item B<div>(inout INT, in INT)

=item B<div>(inout NUM, in INT)

=item B<div>(inout NUM, in NUM)

=item B<div>(inout PMC, in INT)

=item B<div>(inout PMC, in NUM)

=item B<div>(inout PMC, in PMC)

Divide $1 by $2.

=item B<div>(out INT, in INT, in INT)

=item B<div>(out NUM, in NUM, in INT)

=item B<div>(out NUM, in NUM, in NUM)

=item B<div>(inout PMC, in PMC, in INT)

=item B<div>(inout PMC, in PMC, in NUM)

=item B<div>(inout PMC, in PMC, in PMC)

Set $1 to the quotient of $2 divided by $3. In the case of INTVAL division, the
result is truncated (NOT rounded or floored).

=cut

inline op div(inout INT, in INT) {
  $1 /= $2;
  goto NEXT();
}

inline op div(inout NUM, in INT) {
  $1 /= $2;
  goto NEXT();
}

inline op div(inout NUM, in NUM) {
  $1 /= $2;
  goto NEXT();
}

inline op div (inout PMC, in INT) {
  $1->vtable->divide_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op div (inout PMC, in NUM) {
  $1->vtable->divide_float(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op div(out INT, in INT, in INT) {
  $1 = $2 / $3;
  goto NEXT();
}

inline op div(out NUM, in NUM, in INT) {
  $1 = $2 / $3;
  goto NEXT();
}

inline op div(out NUM, in NUM, in NUM) {
  $1 = $2 / $3;
  goto NEXT();
}

inline op div (inout PMC, in PMC, in INT) {
  $2->vtable->divide_int(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op div (inout PMC, in PMC, in NUM) {
  $2->vtable->divide_float(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op div (inout PMC, in PMC, in PMC) {
  $2->vtable->divide(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<inc>(inout INT)

=item B<inc>(inout NUM)

=item B<inc>(inout PMC)

Increase $1 by one.

=cut

inline op inc(inout INT) {
  $1++;
  goto NEXT();
}

inline op inc(inout NUM) {
  $1++;
  goto NEXT();
}

inline op inc(inout PMC) {
  $1->vtable->increment(interpreter, $1);
  goto NEXT();
}


########################################

=item B<mod>(out INT, in INT, in INT)

NOTE: This "corrected mod" algorithm is based on the C code on page 70
of [1]. Assuming correct behavior of the built-in mod operator (%) with
positive arguments, this algorithm implements a mathematically convenient
version of mod, defined thus:

  x mod y = x - y * floor(x / y)

For more information on this definition of mod, see section 3.4 of [2],
pages 81-85.

References:

  [1] Donald E. Knuth, *MMIXware: A RISC Computer for the Third
      Millennium* Springer, 1999.

  [2] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
      Mathematics*, Second Edition. Addison-Wesley, 1994.

=item B<mod>(inout PMC, in PMC, in PMC)

Sets $1 to the modulus of $2 and $3.

=item B<mod>(inout PMC, in INT)

Sets $1 to the modulus of $1 and $2.

=cut

op mod(out INT, in INT, in INT) {
  INTVAL y = $2;
  INTVAL z = $3;
  INTVAL s = 0;
  INTVAL r;

  if (z == 0) {
    r = y;
  }
  else {
    if (y < 0) { s += 2; y = -y; }
    if (z < 0) { s += 1; z = -z; }

    r = y % z;

    switch (s) {
      case 0 + 0:            break;
      case 0 + 1: r = r - z; break;
      case 2 + 0: r = z - r; break;
      case 2 + 1: r = -r;    break;
    }
  }

  $1 = r;
  goto NEXT();
}

inline op mod (inout PMC, in PMC, in PMC) {
  $2->vtable->modulus(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op mod ( inout PMC, in INT ) {
  $1->vtable->modulus_int(interpreter, $1, $2, $1);
  goto NEXT();
}


########################################

=item B<mod>(out NUM, in NUM, in NUM)

NOTE: This "corrected mod" algorithm is based on the formula of [1]:

  x mod y = x - y * floor(x / y)

For more information on this definition of mod, see section 3.4 of [1],
pages 81-85.

References:

  [1] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
      Mathematics*, Second Edition. Addison-Wesley, 1994.

=cut

op mod(out NUM, in NUM, in NUM) {
#ifdef __LCC__

  /* Another workaround for buggy code generation in the lcc compiler-
   * adding a temporary variable makes it pass the test.
   */
  FLOATVAL temp = $3 * floor($2 / $3);

  $1 = $3
     ? ($2 - temp)
     : $2;
#else
  $1 = $3
     ? ($2 - $3 * floor($2 / $3))
     : $2;
#endif
  goto NEXT();
}


########################################

=item B<mul>(inout INT, in INT)

=item B<mul>(inout NUM, in INT)

=item B<mul>(inout NUM, in NUM)

=item B<mul>(inout PMC, in INT)

=item B<mul>(inout PMC, in NUM)

=item B<mul>(inout PMC, in PMC)

Set $1 to the product of $1 and $2.

=item B<mul>(out INT, in INT, in INT)

=item B<mul>(out NUM, in NUM, in INT)

=item B<mul>(out NUM, in NUM, in NUM)

=item B<mul>(inout PMC, in PMC, in INT)

=item B<mul>(inout PMC, in PMC, in NUM)

=item B<mul>(inout PMC, in PMC, in PMC)

Set $1 to the product of $2 and $3.

=cut

inline op mul(inout INT, in INT) {
  $1 *= $2;
  goto NEXT();
}

inline op mul(inout NUM, in INT) {
  $1 *= $2;
  goto NEXT();
}

inline op mul(inout NUM, in NUM) {
  $1 *= $2;
  goto NEXT();
}

inline op mul ( inout PMC, in INT ) {
  $1->vtable->multiply_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op mul ( inout PMC, in NUM ) {
  $1->vtable->multiply_float(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op mul (inout PMC, in PMC) {
  $1->vtable->multiply(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op mul(out INT, in INT, in INT) {
  $1 = $2 * $3;
  goto NEXT();
}

inline op mul(out NUM, in NUM, in INT) {
  $1 = $2 * $3;
  goto NEXT();
}

inline op mul(out NUM, in NUM, in NUM) {
  $1 = $2 * $3;
  goto NEXT();
}

inline op mul (inout PMC, in PMC, in INT) {
  $2->vtable->multiply_int(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op mul (inout PMC, in PMC, in NUM) {
  $2->vtable->multiply_float(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op mul (inout PMC, in PMC, in PMC) {
  $2->vtable->multiply(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<neg>(inout INT)

=item B<neg>(inout NUM)

Set $1 to its negative.

=item B<neg>(out INT, in INT)

=item B<neg>(out NUM, in NUM)

=item B<neg>(inout PMC, in PMC)

Set $1 to the negative of $2.

=cut

inline op neg(inout INT) {
  $1 = 0 - $1;
  goto NEXT();
}

inline op neg(inout NUM) {
  $1 = 0.0 - $1;
  goto NEXT();
}

inline op neg(out INT, in INT) {
  $1 = 0 - $2;
  goto NEXT();
}

inline op neg(out NUM, in NUM) {
  $1 = 0.0 - $2;
  goto NEXT();
}

inline op neg(inout PMC, in PMC) {
  $2->vtable->neg(interpreter, $2, $1);
  goto NEXT();
}

########################################

=item B<pow>(out NUM, in INT, in INT)

=item B<pow>(out NUM, in INT, in NUM)

=item B<pow>(out NUM, in NUM, in INT)

=item B<pow>(out NUM, in NUM, in NUM)

Set $1 to $2 raised to the power $3.

=cut

inline op pow(out NUM, in INT, in INT) {
   $1 = pow((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op pow(out NUM, in INT, in NUM) {
   $1 = pow((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op pow(out NUM, in NUM, in INT) {
   $1 = pow((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op pow(out NUM, in NUM, in NUM) {
   $1 = pow((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}


########################################

=item B<sub>(inout INT, in INT)

=item B<sub>(inout NUM, in INT)

=item B<sub>(inout NUM, in NUM)

=item B<sub>(inout PMC, in INT)

=item B<sub>(inout PMC, in NUM)

=item B<sub>(inout PMC, in PMC)

Decrease $1 by the amount in $2.

=item B<sub>(out INT, in INT, in INT)

=item B<sub>(out NUM, in NUM, in INT)

=item B<sub>(out NUM, in NUM, in NUM)

=item B<sub>(inout PMC, in PMC, in INT)

=item B<sub>(inout PMC, in PMC, in NUM)

=item B<sub>(inout PMC, in PMC, in PMC)

Set $1 to $2 minus $3.

=cut

inline op sub(inout INT, in INT) {
  $1 -= $2;
  goto NEXT();
}

inline op sub(inout NUM, in INT) {
  $1 -= $2;
  goto NEXT();
}

inline op sub(inout NUM, in NUM) {
  $1 -= $2;
  goto NEXT();
}

inline op sub(inout PMC, in INT) {
  $1->vtable->subtract_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op sub(inout PMC, in NUM) {
  $1->vtable->subtract_float(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op sub(inout PMC, in PMC) {
  $1->vtable->subtract(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op sub(out INT, in INT, in INT) {
  $1 = $2 - $3;
  goto NEXT();
}

inline op sub(out NUM, in NUM, in INT) {
  $1 = $2 - $3;
  goto NEXT();
}

inline op sub(out NUM, in NUM, in NUM) {
  $1 = $2 - $3;
  goto NEXT();
}

inline op sub(inout PMC, in PMC, in INT) {
  $2->vtable->subtract_int(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op sub(inout PMC, in PMC, in NUM) {
  $2->vtable->subtract_float(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op sub (inout PMC, in PMC, in PMC) {
  $2->vtable->subtract(interpreter, $2, $3, $1);
  goto NEXT();
}

=back

=cut


###############################################################################

=head2 String operations

These operations operate on STRINGs.

=over 4

=cut


########################################

=item B<chopn>(inout STR, in INT)

=item B<chopn>(out STR, in STR, in INT)

Remove $2 characters from the end of the string in $1.  The 3-arg version
removes $3 characters from the end of the string in $2 and returns the result
in $1

=cut

inline op chopn(inout STR, in INT) {
  (void)string_chopn($1, $2);
  goto NEXT();
}

inline op chopn(out STR, in STR, in INT) {
  $1 = string_copy(interpreter, $2);
  (void)string_chopn($1,$3);
  goto NEXT();
}

########################################

=item B<concat>(inout STR, in STR)

=item B<concat>(out STR, in STR, in STR)

=item B<concat>(inout PMC, in PMC, in PMC)

Append the string in $2 to the string in $1.

The three argument version appends the string $3 to $2 and places the result
into $1.

=cut

inline op concat(inout STR, in STR) {
  $1 = string_append(interpreter, $1, $2, 1);
  goto NEXT();
}

inline op concat(out STR, in STR, in STR) {
  $1 = string_concat(interpreter, $2, $3, 1);
  goto NEXT();
}

inline op concat (inout PMC, in PMC, in PMC) {
  $2->vtable->concatenate(interpreter, $2, $3, $1);
  goto NEXT();
}

#######################################

=item B<repeat>(out STR, in STR, in INT)

=item B<repeat>(inout PMC, in PMC, in PMC)

Repeats string $2 $3 times and stores result in $1.

=cut

inline op repeat(out STR, in STR, in INT) {
  if ($3 < 0) {
      internal_exception(NEG_REPEAT, "Cannot repeat with negative arg");
  }
  $1 = string_repeat(interpreter, $2, (UINTVAL)$3, NULL);
  goto NEXT();
}

inline op repeat (inout PMC, in PMC, in PMC) {
  $2->vtable->repeat(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<length>(out INT, in STR)

Set $1 to the length (in characters) of the string in $2.

=cut

inline op length(out INT, in STR) {
  $1 = string_length($2);
  goto NEXT();
}

=item B<pin>(inout STR)

Make the memory in $1 immobile. This memory will I<not> be moved by
the GC, and may be safely passed to external libraries. (Well, as long
as they don't free it) Pinning a string will move the contents.

The memory only need be unpinned if you plan on using it for any
length of time after its pinning is no longer necessary.

=cut

op pin(inout STR) {
   string_pin(interpreter, $1);
   goto NEXT();
}


=item B<unpin>(inout STR)

Make the memory in $1 moveable again. This will make the memory in $1
move.

=cut

op unpin(inout STR) {
   string_unpin(interpreter, $1);
   goto NEXT();
}


########################################

=item B<substr>(out STR, in STR, in INT, in INT)

=item B<substr>(out STR, in STR, in INT, in INT, in STR)

=item B<substr>(inout STR, in INT, in INT, in STR)

Set $1 to the portion of $2 starting at (zero-based) character position
$3 and having length $4.

Optionally pass in string $5 for replacement. If the length of $5 is
different from the length specified in $4, then $2 will grow or shrink
accordingly. If $3 is one character position larger than the length of
$2, then $5 is appended to $2 (and the empty string is returned);
this is essentially the same as

  concat $2, $5

Finally, if $3 is negative, then it is taken to count backwards from
the end of the string (ie an offset of -1 corresponds to the last
character).

The third form is optimized for replace only, ignoring the replaced
substring and does not waste a register to do the string replace.

=cut

inline op substr(out STR, in STR, in INT, in INT) {
  $1 = string_substr(interpreter, $2, $3, $4, &$1);
  goto NEXT();
}

inline op substr(out STR, inout STR, in INT, in INT, in STR) {
  $1 = string_replace(interpreter, $2, $3, $4, $5, &$1);
  goto NEXT();
}

inline op substr(inout STR, in INT, in INT, in STR) {
  (void)string_replace(interpreter, $1, $2, $3, $4, NULL);
  goto NEXT();
}


=cut

########################################

=item B<index>(out INT, in STR, in STR)

=item B<index>(out INT, in STR, in STR, in INT)

The index function searches for one string within
another, but without the wildcard-like behavior of
a full regular-expression pattern match.  It
returns the position of the first occurrence of
$3 in $2 at or after $4.  If $4 is omitted, starts
searching from the beginning of the string.
The return value is based at "0".
If the substring is not found, returns "-1".

=cut

inline op index(out INT, in STR, in STR) {
    $1 = string_str_index(interpreter, $2, $3, 0);
    goto NEXT();
}

inline op index(out INT, in STR, in STR, in INT) {
    $1 = string_str_index(interpreter, $2, $3, $4);
    goto NEXT();
}

=cut


########################################

=item B<pack>(inout STR, in INT, in INT)

=item B<pack>(inout STR, in INT, in NUM)

=item B<pack>(inout STR, in INT, in STR)

=item B<pack>(inout STR, in INT, in INT, in INT)

=item B<pack>(inout STR, in INT, in NUM, in INT)

=item B<pack>(inout STR, in INT, in STR, in INT)

Concat $2 bytes from $3 at the end of $1 or replace them at $4 if provided.

BE AFRAID, THIS IS A QUICK HACK, USE IT AT YOUR OWN RISK.

=cut

inline op pack(inout STR, in INT, in INT) {
    char *c = (char *)&$3;
    STRING *s;

    s = string_make(interpreter, c, (UINTVAL)$2, NULL, 0, NULL);
    $1 = string_concat(interpreter, $1, s, 1);

    goto NEXT();
}

inline op pack(inout STR, in INT, in NUM) {
    char *c = (char *)&$3;
    STRING *s;

    s = string_make(interpreter, c, (UINTVAL)$2, NULL, 0, NULL);
    $1 = string_concat(interpreter, $1, s, 1);

    goto NEXT();
}

inline op pack(inout STR, in INT, in STR) {
    STRING *t,*s = $3;
    UINTVAL len = (UINTVAL)$2;
    char buf[3];

    if (s->buflen < len) {
        t = string_make(interpreter, buf, (UINTVAL)(len - s->buflen), NULL, 0, NULL);
        $1 = string_concat(interpreter, $1, s, 1);
    } else {
        t = string_make(interpreter, s->strstart, (UINTVAL)len, NULL, 0, NULL);
    }
    $1 = string_concat(interpreter, $1, t, 1);

    goto NEXT();
}


inline op pack(inout STR, in INT, in INT, in INT) {
    char *c = (char *)&$3, *n;
    STRING *s;
    INTVAL ln;
    const char *t;
    int i;

    s = string_make(interpreter, c, (UINTVAL)$2, NULL, 0, NULL);
    ln = string_length($1);
    if (ln < $4 + $2)
    {
       $1->buflen = $1->strlen;
       string_grow(interpreter, $1, $4 + $2 - ln);
       $1->bufused = $1->strlen = $1->buflen;
    }

    /* XXX this is EVIL, use string_replace */
    n = $1->strstart;
    t = string_to_cstring(interpreter, s);
    for (i = $4; i < $4 + $2; i++)
        n[i] = t[i - $4];


    goto NEXT();
}

=cut

########################################

=item B<sprintf>(out STR, in STR, in PMC)

=item B<sprintf>(out PMC, in PMC, in PMC)

=item B<sprintf>(out STR, in STR) [unimplemented]

=item B<sprintf>(out PMC, in PMC) [unimplemented]

Sets $1 to the result of calling C<Parrot_psprintf> with the
given format ($2) and arguments ($3, which should be an ordered
aggregate PMC).  In the (unimplemented) versions that don't include
$3, arguments are popped off the user stack.

The result is quite similar to using the system C<sprintf>, but is
protected against buffer overflows and the like.  There are some
differences, especially concerning sizes (which are largely ignored);
see F<misc.c> for details.

=cut

inline op sprintf(out STR, in STR, in PMC) {
    $1=Parrot_psprintf(interpreter, $2, $3);
    goto NEXT();
}

inline op sprintf(out PMC, in PMC, in PMC) {
    $1->vtable->set_string_native(interpreter, $1,
        Parrot_psprintf(interpreter, $2->vtable->get_string(interpreter, $2), $3)
    );
    goto NEXT();
}

=cut

=item B<new>(out STR)

=item B<new>(out STR, in INT)

=item B<new>(out STR, in INT, in INT)

=item B<new>(out STR, in INT, in INT, in INT)

Allocate a new empty string, of length $2 (optional), encoding $3
(optional) and type $4. (optional)

=cut

inline op new(out STR) {
  $1 = string_make(interpreter, NULL, 0, NULL, 0, NULL);
  goto NEXT();
}

inline op new(out STR, in INT) {
  $1 = string_make(interpreter, NULL, $2, NULL, 0, NULL);
  goto NEXT();
}

inline op new(out STR, in INT, in INT) {
  $1 = string_make(interpreter, NULL, $2, encoding_lookup_index($3), 0, NULL);
  goto NEXT();
}

inline op new(out STR, in INT, in INT, in INT) {
  internal_exception(INVALID_CHARTYPE, "We don't do this yet");
  $1 = string_make(interpreter, NULL, $2, encoding_lookup_index($3), 0, NULL);
  goto NEXT();
}

=item B<transcode>(inout STR, in INT)

Transcode a string from its current encoding to the encoding in $2. $1
becomes a new string. (Transcoding is not inplace)

=item B<transcode>(out STR, in STR, in INT)

Put a transcoded version of $2 in $1, turning it to the encoding in $3

=cut

op transcode(inout STR, in INT) {
  $1 = string_transcode(interpreter, $1, encoding_lookup_index($2), NULL, NULL);
  goto NEXT();
}

op transcode(out STR, in STR, in INT) {
  $1 = string_transcode(interpreter, $2, encoding_lookup_index($3), NULL, NULL);
  goto NEXT();
}

=item B<find_encoding>(out INT, in STR)

Find the encoding named in $2 and return its number in $1

=cut

op find_encoding(out INT, in STR) {
  char *temp_encoding = string_to_cstring(interpreter, $2);
  char encoding[255];

  /* Copy the string to stack storage and free. Ick. */
  strncpy(encoding, temp_encoding, sizeof(encoding));
  encoding[sizeof(encoding)-1] = 0;
  string_cstring_free(temp_encoding);

  $1 = encoding_find_encoding(encoding);
  goto NEXT();
}

=item B<string_encoding>(out INT, in STR)

Find the encoding type for $2 and put it in $1

=back

=cut

op string_encoding(out INT, in STR) {
   $1 = encoding_by_encoding($2->encoding);
   goto NEXT();
}

###############################################################################

=head2 Transcendental mathematical operations

These operations perform various transcendental operations such as logarithmics
and trigonometrics.

=over 4

=cut


########################################

=item B<acos>(out NUM, in INT)

=item B<acos>(out NUM, in NUM)

Set $1 to the arc cosine (in radians) of $2.

=cut

inline op acos(out NUM, in INT) {
  $1 = acos((FLOATVAL)$2);
  goto NEXT();
}

inline op acos(out NUM, in NUM) {
  $1 = acos((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<asec>(out NUM, in INT)

=item B<asec>(out NUM, in NUM)

Set $1 to the arc secant (in radians) of $2.

=cut

inline op asec(out NUM, in INT) {
  $1 = acos(((FLOATVAL)1) / ((FLOATVAL)$2));
  goto NEXT();
}

inline op asec(out NUM, in NUM) {
  $1 = acos(((FLOATVAL)1) / ((FLOATVAL)$2));
  goto NEXT();
}


########################################

=item B<asin>(out NUM, in INT)

=item B<asin>(out NUM, in NUM)

Set $1 to the arc sine (in radians) of $2.

=cut

inline op asin(out NUM, in INT) {
  $1 = asin((FLOATVAL)$2);
  goto NEXT();
}

inline op asin(out NUM, in NUM) {
  $1 = asin((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<atan>(out NUM, in INT)

=item B<atan>(out NUM, in NUM)

=item B<atan>(out NUM, in INT, in INT)

=item B<atan>(out NUM, in INT, in NUM)

=item B<atan>(out NUM, in NUM, in INT)

=item B<atan>(out NUM, in NUM, in NUM)

The two-argument versions set $1 to the arc tangent (in radians) of $2.

The three-argument versions set $1 to the arc tangent (in radians) of
$2 / $3, taking account of the signs of the arguments in determining the
quadrant of the result.

=cut

inline op atan(out NUM, in INT) {
  $1 = atan((FLOATVAL)$2);
  goto NEXT();
}

inline op atan(out NUM, in NUM) {
  $1 = atan((FLOATVAL)$2);
  goto NEXT();
}

inline op atan(out NUM, in INT, in INT) {
  $1 = atan2((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op atan(out NUM, in INT, in NUM) {
  $1 = atan2((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op atan(out NUM, in NUM, in INT) {
  $1 = atan2((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}

inline op atan(out NUM, in NUM, in NUM) {
  $1 = atan2((FLOATVAL)$2, (FLOATVAL)$3);
  goto NEXT();
}


########################################

=item B<cos>(out NUM, in INT)

=item B<cos>(out NUM, in NUM)

Set $1 to the cosine of $2 (given in radians).

=cut

inline op cos(out NUM, in INT) {
  $1 = cos((FLOATVAL)$2);
  goto NEXT();
}

inline op cos(out NUM, in NUM) {
  $1 = cos((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<cosh>(out NUM, in INT)

=item B<cosh>(out NUM, in NUM)

Set $1 to the hyperbolic cosine of $2 (given in radians).

=cut

inline op cosh(out NUM, in INT) {
  $1 = cosh((FLOATVAL)$2);
  goto NEXT();
}

inline op cosh(out NUM, in NUM) {
  $1 = cosh((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<exp>(out NUM, in INT)

=item B<exp>(out NUM, in NUM)

Set $1 to I<e> raised to the power $2. I<e> is the base of the natural logarithm.

=cut

inline op exp(out NUM, in INT) {
  $1 = exp((FLOATVAL)$2);
  goto NEXT();
}

inline op exp(out NUM, in NUM) {
  $1 = exp((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<ln>(out NUM, in INT)

=item B<ln>(out NUM, in NUM)

Set $1 to the natural (base I<e>) logarithm of $2.

=cut

inline op ln(out NUM, in INT) {
  $1 = log((FLOATVAL)$2);
  goto NEXT();
}

inline op ln(out NUM, in NUM) {
  $1 = log((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<log10>(out NUM, in INT)

=item B<log10>(out NUM, in NUM)

Set $1 to the base 10 logarithm of $2.

=cut

inline op log10(out NUM, in INT) {
  $1 = log10((FLOATVAL)$2);
  goto NEXT();
}

inline op log10(out NUM, in NUM) {
  $1 = log10((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<log2>(out NUM, in INT)

=item B<log2>(out NUM, in NUM)

Set $1 to the base 2 logarithm of $2.

=cut

op log2(out NUM, in INT) {
   FLOATVAL temp = log((FLOATVAL)2.0);
  $1 = log((FLOATVAL)$2) / temp;
  goto NEXT();
}

op log2(out NUM, in NUM) {
   FLOATVAL temp = log((FLOATVAL)2.0);
  $1 = log((FLOATVAL)$2) / temp;
  goto NEXT();
}


########################################

=item B<sec>(out NUM, in INT)

=item B<sec>(out NUM, in NUM)

Set $1 to the secant of $2 (given in radians).

=cut

inline op sec(out NUM, in INT) {
  $1 = ((FLOATVAL)1) / cos((FLOATVAL)$2);
  goto NEXT();
}

inline op sec(out NUM, in NUM) {
  $1 = ((FLOATVAL)1) / cos((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<sech>(out NUM, in INT)

=item B<sech>(out NUM, in NUM)

Set $1 to the hyperbolic secant of $2 (given in radians).

=cut

inline op sech(out NUM, in INT) {
  $1 = ((FLOATVAL)1) / cosh((FLOATVAL)$2);
  goto NEXT();
}

inline op sech(out NUM, in NUM) {
  $1 = ((FLOATVAL)1) / cosh((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<sin>(out NUM, in INT)

=item B<sin>(out NUM, in NUM)

Set $1 to the sine of $2 (given in radians).

=cut

inline op sin(out NUM, in INT) {
  $1 = sin((FLOATVAL)$2);
  goto NEXT();
}

inline op sin(out NUM, in NUM) {
  $1 = sin((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<sinh>(out NUM, in INT)

=item B<sinh>(out NUM, in NUM)

Set $1 to the hyperbolic sine of $2 (given in radians).

=cut

inline op sinh(out NUM, in INT) {
  $1 = sinh((FLOATVAL)$2);
  goto NEXT();
}

inline op sinh(out NUM, in NUM) {
  $1 = sinh((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<tan>(out NUM, in INT)

=item B<tan>(out NUM, in NUM)

Set $1 to the tangent of $2 (given in radians).

=cut

inline op tan(out NUM, in INT) {
  $1 = tan((FLOATVAL)$2);
  goto NEXT();
}

inline op tan(out NUM, in NUM) {
  $1 = tan((FLOATVAL)$2);
  goto NEXT();
}


########################################

=item B<tanh>(out NUM, in INT)

=item B<tanh>(out NUM, in NUM)

Set $1 to the hyperbolic tangent of $2 (given in radians).

=cut

inline op tanh(out NUM, in INT) {
  $1 = tanh((FLOATVAL)$2);
  goto NEXT();
}

inline op tanh(out NUM, in NUM) {
  $1 = tanh((FLOATVAL)$2);
  goto NEXT();
}


=back

=cut


###############################################################################

=head2 Bitwise logical operations

These operations apply  bitwise logical functions to their arguments.

=over 4

=cut


########################################

=item B<band>(inout INT, in INT)

=item B<band>(inout PMC, in INT)

=item B<band>(inout PMC, in PMC)

Set the bits of $1 according to the B<and> of the corresponding bits from $1 and $2.

=item B<band>(out INT, in INT, in INT)

=item B<band>(inout PMC, in PMC, in INT)

=item B<band>(inout PMC, in PMC, in PMC)

Set the bits of $1 according to the B<and> of the corresponding bits from $2 and $3.

=cut

inline op band(inout INT, in INT) {
  $1 &= $2;
  goto NEXT();
}

inline op band(inout PMC, in INT) {
  $1->vtable->bitwise_and_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op band(inout PMC, in PMC) {
  $1->vtable->bitwise_and(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op band(out INT, in INT, in INT) {
  $1 = $2 & $3;
  goto NEXT();
}

inline op band(inout PMC, in PMC, in INT) {
  $2->vtable->bitwise_and_int(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op band(inout PMC, in PMC, in PMC) {
  $2->vtable->bitwise_and(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<bnot>(out INT, in INT)

=item B<bnot>(inout PMC, in PMC)

Set the bits of $1 to the B<not> of the corresponding bits from $2.

=cut

inline op bnot(out INT, in INT) {
  $1 = ~ $2;
  goto NEXT();
}

inline op bnot(inout PMC, in PMC) {
  $2->vtable->bitwise_not(interpreter, $2, $1);
  goto NEXT();
}

########################################

=item B<bor>(inout INT, in INT)

=item B<bor>(inout PMC, in INT)

=item B<bor>(inout PMC, in PMC)

Set the bits of $1 according to the B<or> of the corresponding bits from $1 and $2.

=item B<bor>(out INT, in INT, in INT)

=item B<bor>(inout PMC, in PMC, in INT)

=item B<bor>(inout PMC, in PMC, in PMC)

Set the bits of $1 according to the B<or> of the corresponding bits from $2 and $3.

=cut

inline op bor(inout INT, in INT) {
  $1 |= $2;
  goto NEXT();
}

inline op bor(inout PMC, in INT) {
  $1->vtable->bitwise_or_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op bor(inout PMC, in PMC) {
  $1->vtable->bitwise_or(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op bor(out INT, in INT, in INT) {
  $1 = $2 | $3;
  goto NEXT();
}

inline op bor(inout PMC, in PMC, in INT) {
  $2->vtable->bitwise_or_int(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op bor(inout PMC, in PMC, in PMC) {
  $2->vtable->bitwise_or(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<shl>(out INT, in INT, in INT)

=item B<shl>(inout PMC, in PMC, in PMC)

Set $1 to the value of $2 shifted left by $3 bits.

=cut

inline op shl(out INT, in INT, in INT) {
  $1 = $2 << $3;
  goto NEXT();
}

inline op shl(inout PMC, in PMC, in PMC) {
  $2->vtable->bitwise_shl(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<shr>(out INT, in INT, in INT)

=item B<shr>(inout PMC, in PMC, in PMC)

Set $1 to the value of $2 shifted right by $3 bits.

=cut

inline op shr(out INT, in INT, in INT) {
  $1 = $2 >> $3;
  goto NEXT();
}

inline op shr(inout PMC, in PMC, in PMC) {
  $2->vtable->bitwise_shr(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<lsr>(out INT, in INT, in INT)

Set $1 to the value of $2 logically shifted right by $3 bits.

=cut

inline op lsr(out INT, in INT, in INT) {
  $1 = (INTVAL)((UINTVAL)$2 >> $3);
  goto NEXT();
}

########################################

=item B<bxor>(inout INT, in INT)

=item B<bxor>(inout PMC, in INT)

=item B<bxor>(inout PMC, in PMC)

Set the bits of $1 according to the B<xor> of the corresponding bits from $1 and $2.

=item B<bxor>(out INT, in INT, in INT)

=item B<bxor>(inout PMC, in PMC, in INT)

=item B<bxor>(inout PMC, in PMC, in PMC)

Set the bits of $1 according to the B<xor> of the corresponding bits from $2 and $3.

=cut

inline op bxor(inout INT, in INT) {
  $1 ^= $2;
  goto NEXT();
}

inline op bxor(inout PMC, in INT) {
  $1->vtable->bitwise_xor_int(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op bxor(inout PMC, in PMC) {
  $1->vtable->bitwise_xor(interpreter, $1, $2, $1);
  goto NEXT();
}

inline op bxor(out INT, in INT, in INT) {
  $1 = $2 ^ $3;
  goto NEXT();
}

inline op bxor(inout PMC, in PMC, in INT) {
  $2->vtable->bitwise_xor_int(interpreter, $2, $3, $1);
  goto NEXT();
}

inline op bxor(inout PMC, in PMC, in PMC) {
  $2->vtable->bitwise_xor(interpreter, $2, $3, $1);
  goto NEXT();
}

=back

=cut


###############################################################################

=head2 Logical operations

These operations apply logical functions to their arguments.

=over 4

=cut


########################################

=item B<and>(out INT, in INT, in INT)

=item B<and>(inout PMC, in PMC, in PMC)

Short-circuiting logical and.  Returns $2 if it's false, else returns $3.

=cut

inline op and(out INT, in INT, in INT) {
  $1 = $2 ? $3 : $2;
  goto NEXT();
}

inline op and(inout PMC, in PMC, in PMC) {
  $2->vtable->logical_and(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<not>(out INT, in INT)

=item B<not>(inout PMC, in PMC)

Set the boolean state of $1 to the opposite of the boolean state from $2.

=cut

inline op not(out INT, in INT) {
  $1 = ! $2;
  goto NEXT();
}

inline op not(inout PMC, in PMC) {
  $2->vtable->logical_not(interpreter, $2, $1);
  goto NEXT();
}

########################################

=item B<or>(out INT, in INT, in INT)

=item B<or>(inout PMC, in PMC, in PMC)

Short-circuiting logical or.  Returns $2 if it's true, else returns $3.

=cut

inline op or(out INT, in INT, in INT) {
  $1 = $2 ? $2 : $3;
  goto NEXT();
}

inline op or(inout PMC, in PMC, in PMC) {
  $2->vtable->logical_or(interpreter, $2, $3, $1);
  goto NEXT();
}

########################################

=item B<xor>(out INT, in INT, in INT)

=item B<xor>(inout PMC, in PMC, in PMC)

Logical xor.  Returns $2 if it's true and $3 isn't,
returns $3 if it's true and $2 isn't, else returns false.

=cut

inline op xor(out INT, in INT, in INT) {
  $1 = ($2 && ! $3) ? $2 : ($3 && ! $2) ? $3 : 0;
  goto NEXT();
}

inline op xor(inout PMC, in PMC, in PMC) {
  $2->vtable->logical_xor(interpreter, $2, $3, $1);
  goto NEXT();
}

=cut

=item B<defined>(out INT, in PMC)

=item B<defined>(out INT, in PMC, in INTKEY)

=item B<defined>(out INT, in PMC, in KEY)

Test for PMC definedness.

=item B<exists>(out INT, in PMC, in INTKEY)

=item B<exists>(out INT, in PMC, in KEY)

Test for key existence.

=cut

inline op defined(out INT, in PMC) {
  $1 = $2 ? $2->vtable->defined(interpreter, $2) : 0;
  goto NEXT();
}

inline op defined(out INT, in PMC, in INTKEY) {
  INTVAL key = $3;
  $1 = $2 ? $2->vtable->defined_keyed_int(interpreter, $2, &key) : 0;
  goto NEXT();
}

inline op defined(out INT, in PMC, in KEY) {
  $1 = ($2 && $3) ? $2->vtable->defined_keyed(interpreter, $2, $3) : 0;
  goto NEXT();
}

inline op exists(out INT, in PMC, in INTKEY) {
  INTVAL key = $3;
  $1 = $2 ? $2->vtable->exists_keyed_int(interpreter, $2, &key) : 0;
  goto NEXT();
}

inline op exists(out INT, in PMC, in KEY) {
  $1 = ($2 && $3) ? $2->vtable->exists_keyed(interpreter, $2, $3) : 0;
  goto NEXT();
}

=cut

=item B<delete>(inout PMC, in KEY)

Delete the specified entry $2 from aggregate $1.

=back

=cut

inline op delete(inout PMC, in KEY) {
  $1->vtable->delete_keyed(interpreter, $1, $2);
  goto NEXT();
}
###############################################################################

=head2 Interpreter flag modification operations

These operations modify the internal interpreter flags, affecting its
subsequent operation.

=over 4

=cut


########################################

=item B<debug>(in INT)

If $1 is zero, turn off debugging. Otherwise turn it on.

=cut

inline op debug(in INT) {
  if ($1 != 0) { Interp_flags_SET(interpreter,   PARROT_DEBUG_FLAG); }
  else         { Interp_flags_CLEAR(interpreter, PARROT_DEBUG_FLAG); }
  restart NEXT();
}


########################################

=item B<bounds>(in INT)

If $1 is zero, turn off byte code bounds checking. Otherwise turn it on.

=cut

inline op bounds(in INT) {
  if ($1 != 0) { Interp_flags_SET(interpreter,   PARROT_BOUNDS_FLAG); }
  else         { Interp_flags_CLEAR(interpreter, PARROT_BOUNDS_FLAG); }
  restart NEXT();
}


########################################

=item B<profile>(in INT)

If $1 is zero, turn off profiling. Otherwise turn it on.

=cut

inline op profile(in INT) {
  if ($1 != 0) { Interp_flags_SET(interpreter,   PARROT_PROFILE_FLAG); }
  else         { Interp_flags_CLEAR(interpreter, PARROT_PROFILE_FLAG); }
  restart NEXT();
}


########################################

=item B<trace>(in INT)

If $1 is zero, turn off tracing. Otherwise turn it on.

=cut

inline op trace(in INT) {
  if ($1 != 0) { Interp_flags_SET(interpreter,   PARROT_TRACE_FLAG); }
  else         { Interp_flags_CLEAR(interpreter, PARROT_TRACE_FLAG); }
  restart NEXT();
}

########################################

=item B<gc_debug>(in INT)

If $1 is zero, turn off GC_DEBUG. Otherwise turn it on.

=cut

inline op gc_debug(in INT) {
  if ($1 != 0) { Interp_flags_SET(interpreter,   PARROT_GC_DEBUG_FLAG); }
  else         { Interp_flags_CLEAR(interpreter, PARROT_GC_DEBUG_FLAG); }
  goto NEXT();
}

=back

=cut


###############################################################################

=head2 Register operations

These operations effect entire sets of registers.

=over 4

=cut


########################################

=item B<cleari>()

=item B<clearn>()

=item B<clearp>()

=item B<clears>()

Clear all the registers of the type indicated in the name of the operation.

INTVAL ('i') and FLOATVAL ('n') registers clear to zero.

PMC ('p') and STRING ('s') registers clear to NULL.

=cut

inline op cleari() {
  Parrot_clear_i(interpreter);
  goto NEXT();
}

inline op clearn() {
  Parrot_clear_n(interpreter);
  goto NEXT();
}

inline op clears() {
  Parrot_clear_s(interpreter);
  goto NEXT();
}

inline op clearp() {
  Parrot_clear_p(interpreter);
  goto NEXT();
}


########################################

=item B<popi>()

=item B<popn>()

=item B<popp>()

=item B<pops>()

Restore all the registers of the type indicated in the name of the operation
from the most recently B<push>ed copies.

=cut

inline op popi() {
  Parrot_pop_i(interpreter);
  goto NEXT();
}

inline op popn() {
  Parrot_pop_n(interpreter);
  goto NEXT();
}

inline op pops() {
  Parrot_pop_s(interpreter);
  goto NEXT();
}

inline op popp() {
  Parrot_pop_p(interpreter);
  goto NEXT();
}


########################################

=item B<halfpopi>()

=item B<halfpopn>()

=item B<halfpopp>()

=item B<halfpops>()

Restores registers 16-31 of the type indicated in the name of the operation
from the most recently B<push>ed copies. Registers 0-15 of the saved set are
discarded.

=cut

inline op halfpopi() {
  Parrot_half_pop_i(interpreter);
  goto NEXT();
}

inline op halfpopn() {
  Parrot_half_pop_n(interpreter);
  goto NEXT();
}

inline op halfpops() {
  Parrot_half_pop_s(interpreter);
  goto NEXT();
}

inline op halfpopp() {
  Parrot_half_pop_p(interpreter);
  goto NEXT();
}


########################################

=item B<pushi>()

=item B<pushn>()

=item B<pushp>()

=item B<pushs>()

Save all the registers of the type indicated in the name of the operation.

=cut

inline op pushi() {
  Parrot_push_i(interpreter);
  goto NEXT();
}

inline op pushn() {
  Parrot_push_n(interpreter);
  goto NEXT();
}

inline op pushs() {
  Parrot_push_s(interpreter);
  goto NEXT();
}

inline op pushp() {
  Parrot_push_p(interpreter);
  goto NEXT();
}

=back

=cut

###############################################################################

=head2 Register stack operations

These operations affect individual registers.

=over 4

=cut


########################################

=item B<entrytype>(out INT, in INT)

Gets the type of entry $2 of the user stack and puts it in $1.

=cut

op entrytype(out INT, in INT) {
  Stack_Entry_t *entry;

  entry = stack_entry(interpreter, interpreter->ctx.user_stack, $2);
  if (!entry) {
    internal_exception(99, "Stack Depth wrong");
  }
  $1 = get_entry_type(interpreter, entry);
  goto NEXT();
}

########################################

=item B<depth>(out INT)

Puts the depth of the user stack in $1.

=cut

inline op depth(out INT) {
  $1 = stack_height(interpreter, interpreter->ctx.user_stack);
  goto NEXT();
}


#######################################

=item B<lookback>(out INT, in INT)

=item B<lookback>(out STR, in INT)

=item B<lookback>(out NUM, in INT)

=item B<lookback>(out PMC, in INT)

Finds the entry in the user stack at offset $2 from the top and put it
in register $1. Positive numbers count down from the top of the stack,
negative numbers count up from the bottom. (0 is the topmost entry, -1
is the bottom-most)

=cut

op lookback(out INT, in INT) {
  Stack_Entry_t *entry =
  	stack_entry(interpreter, interpreter->ctx.user_stack, $2);
  if (!entry)
      internal_exception(99, "Stack depth wrong");
  if (entry->entry_type != STACK_ENTRY_INT) {
    internal_exception(ERROR_BAD_STACK_TYPE, "Wrong type on stack!");
  }

  $1 = entry->entry.int_val;
  goto NEXT();
}

op lookback(out STR, in INT) {
  Stack_Entry_t *entry =
  	stack_entry(interpreter, interpreter->ctx.user_stack, $2);
  if (!entry)
      internal_exception(99, "Stack depth wrong");
  if (entry->entry_type != STACK_ENTRY_STRING) {
    internal_exception(ERROR_BAD_STACK_TYPE, "Wrong type on stack!");
  }

  $1 = entry->entry.string_val;
  goto NEXT();
}

op lookback(out NUM, in INT) {
  Stack_Entry_t *entry =
  	stack_entry(interpreter, interpreter->ctx.user_stack, $2);
  if (!entry)
      internal_exception(99, "Stack depth wrong");
  if (entry->entry_type != STACK_ENTRY_FLOAT) {
    internal_exception(ERROR_BAD_STACK_TYPE, "Wrong type on stack!");
  }

  $1 = entry->entry.num_val;
  goto NEXT();
}

op lookback(out PMC, in INT) {
  Stack_Entry_t *entry =
  	stack_entry(interpreter, interpreter->ctx.user_stack, $2);
  if (!entry)
      internal_exception(99, "Stack depth wrong");
  if (entry->entry_type != STACK_ENTRY_PMC) {
    internal_exception(ERROR_BAD_STACK_TYPE, "Wrong type on stack!");
  }

  $1 = entry->entry.pmc_val;
  goto NEXT();
}

########################################

=item B<save>(in INT)

=item B<save>(in NUM)

=item B<save>(in STR)

=item B<save>(in PMC)

Save register or constant $1 onto the user stack.

=cut

inline op save(in INT) {
  INTVAL i = $1;
  stack_push(interpreter, &interpreter->ctx.user_stack, &i, STACK_ENTRY_INT, STACK_CLEANUP_NULL);
  goto NEXT();
}

inline op save(in NUM) {
  stack_push(interpreter, &interpreter->ctx.user_stack, &($1), STACK_ENTRY_FLOAT, STACK_CLEANUP_NULL);
  goto NEXT();
}

inline op save(in PMC) {
  stack_push(interpreter, &interpreter->ctx.user_stack, $1, STACK_ENTRY_PMC, STACK_CLEANUP_NULL);
  goto NEXT();
}

inline op save(in STR) {
  stack_push(interpreter, &interpreter->ctx.user_stack, $1, STACK_ENTRY_STRING, STACK_CLEANUP_NULL);
  goto NEXT();
}


########################################

=item B<savec>(in STR)

=item B<savec>(in PMC)

Save a clone of register or constant $1 onto the user stack.

=cut

inline op savec(in STR) {
  stack_push(interpreter, &interpreter->ctx.user_stack, string_copy(interpreter, $1), STACK_ENTRY_STRING, STACK_CLEANUP_NULL);
  goto NEXT();
}


########################################

=item B<restore>(out INT)

=item B<restore>(out NUM)

=item B<restore>(out PMC)

=item B<restore>(out STR)

Restore register $1 from the user stack.

=cut

inline op restore(out INT) {
  (void)stack_pop(interpreter, &interpreter->ctx.user_stack, &($1),
                  STACK_ENTRY_INT);
  goto NEXT();
}

inline op restore(out NUM) {
  (void)stack_pop(interpreter, &interpreter->ctx.user_stack, &($1),
                  STACK_ENTRY_FLOAT);
  goto NEXT();
}

inline op restore(out PMC) {
  (void)stack_pop(interpreter, &interpreter->ctx.user_stack, &($1),
                  STACK_ENTRY_PMC);
  goto NEXT();
}

inline op restore(out STR) {
  (void)stack_pop(interpreter, &interpreter->ctx.user_stack, &($1),
                  STACK_ENTRY_STRING);
  goto NEXT();
}


########################################

=item B<rotate_up>(in INT)

Rotate the top $1 entries in the user stack by one. If $1 is positive,
then the stack rotates upwards: the ($1)th entry becomes the ($1-1)th
entry and so on, all the way up to the top of the stack, while the
entry formerly at the top of the stack becomes the new ($1)th entry.
If $1 is negative, the stack rotates downwards: the top entry becomes
the second entry, the second becomes the third etc., while the former
($1)th entry becomes the new top entry.

=cut

inline op rotate_up(in INT) {
  rotate_entries(interpreter, &interpreter->ctx.user_stack, $1);
  goto NEXT();
}

########################################

=item B<intsave>(in INT)

Save register or constant $1 onto the high-speed int stack.

=cut

inline op intsave(in INT) {
  intstack_push(interpreter, interpreter->ctx.intstack, $1);
  goto NEXT();
}

########################################

=item B<intrestore>(out INT)

Restore register $1 from the high-speed int stack.

=cut

inline op intrestore(out INT) {
  $1=intstack_pop(interpreter, interpreter->ctx.intstack);
  goto NEXT();
}

########################################

=item B<intdepth>(out INT)

Puts the depth of the high-speed int stack in $1.

=cut

inline op intdepth(out INT) {
  $1=intstack_depth(interpreter, interpreter->ctx.intstack);
  goto NEXT();
}

=cut

########################################

=item B<saveall>()

Save all the registers.

=item B<restoreall>()

Restore all the registers.

=cut

inline op saveall() {
  Parrot_push_i(interpreter);
  Parrot_push_n(interpreter);
  Parrot_push_s(interpreter);
  Parrot_push_p(interpreter);
  goto NEXT();
}

inline op restoreall() {
  Parrot_pop_i(interpreter);
  Parrot_pop_n(interpreter);
  Parrot_pop_s(interpreter);
  Parrot_pop_p(interpreter);
  goto NEXT();
}

=back

=cut

###############################################################################

=head2 Fast access ops

The fast access ops are shortcuts to common operations implemented in PMCs.

=over 4

=cut

########################################

=item B<push>(inout PMC, in INT)

=item B<push>(inout PMC, in NUM)

=item B<push>(inout PMC, in STR)

=item B<push>(inout PMC, in PMC)

Push $2 onto the end of the aggregate PMC $1, if that operation is defined.

=cut

inline op push (inout PMC, in INT) {
    $1->vtable->push_integer(interpreter, $1, $2);
    goto NEXT();
}

inline op push (inout PMC, in NUM) {
    $1->vtable->push_float(interpreter, $1, $2);
    goto NEXT();
}

inline op push (inout PMC, in STR) {
    $1->vtable->push_string(interpreter, $1, $2);
    goto NEXT();
}

inline op push (inout PMC, in PMC) {
    $1->vtable->push_pmc(interpreter, $1, $2);
    goto NEXT();
}

=item B<pop>(out INT, inout PMC)

=item B<pop>(out NUM, inout PMC)

=item B<pop>(out STR, inout PMC)

=item B<pop>(out PMC, inout PMC)

Pop off last entry in the aggregate $2, placing the result in $1.

=cut

inline op pop (out INT, inout PMC) {
    $1 = $2->vtable->pop_integer(interpreter, $2);
    goto NEXT();
}

inline op pop (out NUM, inout PMC) {
    $1 = $2->vtable->pop_float(interpreter, $2);
    goto NEXT();
}

inline op pop (out STR, inout PMC) {
    $1 = $2->vtable->pop_string(interpreter, $2);
    goto NEXT();
}

inline op pop (out PMC, inout PMC) {
    $1 = $2->vtable->pop_pmc(interpreter, $2);
    goto NEXT();
}

=item B<unshift>(inout PMC, in INT)

=item B<unshift>(inout PMC, in NUM)

=item B<unshift>(inout PMC, in STR)

=item B<unshift>(inout PMC, in PMC)

Unshift $2 onto the end of the aggregate PMC $1, if that operation is defined.

=cut

inline op unshift (inout PMC, in INT) {
    $1->vtable->unshift_integer(interpreter, $1, $2);
    goto NEXT();
}

inline op unshift (inout PMC, in NUM) {
    $1->vtable->unshift_float(interpreter, $1, $2);
    goto NEXT();
}

inline op unshift (inout PMC, in STR) {
    $1->vtable->unshift_string(interpreter, $1, $2);
    goto NEXT();
}

inline op unshift (inout PMC, in PMC) {
    $1->vtable->unshift_pmc(interpreter, $1, $2);
    goto NEXT();
}

=item B<shift>(out INT, inout PMC)

=item B<shift>(out NUM, inout PMC)

=item B<shift>(out STR, inout PMC)

=item B<shift>(out PMC, inout PMC)

Shift off last entry in the aggregate $2, placing the result in $1.

=cut

inline op shift (out INT, inout PMC) {
    $1 = $2->vtable->shift_integer(interpreter, $2);
    goto NEXT();
}

inline op shift (out NUM, inout PMC) {
    $1 = $2->vtable->shift_float(interpreter, $2);
    goto NEXT();
}

inline op shift (out STR, inout PMC) {
    $1 = $2->vtable->shift_string(interpreter, $2);
    goto NEXT();
}

inline op shift (out PMC, inout PMC) {
    $1 = $2->vtable->shift_pmc(interpreter, $2);
    goto NEXT();
}

=item B<splice>(inout PMC, in PMC, in INT, in INT)

Replace $4 values at offset $3 in aggregate $1 with the PMCs in aggregate $2.
The values are put into the aggregate by a shallow copy. If the values would
be reused, they have to be B<clone>d.

=cut

inline op splice(inout PMC, in PMC, in INT, in INT) {
    $1->vtable->splice(interpreter, $1, $2, $3, $4);
    goto NEXT();
}

=back

=cut

###############################################################################

=head2 Control flow

The control flow opcodes check conditions and manage program flow.

=over 4

=cut

########################################

=item B<branch>(in INT)

Branch forward or backward by the amount in $1.

=cut

inline op branch (in INT) {
  goto OFFSET($1);
}


=item B<branch_cs>(in INT)

Intersegment branch to location in fixup table $1.

=cut

inline op branch_cs (in INT) {
  interpreter->resume_offset = $1;
  interpreter->resume_flag = 2;
  goto ADDRESS(0);
}


########################################

=item B<bsr>(in INT)

Branch to the location specified by $1. Push the current location onto the call
stack for later returning.

=cut

inline op bsr (in INT) {
  stack_push(interpreter, &interpreter->ctx.control_stack, expr NEXT(),  STACK_ENTRY_DESTINATION, STACK_CLEANUP_NULL);
  goto OFFSET($1);
}


########################################

=item B<jsr>(in INT)

Jump to the location specified by register $1. Push the current
location onto the call stack for later returning.

=cut

inline op jsr(in INT) {
  opcode_t * loc;
  stack_push(interpreter, &interpreter->ctx.control_stack, expr NEXT(),  STACK_ENTRY_DESTINATION, STACK_CLEANUP_NULL);
  loc = INTVAL2PTR(opcode_t *, $1);
  goto ADDRESS(loc);
}


########################################

=item B<jump>(in INT)

Jump to the address held in register $1.

=cut

inline op jump(in INT) {
  opcode_t * loc;
  loc = INTVAL2PTR(opcode_t *, $1);
  goto ADDRESS(loc);
}

=back

=cut

###############################################################################

=head2 Symbol table ops

Ops to manipulate the symbol table

=over 4

=cut

########################################

=item B<new_pad>(in INT)

Create a new lexical scope pad with static nesting depth $1
and push it onto the lexical scope stack. Static depths 0
through $1 - 1, inclusive, are copied from the current static
nesting.

=item B<new_pad>(out PMC, in INT)

Create a new lexical scope pad with static nesting depth $2
and store it in $1 (do NOT push on the stack). Static depths 0
through $2 - 1, inclusive, are copied from the current static
nesting.

=item B<push_pad>(in PMC)

Push the scratchpad in $1 onto the lexical scope stack.

=item B<pop_pad>()

Pop the current lexical scope pad off the stack

=item B<pop_pad>(out PMC)

Pop the current lexical scope pad off the stack and store
it in $1 (XXX JPS: not implemented yet).

=item B<peek_pad>(out PMC)

Store the current lexical scope pad (i.e. the one at the
top of the lexical pad stack) in $1.

=item B<store_lex>(in STR, in PMC)

Store object $2 as lexical symbol $1.  $1 must have already been
created at some static depth.

=item B<store_lex>(in INT, in STR, in PMC)

Store object $3 as lexical $2 at depth $1.  If [$1, $2] does not
exist, it will be created.  If $1 is negative, count out from the
current lexical scope; otherwise, count in from the outermost scope.
So store_lex -1, .... will operate on the current pad.

=item B<store_lex>(in INT, in INT, in PMC)

Store object $3 at lexical position $2 at depth $1.  If [$1, $2] does
not exist, it will be created.  If $1 is negative, count out from the
current lexical scope; otherwise, count in from the outermost scope.
So store_lex -1, .... will operate on the current pad.

=item B<find_lex>(out PMC, in STR)

Find the lexical variable named $2 (at any depth) and store it in $1.

=item B<find_lex>(out PMC, in INT, in STR)

Find the lexical variable named $3 at depth $2 and store it in $1.
If $2 is negative the, count out from the current lexical scope;
otherwise, count up from the outermost scope.

=item B<find_lex>(out PMC, in INT, in INT)

Find the lexical variable at position $3 at depth $2 and store it in
$1. If $2 is negative the, count out from the current lexical scope;
otherwise, count up from the outermost scope.

=item B<store_global>(in STR, in PMC)

Store global $2 as global symbol $1

=item B<find_global>(out PMC, in STR)

Find the global named $2 and store it in $1

=cut

op new_pad(in INT) {
    PMC * pad;
    PMC * parent = scratchpad_get_current(interpreter);
    pad = scratchpad_new(interpreter, parent, $1);
    stack_push(interpreter, &interpreter->ctx.pad_stack, pad,
               STACK_ENTRY_PMC, STACK_CLEANUP_NULL);
    goto NEXT();
}

op new_pad(out PMC, in INT) {
    PMC * parent = scratchpad_get_current(interpreter);
    $1 = scratchpad_new(interpreter, parent, $2);
    goto NEXT();
}

op push_pad(in PMC) {
    stack_push(interpreter, &interpreter->ctx.pad_stack, $1,
               STACK_ENTRY_PMC, STACK_CLEANUP_NULL);
    goto NEXT();
}

op pop_pad() {
    stack_pop(interpreter, &interpreter->ctx.pad_stack,
              NULL, STACK_ENTRY_PMC);
    goto NEXT();
}

op peek_pad(out PMC) {
    $1 = scratchpad_get_current(interpreter);
    goto NEXT();
}

op store_lex(in STR, in PMC) {
    PMC * pad = scratchpad_get_current(interpreter);
    scratchpad_store(interpreter, pad, $1, 0, $2);
    goto NEXT();
}

op store_lex(in INT, in STR, in PMC) {
    PMC * pad = scratchpad_get_current(interpreter);
    scratchpad_store_index(interpreter, pad, $1, $2, 0, $3);
    goto NEXT();
}

op store_lex(in INT, in INT, in PMC) {
    PMC * pad = scratchpad_get_current(interpreter);
    scratchpad_store_index(interpreter, pad, $1, NULL, $2, $3);
    goto NEXT();
}

op find_lex(out PMC, in STR) {
    PMC * pad = scratchpad_get_current(interpreter);
    $1 = scratchpad_get(interpreter, pad, $2, 0);
    goto NEXT();
}

op find_lex(out PMC, in INT) {
    PMC * pad = scratchpad_get_current(interpreter);
    $1 = scratchpad_get(interpreter, pad, NULL, $2);
    goto NEXT();
}

op find_lex(out PMC, in INT, in STR) {
    PMC * pad = scratchpad_get_current(interpreter);
    $1 = scratchpad_get_index(interpreter, pad, $2, $3, 0);
    goto NEXT();
}

op find_lex(out PMC, in INT, in INT) {
    PMC * pad = scratchpad_get_current(interpreter);
    $1 = scratchpad_get_index(interpreter, pad, $2, NULL, $3);
    goto NEXT();
}

op store_global(in STR, in PMC) {
    PMC * key = key_new_string(interpreter, $1);
    PMC * globals = interpreter->perl_stash->stash_hash;
    globals->vtable->set_pmc_keyed(interpreter, globals, key, $2, NULL);
    goto NEXT();
}

op find_global(out PMC, in STR) {
    PMC * key = key_new_string(interpreter, $2);
    PMC * globals = interpreter->perl_stash->stash_hash;
    $1 = globals->vtable->get_pmc_keyed(interpreter, globals, key);
    goto NEXT();
}

=back

=cut

###############################################################################

=head2 Properties

Ops to deal with PMC properties

=over 4

=cut

########################################

=item B<setprop>(in PMC, in STR, in PMC)

Set property $2 to value $3 for PMC $1

=cut

op setprop(in PMC, in STR, in PMC) {
      $1->vtable->setprop(interpreter, $1, $2, $3);
      goto NEXT();
}

=item B<getprop>(out PMC, in STR, in PMC)

Get property $2 of PMC $3 and put it in $1

=cut

op getprop(out PMC, in STR, in PMC) {
   $1 = $3->vtable->getprop(interpreter, $3, $2);
   goto NEXT();
}

=item B<delprop>(in PMC, in STR)

Delete property $2 from PMC $1

=cut

op delprop(in PMC, in STR) {
   $1->vtable->delprop(interpreter, $1, $2);
   goto NEXT();
}

=item B<prophash>(out PMC, in PMC)

Get a hash for the properties in PMC $2 and put it in $1

=cut

op prophash(out PMC, in PMC) {
   $1 = $2->vtable->getprops(interpreter, $2);
   goto NEXT();
}

=back

=cut

###############################################################################

=head2 Miscellaneous

Opcodes which need to be sorted into better categories.

=over 4

=cut

########################################

=item B<sweep>(inconst INT)

0 ...  Trigger a DOD run only if there are things that have flagged
       themselves as really needing to be collected.
1 ...  Trigger a dead object detection (DOD) sweep unconditionally.

=cut

op sweep(inconst INT) {
  if ($1 || interpreter->has_early_DOD_PMCs)
    Parrot_do_dod_run(interpreter);
  goto NEXT();
}


=item B<collect>()

Trigger a garbage collection.

=cut

op collect() {
  Parrot_go_collect(interpreter);
  goto NEXT();
}

=item B<sweepoff>()

Disable DOD sweeps. (Nestable)

=cut

op sweepoff() {
  Parrot_block_DOD(interpreter);
  goto NEXT();
}

=item B<sweepon>()

Re-enable DOD sweeps.

=cut

op sweepon() {
  Parrot_unblock_DOD(interpreter);
  goto NEXT();
}

=item B<collectoff>()

Disable GC runs (nestable).

=cut

op collectoff() {
  Parrot_block_GC(interpreter);
  goto NEXT();
}

=item B<collecton>()

Re-enable GC.

=cut

op collecton() {
  Parrot_unblock_GC(interpreter);
  goto NEXT();
}

item B<needs_destroy>(inout PMC)

Mark the PMC wanting destruction as soon as possible, i.e.
when unused during the lazy sweep, triggered by "sweep 0".

=cut

op needs_destroy(inout PMC) {
   PObj_needs_early_DOD_SET($1);
   interpreter->has_early_DOD_PMCs = 1;
  goto NEXT();
}

########################################

=item B<interpinfo>(out INT, in INT)

Fetch some piece of information about the interpreter and put it in $1.
Possible values for $2 are:

=over 4

=item 1 The total amount of allocatable memory allocated. This figure
does not include memory used for headers or for the interpreter's internal
structures.

=item 2 The number of dead object detection runs performed.

=item 3 The number of garbage collection runs performed.

=item 4 The number of active PMCs.

=item 5 The number of active buffers.

=item 6 The total number of PMCs allocated.

=item 7 The total number of buffers allocated.

=item 8 The number of headers (PMC or buffer) that have been allocated
since the last DOD run.

=item 9 The number of new blocks of memory allocated since the last GC run.

=item 10 The total amount of memory copied during garbage collections.

=back

=cut

op interpinfo(out INT, in INT) {
  $1 = interpinfo(interpreter, $2);
  goto NEXT();
}

########################################

=item B<sysinfo>(out STR, in INT)

=item B<sysinfo>(out INT, in INT)

Return system information. The values it returns depends on what you
ask. They are:

=over 4

=item 1 The size of a platform integer

=item 2 The size of a platform float

=item 3 The size of a platform pointer. (Largest possible data pointer)

=item 4 The OS name

This is something like "OS X", "MacOS", "Windows", or "VMS".

=item 5 The OS version string

This is the current (hopefully) OS Version. For OSes that have plain
version numbers it will be the version number. For OSes that name
their versions, it will be the version name.

On HP/UX, this may be something like 11.2, while on Windows it may be
"95", "98", "2000", "NT", "ME", or "XP".

=item 6 The OS version number string

On OSes that don't name themselves, this will be the same as what's
returned in the OS version string. On OSes that I<do> name themselves,
this will be a more specific version number. In all cases it is OS
dependent.

=item 7 The CPU architecture

The name of the CPU family, such as "VAX", "Alpha", "PPC", or "x86".

=item 8 The CPU model

The model name of the current system's CPU. This is something like
"EV68", "Athlon", or "Pentium III".

=back

Note that some of these values may be set at parrot compile time,
rather than at runtime, if the system has no reliable way to fetch the
data dynamically, or if there is no way the value can change. Also,
the value returned may be somewhat misleading--Parrot running under a
VirtualPC window will report "Windows" as its OS and "x86" as its CPU,
even if it's really running on an OS X system.

=cut

inline op sysinfo(out STR, in INT) {
   $1 = sysinfo_s(interpreter, $2);
   goto NEXT();
}

inline op sysinfo(out INT, in INT) {
   $1 = sysinfo_i(interpreter, $2);
   goto NEXT();
}

########################################

=item B<stringinfo>(out INT, in STR, in INT)

Extract some information about string $2 and store it in $1.
Possible values for $3 are:

=over 4

=item 1 The location of the string buffer header.

=item 2 The location of the start of the string.

=item 3 The length of the string buffer (in bytes).

=item 4 The flags attached to the string (if any).

=item 5 The amount of the string buffer used (in bytes).

=item 6 The length of the string (in characters).

=back

=cut

inline op stringinfo(out INT, in STR, in INT) {
  switch ($3) {
    case STRINGINFO_HEADER:   $1 = PTR2UINTVAL($2);
                              break;
    case STRINGINFO_STRSTART: $1 = PTR2UINTVAL($2->strstart);
                              break;
    case STRINGINFO_BUFLEN:   $1 = $2->buflen;
                              break;
    case STRINGINFO_FLAGS:    $1 = PObj_get_FLAGS($2);
                              break;
    case STRINGINFO_BUFUSED:  $1 = $2->bufused;
                              break;
    case STRINGINFO_STRLEN:   $1 = $2->strlen;
                              break;
  }
  goto NEXT();
}


########################################

=item B<newinterp>(out PMC, in INT)

Create a new interpreter and store it in a PMC.

=cut

op newinterp(out PMC, in INT) {
  struct Parrot_Interp *new_interp;
  struct PMC *new_pmc;
  new_pmc = new_pmc_header(interpreter);
  $1 = new_pmc;
  new_interp = make_interpreter((Interp_flags)$2);
  new_interp->parent_interpreter = interpreter;
  PMC_data(new_pmc) = new_interp;
  new_pmc->vtable = YOU_LOSE_VTABLE;
  goto NEXT();
}


=item B<runinterp>(inout PMC, in INT)

Take a built interpreter and run the code starting at offset $2.

=cut

op runinterp(inout PMC, in INT) {
  struct Parrot_Interp * new_interp =
      (struct Parrot_Interp *)PMC_data($1);
  Interp_flags_SET(new_interp, PARROT_EXTERN_CODE_FLAG);
  new_interp->code = interpreter->code;
  runops(new_interp, REL_PC + $2);
  goto NEXT();
}

op enternative() {
  goto ADDRESS(( run_native(interpreter, CUR_OPCODE, interpreter->code->byte_code) ));
}

########################################

=item B<new>(out PMC, in INT)

=item B<new>(out PMC, in INT, in PMC)

Create a new PMC of class $2; look in F<core_pmcs.h> for the base
vtable types. The assembler allows you to specify PMCs by type
name as well as by integer - you should do this for compatibility,
to avoid problems if the base types get reassigned. For example:

  new P0, .PerlScalar

Optionally a PMC may be passed to the constructor. It's up to the
class, what to do with the intializer.
s. PDD02 for more.

=cut

op new(out PMC, in INT) {
  if ($2 <= 0 || $2 >= enum_class_max) {
    internal_exception(1, "Illegal PMC enum (%d) in new\n", (int)$2);
    abort(); /* Deserve to lose */
  }

  /* Why?? If we're creating a continuation, the continuation PMC
   * needs to be in the destination register before its init method
   * copies the registers. */
  $1 = pmc_new_noinit(interpreter, $2);
  $1->vtable->init(interpreter, $1);
  goto NEXT();
}

op new(out PMC, in INT, in PMC) {
  if ($2 <= 0 || $2 >= enum_class_max) {
    internal_exception(1, "Illegal PMC enum (%d) in new\n", (int)$2);
  }
  $1 = pmc_new_init(interpreter, $2, $3);
  goto NEXT();
}

=item B<typeof>(out STR, in PMC)

=item B<typeof>(out INT, in PMC)

Return the type of PMC in $2.

=cut

inline op typeof (out STR, in PMC) {
  PMC *p = $2;
  $1 = (p->vtable->name(interpreter, p));
  goto NEXT();
}

inline op typeof (out INT, in PMC) {
  PMC *p = $2;
  $1 = (p->vtable->type(interpreter, p));
  goto NEXT();
}

=item B<typeof>(out STR, in INT)

Return the (native) parrot type of datatype $2.

=cut

inline op typeof(out STR, in INT) {
    if ($2 > 0 && $2 < enum_class_max)
	$1 = Parrot_base_vtables[$2].name(interpreter, 0);
    else
	$1 = Parrot_get_datatype_name(interpreter, $2);
    goto NEXT();
}

########################################

=item B<find_type>(out INT, in STR)

Find the PMC type or parrot data type by name.

=cut

op find_type(out INT, in STR) {
    PMC * key = key_new_string(interpreter, $2);

    $1 = interpreter->Parrot_base_classname_hash->vtable->
    	get_integer_keyed(interpreter,
		interpreter->Parrot_base_classname_hash, key);
    if ($1 == enum_type_undef)
	$1 = Parrot_get_datatype_enum(interpreter, $2);
    goto NEXT();
}

=item B<valid_type>(out INT, in INT)

Check if the PMC type or parrot data type $2 is valid.

=cut

op valid_type(out INT, in INT) {
    if ($2 > 0 && $2 < enum_class_max)
        $1 = 1;
    else if ($2 >= enum_first_type && $2 < enum_last_type)
        $1 = 1;
    else
        $1 = 0;
    goto NEXT();
}

########################################

=item B<ret>()

Pop the location off the top of the call stack and go there.

=cut

inline op ret() {
  goto POP();
}


########################################

=item B<sleep>(in INT)

Sleep for $1 seconds.

=cut

inline op sleep(in INT) {
  if ($1 < 0) {
      internal_exception(NEG_SLEEP, "Cannot go back in time");
  }
  Parrot_sleep((UINTVAL)$1);
  goto NEXT();
}


#######################################

#######################################

=item B<setline>(in INT)

Set the line number for which we're currently executing code.

=cut

inline op setline(in INT) {
  interpreter->current_line = $1;
  goto NEXT();
}

=item B<getline>(out INT)

Get the current line number.

=cut

inline op getline(out INT) {
  $1 = interpreter->current_line;
  goto NEXT();
}

=item B<setfile>(in STR)

Set the name of the file for which we're currently executing code.

=cut

inline op setfile(in STR) {
  interpreter->current_file = $1;
  goto NEXT();
}

=item B<getfile>(out STR)

Get the name of the current file.

=cut

inline op getfile(out STR) {
  $1 = interpreter->current_file;
  goto NEXT();
}

=item B<setpackage>(in STR)

Set the name of the package for which we're currently executing code.

=cut

inline op setpackage(in STR) {
  interpreter->current_package = $1;
  goto NEXT();
}

=item B<getpackage>(out STR)

Get the name of the current package.

=cut

inline op getpackage(out STR) {
  $1 = interpreter->current_package;
  goto NEXT();
}

=item B<loadext>(in STR, in STR)

Load in an extension. $1 is the name of the extension library, $2 is the
initialization routine for it.

=item B<loadlib>(out PMC, in STR)

Load a dynamic link library named $2 and store it in $1.

=item B<dlfunc>(out PMC, in PMC, in STR, in STR)

Look up symbol $3 in library $2 with signature $4, and put the
corresponding sub object in $1. Note that you need the signature so we
can build or find an appropriate thunking function.

=item B<invoke>()

Call the subroutine in P0, with parrot calling convention as
described in PDD03.

=item B<invoke>(in PMC)

Call the subroutine in $1 with no defined calling convention, as
described in the PDD03 in the first chapters of DESCRIPTION.

=item B<compile>(out PMC, in PMC, in STR)

Compile source code $3 with compiler $2 into PMC $1.

=item B<compreg>(out PMC, in STR)

Get a compiler for source type $2.

=item B<compreg>(in STR, in PMC)

Register the sub $2 as a compiler for source type $1.
XXX: leo: N/Y how would we get the C-subroutine?

=item B<compreg>(in STR, in INT)

Register the PASM sub at address $2 as a compiler for source type $1.
XXX: leo N/Y

=cut

inline op loadext(in STR, in STR) {
  void * p;
  void (*func)(void);
  string_to_cstring(interpreter, ($2));
  string_to_cstring(interpreter, ($1));
  p = Parrot_dlopen($1->strstart);
  if(p == NULL) {
     const char * err = Parrot_dlerror();
     fprintf(stderr, "%s\n", err);
     PANIC("Failed to load native library");
  }
  func = D2FPTR(Parrot_dlsym(p, $2->strstart));
  if (NULL == func) {
    PANIC("Failed to find symbol in native library");
  }
  (*func)();
  goto NEXT();
}

inline op loadlib(out PMC, in STR) {
  PMC * pmc;
  void * p;
  const char * s = string_to_cstring(interpreter, ($2));
  p = Parrot_dlopen(s);
  if(p == NULL) {
     const char * err = Parrot_dlerror();
     fprintf(stderr, "%s\n", err);
     PANIC("Failed to load native library");
  }
  pmc = new_pmc_header(interpreter);
  PMC_data(pmc) = (void *)p;
  $1 = pmc;
  goto NEXT();
}

op dlfunc (out PMC, in PMC, in STR, in STR) {
  char * name = string_to_cstring(interpreter, ($3));
  PMC *nci;

  Parrot_csub_t p = (Parrot_csub_t)D2FPTR(Parrot_dlsym(PMC_data($2), name));
  free(name);
  if(p == NULL) {
     const char * err = Parrot_dlerror();
     if(err != NULL) {
         fprintf(stderr, "%s\n", err);
     }
     PANIC("Failed to link native method");
  }
  $1 = nci = pmc_new(interpreter, enum_class_NCI);
  nci->vtable->set_string_keyed(interpreter, nci, (PMC*)F2DPTR(p), $4);
  goto NEXT();
}

inline op invoke() {
  opcode_t *dest;
  PMC * p = interpreter->ctx.pmc_reg.registers[0];

  dest = (opcode_t *)p->vtable->invoke(interpreter, p, expr NEXT());

  goto ADDRESS(dest);
}

inline op invoke(in PMC) {
  opcode_t *dest;
  PMC * p = $1;

  dest = (opcode_t *)p->vtable->invoke(interpreter, p, expr NEXT());

  goto ADDRESS(dest);
}

inline op compile(OUT PMC, in PMC, in STR) {
  $1 = $2->vtable->invoke(interpreter, $2, $3);
  goto NEXT();
}

inline op compreg(OUT PMC, in STR) {
  PMC *key = key_new_string(interpreter, $2);
  $1 = interpreter->Parrot_compreg_hash->vtable->get_pmc_keyed(
    interpreter, interpreter->Parrot_compreg_hash, key);
  goto NEXT();
}

=item B<find_method>(out PMC, in PMC, in STR)

Looks up method $3 in $2's vtable, placing the corresponding method
PMC in $1.

=cut

op find_method(out PMC, in PMC, in STR) {
    $1 = $2->vtable->find_method(interpreter, $2, $3);
    goto NEXT();
}

=item B<warningson>(in INT)

Turns on warnings categories.  Categories already turned on will
stay on.  Current categories and the numbers they map to are:

=over 4

=item 1: undef

=item 2: IO

=item -1: all

=back

To turn on multiple categories, OR the category numbers together.

=cut

inline op warningson(in INT) {
  PARROT_WARNINGS_on(interpreter, $1);
  goto NEXT();
}

=item B<warningsoff>(in INT)

Turns off warnings categories.  Categories already turned off will
stay off.  See the documentation for B<warningson> for category
numbers.

=cut

inline op warningsoff(in INT) {
  PARROT_WARNINGS_off(interpreter, $1);
  goto NEXT();
}


=back

=cut

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001, 2002, 2003 Yet Another Society. All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut
