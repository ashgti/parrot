/*
** myops.ops - sample
*/

#include "parrot/dynext.h"
VERSION = PARROT_VERSION;

=head1 NAME

myops.ops - Parrot Sample Ops

=cut

=head1 DESCRIPTION

A dynamic oplib loadable at demand.

=cut

=head1 Essential ops

=over 4

=item B<fortytwo>(out INT)

The famous and ever wanted opcode, proposed by Jos Visser in
"We *need* this op! :-)".

=item B<what_do_you_get_if_you_multiply_six_by_nine>(out INT)

Alternate spelling of this op, proposed by Nicholas Clark. It might bring
imcc to its limits due the lengthy name.

=cut

inline op fortytwo(out INT) {
    $1 = 42;
    goto NEXT();
}

inline op what_do_you_get_if_you_multiply_six_by_nine(out STR) {
    $1 = string_from_cstring(interp, "fortytwo", 0);
    goto NEXT();
}

=item B<hcf>

Halt and Catch Fire. Tries to crash parrot.

=cut

op hcf() {
    int *a, i;
    a = NULL;
    i = *a;
    goto OFFSET(i) ; /* in case your runtime is very forgiving. */
}

=item B<q>

Support for writing a very short quine.

=cut

op q() {
    PIO_printf(interp, ".loadlib \"myops_ops\"\nq\n");
    HALT();
}

=item B<bxand>(out INT, in INT, in INT)

Binary operator, defined as A and B, but not BOTH.

=cut

op bxand(out INT, in INT, in INT) {
    /* short circuit boolean logic */
    $1 = 0;
    goto NEXT();
}

=item B<alarm>(in NUM, in PMC)

Call alarm handler sub $2 after $1 time has elapsed.

=item B<alarm>(in NUM, in NUM, in PMC)

Call alarm handler sub $3 after $1 time has elapsed, repeat after $2.

=cut

op alarm(in NUM, in PMC) {
     Parrot_new_timer_event(interp, NULL, $1, 0.0, 0, $2,
     EVENT_TYPE_TIMER);
    goto NEXT();
}

op alarm(in NUM, in NUM, in PMC) {
     Parrot_new_timer_event(interp, NULL, $1, $2, -1, $3,
     EVENT_TYPE_TIMER);
    goto NEXT();
}

=item B<conv_u2>(inout INT)

Conversion of a two byte unsigned int to an INT.
Formerly in dotgnu.ops. Used only in ./languages/Zcode/z3main.pir.

=item B<conv_i2>(inout INT)

Conversion of a two byte signed int to an INT.
Formerly in dotgnu.ops. Used only in ./languages/Zcode/z3main.pir.

=cut

inline op conv_u2(inout INT) :base_core {
  $1 = (INTVAL)((Parrot_UInt2)($1));
  goto NEXT();
}

inline op conv_i2(inout INT) :base_core {
  $1 = (INTVAL)((Parrot_Int2)($1));
  goto NEXT();
}


=back

=cut

# vim: sw=4

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
