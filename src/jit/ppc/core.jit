;
; ppc/core.jit
;
;
; $Id$
;

# TODO complete this
#define P_ARITH ((PREV_OP == dec_i) || (PREV_OP == inc_i) || (PREV_OP == sub_i_i_i))
Parrot_end {
    jit_emit_lwz(NATIVECODE, r1, 0, r1);
    jit_emit_lwz(NATIVECODE, r0, 8, r1);

	jit_emit_call_func(NATIVECODE, (void *)Parrot_ppc_jit_restore_nonvolatile_registers);

    jit_emit_mtlr(NATIVECODE, r0);
    jit_emit_lmw(NATIVECODE, r13, -PPC_JIT_GP_REGISTER_SAVE_SPACE, r1);

    jit_emit_blr(NATIVECODE);
}

Parrot_noop {
; preferred no-op on ppc
    jit_emit_ori(NATIVECODE, r0, r0, 0);
}

Parrot_set_i_ic {
    if (MAP[1]) {
        jit_emit_mov_ri_i(NATIVECODE, MAP[1], *INT_CONST[2]);
    }
    else {
        jit_emit_mov_ri_i(NATIVECODE, ISR1, *INT_CONST[2]);
        jit_emit_mov_mr_i(NATIVECODE, ROFFS_INT(1), ISR1); 
    }
}

Parrot_set_i_n {
    if (MAP[2]) {
	jit_emit_fctiwz  (NATIVECODE, FSR2, MAP[2]);
    }
    else {
        jit_emit_mov_rm_n(NATIVECODE, FSR1, ROFFS_NUM(2));
	jit_emit_fctiwz  (NATIVECODE, FSR2, FSR1);
    }
    if (MAP[1]) {
	jit_emit_add_rri_i(NATIVECODE, ISR1, 0, -4);
	jit_emit_stfiwx   (NATIVECODE, FSR2, ISR1, r1);   /* -> -4(sp) */
	jit_emit_lwz      (NATIVECODE, MAP[1], -4, r1);
    }
    else {
	jit_emit_add_rri_i(NATIVECODE, ISR1, 0, ROFFS_INT(1));
	jit_emit_stfiwx   (NATIVECODE, FSR2, ISR1, r13);   /* -> offs(base) */
    }
}

Parrot_set_n_ic {
    static double xx = 4503601774854144.0; /* 0x4330000080000000L; */
    jit_emit_mov_ri_i(NATIVECODE, ISR1, *INT_CONST[2]);
    jit_emit_xoris(   NATIVECODE, ISR1, ISR1, 0x8000);   
    /* use redzone for intermediate */
    jit_emit_stw(     NATIVECODE, ISR1, -4, r1);
    jit_emit_addis(   NATIVECODE, ISR1, r31, 0x4330);   
    jit_emit_stw(     NATIVECODE, ISR1, -8, r1);
    jit_emit_lfd(     NATIVECODE, FSR1, -8, r1);
    /* we should keep this magic const in a preserved eg eg. f31 */
    jit_emit_mov_ri_i(NATIVECODE, ISR2, &xx);
    jit_emit_lfd(     NATIVECODE, FSR2, 0, ISR2);
    if (MAP[1]) {
	jit_emit_fsub_rrr(NATIVECODE, MAP[1], FSR1, FSR2);
    }
    else {
	jit_emit_fsub_rrr(NATIVECODE, FSR1, FSR1, FSR2);
        jit_emit_mov_mr_n(NATIVECODE, ROFFS_NUM(1), FSR1); 
    }
}

Parrot_set_n_i {
    static double xx = 4503601774854144.0; /* 0x4330000080000000L; */
    if (MAP[2]) {
	jit_emit_xoris(   NATIVECODE, ISR1, MAP[2], 0x8000);   
    }
    else {
        jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_INT(2)); 
	jit_emit_xoris(   NATIVECODE, ISR1, ISR1, 0x8000);   
    }
    /* use redzone for intermediate */
    jit_emit_stw(     NATIVECODE, ISR1, -4, r1);
    jit_emit_addis(   NATIVECODE, ISR1, r31, 0x4330);   
    jit_emit_stw(     NATIVECODE, ISR1, -8, r1);
    jit_emit_lfd(     NATIVECODE, FSR1, -8, r1);
    /* we should keep this magic const in a preserved eg  f31 */
    jit_emit_mov_ri_i(NATIVECODE, ISR2, &xx);
    jit_emit_lfd(     NATIVECODE, FSR2, 0, ISR2);
    if (MAP[1]) {
	jit_emit_fsub_rrr(NATIVECODE, MAP[1], FSR1, FSR2);
    }
    else {
	jit_emit_fsub_rrr(NATIVECODE, FSR1, FSR1, FSR2);
        jit_emit_mov_mr_n(NATIVECODE, ROFFS_NUM(1), FSR1); 
    }
}

Parrot_null_i {
    if (MAP[1]) {
        jit_emit_mov_rr(NATIVECODE, MAP[1], r31);
    }
    else {
        jit_emit_mov_mr_i(NATIVECODE, ROFFS_INT(1), r31); 
    }
}

TEMPLATE Parrot_set_x_x {
    if (MAP[1] && MAP[2]) {
        jit_emit_mov_rr(NATIVECODE, MAP[1], MAP[2]);
    }
    else if (MAP[1]) {
        jit_emit_mov_rm_i(NATIVECODE, MAP[1], ROFFS_INT(2)); 
    } 
    else if (MAP[2]) {
        jit_emit_mov_mr_i(NATIVECODE, ROFFS_INT(1), MAP[2]); 
    }
    else {
        jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_INT(2)); 
        jit_emit_mov_mr_i(NATIVECODE, ROFFS_INT(1), ISR1); 
    }
}

Parrot_set_i_i {
    Parrot_set_x_x
}

Parrot_set_s_s {
    Parrot_set_x_x s/INT/STR/`
}

Parrot_set_p_p {
    Parrot_set_x_x s/INT/PMC/
}

Parrot_set_n_n {
    if (MAP[1] && MAP[2]) {
        jit_emit_mov_rr_n(NATIVECODE, MAP[1], MAP[2]);
    }
    else if (MAP[1]) {
	jit_emit_mov_rm_n(NATIVECODE, MAP[1], ROFFS_NUM(2));
    }
    else if (MAP[2]) {
        jit_emit_mov_mr_n(NATIVECODE, ROFFS_NUM(1), MAP[2]);
    }
    else {
	jit_emit_mov_rm_n(NATIVECODE, FSR1, ROFFS_NUM(2));
        jit_emit_mov_mr_n(NATIVECODE, ROFFS_NUM(1), FSR1);
    }
}

Parrot_set_n_nc {
    if (MAP[1]) {
        jit_emit_mov_ri_i(NATIVECODE, ISR1, &NUM_CONST[2]);
        jit_emit_lfd(NATIVECODE, MAP[1], 0, ISR1);
    }
    else {
        jit_emit_mov_ri_i(NATIVECODE, ISR1, &NUM_CONST[2]);
        jit_emit_lfd(NATIVECODE, FSR1, 0, ISR1);
        jit_emit_mov_mr_n(NATIVECODE, ROFFS_NUM(1), FSR1); 
    }
}

Parrot_neg_i_i {
    if (MAP[1] && MAP[2]) {
        jit_emit_neg_rr(NATIVECODE, MAP[1], MAP[2]);
    }
    else if (MAP[1]) {
        jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_INT(2)); 
        jit_emit_neg_rr(NATIVECODE, MAP[1], ISR1);
    }
    else if (MAP[2]) {
        jit_emit_neg_rr(NATIVECODE, ISR1, MAP[1]);
        jit_emit_mov_mr_i(NATIVECODE, ROFFS_INT(1), ISR1);
    }
    else {
        jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_INT(2));
        jit_emit_neg_rr(NATIVECODE, ISR1, ISR1);
        jit_emit_mov_mr_i(NATIVECODE, ROFFS_INT(1), ISR1);
    }
}

TEMPLATE Parrot_binop_i_ic {
    if (MAP[1]) {
        jit_emit_mov_ri_i(NATIVECODE, ISR1, *INT_CONST[2]); 
        jit_emit_<op>_rrr(NATIVECODE, MAP[1], MAP[1], ISR1);
    }
    else {
        jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_INT(1));
        jit_emit_mov_ri_i(NATIVECODE, ISR2, *INT_CONST[2]);
        jit_emit_<op>_rrr(NATIVECODE, ISR1, ISR1, ISR2);
        jit_emit_mov_mr_i(NATIVECODE, ROFFS_INT(1), ISR1);
    }
}

TEMPLATE Parrot_binop_x_x {
    if (MAP[1] && MAP[2]) {
        jit_emit_<op>_rrr(NATIVECODE, MAP[1], MAP[1], MAP[2]);
    }
    else if (MAP[1]) {
        jit_emit_mov_rm<_N>(NATIVECODE, <s1>, ROFFS_<T>(2)); 
        jit_emit_<op>_rrr(NATIVECODE, MAP[1], MAP[1], <s1>);
    }
    else if (MAP[2]) {
        jit_emit_mov_rm<_N>(NATIVECODE, <s1>, ROFFS_<T>(1));
        jit_emit_<op>_rrr(NATIVECODE, <s1>, <s1>, MAP[2]);
        jit_emit_mov_mr<_N>(NATIVECODE, ROFFS_<T>(1), <s1>);
    }
    else {
        jit_emit_mov_rm<_N>(NATIVECODE, <s1>, ROFFS_<T>(1));
        jit_emit_mov_rm<_N>(NATIVECODE, <s2>, ROFFS_<T>(2));
        jit_emit_<op>_rrr(NATIVECODE, <s1>, <s1>, <s2>);
        jit_emit_mov_mr<_N>(NATIVECODE, ROFFS_<T>(1), <s1>);
    }
}

TEMPLATE Parrot_binop_x_x_x {
    if (MAP[1] && MAP[2] && MAP[3]) {
        jit_emit_<op>_rrr(NATIVECODE, MAP[1], MAP[2], MAP[3]);
    }
    else if (MAP[1] && MAP[2]) {
        jit_emit_mov_rm<_N>(NATIVECODE, <s1>, ROFFS_<T>(3)); 
        jit_emit_<op>_rrr(NATIVECODE, MAP[1], MAP[2], <s1>);
    }
    else if (MAP[1] && MAP[3]) {
        jit_emit_mov_rm<_N>(NATIVECODE, <s1>, ROFFS_<T>(2));
        jit_emit_<op>_rrr(NATIVECODE, MAP[1], <s1>, MAP[3]);
    }
    else if (MAP[2] && MAP[3]) {
        jit_emit_<op>_rrr(NATIVECODE, <s1>, MAP[2], MAP[3]);
        jit_emit_mov_mr<_N>(NATIVECODE, ROFFS_<T>(1), <s1>);
    }
    else if (MAP[1]) {
        jit_emit_mov_rm<_N>(NATIVECODE, <s1>, ROFFS_<T>(3));
        jit_emit_mov_rm<_N>(NATIVECODE, <s2>, ROFFS_<T>(2));
        jit_emit_<op>_rrr(NATIVECODE, MAP[1], <s2>, <s1>);
    }
    else if (MAP[2]) {
        jit_emit_mov_rm<_N>(NATIVECODE, <s1>, ROFFS_<T>(3));
        jit_emit_<op>_rrr(NATIVECODE, <s1>, MAP[2], <s1>);
        jit_emit_mov_mr<_N>(NATIVECODE, ROFFS_<T>(1), <s1>);
    }
    else if (MAP[3]) {
        jit_emit_mov_rm<_N>(NATIVECODE, <s1>, ROFFS_<T>(2));
        jit_emit_<op>_rrr(NATIVECODE, <s1>, <s1>, MAP[3]);
        jit_emit_mov_mr<_N>(NATIVECODE, ROFFS_<T>(1), <s1>);
    }
    else {
        jit_emit_mov_rm<_N>(NATIVECODE, <s1>, ROFFS_<T>(3));
        jit_emit_mov_rm<_N>(NATIVECODE, <s2>, ROFFS_<T>(2));
        jit_emit_<op>_rrr(NATIVECODE, <s1>, <s2>, <s1>);
        jit_emit_mov_mr<_N>(NATIVECODE, ROFFS_<T>(1), <s1>);
    }
}

TEMPLATE Parrot_binop_i_ic_i {
    if (MAP[1] && MAP[3]) {
        jit_emit_mov_ri_i(NATIVECODE, ISR1, *INT_CONST[2]);
        jit_emit_<op>_rrr(NATIVECODE, MAP[1], ISR1, MAP[3]);
    }
    else if (MAP[1]) {
        jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_INT(3));
        jit_emit_mov_ri_i(NATIVECODE, ISR2, *INT_CONST[2]);
        jit_emit_<op>_rrr(NATIVECODE, MAP[1], ISR2, ISR1);
    }
    else if (MAP[3]) {
        jit_emit_mov_ri_i(NATIVECODE, ISR1, *INT_CONST[2]);
        jit_emit_<op>_rrr(NATIVECODE, ISR1, ISR1, MAP[3]);
        jit_emit_mov_mr_i(NATIVECODE, ROFFS_INT(1), ISR1);
    }
    else {
        jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_INT(3));
        jit_emit_mov_ri_i(NATIVECODE, ISR2, *INT_CONST[2]);
        jit_emit_<op>_rrr(NATIVECODE, ISR1, ISR2, ISR1);
        jit_emit_mov_mr_i(NATIVECODE, ROFFS_INT(1), ISR1);
    }
}

TEMPLATE Parrot_binop_i_i_ic {
    if (MAP[1] && MAP[2]) {
        jit_emit_mov_ri_i(NATIVECODE, ISR1, *INT_CONST[3]); 
        jit_emit_<op>_rrr(NATIVECODE, MAP[1], MAP[2], ISR1);
    }
    else if (MAP[1]) {
        jit_emit_mov_ri_i(NATIVECODE, ISR1, *INT_CONST[3]);
        jit_emit_mov_rm_i(NATIVECODE, ISR2, ROFFS_INT(2));
        jit_emit_<op>_rrr(NATIVECODE, MAP[1], ISR2, ISR1);
    }
    else if (MAP[2]) {
        jit_emit_mov_ri_i(NATIVECODE, ISR1, *INT_CONST[3]);
        jit_emit_<op>_rrr(NATIVECODE, ISR1, MAP[2], ISR1);
        jit_emit_mov_mr_i(NATIVECODE, ROFFS_INT(1), ISR1);
    }
    else {
        jit_emit_mov_ri_i(NATIVECODE, ISR1, *INT_CONST[3]);
        jit_emit_mov_rm_i(NATIVECODE, ISR2, ROFFS_INT(2));
        jit_emit_<op>_rrr(NATIVECODE, ISR1, ISR2, ISR1);
        jit_emit_mov_mr_i(NATIVECODE, ROFFS_INT(1), ISR1);
    }
}

Parrot_band_i_i {
    Parrot_binop_x_x s/<_N>/_i/ s/<op>/and/ s/<s1>/ISR1/ s/<s2>/ISR2/ s/<T>/INT/
}

Parrot_bor_i_i {
    Parrot_binop_x_x s/<_N>/_i/ s/<op>/or/ s/<s1>/ISR1/ s/<s2>/ISR2/ s/<T>/INT/
}

Parrot_bxor_i_i {
    Parrot_binop_x_x s/<_N>/_i/ s/<op>/xor/ s/<s1>/ISR1/ s/<s2>/ISR2/ s/<T>/INT/
}

Parrot_add_i_i {
    Parrot_binop_x_x s/<_N>/_i/ s/<op>/add/ s/<s1>/ISR1/ s/<s2>/ISR2/ s/<T>/INT/
}

Parrot_sub_i_i {
    Parrot_binop_x_x s/<_N>/_i/ s/<op>/sub/ s/<s1>/ISR1/ s/<s2>/ISR2/ s/<T>/INT/
}

Parrot_mul_i_i {
    Parrot_binop_x_x s/<_N>/_i/ s/<op>/mul/ s/<s1>/ISR1/ s/<s2>/ISR2/ s/<T>/INT/
}

parrot_div_i_i {
    parrot_binop_x_x s/<_n>/_i/ s/<op>/div/ s/<s1>/isr1/ s/<s2>/isr2/ s/<t>/int/
}

parrot_cmod_i_i {
    parrot_binop_x_x s/<_n>/_i/ s/<op>/cmod/ s/<s1>/isr1/ s/<s2>/isr2/ s/<t>/int/
}

Parrot_band_i_ic {
    Parrot_binop_i_ic s/<op>/and/
}

Parrot_bor_i_ic {
    Parrot_binop_i_ic s/<op>/or/
}

Parrot_bxor_i_ic {
    Parrot_binop_i_ic s/<op>/xor/
}

Parrot_add_i_ic {
    Parrot_binop_i_ic s/<op>/add/
}

Parrot_sub_i_ic {
    Parrot_binop_i_ic s/<op>/sub/
}

Parrot_mul_i_ic {
    Parrot_binop_i_ic s/<op>/mul/
}

Parrot_div_i_ic {
    Parrot_binop_i_ic s/<op>/div/
}

Parrot_cmod_i_ic {
    Parrot_binop_i_ic s/<op>/cmod/
}

Parrot_add_n_n {
    Parrot_binop_x_x s/<_N>/_n/ s/<op>/fadd/ s/<s1>/FSR1/ s/<s2>/FSR2/ s/<T>/NUM/
}

Parrot_div_n_n {
    Parrot_binop_x_x s/<_N>/_n/ s/<op>/fdiv/ s/<s1>/FSR1/ s/<s2>/FSR2/ s/<T>/NUM/
}

Parrot_mul_n_n {
    Parrot_binop_x_x s/<_N>/_n/ s/<op>/fmul/ s/<s1>/FSR1/ s/<s2>/FSR2/ s/<T>/NUM/
}

Parrot_sub_n_n {
    Parrot_binop_x_x s/<_N>/_n/ s/<op>/fsub/ s/<s1>/FSR1/ s/<s2>/FSR2/ s/<T>/NUM/
}

Parrot_band_i_i_i {
    Parrot_binop_x_x_x s/<_N>/_i/ s/<op>/and/ s/<s1>/ISR1/ s/<s2>/ISR2/ s/<T>/INT/
}

Parrot_bor_i_i_i {
    Parrot_binop_x_x_x s/<_N>/_i/ s/<op>/or/ s/<s1>/ISR1/ s/<s2>/ISR2/ s/<T>/INT/
}

Parrot_bxor_i_i_i {
    Parrot_binop_x_x_x s/<_N>/_i/ s/<op>/xor/ s/<s1>/ISR1/ s/<s2>/ISR2/ s/<T>/INT/
}

Parrot_add_i_i_i {
    Parrot_binop_x_x_x s/<_N>/_i/ s/<op>/add/ s/<s1>/ISR1/ s/<s2>/ISR2/ s/<T>/INT/
}

Parrot_sub_i_i_i {
    Parrot_binop_x_x_x s/<_N>/_i/ s/<op>/sub/ s/<s1>/ISR1/ s/<s2>/ISR2/ s/<T>/INT/
}

Parrot_mul_i_i_i {
    Parrot_binop_x_x_x s/<_N>/_i/ s/<op>/mul/ s/<s1>/ISR1/ s/<s2>/ISR2/ s/<T>/INT/
}

Parrot_div_i_i_i {
    Parrot_binop_x_x_x s/<_N>/_i/ s/<op>/div/ s/<s1>/ISR1/ s/<s2>/ISR2/ s/<T>/INT/
}

Parrot_cmod_i_i_i {
    Parrot_binop_x_x_x s/<_N>/_i/ s/<op>/cmod/ s/<s1>/ISR1/ s/<s2>/ISR2/ s/<T>/INT/
}

Parrot_band_i_i_ic {
    Parrot_binop_i_i_ic s/<op>/and/
}

Parrot_bor_i_i_ic {
    Parrot_binop_i_i_ic s/<op>/or/
}

Parrot_bxor_i_i_ic {
    Parrot_binop_i_i_ic s/<op>/xor/
}

Parrot_add_i_i_ic {
    Parrot_binop_i_i_ic s/<op>/add/
}

Parrot_sub_i_i_ic {
    Parrot_binop_i_i_ic s/<op>/sub/
}

Parrot_mul_i_i_ic {
    Parrot_binop_i_i_ic s/<op>/mul/
}

Parrot_div_i_i_ic {
    Parrot_binop_i_i_ic s/<op>/div/
}

Parrot_cmod_i_i_ic {
    Parrot_binop_i_i_ic s/<op>/cmod/
}

Parrot_band_i_ic_i {
    Parrot_binop_i_ic_i s/<op>/and/
}

Parrot_bor_i_ic_i {
    Parrot_binop_i_ic_i s/<op>/or/
}

Parrot_bxor_i_ic_i {
    Parrot_binop_i_ic_i s/<op>/xor/
}

Parrot_add_i_ic_i {
    Parrot_binop_i_ic_i s/<op>/add/
}

Parrot_sub_i_ic_i {
    Parrot_binop_i_ic_i s/<op>/sub/
}

Parrot_mul_i_ic_i {
    Parrot_binop_i_ic_i s/<op>/mul/
}

Parrot_div_i_ic_i {
    Parrot_binop_i_ic_i s/<op>/div/
}

Parrot_cmod_i_ic_i {
    Parrot_binop_i_ic_i s/<op>/cmod/
}

Parrot_add_n_n_n {
    Parrot_binop_x_x_x s/<_N>/_n/ s/<op>/fadd/ s/<s1>/FSR1/ s/<s2>/FSR2/ s/<T>/NUM/
}

Parrot_sub_n_n_n {
    Parrot_binop_x_x_x s/<_N>/_n/ s/<op>/fsub/ s/<s1>/FSR1/ s/<s2>/FSR2/ s/<T>/NUM/
}

Parrot_mul_n_n_n {
    Parrot_binop_x_x_x s/<_N>/_n/ s/<op>/fmul/ s/<s1>/FSR1/ s/<s2>/FSR2/ s/<T>/NUM/
}

Parrot_div_n_n_n {
    Parrot_binop_x_x_x s/<_N>/_n/ s/<op>/fdiv/ s/<s1>/FSR1/ s/<s2>/FSR2/ s/<T>/NUM/
}

Parrot_inc_i {
    if (MAP[1]) {
        jit_emit_add_rri_i (NATIVECODE, MAP[1], MAP[1], 1);
    }
    else {
        jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_INT(1)); 
        jit_emit_add_rri_i (NATIVECODE, ISR1, ISR1, 1);
        jit_emit_mov_mr_i(NATIVECODE, ROFFS_INT(1), ISR1);
    }
}

Parrot_dec_i {
    if (MAP[1]) {
        jit_emit_add_rri_i (NATIVECODE, MAP[1], MAP[1], -1);
    }
    else {
        jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_INT(1)); 
        jit_emit_add_rri_i (NATIVECODE, ISR1, ISR1, -1);
        jit_emit_mov_mr_i(NATIVECODE, ROFFS_INT(1), ISR1);
    }
}

Parrot_inc_n {
    static const double one = 1.0;
    jit_emit_mov_ri_i(NATIVECODE, ISR1, &one);
    jit_emit_lfd(NATIVECODE, FSR1, 0, ISR1);
    if (MAP[1]) {
        jit_emit_fadd_rrr(NATIVECODE, MAP[1], MAP[1], FSR1);
    }
    else {
	jit_emit_mov_rm_n(NATIVECODE, FSR2, ROFFS_NUM(1));
        jit_emit_fadd_rrr(NATIVECODE, FSR2, FSR2, FSR1);
        jit_emit_mov_mr_n(NATIVECODE, ROFFS_NUM(1), FSR2);
    }
}

Parrot_dec_n {
    static const double one = 1.0;
    jit_emit_mov_ri_i(NATIVECODE, ISR1, &one);
    jit_emit_lfd(NATIVECODE, FSR1, 0, ISR1);
    if (MAP[1]) {
        jit_emit_fsub_rrr(NATIVECODE, MAP[1], MAP[1], FSR1);
    }
    else {
	jit_emit_mov_rm_n(NATIVECODE, FSR2, ROFFS_NUM(1));
        jit_emit_fsub_rrr(NATIVECODE, FSR2, FSR2, FSR1);
        jit_emit_mov_mr_n(NATIVECODE, ROFFS_NUM(1), FSR2);
    }
}

Parrot_neg_n_n {
    if (MAP[1] && MAP[2]) {
        jit_emit_fneg_rrr(NATIVECODE, MAP[1], MAP[2]);
    }
    else if (MAP[1]) {
        jit_emit_mov_rm_n(NATIVECODE, FSR1, ROFFS_NUM(2));
        jit_emit_fneg_rrr(NATIVECODE, MAP[1], FSR1);
    }
    else if (MAP[2]) {
        jit_emit_fneg_rrr(NATIVECODE, FSR1, MAP[2]);
        jit_emit_mov_mr_n(NATIVECODE, ROFFS_NUM(1), FSR1);
    }
    else {
        jit_emit_mov_rm_n(NATIVECODE, FSR1, ROFFS_NUM(2));
        jit_emit_fneg_rrr(NATIVECODE, FSR1, FSR1);
        jit_emit_mov_mr_n(NATIVECODE, ROFFS_NUM(1), FSR1);
    }
}

TEMPLATE Parrot_unaryop_x {
    if (MAP[1]) {
        jit_emit_<op>(NATIVECODE, MAP[1], MAP[1]);
    }
    else {
        jit_emit_mov_rm<_N>(NATIVECODE, SCRATCH1, ROFFS_INT(1));
        jit_emit_<op>(NATIVECODE, SCRATCH1, SCRATCH1);
        jit_emit_mov_mr<_N>(NATIVECODE, ROFFS_INT(1), SCRATCH1);
    }
}

TEMPLATE Parrot_unaryop_i {
    Parrot_unaryop_x s/<_N>/_i/  s/SCRATCH1/ISR1/
}

TEMPLATE Parrot_unaryop_n {
    Parrot_unaryop_x s/<_N>/_n/ s/INT/NUM/ s/SCRATCH1/FSR1/
}

Parrot_neg_i {
    Parrot_unaryop_i s/<op>/neg_rr/
}

Parrot_neg_n {
    Parrot_unaryop_n s/<op>/fneg_rrr/
}

Parrot_abs_n {
    Parrot_unaryop_n s/<op>/fabs_rrr/
}

Parrot_abs_i {
    if (MAP[1]) {
        jit_emit_srawi(NATIVECODE, ISR1, MAP[1], 31);
        jit_emit_add_rrr(NATIVECODE, ISR2, ISR1, MAP[1]);
        jit_emit_xor_rrr(NATIVECODE, MAP[1], ISR2, ISR1);
    }
    else {
        jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_INT(1));
        jit_emit_srawi(NATIVECODE, ISR2, ISR1, 31);
        jit_emit_add_rrr(NATIVECODE, ISR1, ISR2, ISR1);
        jit_emit_xor_rrr(NATIVECODE, ISR1, ISR1, ISR2);
        jit_emit_mov_mr_i(NATIVECODE, ROFFS_INT(1), ISR1);
    }
}

Parrot_abs_n_n {
    if (MAP[1] && MAP[2]) {
        jit_emit_fabs_rrr(NATIVECODE, MAP[1], MAP[2]);
    }
    else if (MAP[1]) {
        jit_emit_mov_rm_n(NATIVECODE, FSR1, ROFFS_NUM(2));
        jit_emit_fabs_rrr(NATIVECODE, MAP[1], FSR1);
    }
    else if (MAP[2]) {
        jit_emit_fabs_rrr(NATIVECODE, FSR1, MAP[2]);
        jit_emit_mov_mr_n(NATIVECODE, ROFFS_NUM(1), FSR1);
    }
    else {
        jit_emit_mov_rm_n(NATIVECODE, FSR1, ROFFS_NUM(2));
        jit_emit_fabs_rrr(NATIVECODE, FSR1, FSR1);
        jit_emit_mov_mr_n(NATIVECODE, ROFFS_NUM(1), FSR1);
    }
}

TEMPLATE Parrot_ifunless_i_ic {
    if (P_ARITH && MAP[1]) {
        /* set the Rc bit of prev for the sake of +50% more MOPS  */
        NATIVECODE[-1] |= 1;
    }
    else if (MAP[1]) {
        jit_emit_cmp_ri(NATIVECODE, MAP[1], 0);
    }
    else {
        jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_INT(1));
        jit_emit_cmp_ri(NATIVECODE, ISR1, 0);
    }
    jit_emit_bc(jit_info, <COND>, *INT_CONST[2]);
}

Parrot_if_i_ic {
    Parrot_ifunless_i_ic s/<COND>/BNE/
}

Parrot_unless_i_ic {
    Parrot_ifunless_i_ic s/<COND>/BEQ/
}

TEMPLATE Parrot_ifunless_n_ic {
    static const double zero = 0.0;
    jit_emit_mov_ri_i(NATIVECODE, ISR1, &zero);
    jit_emit_lfd(NATIVECODE, FSR1, 0, ISR1);
    if (MAP[1]) {
        jit_emit_fcmp_rr(NATIVECODE, MAP[1], FSR1);
    }
    else {
	jit_emit_mov_rm_n(NATIVECODE, FSR2, ROFFS_NUM(1));
        jit_emit_fcmp_rr(NATIVECODE, FSR2, FSR1);
    }
    jit_emit_bc(jit_info, <COND>, *INT_CONST[2]);
}

Parrot_if_n_ic {
    Parrot_ifunless_n_ic s/<COND>/BNE/
}

Parrot_unless_n_ic {
    Parrot_ifunless_n_ic s/<COND>/BEQ/
}

TEMPLATE Parrot_branch_i_i_ic {
; First, emit the compare op:
    if (MAP[1] && MAP[2]) {
        jit_emit_cmp_rr(NATIVECODE, MAP[1], MAP[2]);
    }
    else if (MAP[1]) {
        jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_INT(2)); 
        jit_emit_cmp_rr(NATIVECODE, MAP[1], ISR1);
    }
    else if (MAP[2]) {
        jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_INT(1));
        jit_emit_cmp_rr(NATIVECODE, ISR1, MAP[2]);
    }
    else {
        jit_emit_mov_rm_i(NATIVECODE, ISR2, ROFFS_INT(1));
        jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_INT(2));
        jit_emit_cmp_rr(NATIVECODE, ISR2, ISR1);
    }
; Now the branch. XXX: need to handle large displacements.
    jit_emit_bc(jit_info, <CON>, *INT_CONST[3]);
}

TEMPLATE Parrot_branch_i_ic_ic {
    jit_emit_mov_ri_i(NATIVECODE, ISR1, *INT_CONST[2]);

    if (MAP[1]) {
        jit_emit_cmp_rr(NATIVECODE, MAP[1], ISR1);
    }
    else {
        jit_emit_mov_rm_i(NATIVECODE, ISR2, ROFFS_INT(1));
        jit_emit_cmp_rr(NATIVECODE, ISR2, ISR1);
    }
; Now the branch. XXX: need to handle large displacements.
    jit_emit_bc(jit_info, <CON>, *INT_CONST[3]);
   
}

TEMPLATE Parrot_branch_ic_i_ic {
    jit_emit_mov_ri_i(NATIVECODE, ISR1, *INT_CONST[1]);

    if (MAP[2]) {
        jit_emit_cmp_rr(NATIVECODE, ISR1, MAP[2]);
    }
    else {
        jit_emit_mov_rm_i(NATIVECODE, ISR2, ROFFS_INT(2));
        jit_emit_cmp_rr(NATIVECODE, ISR1, ISR2);
    }
; Now the branch. XXX: need to handle large displacements.
    jit_emit_bc(jit_info, <CON>, *INT_CONST[3]);
}

Parrot_eq_i_i_ic {
    Parrot_branch_i_i_ic s/<CON>/BEQ/
}

Parrot_eq_i_ic_ic {
    Parrot_branch_i_ic_ic s/<CON>/BEQ/
}

Parrot_eq_ic_i_ic {
    Parrot_branch_ic_i_ic s/<CON>/BEQ/
}


Parrot_lt_i_i_ic {
    Parrot_branch_i_i_ic s/<CON>/BLT/
}

Parrot_lt_i_ic_ic {
    Parrot_branch_i_ic_ic s/<CON>/BLT/
}

Parrot_lt_ic_i_ic {
    Parrot_branch_ic_i_ic s/<CON>/BLT/
}

Parrot_le_i_i_ic {
    Parrot_branch_i_i_ic s/<CON>/BLE/
}

Parrot_le_i_ic_ic {
    Parrot_branch_i_ic_ic s/<CON>/BLE/
}

Parrot_le_ic_i_ic {
    Parrot_branch_ic_i_ic s/<CON>/BLE/
}


Parrot_ne_i_i_ic {
    Parrot_branch_i_i_ic s/<CON>/BNE/
}

Parrot_ne_i_ic_ic {
    Parrot_branch_i_ic_ic s/<CON>/BNE/
}

Parrot_ne_ic_i_ic {
    Parrot_branch_ic_i_ic s/<CON>/BNE/
}


TEMPLATE Parrot_branch_n_n_ic {
    if (MAP[1] && MAP[2]) {
        jit_emit_fcmp_rr(NATIVECODE, MAP[1], MAP[2]);
    }
    else if (MAP[1]) {
        jit_emit_mov_rm_n(NATIVECODE, FSR1, ROFFS_NUM(2));
        jit_emit_fcmp_rr(NATIVECODE, MAP[1], FSR1);
    }
    else if (MAP[2]) {
        jit_emit_mov_rm_n(NATIVECODE, FSR1, ROFFS_NUM(1));
        jit_emit_fcmp_rr(NATIVECODE, FSR1, MAP[2]);
    }
    else {
        jit_emit_mov_rm_n(NATIVECODE, FSR2, ROFFS_NUM(1));
        jit_emit_mov_rm_n(NATIVECODE, FSR1, ROFFS_NUM(2));
        jit_emit_fcmp_rr(NATIVECODE, FSR2, FSR1);
    }
    jit_emit_bc(jit_info, <CON>, *INT_CONST[3]);
}

TEMPLATE Parrot_branch_n_nc_ic {
    if (MAP[1]) {
        jit_emit_mov_ri_i(NATIVECODE, ISR1, &NUM_CONST[2]);
        jit_emit_lfd(NATIVECODE, FSR1, 0, ISR1);
        jit_emit_fcmp_rr(NATIVECODE, MAP[1], FSR1);
    }
    else {
        jit_emit_mov_rm_n(NATIVECODE, FSR2, ROFFS_NUM(1));
        jit_emit_mov_ri_i(NATIVECODE, ISR1, &NUM_CONST[2]);
        jit_emit_lfd(NATIVECODE, FSR1, 0, ISR1);
        jit_emit_fcmp_rr(NATIVECODE, FSR2, FSR1);
    }
    jit_emit_bc(jit_info, <CON>, *INT_CONST[3]);
}

TEMPLATE Parrot_branch_nc_n_ic {
    if (MAP[2]) {
        jit_emit_mov_ri_i(NATIVECODE, ISR1, &NUM_CONST[1]);
        jit_emit_lfd(NATIVECODE, FSR1, 0, ISR1);
        jit_emit_fcmp_rr(NATIVECODE, FSR1, MAP[2]);
    }
    else {
        jit_emit_mov_rm_n(NATIVECODE, FSR2, ROFFS_NUM(2));
        jit_emit_mov_ri_i(NATIVECODE, ISR1, &NUM_CONST[1]);
        jit_emit_lfd(NATIVECODE, FSR1, 0, ISR1);
        jit_emit_fcmp_rr(NATIVECODE, FSR1, FSR2);
    }
    jit_emit_bc(jit_info, <CON>, *INT_CONST[3]);
}

Parrot_eq_n_n_ic {
        Parrot_branch_n_n_ic s/<CON>/BEQ/
}

Parrot_eq_n_nc_ic {
    Parrot_branch_n_nc_ic s/<CON>/BEQ/
}

Parrot_eq_nc_n_ic {
    Parrot_branch_nc_n_ic s/<CON>/BEQ/
}


Parrot_lt_n_n_ic {
    Parrot_branch_n_n_ic s/<CON>/BLT/
}

Parrot_lt_n_nc_ic {
    Parrot_branch_n_nc_ic s/<CON>/BLT/
}

Parrot_lt_nc_n_ic {
    Parrot_branch_nc_n_ic s/<CON>/BLT/
}


Parrot_le_n_n_ic {
    Parrot_branch_n_n_ic s/<CON>/BLE/
}

Parrot_le_n_nc_ic {
    Parrot_branch_n_nc_ic s/<CON>/BLE/
}

Parrot_le_nc_n_ic {
    Parrot_branch_nc_n_ic s/<CON>/BLE/
}

Parrot_ne_n_n_ic {
    Parrot_branch_n_n_ic s/<CON>/BNE/
}

Parrot_ne_n_nc_ic {
    Parrot_branch_n_nc_ic s/<CON>/BNE/
}

Parrot_ne_nc_n_ic {
    Parrot_branch_nc_n_ic s/<CON>/BLE/
}


Parrot_branch_ic {
    jit_emit_bx(jit_info, 0, *INT_CONST[1]);
}

Parrot_branch_i {
    jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_INT(1));
    jit_emit_mtlr(NATIVECODE, ISR1);
    jit_emit_blr(NATIVECODE);
}

TEMPLATE Parrot_set_or_clone_s_sc {
; string_copy(Interp *interpreter, STRING *s)
    jit_emit_mov_rr(NATIVECODE, r3, r16);
    jit_emit_mov_ri_i(NATIVECODE, r4, CONST(2)->u.string);

    jit_emit_call_func(NATIVECODE, (void*) string_copy);

    jit_emit_mov_mr_i(NATIVECODE, ROFFS_STR(1), r3);
}

Parrot_set_s_sc {
    Parrot_set_or_clone_s_sc
}

Parrot_clone_s_sc {
    Parrot_set_or_clone_s_sc
}

Parrot_set_s_s {
	jit_emit_mov_rm_i(NATIVECODE, ISR1, ROFFS_STR(2)); 
	jit_emit_mov_mr_i(NATIVECODE, ROFFS_STR(1), ISR1); 
}

Parrot_clone_s_s {
    jit_emit_mov_rr(NATIVECODE, r3, r16);
    jit_emit_mov_rm_i(NATIVECODE, r4, ROFFS_STR(2));

    jit_emit_call_func(NATIVECODE, (void*) string_copy);

    jit_emit_mov_mr_i(NATIVECODE,ROFFS_STR(1), r3);
}

Parrot_set_p_pc {
    jit_emit_mov_ri_i(NATIVECODE, ISR1, CONST(2)->u.key);
    jit_emit_mov_mr_i(NATIVECODE, ROFFS_PMC(1), ISR1); 
}

; the following 4 ops don't branch but are translated as cpfp
; which adds unneeded overhead - convert to normal ops
; or just JIT (TODO)  the 2 easy ones
Parrot_set_args_pc {
    if (jit_info->code_type == JIT_CODE_FILE) {
	jit_emit_mov_ri_i(NATIVECODE, ISR1, jit_info->cur_op);
	jit_emit_stw(NATIVECODE, ISR1, offsetof(Interp, current_args), r16);
    }
    else  {
        jit_set_args_pc(jit_info, interpreter, 
            jit_info->flags & JIT_CODE_RECURSIVE);
    }
}

extern Parrot_set_returns_pc {
    if (jit_info->code_type == JIT_CODE_FILE)
	Parrot_jit_normal_op(jit_info, interpreter);
    else {
        jit_set_returns_pc(jit_info, interpreter, 
            jit_info->flags & JIT_CODE_RECURSIVE);
    }
}

extern Parrot_returncc {
    if (jit_info->code_type == JIT_CODE_FILE)
	Parrot_jit_restart_op(jit_info, interpreter);
    else {
	/* fetch args[n+1] -> retval */
        if (!(jit_info->flags & JIT_CODE_RECURSIVE)) {
	    jit_emit_lwz(jit_info->native_ptr, r1, 0, r1);
	    jit_emit_lwz(jit_info->native_ptr, r3, 4 + jit_info->n_args * 4, r5);
	    jit_emit_lwz(jit_info->native_ptr, r31, -4, r1);
	    jit_emit_lwz(jit_info->native_ptr, r0, 8, r1);   /* get link reg */
	    jit_emit_mtlr(jit_info->native_ptr, r0);   /* move to link reg */
	}
	jit_emit_blr(jit_info->native_ptr);
    }
}

Parrot_pic_callr___pc {
    int offset, here, op_i;
    struct PackFile_Constant ** constants;
    PMC *sig_params, *sig_result;
    opcode_t *params;
    int skip;

    constants = CONTEXT(interpreter->ctx)->constants;
    params = jit_info->optimizer->sections->begin;
    sig_params = constants[params[1]]->u.key;
    op_i = 2 + SIG_ELEMS(sig_params);

    offset = jit_info->arena.op_map[op_i].offset;
    /* TODO preserve necessary regs */
    assert(*CUR_OPCODE == PARROT_OP_get_results_pc);
    constants = CONTEXT(interpreter->ctx)->constants;
    sig_result = constants[CUR_OPCODE[1]]->u.key;
    if (!SIG_ELEMS(sig_result))
	skip = -1;
    else 
	skip = MAP(2);      /* skip result - save rest */
    jit_save_regs_call(jit_info, interpreter, skip);

    here = NATIVECODE - jit_info->arena.start;
    offset -= here;
    _emit_bx(NATIVECODE, 1, offset); /* bl */

    jit_restore_regs_call(jit_info, interpreter, skip);
}

extern Parrot_get_params_pc {
    if (jit_info->code_type == JIT_CODE_FILE)
	Parrot_jit_normal_op(jit_info, interpreter);
    else if (!(jit_info->flags & JIT_CODE_RECURSIVE)) {
        jit_get_params_pc(jit_info, interpreter);
    }
}

Parrot_get_results_pc {
    if (jit_info->code_type == JIT_CODE_FILE) {
	jit_emit_mov_ri_i(NATIVECODE, ISR1, jit_info->cur_op);
	jit_emit_lwz(NATIVECODE, ISR2, offsetof(Interp, ctx.state), r16);
	jit_emit_stw(NATIVECODE, ISR1, 
		offsetof(parrot_context_t, current_results), ISR2);
    }
    else {
	struct PackFile_Constant ** constants;
	PMC *sig_result;

	constants = CONTEXT(interpreter->ctx)->constants;
	sig_result = constants[CUR_OPCODE[1]]->u.key;
	if (!SIG_ELEMS(sig_result))
	    return;
	/* result is r3 TODO Nums */
	jit_emit_mov_rr(NATIVECODE, MAP(2), r3);
    }
}
