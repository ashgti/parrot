/*
 * $Id$
 * Copyright (C) 2002-2008, Parrot Foundation.
** io.ops
*/

BEGIN_OPS_PREAMBLE
#include "../io/io_private.h"
END_OPS_PREAMBLE


=head1 NAME

io.ops - I/O Opcodes

=cut

=head1 DESCRIPTION

Parrot's IO API

=cut

###############################################################################

=head2 Parrot IO API Operations

=over 4

=cut

########################################

=item B<print>(in INT)

=item B<print>(in NUM)

=item B<print>(invar PMC)

=item B<print>(in STR)

Print $1 to standard output.

=cut

inline op print(in INT) :base_io {
    Parrot_io_printf(interp, INTVAL_FMT, (INTVAL)$1);
}

inline op print(in NUM) :base_io {
#ifdef PARROT_HAS_NEGATIVE_ZERO
    Parrot_io_printf(interp, FLOATVAL_FMT, $1);
#else
    /* Workaround for older msvcrt and openbsd. TT #313 */
    if (Parrot_is_nzero($1)) {
        Parrot_io_printf(interp, "-0");
    }
    else {
        Parrot_io_printf(interp, FLOATVAL_FMT, $1);
    }
#endif
}

op print(in STR) :base_io {
    STRING * const s = $1;
    if (s && Parrot_str_byte_length(interp, s))
        Parrot_io_putps(interp, _PIO_STDOUT(interp), s);
}

op print(invar PMC) :base_io {
    PMC * const p = $1;
    STRING * const s = (VTABLE_get_string(interp, p));
    if (s)
        Parrot_io_putps(interp, _PIO_STDOUT(interp), s);
}

=item B<say>(in INT)

=item B<say>(in NUM)

=item B<say>(invar PMC)

=item B<say>(in STR)

Print $1 to standard output with a trailing newline.

=cut

inline op say(in INT) :base_io {
    Parrot_io_printf(interp, INTVAL_FMT "\n", (INTVAL)$1);
}

inline op say(in NUM) :base_io {
#ifdef PARROT_HAS_NEGATIVE_ZERO
    Parrot_io_printf(interp, FLOATVAL_FMT "\n", $1);
#else
    /* Workaround for older msvcrt and openbsd. TT #313 */
    if (Parrot_is_nzero($1)) {
        Parrot_io_printf(interp, "-0\n");
    }
    else {
        Parrot_io_printf(interp, FLOATVAL_FMT "\n", $1);
    }
#endif
}

op say(in STR) :base_io {
    STRING * const s = $1;
    if (s && Parrot_str_byte_length(interp, s))
        Parrot_io_putps(interp, _PIO_STDOUT(interp), s);
    Parrot_io_putps(interp, _PIO_STDOUT(interp), Parrot_str_new_constant(interp, "\n"));
}

op say(invar PMC) :base_io {
    PMC * const p = $1;

    if (PMC_IS_NULL(p)) {
        opcode_t *handler = Parrot_ex_throw_from_op_args(interp, expr NEXT(),
             EXCEPTION_UNEXPECTED_NULL,
            "Null PMC in say");
        goto ADDRESS(handler);
    }
    else {
        STRING * const s = VTABLE_get_string(interp, p);
        if (s)
            Parrot_io_putps(interp, _PIO_STDOUT(interp), s);
        Parrot_io_putps(interp, _PIO_STDOUT(interp), Parrot_str_new_constant(interp, "\n"));
    }
}




##########################################

=item B<printerr>(in INT)

=item B<printerr>(in NUM)

=item B<printerr>(in STR)

=item B<printerr>(invar PMC)

Print $1 to standard error.

=cut

op printerr(in INT) :base_io {
    Parrot_io_eprintf(interp, INTVAL_FMT, $1);
}

op printerr(in NUM) :base_io {
    Parrot_io_eprintf(interp, FLOATVAL_FMT, $1);
}

op printerr(in STR) :base_io {
    STRING * const s = $1;
    if (s && Parrot_str_byte_length(interp, s))
        Parrot_io_putps(interp, _PIO_STDERR(interp), s);
}

op printerr(invar PMC) :base_io {
    PMC * const p = $1;
    STRING * const s = (VTABLE_get_string(interp, p));
    if (s)
        Parrot_io_putps(interp, _PIO_STDERR(interp), s);
}

##########################################

=item B<print>(invar PMC, in INT)

=item B<print>(invar PMC, in NUM)

=item B<print>(invar PMC, in STR)

=item B<print>(invar PMC, invar PMC)

Print $2 on the IO stream object $1.

=cut

op print(invar PMC, in INT) :base_io {
    if ($1) {
        STRING * const s = Parrot_str_from_int(interp, $2);
        Parrot_io_putps(interp, $1, s);
    }
}

op print(invar PMC, in NUM) :base_io {
    if ($1) {
        STRING * const s = Parrot_sprintf_c(interp, FLOATVAL_FMT, $2);
        Parrot_io_putps(interp, $1, s);
    }
}

op print(invar PMC, in STR) :base_io {
    if ($2 && $1) {
        Parrot_io_putps(interp, $1, $2);
    }
}

op print(invar PMC, invar PMC) :base_io {
    if ($2 && $1) {
        STRING * const s = VTABLE_get_string(interp, $2);
        Parrot_io_putps(interp, $1, s);
    }
}

##########################################

=item B<read>(out STR, in INT)

Read up to N bytes from standard input stream

=item B<read>(out STR, invar PMC, in INT)

Read up to N bytes from IO PMC stream.

=cut

op read(out STR, in INT) :base_io {
    $1 = Parrot_io_reads(interp, _PIO_STDIN(interp), (size_t)$2);
}

op read(out STR, invar PMC, in INT) :base_io {
    $1 = Parrot_io_reads(interp, $2, (size_t)$3);
}

=item B<readline>(out STR, invar PMC)

Read a line up to EOL from filehandle $2.
This switches the filehandle to linebuffer-mode.

=cut

inline op readline(out STR, invar PMC) :base_io {
    $1 = Parrot_io_readline(interp, $2);
}

##########################################

=item B<stat>(out INT, in STR, in INT)

=item B<stat>(out INT, in INT, in INT)

Stat the file. Return stat element $3 for file $2 into $1. The queryable
items currently are:

 EXISTS     0
 FILESIZE   1
 ISDIR      2
 ISDEV      3
 CREATETIME 4 (Time file was created)
 ACCESSTIME 5 (Time file was last accessed)
 MODIFYTIME 6 (Time file data was changed)
 CHANGETIME 7 (Time file metadata was changed)
 BACKUPTIME 8 (Time of last backup)
 UID        9
 GID        10


=cut

op stat(out INT, in STR, in INT) {
    $1 = Parrot_stat_info_intval(interp, $2, $3);
}

op stat(out INT, in INT, in INT) {
    $1 = Parrot_fstat_info_intval(interp, $2, $3);
}

###############################################################################

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
