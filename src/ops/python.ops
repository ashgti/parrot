/*
** python.ops
*/

/* XXX in io/io.c */
int PIO_softspace(theINTERP, PMC *pmc, int new);

VERSION = PARROT_VERSION;

=head1 NAME

python.ops - Python Operations

=cut

=head1 DESCRIPTION

Currently included in main - will be split.

=cut

###############################################################################

=head2 IO operations

=over 4

=cut

########################################

=item B<print_item>(in INT)

=item B<print_item>(in NUM)

=item B<print_item>(in PMC)

=item B<print_item>(in STR)

Print $1 to standard output. If another C<print_item> follows, a
space is inserted.

=item B<print_newline>()

Print a newline char to standard output.

=cut

inline op print_item(in INT) :base_io {
  PMC * const io = PIO_STDOUT(interpreter);
  if (PIO_softspace(interpreter, io, 0))
    PIO_puts(interpreter, io, " ");
  PIO_printf(interpreter, INTVAL_FMT, (INTVAL)$1);
  PIO_softspace(interpreter, io, 1);
  goto NEXT();
}

inline op print_item(in NUM) :base_io {
  PMC * const io = PIO_STDOUT(interpreter);
  STRING *s;
  if (PIO_softspace(interpreter, io, 0))
    PIO_puts(interpreter, io, " ");
  s = Parrot_sprintf_c(interpreter, "%.12g", (double)$1);
  PIO_putps(interpreter, io, s);
  if (string_str_index(interpreter, s,
	const_string(interpreter, "."), 0) == -1 &&
      string_str_index(interpreter, s,
	const_string(interpreter, "e"), 0) == -1)
    PIO_puts(interpreter, io, ".0");
  PIO_softspace(interpreter, io, 1);
  goto NEXT();
}

op print_item(in STR) :base_io {
  STRING * const s = $1;
  PMC * const io = PIO_STDOUT(interpreter);
  if (s && string_length(interpreter, s)) {
    if (PIO_softspace(interpreter, io, 0))
      PIO_puts(interpreter, io, " ");
    PIO_putps(interpreter, PIO_STDOUT(interpreter), s);
    PIO_softspace(interpreter, io, 1);
  }
  goto NEXT();
}

op print_item(in PMC) :base_io {
  PMC * const p = $1;
  PMC * const io = PIO_STDOUT(interpreter);
  STRING * const s = (VTABLE_get_string(interpreter, p));
  if (s) {
    if (PIO_softspace(interpreter, io, 0))
      PIO_puts(interpreter, io, " ");
    PIO_putps(interpreter, PIO_STDOUT(interpreter), s);
    PIO_softspace(interpreter, io, 1);
  }
  goto NEXT();
}

op print_newline() :base_io {
  PMC * const io = PIO_STDOUT(interpreter);
  PIO_puts(interpreter, io, "\n");
  PIO_softspace(interpreter, io, 0);
  goto NEXT();
}

=item B<print_item>(in PMC, in INT)

=item B<print_item>(in PMC, in NUM)

=item B<print_item>(in PMC, in PMC)

=item B<print_item>(in PMC, in STR)

Print $2 to IO stream object $1. If another C<print_item> follows, a
space is inserted.

=item B<print_newline>(in PMC)

Print a newline char to IO stream object $1.

=cut

inline op print_item(in PMC, in INT) :base_io {
  PMC * const io = $1;
  if (PIO_softspace(interpreter, io, 0))
    PIO_puts(interpreter, io, " ");
  PIO_fprintf(interpreter, io, INTVAL_FMT, (INTVAL)$2);
  PIO_softspace(interpreter, io, 1);
  goto NEXT();
}

inline op print_item(in PMC, in NUM) :base_io {
  PMC * const io = $1;
  STRING *s;
  if (PIO_softspace(interpreter, io, 0))
    PIO_puts(interpreter, io, " ");
  s = Parrot_sprintf_c(interpreter, "%.12g", (double)$2);
  PIO_putps(interpreter, io, s);
  if (string_str_index(interpreter, s,
	const_string(interpreter, "."), 0) == -1 &&
      string_str_index(interpreter, s,
	const_string(interpreter, "e"), 0) == -1)
    PIO_puts(interpreter, io, ".0");
  PIO_softspace(interpreter, io, 1);
  goto NEXT();
}

op print_item(in PMC, in STR) :base_io {
  STRING * const s = $2;
  PMC * const io = $1; /* TODO Can this be localized? */
  if (s && string_length(interpreter, s)) {
    if (PIO_softspace(interpreter, io, 0))
      PIO_puts(interpreter, io, " ");
    PIO_putps(interpreter, io, s);
    PIO_softspace(interpreter, io, 1);
  }
  goto NEXT();
}

op print_item(in PMC, in PMC) :base_io {
  PMC * const p = $2;
  PMC * const io = $1; /* TODO Can this be localized? */
  STRING *s = (VTABLE_get_string(interpreter, p));
  if (s) {
    if (PIO_softspace(interpreter, io, 0))
      PIO_puts(interpreter, io, " ");
    PIO_putps(interpreter, io, s);
    PIO_softspace(interpreter, io, 1);
  }
  goto NEXT();
}

op print_newline(in PMC) :base_io {
  PMC * const io = $1;
  PIO_puts(interpreter, io, "\n");
  PIO_softspace(interpreter, io, 0);
  goto NEXT();
}

########################################

=back

=cut


###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001-2006, The Perl Foundation.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut

