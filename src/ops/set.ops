/*
** set.ops
*/

VERSION = PARROT_VERSION;

=head1 NAME

set.ops - Register Loading Ops

=head1 DESCRIPTION

These operations all set registers to various values.

=over 4

=cut

########################################

=item B<clone>(out STR, in STR)

Make a clone of $2, and put it in $1. Doesn't affect what was in
$1. Removes the constant flag on the copy, if there was one.

=cut

inline op clone(out STR, in STR) :base_mem {
  $1 = string_copy(interpreter, $2);
  goto NEXT();
}



########################################

=item B<exchange>(inout INT, inout INT)

=item B<exchange>(inout NUM, inout NUM)

=item B<exchange>(inout PMC, inout PMC)

=item B<exchange>(inout STR, inout STR)

Exchange the contents of registers $1 and $2

=cut

op exchange(inout INT, inout INT) :base_core {
   const INTVAL temp = $1;
   $1 = $2;
   $2 = temp;
   goto NEXT();
}

op exchange(inout PMC, inout PMC) :base_core {
   PMC * const temp = $1;
   $1 = $2;
   $2 = temp;
   goto NEXT();
}

op exchange(inout NUM, inout NUM) :base_core {
   FLOATVAL temp = $1;
   $1 = $2;
   $2 = temp;
   goto NEXT();
}

op exchange(inout STR, inout STR) :base_core {
   STRING * const temp = $1;
   $1 = $2;
   $2 = temp;
   goto NEXT();
}

########################################

=item B<set>(out INT, in INT)

=item B<set>(out INT, in NUM)

=item B<set>(out INT, in PMC)

=item B<set>(out INT, in PMC)

=item B<set>(out INT, in STR)

=item B<set>(out NUM, in INT)

=item B<set>(out NUM, in NUM)

=item B<set>(out NUM, in PMC)

=item B<set>(out NUM, in STR)

=item B<set>(in PMC, in INT)

=item B<set>(in PMC, in NUM)

=item B<set>(out PMC, in PMC)

=item B<set>(in PMC, invar STR)

=item B<set>(out STR, in INT)

=item B<set>(out STR, in NUM)

=item B<set>(out STR, in PMC)

=item B<set>(out STR, inconst STR)

=item B<set>(out STR, invar STR)

=item B<set>(out PMC, inconst PMC)

=item B<set>(in PMC, inconst STR)

Set $1 to $2.

=cut

inline op set(out INT, in INT) :base_core {
  $1 = $2;
  goto NEXT();
}

inline op set(out INT, in NUM) :base_core {
  $1 = (INTVAL)($2);
  goto NEXT();
}

inline op set(out INT, in STR) :base_core {
  $1 = string_to_int(interpreter, $2);
  goto NEXT();
}

inline op set(out NUM, in NUM) :base_core {
  $1 = $2;
  goto NEXT();
}

inline op set(out NUM, in INT) :base_core {
  $1 = (FLOATVAL)$2;
  goto NEXT();
}

inline op set(out NUM, in STR) :base_core {
  $1 = string_to_num(interpreter, $2);
  goto NEXT();
}

inline op set(out NUM, in PMC) :base_core {
  $1 = $2->vtable->get_number(interpreter, $2);
  goto NEXT();
}

inline op set(out STR, in PMC) :base_core {
  $1 = $2->vtable->get_string(interpreter, $2);
  goto NEXT();
}

inline op set(out STR, invar STR) :base_core {
  $1 = $2;
  goto NEXT();
}

inline op set(out STR, inconst STR) :base_core {
  $1 = string_copy(interpreter, $2);
  goto NEXT();
}

inline op set(out STR, in INT) :base_core {
  $1 = string_from_int(interpreter, $2);
  goto NEXT();
}

inline op set(out STR, in NUM) :base_core {
  $1 = string_from_num(interpreter, $2);
  goto NEXT();
}

inline op set(out PMC, inconst PMC) :base_core {
  $1 = $2;
  goto NEXT();
}

inline op set(out PMC, in PMC) :base_core {
  $1 = $2;
  goto NEXT();
}

inline op set(in PMC, in INT) :base_core {
  $1->vtable->set_integer_native(interpreter, $1, $2);
  goto NEXT();
}

inline op set(in PMC, in NUM) :base_core {
  $1->vtable->set_number_native(interpreter, $1, $2);
  goto NEXT();
}

inline op set(in PMC, invar STR) :base_core {
  $1->vtable->set_string_native(interpreter, $1, $2);
  goto NEXT();
}

inline op set(in PMC, inconst STR) :base_core {
  $1->vtable->set_string_native(interpreter, $1,
    string_copy(interpreter, $2));
  goto NEXT();
}
inline op set(out INT, in PMC) :base_core {
  $1 = $2->vtable->get_integer(interpreter, $2);
  goto NEXT();
}

=back

=cut

########################################

=head2 PMC assignment operations: Px = x

=over 4

=item B<assign>(in PMC, in INT)

=item B<assign>(in PMC, in NUM)

Assign a new value $2, to PMC $1. Same as the equivalent B<set> opcodes.

=item B<assign>(in PMC, in STR)

=item B<assign>(in PMC, in PMC)

Assign a new value $2, to PMC $1 by copying the value.

=item B<assign>(out STR, in STR)

Assign a new value to a string by reusing the string header.

=item B<setref>(in PMC, in PMC)

Make $1 refer to $2 by calling C<set_pmc>.

=item B<deref>(out PMC, in PMC)

Not strictly an assignment operation: Put into $1 the PMC that the
reference PMC $2 refers to.

=cut

inline op assign(in PMC, in PMC) :base_core {
  $1->vtable->assign_pmc(interpreter, $1, $2);
  goto NEXT();
}

inline op assign(in PMC, in INT) :base_core {
  $1->vtable->set_integer_native(interpreter, $1, $2);
  goto NEXT();
}

inline op assign(in PMC, in NUM) :base_core {
  $1->vtable->set_number_native(interpreter, $1, $2);
  goto NEXT();
}

inline op assign(in PMC, in STR) :base_core {
  $1->vtable->assign_string_native(interpreter, $1, $2);
  goto NEXT();
}

inline op assign(out STR, in STR) :base_core {
  $1 = string_set(interpreter, $1, $2);
  goto NEXT();
}

inline op setref(in PMC, in PMC) :base_core {
  $1->vtable->set_pmc(interpreter, $1, $2);
  goto NEXT();
}

inline op deref(out PMC, in PMC) :base_ref {
  $1 = $2->vtable->get_pmc(interpreter, $2);
  goto NEXT();
}

=back

=head2 Indirect PMC register set

=over 4

=item B<setp_ind>(in INT, in PMC)

Set the PMC in register $1 to $2.
Please note, that the register allocator doesn't track the usage of the
affected register - handle with care.

=cut

inline op setp_ind(in INT, in PMC) :base_ref {
    if ($1 < 0 || $1 >= NUM_REGISTERS)
        PANIC("Out of bound register access");
    REG_PMC($1) = $2;
    goto NEXT();
}

=item B<setn_ind>(in INT, in NUM)

Set the number in register $1 to $2.
Please note, that the register allocator doesn't track the usage of the
affected register - handle with care.

=cut

inline op setn_ind(in INT, in NUM) :base_ref {
    if ($1 < 0 || $1 >= NUM_REGISTERS)
        PANIC("Out of bound register access");
    REG_NUM($1) = $2;
    goto NEXT();
}

=item B<sets_ind>(in INT, in STR)

Set the string in register $1 to $2.
Please note, that the register allocator doesn't track the usage of the
affected register - handle with care.

=cut

inline op sets_ind(in INT, in STR) :base_ref {
    if ($1 < 0 || $1 >= NUM_REGISTERS)
        PANIC("Out of bound register access");
    REG_STR($1) = $2;
    goto NEXT();
}

=item B<seti_ind>(in INT, in INT)

Set the int in register $1 to $2.
Please note, that the register allocator doesn't track the usage of the
affected register - handle with care.

=cut

inline op seti_ind(in INT, in INT) :base_ref {
    if ($1 < 0 || $1 >= NUM_REGISTERS)
        PANIC("Out of bound register access");
    REG_INT($1) = $2;
    goto NEXT();
}

=back

=cut

########################################

=head2 Keyed set operations: Px[ INTKEY ] = Bx

=over 4

=item B<set>(in PMC, in INTKEY, in INT)

=item B<set>(in PMC, in INTKEY, in NUM)

=item B<set>(in PMC, in INTKEY, in STR)

=item B<set>(in PMC, in INTKEY, in PMC)

=cut

inline op set (in PMC, in INTKEY, in INT) :base_core {
    $1->vtable->set_integer_keyed_int(interpreter, $1, $2, $3);
    goto NEXT();
}

inline op set (in PMC, in INTKEY, in NUM) :base_core {
    $1->vtable->set_number_keyed_int(interpreter, $1, $2, $3);
    goto NEXT();
}

inline op set (in PMC, in INTKEY, in STR) :base_core {
    $1->vtable->set_string_keyed_int(interpreter, $1, $2, $3);
    goto NEXT();
}

inline op set (in PMC, in INTKEY, in PMC) :base_core {
    $1->vtable->set_pmc_keyed_int(interpreter, $1, $2, $3);
    goto NEXT();
}

=back

=cut

########################################

=head2 Keyed get operations: Ax = Px[ INTKEY ]

=over 4

=item B<set>(out INT, in PMC, in INTKEY)

=item B<set>(out NUM, in PMC, in INTKEY)

=item B<set>(out STR, in PMC, in INTKEY)

=item B<set>(out PMC, in PMC, in INTKEY)

=cut

inline op set (out INT, in PMC, in INTKEY) :base_core {
    $1 = $2->vtable->get_integer_keyed_int(interpreter, $2, $3);
    goto NEXT();
}

inline op set (out NUM, in PMC, in INTKEY) :base_core {
    $1 = $2->vtable->get_number_keyed_int(interpreter, $2, $3);
    goto NEXT();
}

inline op set (out STR, in PMC, in INTKEY) :base_core {
    $1 = $2->vtable->get_string_keyed_int(interpreter, $2, $3);
    goto NEXT();
}

inline op set (out PMC, in PMC, in INTKEY) :base_core {
    $1 = $2->vtable->get_pmc_keyed_int(interpreter, $2, $3);
    goto NEXT();
}

=back

=cut

########################################

=head2 Keyed set operations: Px[ KEY ] = Bx

=over 4

=item B<set>(in PMC, in KEY, in INT)

=item B<set>(in PMC, in KEY, in NUM)

=item B<set>(in PMC, in KEY, in STR)

=item B<set>(in PMC, in KEY, in PMC)

=cut

inline op set (in PMC, in KEY, in INT) :base_core {
    $1->vtable->set_integer_keyed(interpreter, $1, $2, $3);
    goto NEXT();
}

inline op set (in PMC, in KEY, in NUM) :base_core {
    $1->vtable->set_number_keyed(interpreter, $1, $2, $3);
    goto NEXT();
}

inline op set (in PMC, in KEY, in STR) :base_core {
    $1->vtable->set_string_keyed(interpreter, $1, $2, $3);
    goto NEXT();
}

inline op set (in PMC, in KEY, in PMC) :base_core {
    $1->vtable->set_pmc_keyed(interpreter, $1, $2, $3);
    goto NEXT();
}

=back

=cut

########################################

=head2 Keyed get operations: Ax = Px[ KEY ]

=over 4

=item B<set>(out INT, in PMC, in KEY)

=item B<set>(out NUM, in PMC, in KEY)

=item B<set>(out STR, in PMC, in KEY)

=item B<set>(out PMC, in PMC, in KEY)

=cut

inline op set (out INT, in PMC, in KEY) :base_core {
    $1 = $2->vtable->get_integer_keyed(interpreter, $2, $3);
    goto NEXT();
}

inline op set (out NUM, in PMC, in KEY) :base_core {
    $1 = $2->vtable->get_number_keyed(interpreter, $2, $3);
    goto NEXT();
}

inline op set (out STR, in PMC, in KEY) :base_core {
    $1 = $2->vtable->get_string_keyed(interpreter, $2, $3);
    goto NEXT();
}

inline op set (out PMC, in PMC, in KEY) :base_core {
    $1 = $2->vtable->get_pmc_keyed(interpreter, $2, $3);
    goto NEXT();
}


=item B<clone>(out PMC, in PMC)

Makes a copy of the PMC in $2 and puts it in $1.

=cut

inline op clone(out PMC, in PMC) :base_mem {
  $1 = VTABLE_clone(interpreter, $2);
  goto NEXT();
}

=back

=cut

###############################################################################

=head2 Register operations

These operations effect entire sets of registers.

=over 4

=cut

########################################

=item B<null>(out STR)

=item B<null>(out INT)

=item B<null>(out PMC)

=item B<null>(out NUM)

Set register $1 to a null value, or zero for the numeric registers

=cut

inline op null(out STR) :base_core {
  $1 = NULL;
  goto NEXT();
}

inline op null(out INT) :base_core {
  $1 = 0;
  goto NEXT();
}

inline op null(out PMC) :base_core {
  $1 = PMCNULL;
  goto NEXT();
}

inline op null(out NUM) :base_core {
  $1 = 0;
  goto NEXT();
}

########################################

=item B<cleari>()

=item B<clearn>()

=item B<clearp>()

=item B<clears>()

Clear all the registers of the type indicated in the name of the operation.

INTVAL ('i') and FLOATVAL ('n') registers clear to zero.

PMC ('p') and STRING ('s') registers clear to NULL.

=cut

inline op cleari() :base_core {
  Parrot_clear_i(interpreter);
  goto NEXT();
}

inline op clearn() :base_core {
  Parrot_clear_n(interpreter);
  goto NEXT();
}

inline op clears() :base_core {
  Parrot_clear_s(interpreter);
  goto NEXT();
}

inline op clearp() :base_core {
  Parrot_clear_p(interpreter);
  goto NEXT();
}

=back

=cut

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001-2006, The Perl Foundation.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut
