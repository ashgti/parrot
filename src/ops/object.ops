/*
** object.ops
*/


VERSION = PARROT_VERSION;

=head1 NAME

object.ops

=head1 DESCRIPTION

Parrot's library of object ops

=over 4

=cut

=item B<callmethodcc>(invar PMC, in STR)

Call method $2 with invocant $1 and generate a new return continuation.
The invocant ($1) is used for method lookup. The object is passed as
the first argument in B<set_args>.

Throws a Method_Not_Found_Exception for a non-existent method.

=item B<callmethodcc>(invar PMC, invar PMC)

Like above but use the Sub object $2 as method.

=item B<callmethod>(invar PMC, in STR, invar PMC)

=item B<callmethod>(invar PMC, invar PMC, invar PMC)

Like above, but use continuation $3 instead of creating a new continuation.

=cut

=item B<tailcallmethod>(invar PMC, in STR)

=item B<tailcallmethod>(invar PMC, invar PMC)

Make a tailcall to method $2 with invocant $1.

=cut

op callmethodcc(invar PMC, in STR) :object_base {
  opcode_t *dest;
  PMC *method_pmc, *object;
  opcode_t *next;
  STRING *meth;

  object = $1;
  meth = $2;
  next = expr NEXT();
  method_pmc = VTABLE_find_method(interp, object, meth);
  if (!method_pmc) {
    real_exception(interp, next, METH_NOT_FOUND,
        "Method '%Ss' not found", meth);
  }
  interp->current_object = object;
  interp->current_cont = NEED_CONTINUATION;
  dest = VTABLE_invoke(interp, method_pmc, next);
  goto ADDRESS(dest);
}

op callmethodcc(invar PMC, invar PMC) :object_base {
  opcode_t *dest;
  PMC *method_pmc, *object;
  opcode_t *next;

  object = $1;
  method_pmc = $2;
  /* RT#42371 should we check if object.can(method) */

  next = expr NEXT();
  interp->current_object = object;
  interp->current_cont = NEED_CONTINUATION;
  dest = VTABLE_invoke(interp, method_pmc, next);
  goto ADDRESS(dest);
}

op callmethod(invar PMC, in STR, invar PMC) :object_base {
  opcode_t *dest;
  PMC *method_pmc, *object;
  opcode_t *next;
  STRING *meth;

  object = $1;
  meth = $2;
  next = expr NEXT();
  method_pmc = VTABLE_find_method(interp, object, meth);
  if (!method_pmc) {
    real_exception(interp, next, METH_NOT_FOUND,
        "Method '%Ss' not found", meth);
  }
  interp->current_object = object;
  interp->current_cont = $3;
  dest = (opcode_t *)VTABLE_invoke(interp, method_pmc, next);
  goto ADDRESS(dest);
}

op callmethod(invar PMC, invar PMC, invar PMC) :object_base {
  opcode_t *dest;
  PMC *method_pmc, *object;
  opcode_t *next;

  object = $1;
  method_pmc = $2;

  next = expr NEXT();
  interp->current_object = object;
  interp->current_cont = $3;
  dest = (opcode_t *)VTABLE_invoke(interp, method_pmc, next);
  goto ADDRESS(dest);
}

op tailcallmethod(invar PMC, in STR) :object_base {
  opcode_t *dest;
  PMC *method_pmc, *object;
  opcode_t *next = expr NEXT();
  STRING *meth;

  object = $1;
  meth = $2;
  method_pmc = VTABLE_find_method(interp, object, meth);
  if (!method_pmc) {
    real_exception(interp, next, METH_NOT_FOUND,
        "Method '%Ss' not found", meth);
  }
  interp->current_cont = CONTEXT(interp->ctx)->current_cont;
  PObj_get_FLAGS(interp->current_cont) |= SUB_FLAG_TAILCALL;
  interp->current_object = object;
  dest = (opcode_t *)VTABLE_invoke(interp, method_pmc, next);
  goto ADDRESS(dest);
}

op tailcallmethod(invar PMC, invar PMC) :object_base {
  opcode_t *dest;
  PMC *method_pmc, *object;
  opcode_t *next = expr NEXT();

  object = $1;
  method_pmc = $2;
  interp->current_cont = CONTEXT(interp->ctx)->current_cont;
  PObj_get_FLAGS(interp->current_cont) |= SUB_FLAG_TAILCALL;
  interp->current_object = object;
  dest = (opcode_t *)VTABLE_invoke(interp, method_pmc, next);
  goto ADDRESS(dest);
}

=item B<addmethod>(invar PMC, in STR, invar PMC)

Adds $3 as a method named $2 to $1.

=cut

inline op addmethod(invar PMC, in STR, invar PMC) :object_classes {
  VTABLE_add_method(interp, $1, $2, $3);
  goto NEXT();
}

=item B<can>(out INT, invar PMC, in STR)

Sets $1 to true or false, depending on whether $2 ->can the method in $3.

=cut

inline op can(out INT, invar PMC, in STR) :object_base {
  $1 = $2->vtable->can(interp, $2, $3);
  goto NEXT();
}

=item B<does>(out INT, invar PMC, in STR)

Sets $1 to true or false, depending on whether $2 ->does the interface in $3.

See L<tools/build/pmc2c.pl> for a list of available interfaces.

=item B<isa>(out INT, invar PMC, in STR)

=item B<isa>(out INT, invar PMC, in PMC)

Sets $1 to true or false, depending on whether $2 isa $3.

=cut

inline op does(out INT, invar PMC, in STR) :object_base {
  $1 = $2->vtable->does(interp, $2, $3);
  goto NEXT();
}

inline op isa(out INT, invar PMC, in STR) :object_base {
  $1 = $2->vtable->isa(interp, $2, $3);
  goto NEXT();
}

inline op isa(out INT, invar PMC, in PMC) :object_base {
    PMC *_class = Parrot_class_lookup_p(interp, $3);
    $1 = Parrot_object_isa(interp, $2, _class);
    goto NEXT();
}

###############################################################################

=item B<newclass>(out PMC, in STR)

Creates a new Parrot-style class, named $2, and puts the new PMC for it
into $1.

=item B<newclass>(out PMC, in PMC)

Create a new Parrot-style class, with the hierarchical name given in $2.

=cut

inline op newclass(out PMC, in STR) :object_classes {
  PMC *name = pmc_new(interp, enum_class_String);
  VTABLE_set_string_native(interp, name, $2);
  $1 = pmc_new_init(interp, enum_class_ParrotClass, name);
  goto NEXT();
}

inline op newclass(out PMC, in PMC) :object_classes {
    $1 = pmc_new_init(interp, enum_class_ParrotClass, $2);
    goto NEXT();
}

=item B<subclass>(out PMC, invar PMC)

=item B<subclass>(out PMC, invar PMC, in STR)

=item B<subclass>(out PMC, invar PMC, in PMC)

RT#42372 KLUDGE ALERT - OPCODE NAME SHOULD DIFFER FROM BELOW

Create a new class, put in $1, that is a subclass of $2.  $3, if available
and not null, is the name of the new class--if not, the subclass is an
anonymous subclass.

=cut

inline op subclass(out PMC, invar PMC) :object_classes {
  $1 = VTABLE_subclass(interp, $2, PMCNULL);
  goto NEXT();
}

inline op subclass(out PMC, invar PMC, in STR) :object_classes {
  PMC *name = pmc_new(interp, enum_class_String);
  VTABLE_set_string_native(interp, name, $3);
  $1 = VTABLE_subclass(interp, $2, name);
  goto NEXT();
}

inline op subclass(out PMC, invar PMC, in PMC) :object_classes {
  $1 = VTABLE_subclass(interp, $2, $3);
  goto NEXT();
}

=item B<subclass>(out PMC, inconst PMC)

=item B<subclass>(out PMC, inconst PMC, in STR)

=item B<subclass>(out PMC, inconst PMC, in PMC)

=item B<subclass>(out PMC, in STR)

=item B<subclass>(out PMC, in STR, in STR)

=item B<subclass>(out PMC, in STR, in PMC)

RT#42372 KLUDGE ALERT - OPCODE NAME SHOULD DIFFER FROM ABOVE

Create a new class, put in $1, that is a subclass of the class named $2.
$3, if available and not null, is the name of the new class--if not, the
subclass is an anonymous subclass.

=cut

op subclass(out PMC, inconst PMC) :object_classes {
  PMC *_class = Parrot_class_lookup_p(interp, $2);
  opcode_t *next = expr NEXT();
  if (PMC_IS_NULL(_class)) {
    STRING *name = readable_name(interp, $2);
    real_exception(interp, next, NO_CLASS,
                "Class '%Ss' doesn't exist", name);
  }
  $1 = VTABLE_subclass(interp, _class, PMCNULL);
  goto ADDRESS(next);
}

op subclass(out PMC, in STR) :object_classes {
  PMC *_class = Parrot_class_lookup(interp, $2);
  opcode_t *next = expr NEXT();
  if (PMC_IS_NULL(_class)) {
    real_exception(interp, next, NO_CLASS,
                "Class '%Ss' doesn't exist", $2);
  }
  $1 = VTABLE_subclass(interp, _class, PMCNULL);
  goto ADDRESS(next);
}


op subclass(out PMC, inconst PMC, in STR) :object_classes {
  PMC *_class = Parrot_class_lookup_p(interp, $2);
  PMC *subname_p;
  opcode_t *next = expr NEXT();
  if (PMC_IS_NULL(_class)) {
    STRING *name = readable_name(interp, $2);
    real_exception(interp, next, NO_CLASS,
                "Class '%Ss' doesn't exist", name);
  }
  subname_p = pmc_new(interp, enum_class_String);
  VTABLE_set_string_native(interp, subname_p, $3);
  $1 = VTABLE_subclass(interp, _class, subname_p);
  goto NEXT();
}

op subclass(out PMC, in STR, in STR) :object_classes {
  PMC *_class = Parrot_class_lookup(interp, $2);
  PMC *subname_p;
  opcode_t *next = expr NEXT();
  if (PMC_IS_NULL(_class)) {
    real_exception(interp, next, NO_CLASS,
                "Class '%Ss' doesn't exist", $2);
  }
  subname_p = pmc_new(interp, enum_class_String);
  VTABLE_set_string_native(interp, subname_p, $3);
  $1 = VTABLE_subclass(interp, _class, subname_p);
  goto ADDRESS(next);
}


op subclass(out PMC, inconst PMC, in PMC) :object_classes {
  PMC *_class = Parrot_class_lookup_p(interp, $2);
  opcode_t *next = expr NEXT();
  if (PMC_IS_NULL(_class)) {
    STRING *name = readable_name(interp, $2);
    real_exception(interp, next, NO_CLASS,
                "Class '%Ss' doesn't exist", name);
  }
  $1 = VTABLE_subclass(interp, _class, $3);
  goto ADDRESS(next);
}

op subclass(out PMC, in STR, in PMC) :object_classes {
    PMC      *_class = Parrot_class_lookup(interp, $2);
    opcode_t *next   = expr NEXT();

    if (PMC_IS_NULL(_class)) {
        char *class_name = string_to_cstring(interp, $2);
        real_exception(interp, next, NO_CLASS, "Class '%s' doesn't exist",
                class_name);
    }

    $1 = VTABLE_subclass(interp, _class, $3);
    goto ADDRESS(next);
}

###############################################################################

=item B<getclass>(out PMC, in STR)

=item B<getclass>(out PMC, in PMC)

Find the PMC for a class, by name. Deprecated - works with the old class
system.

=cut

inline op getclass(out PMC, in STR) :object_classes {
    PMC      *_class = Parrot_class_lookup(interp, $2);
    opcode_t *next   = expr NEXT();

    if (PMC_IS_NULL(_class)) {
        char *class_name = string_to_cstring(interp, $2);
        real_exception(interp, next, NO_CLASS, "Class '%s' doesn't exist",
                class_name);
    }
    else
        $1 = _class;

  goto ADDRESS(next);
}

inline op getclass(out PMC, in PMC) :object_classes {
  PMC *_class = Parrot_class_lookup_p(interp, $2);
  opcode_t *next = expr NEXT();
  if (PMC_IS_NULL(_class)) {
    STRING *name = readable_name(interp, $2);
    real_exception(interp, next, NO_CLASS,
         "Class '%Ss' doesn't exist", name);
  }
  else
    $1 = _class;
  goto ADDRESS(next);
}

###############################################################################

=item B<get_class>(out PMC, in STR)

=item B<get_class>(out PMC, in PMC)

Find the PMC for a class, by string name or by key.

=cut

inline op get_class(out PMC, in STR) :object_classes {
  PMC *_class = PMCNULL;
  opcode_t *next = expr NEXT();

  /* Look up a namespace with the given name within the current
   * namespace and if we find it, get the class associated with it, if any. */
  PMC *ns = Parrot_get_namespace_keyed_str(interp,
      CONTEXT(interp->ctx)->current_namespace, $2);
  if (!PMC_IS_NULL(ns))
      Parrot_PCCINVOKE(interp, ns,
          string_from_const_cstring(interp, "get_class", 0), "->P", &_class);

  /* If class is not found, throw an exception; otherwise, put it in $1. */
  if (PMC_IS_NULL(_class))
      real_exception(interp, next, NO_CLASS, "Class '%Ss' doesn't exist", $2);
  else
      $1 = _class;

  goto ADDRESS(next);
}

inline op get_class(out PMC, in PMC) :object_classes {
  PMC *_class = PMCNULL;
  opcode_t *next = expr NEXT();

  /* If we were not passed a namespace PMC, look it up, otherwise just use
   * the supplied namespace PMC. */
  PMC *ns;
  if (!VTABLE_isa(interp, $2, string_from_const_cstring(interp, "NameSpace", 0)))
      ns = Parrot_get_namespace_autobase(interp, $2);
  else
      ns = $2;

  /* If we have got a namespace, get the class associated with it, if any. */
  if (!PMC_IS_NULL(ns))
      Parrot_PCCINVOKE(interp, ns,
          string_from_const_cstring(interp, "get_class", 0), "->P", &_class);

  /* If class is not found, throw an exception; otherwise, put it in $1. */
  if (PMC_IS_NULL(_class)) {
      STRING *name = readable_name(interp, $2);
      real_exception(interp, next, NO_CLASS, "Class '%Ss' doesn't exist", name);
  }
  else {
      $1 = _class;
  }

  goto ADDRESS(next);
  /* Shouldn't be reached */
  return NULL;
}

###############################################################################

=item B<singleton>(invar PMC)  B<(unimplemented)>

Take the object in $1 and put it into its own singleton class, which is
an anonymous subclass of the object's current class.

=cut

inline op singleton(invar PMC) :object_classes {
  goto NEXT();
}

=item B<class>(out PMC, invar PMC)

Get the class PMC for the object in $2 and put it in $1.

=cut

inline op class(out PMC, invar PMC) :object_classes {
    $1 = VTABLE_get_class(interp, $2);
    goto NEXT();
}

=item B<classname>(out STR, invar PMC)

Get the class name for the class in $2 and put it in $1.

=cut

inline op classname(out STR, invar PMC) :object_base {
    $1 = VTABLE_name(interp, $2);
    goto NEXT();
}


##################################################


=item B<addparent>(invar PMC, invar PMC)

Add class $2 to the list of parent classes for $1.

=cut

inline op addparent(invar PMC, invar PMC) :object_classes {
    VTABLE_add_parent(interp, $1, $2);
    goto NEXT();
}

=item B<removeparent>(invar PMC, invar PMC)

Remove class $2 from class $1's list of parents.

=cut

inline op removeparent(invar PMC, invar PMC) :object_classes {
    Parrot_remove_parent(interp, $2, $1);
    goto NEXT();
}

=item B<addrole>(invar PMC, invar PMC)

Compose the role $2 into $1.

=cut

inline op addrole(invar PMC, invar PMC) :object_classes {
    VTABLE_add_role(interp, $1, $2);
    goto NEXT();
}

=item B<addattribute>(invar PMC, in STR)

Add the attribute named $2 to the class $1.

=cut

inline op addattribute(invar PMC, in STR) :object_classes {
    STRING *class_name  = string_from_const_cstring(interp, "Class", 0);
    STRING *pclass_name = string_from_const_cstring(interp, "ParrotClass", 0);

    if (VTABLE_isa(interp, $1, class_name))
        VTABLE_add_attribute(interp, $1, $2, PMCNULL);
    else if (VTABLE_isa(interp, $1, pclass_name))
        Parrot_add_attribute(interp, $1, $2);
    else
        real_exception(interp, NULL, INVALID_OPERATION,
            "Cannot add attribute to non-class" );

    goto NEXT();
}

=item B<removeattribute>(invar PMC, in STR) B<(unimplemented)>

=item B<removeattribute>(invar PMC, in INT) B<(unimplemented)>

Remove attribute $2 from class $1, specified either by name or offset.

=cut

op removeattribute(invar PMC, in STR) {
    internal_exception(UNIMPLEMENTED, "removeattribute is not implemented");
    goto NEXT();
}

op removeattribute(invar PMC, in INT) {
    internal_exception(UNIMPLEMENTED, "removeattribute is not implemented");
    goto NEXT();
}

=item B<getattribute>(out PMC, invar PMC, in INT)

=item B<getattribute>(out PMC, invar PMC, in STR)

Get attribute number $3 from object $2 and put the result in $1.
String attribute names have to be fully qualified.

=cut

inline op getattribute(out PMC, invar PMC, in INT) :object_classes {
    $1 = VTABLE_get_attr(interp, $2, $3);
    goto NEXT();
}

inline op getattribute(out PMC, invar PMC, in STR) :object_classes {
    $1 = VTABLE_get_attr_str(interp, $2, $3);
    goto NEXT();
}

=item B<setattribute>(invar PMC, in INT, invar PMC)

=item B<setattribute>(invar PMC, in STR, invar PMC)

Set attribute $2 of object $1 to $3

=cut

inline op setattribute(invar PMC, in INT, invar PMC) :object_classes {
    VTABLE_set_attr(interp, $1, $2, $3);
    goto NEXT();
}

inline op setattribute(invar PMC, in STR, invar PMC) :object_classes {
    VTABLE_set_attr_str(interp, $1, $2, $3);
    goto NEXT();
}

=item B<classoffset>(out INT, invar PMC, in STR)

Returns the offset of the first attribute for class $3 in object $2.
Throws an exception if $3 isn't in $2's hierarchy.

=cut

op classoffset(out INT, invar PMC, in STR) :object_classes {
    opcode_t *next = expr NEXT();
    INTVAL offset;
    offset = Parrot_class_offset(interp, $2, $3);
    if (offset < 0) {
        real_exception(interp, next, NO_CLASS,
            "Class not parent of object");
    }
    $1 = offset;
    goto ADDRESS(next);
}


=item B<adddoes>(invar PMC, in STR) B<(unimplemented)>

Add $2 to the list of interfaces that this class claims to implement.

=item B<removedoes>(invar PMC, in STR) B<(unimplemented)>

Remove $2 from the list of interfaces that this class claims to
implement.

=cut

op adddoes(invar PMC, in STR) :object_classes {
    internal_exception(UNIMPLEMENTED, "removedoes is not implemented");
    goto NEXT();
}

op removedoes(invar PMC, in STR) :object_classes {
    internal_exception(UNIMPLEMENTED, "removedoes is not implemented");
    goto NEXT();
}

###############################################################################

=item B<inspect>(out PMC, in PMC)

Sets $1 to a PMC hash of all introspection data available for $2, keyed on
name.

=item B<inspect>(out PMC, in PMC, in STR)

Sets $1 to a PMC Hash, Array, String, Integer, or Number value with
introspection information corresponding to the requested string name.

=cut

inline op inspect(out PMC, in PMC) :object_classes {
  $1 = VTABLE_inspect(interp, $2);
  goto NEXT();
}

inline op inspect(out PMC, in PMC, in STR) :object_classes {
  $1 = VTABLE_inspect_str(interp, $2, $3);
  goto NEXT();
}

=back

=head1 COPYRIGHT

Copyright (C) 2001-2007, The Perl Foundation.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
