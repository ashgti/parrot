/*

Copyright (C) 2001-2008, The Perl Foundation.
$Id$

pmc.ops

*/

VERSION = PARROT_VERSION;

=head1 NAME

pmc.ops - PMC Operations

=head1 DESCRIPTION

Operations that deal with PMCs, including creation and
destruction, manipulation, and introspection.

=cut

###############################################################################

=head2 Creation and Types

These operations are used to create PMCs and examine
type information.

=over 4

=cut

########################################

=item B<new>(out PMC, in INT)

=item B<new>(out PMC, in INT, invar PMC)

=item B<new>(out PMC, in STR)

=item B<new>(out PMC, in STR, invar PMC)

=item B<new>(out PMC, in PMC)

=item B<new>(out PMC, in PMC, invar PMC)

Instantiate a new object from a string PMC or key name, or from a class object.
For strings and keys, first check the namespace for a class object, then fall
back to the type ID if no class object is stored in the namespace.

Creating a new PMC by type ID is deprecated. See RT #48014.

  new P0, 'ResizableBooleanArray'

Optionally a PMC may be passed to the constructor. It's up to the class what
to do with the intializer.  See PDD02 for more.

=cut

op new(out PMC, in INT) {
  if ($2 <= 0 || $2 >= interp->n_vtable_max) {
    Parrot_ex_throw_from_c_args(interp, 0, EXCEPTION_NO_CLASS,
                   "Illegal PMC enum (%d) in new", (int)$2);
  }

  /* If we're creating a continuation, the continuation PMC needs to be in the
   * destination register before its init method copies the registers. */
  if ($2 == enum_class_Continuation) {
      $1 = pmc_new_noinit(interp, $2);
      VTABLE_init(interp, $1);
  }
  else
    $1 = pmc_new(interp, $2);
}

op new(out PMC, in INT, in PMC) {
  if ($2 <= 0 || $2 >= interp->n_vtable_max) {
    Parrot_ex_throw_from_c_args(interp, 0, EXCEPTION_NO_CLASS,
                   "Illegal PMC enum (%d) in new", (int)$2);
  }
  $1 = pmc_new_init(interp, $2, $3);
}

op new(out PMC, in STR) {
    STRING * const classname = $2;
    PMC * const classobj = Parrot_oo_get_class_str(interp, classname);

    if (!PMC_IS_NULL(classobj)) {
        fprintf(stderr, "Instantiating class from %p\n", classobj);
        $1 = VTABLE_instantiate(interp, classobj, PMCNULL);
    }
    else {
        const INTVAL type = pmc_type(interp, classname);
        if (type <= 0)
            Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_NO_CLASS,
                "Class '%Ss' not found", classname);
        $1 = pmc_new(interp, type);
    }
}

op new(out PMC, in STR, in PMC) {
    STRING * const classname = $2;
    PMC * const classobj = Parrot_oo_get_class_str(interp, classname);

    if (!PMC_IS_NULL(classobj))
        $1 = VTABLE_instantiate(interp, classobj, $3);
    else {
        const INTVAL type = pmc_type(interp, classname);
        if (type <= 0)
            Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_NO_CLASS,
                "Class '%Ss' not found", classname);
        $1 = pmc_new_init(interp, type, $3);
    }
}

inline op new(out PMC, in PMC) :object_classes {
    PMC * const classname_key = $2;
    PMC * const classobj = Parrot_oo_get_class(interp, classname_key);

    if (!PMC_IS_NULL(classobj))
        $1 = VTABLE_instantiate(interp, classobj, PMCNULL);
    else {
        const INTVAL type = pmc_type_p(interp, classname_key);
        if (type <= 0)
            Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_NO_CLASS,
                "Class '%Ss' not found", readable_name(interp, classname_key));
        $1 = pmc_new(interp, type);
    }
}

op new(out PMC, in PMC, in PMC) {
    PMC * const classname_key = $2;
    PMC * const classobj = Parrot_oo_get_class(interp, classname_key);

    if (!PMC_IS_NULL(classobj))
        $1 = VTABLE_instantiate(interp, classobj, $3);
    else {
        const INTVAL type = pmc_type_p(interp, classname_key);
        if (type <= 0)
            Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_NO_CLASS,
                "Class '%Ss' not found", readable_name(interp, classname_key));
        $1 = pmc_new_init(interp, type, $3);
    }
}

########################################

=item B<typeof>(out STR, invar PMC)

=item B<typeof>(out INT, invar PMC)

=item B<typeof>(out PMC, invar PMC)

Return the type of PMC in $2.

=item B<typeof>(out INT, invar PMC, in KEY)

=item B<typeof>(out INT, invar PMC, in INTKEY)

Return the type of the entry in aggregate PMC in $2 at key $3.

=cut

inline op typeof(out STR, invar PMC) {
  $1 = VTABLE_name(interp, $2);
}

inline op typeof(out PMC, invar PMC) {
  $1 = VTABLE_get_class(interp, $2);
}

inline op typeof(out INT, invar PMC) {
  $1 = VTABLE_type(interp, $2);
}

inline op typeof(out INT, invar PMC, in KEY) {
  $1 = VTABLE_type_keyed(interp, $2, $3);
}

inline op typeof(out INT, invar PMC, in INTKEY) {
  $1 = VTABLE_type_keyed_int(interp, $2, $3);
}
########################################

=item B<typeof>(out STR, in INT)

Return the (native) Parrot type of datatype $2.

=cut

inline op typeof(out STR, in INT) {
    if ($2 > 0 && $2 < interp->n_vtable_max)
                $1 = interp->vtables[$2]->whoami;
    else
                $1 = Parrot_get_datatype_name(interp, $2);
}

########################################

=item B<find_type>(out INT, in STR)

=item B<find_type>(out INT, in PMC)

Find the PMC type or Parrot datatype by name.

=cut

op find_type(out INT, in STR) {
    $1 = pmc_type(interp, $2);
}

op find_type(out INT, in PMC) {

    INTVAL n;

    if ($2->vtable->base_type == enum_class_String)
        $1 = pmc_type(interp, VTABLE_get_string(interp, $2));
    else if ($2->vtable->base_type == enum_class_Key)
        $1 = pmc_type_p(interp, $2);
    else if ((n = VTABLE_elements(interp, $2)) <= 0)
        $1 = 0;
    else {
        PMC *_class = interp->class_hash;
        INTVAL i;
        for (i = 0; i < n; ++i) {
            STRING *part = VTABLE_get_string_keyed_int(interp, $2, i);
            _class = VTABLE_get_pmc_keyed_str(interp, _class, part);
            if (PMC_IS_NULL(_class))
                break;
        }
        $1 = PMC_IS_NULL(_class) ? 0 : PMC_int_val(_class);
    }
}

########################################

=item B<valid_type>(out INT, in INT)

Check if the PMC type or Parrot datatype $2 is valid.

=cut

op valid_type(out INT, in INT) {
    if ($2 > 0 && $2 < interp->n_vtable_max)
        $1 = 1;
    else if ($2 >= enum_first_type && $2 < enum_last_type)
        $1 = 1;
    else
        $1 = 0;
}


=item B<get_repr>(out STR, invar PMC)

Set $1 to a string representation of $2

=cut

op get_repr(out STR, invar PMC) {
    $1 = VTABLE_get_repr(interp, $2);
}

=back

=cut

###############################################################################

=head2 Basic Operations

A few simple and common PMC operations.

=over 4

=cut

########################################

=item B<find_method>(out PMC, invar PMC, in STR)

Looks up method $3 in $2's vtable, placing the corresponding method
PMC in $1.

=cut

op find_method(out PMC, invar PMC, in STR) :flow {
    opcode_t * const resume = expr NEXT();
    $1 = VTABLE_find_method(interp, $2, $3);
    if (PMC_IS_NULL($1) || !VTABLE_defined(interp, $1)) {
        Parrot_ex_throw_from_c_args(interp, resume, EXCEPTION_METH_NOT_FOUND,
            "Method '%Ss' not found for invocant of class '%Ss'", $3,
            VTABLE_get_string(interp, VTABLE_get_class(interp, $2)));
    }
    restart ADDRESS(resume);
}

########################################

=item B<defined>(out INT, invar PMC)

=item B<defined>(out INT, invar PMC, in INTKEY)

=item B<defined>(out INT, invar PMC, in KEY)

Test PMC for definedness.

=item B<exists>(out INT, invar PMC, in INTKEY)

=item B<exists>(out INT, invar PMC, in KEY)

Tests whether KEY or INTKEY exists in the aggregate PMC.
Places the answer in INT.

=cut

inline op defined(out INT, invar PMC) {
  $1 = PMC_IS_NULL($2) ? 0 : VTABLE_defined(interp, $2);
}

inline op defined(out INT, invar PMC, in INTKEY) {
  $1 = PMC_IS_NULL($2) ? 0 : VTABLE_defined_keyed_int(interp, $2, $3);
}

inline op defined(out INT, invar PMC, in KEY) {
  $1 = PMC_IS_NULL($2) ? 0 : VTABLE_defined_keyed(interp, $2, $3);
}

inline op exists(out INT, invar PMC, in INTKEY) {
  $1 = PMC_IS_NULL($2) ? 0 : VTABLE_exists_keyed_int(interp, $2, $3);
}

inline op exists(out INT, invar PMC, in KEY) {
  $1 = PMC_IS_NULL($2) ? 0: VTABLE_exists_keyed(interp, $2, $3);
}

########################################

=item B<delete>(invar PMC, in KEY)

=item B<delete>(invar PMC, in INTKEY)

Delete the specified entry $2 from aggregate $1.

=cut

inline op delete(invar PMC, in KEY) {
  VTABLE_delete_keyed(interp, $1, $2);
}

inline op delete(invar PMC, in INTKEY) {
  VTABLE_delete_keyed_int(interp, $1, $2);
}

########################################

=item B<elements>(out INT, invar PMC)

Returns the number of items in aggregate $2

=cut

inline op elements(out INT, invar PMC) {
  $1 = VTABLE_elements(interp, $2);
}

=back

=cut

###############################################################################

=head2 Fast access ops

The fast access ops are shortcuts to common operations implemented invar PMCs.

=over 4

=cut

########################################

=item B<push>(invar PMC, in INT)

=item B<push>(invar PMC, in NUM)

=item B<push>(invar PMC, in STR)

=item B<push>(invar PMC, invar PMC)

Push $2 onto the end of the aggregate PMC $1, if that operation is defined.

=cut

inline op push(invar PMC, in INT) {
    VTABLE_push_integer(interp, $1, $2);
}

inline op push(invar PMC, in NUM) {
    VTABLE_push_float(interp, $1, $2);
}

inline op push(invar PMC, in STR) {
    VTABLE_push_string(interp, $1, $2);
}

inline op push(invar PMC, invar PMC) {
    VTABLE_push_pmc(interp, $1, $2);
}

########################################

=item B<pop>(out INT, invar PMC)

=item B<pop>(out NUM, invar PMC)

=item B<pop>(out STR, invar PMC)

=item B<pop>(out PMC, invar PMC)

Pop off last entry in the aggregate $2, placing the result in $1.

=cut

inline op pop(out INT, invar PMC) {
    $1 = VTABLE_pop_integer(interp, $2);
}

inline op pop(out NUM, invar PMC) {
    $1 = VTABLE_pop_float(interp, $2);
}

inline op pop(out STR, invar PMC) {
    $1 = VTABLE_pop_string(interp, $2);
}

inline op pop(out PMC, invar PMC) {
    $1 = VTABLE_pop_pmc(interp, $2);
}

########################################

=item B<unshift>(invar PMC, in INT)

=item B<unshift>(invar PMC, in NUM)

=item B<unshift>(invar PMC, in STR)

=item B<unshift>(invar PMC, invar PMC)

Unshift $2 onto the front of the aggregate PMC $1.

=cut

inline op unshift(invar PMC, in INT) {
    VTABLE_unshift_integer(interp, $1, $2);
}

inline op unshift(invar PMC, in NUM) {
    VTABLE_unshift_float(interp, $1, $2);
}

inline op unshift(invar PMC, in STR) {
    VTABLE_unshift_string(interp, $1, $2);
}

inline op unshift(invar PMC, invar PMC) {
    VTABLE_unshift_pmc(interp, $1, $2);
}

########################################

=item B<shift>(out INT, invar PMC)

=item B<shift>(out NUM, invar PMC)

=item B<shift>(out STR, invar PMC)

=item B<shift>(out PMC, invar PMC)

Shift off the first entry in the aggregate $2 and places it in $1.

=cut

inline op shift(out INT, invar PMC) {
    $1 = VTABLE_shift_integer(interp, $2);
}

inline op shift(out NUM, invar PMC) {
    $1 = VTABLE_shift_float(interp, $2);
}

inline op shift(out STR, invar PMC) {
    $1 = VTABLE_shift_string(interp, $2);
}

inline op shift(out PMC, invar PMC) {
    $1 = VTABLE_shift_pmc(interp, $2);
}


=back

=cut

###############################################################################

=head2 Properties

Ops to deal with PMC properties.

=over 4

=cut

########################################

=item B<setprop>(invar PMC, in STR, invar PMC)

Set property $2 to value $3 for PMC $1.

=cut

op setprop(invar PMC, in STR, invar PMC) {
      VTABLE_setprop(interp, $1, $2, $3);
}

########################################

=item B<getprop>(out PMC, in STR, invar PMC)

Get property $2 of PMC $3 and put it in $1.

=cut

op getprop(out PMC, in STR, invar PMC) {
   $1 = VTABLE_getprop(interp, $3, $2);
}

########################################

=item B<delprop>(invar PMC, in STR)

Delete property $2 from PMC $1.

=cut

op delprop(invar PMC, in STR) {
   VTABLE_delprop(interp, $1, $2);
}

########################################

=item B<prophash>(out PMC, invar PMC)

Get a hash for the properties invar PMC $2 and put it in $1. If the property
hash doesn't exist, the C<Null> PMC is returned.

=cut

op prophash(out PMC, invar PMC) {
   $1 = VTABLE_getprops(interp, $2);
}

=back

=cut

###############################################################################

=head2 Freeze, thaw and friends

Ops to PMC freeze, thaw.

=over 4

=cut

########################################

=item B<freeze>(out STR, invar PMC)

Set $1 to the frozen image of $2.

=item B<thaw>(out PMC, in STR)

Set $1 to a newly created PMC from the image $2.

=cut

op freeze(out STR, invar PMC) {
   $1 = Parrot_freeze(interp, $2);
}

op thaw(out PMC, in STR) {
   $1 = Parrot_thaw(interp, $2);
}

=back

=cut

###############################################################################

=head2 Vtable MMD manipulation functions

These functions manipulate the vtable MMD function table.

These functions allow bytecode to register subs or methods and query which
sub or method would get called for a particular vtable operation. This way
you're not required to drop to C to register a new method variant for
addition or subtraction, or one of the other binary MMD operations.

=over 4

=cut

########################################

=item B<mmdvtregister>(in INT, in INT, in INT, invar PMC)

Register method $4 as the MMD method for vtable entry $1 for classes
$2 and $3.

=cut

inline op mmdvtregister(in INT, in INT, in INT, invar PMC) {
  mmd_register_sub(interp, $1, $2, $3, $4);
}

=item B<mmdvtfind>(out PMC, in INT, in INT, in INT)

Find the sub that would be called for vtable entry $2 for types $3 and $4.

=cut

inline op mmdvtfind(out PMC, in INT, in INT, in INT) {
  $1 = mmd_vtfind(interp, $2, $3, $4);
}

=back

=cut

###############################################################################

=head2 Misc PMC related ops

=over 4

=cut

########################################

=item B<register>(invar PMC)

Add a reference of PMC $1 to the interpreter's root set of PMCs. This is needed
for extensions to make sure that the PMC is properly marked during DOD, if that
PMC is not known to Parrot's core elsewhere.

A PMC can be registered multiple times.  If it's unregistered and the
registration count reaches zero, it will be destroyed during the next DOD run.

=item B<unregister>(invar PMC)

Remove one reference of $1.

=cut

op register(invar PMC) {
  dod_register_pmc(interp, $1);
}

op unregister(invar PMC) {
  dod_unregister_pmc(interp, $1);
}

=item B<get_mro>(out PMC, invar PMC)

Set $1 to the mro array of the PMC $2. Please note that this is a
direct reference so messing with it can do harm to the method lookup.

=cut

op get_mro(out PMC, invar PMC) :deprecated {
  $1 = $2->vtable->mro;
}

=back

=head1 COPYRIGHT

Copyright (C) 2001-2008, The Perl Foundation.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
