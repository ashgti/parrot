/*
** core.ops
*/

#include "parrot/dynext.h"
#include "parrot/embed.h"
#include "../interp_guts.h"

VERSION = PARROT_VERSION;

=head1 NAME

core.ops - Parrot Core Ops

=cut

=head1 DESCRIPTION

Parrot's core library of ops.

Core operations are primarily flow control and interpreter
introspection.

=cut

# ' for emacs

###############################################################################

=head2 Basic ops

These are the fundamental operations.
Please note: These opcodes must not be moved; they must have
exactly these opcode numbers. Opcodes ending with underscores are for
internal use only, don't emit these opcodes.

=over 4

=cut

########################################

=item B<end>()

Halts the interpreter. (Must be op #0, CORE_OPS_end). See also B<exit>.

=cut

inline op end() :base_core,check_event {
  HALT();
}


########################################

=item B<noop>()

Does nothing other than waste an iota of time and 32 bits of bytecode space.
(Must be op #1, CORE_OPS_noop)

=item B<cpu_ret>()

Emit a cpu return instruction. This is used to return from CGP core
to JIT code. Note: Do B<not> use this opcode. It is for internal use only.
(Must be op #2, CORE_OPS_cpu_ret)

=item B<check_events>()

Check the event queue and run event handlers if there are unhandled events.
Note: This opcode is mainly for testing. It should not be necessary to ever
use it explicitly.
(Must be op #3, CORE_OPS_check_events).

=item B<check_events__>()

Check the event queue and run event handlers if there are unhandled events.
Note: Do B<not> use this opcode. It is for internal use only.
(Must be op #4, CORE_OPS_check_events__).

=item B<wrapper__>()

Internal opcode to wrap unknown ops from loaded opcode libs.
Don't use.
(Must be op #5, CORE_OPS_wrapper__).

=item B<prederef__>()

Internal opcode to prederef opcodes on the fly.
Don't use.
(Must be op #6, CORE_OPS_prederef__ ).

=item B<reserved>(inconst INT)

Reserve 1 more fix entry.

=item B<load_bytecode>(in STR)

Load Parrot bytecode from file $1, and (TODO) search the library path,
to locate the file.

=cut

inline op noop() :base_core {
  goto NEXT();
}

inline op cpu_ret() {
#ifdef __GNUC__
# ifdef I386
   asm("ret");
# endif
#endif
  goto NEXT();
}

inline op check_events() :base_core {
  opcode_t *next = expr NEXT();
  next = CHECK_EVENTS(interpreter, next);
  goto ADDRESS(next);	/* force this being a branch op */
}

inline op check_events__() :internal {
  opcode_t *this = CUR_OPCODE;
  this = HANDLE_EVENTS(interpreter, this);
  goto ADDRESS(this);	/* force this being a branch op */
}

inline op wrapper__() :internal {
    opcode_t *pc = CUR_OPCODE;
    DO_OP(pc, interpreter);
    goto ADDRESS(pc);
}

inline op prederef__() :internal {
    do_prederef((void**)cur_opcode, interpreter, op_lib.core_type);
    goto OFFSET(0);
}

inline op reserved(inconst INT) {
  goto NEXT();  /* reserve 1 entries */
}

inline op load_bytecode(in STR) :load_file {
    Parrot_load_bytecode(interpreter, $1);
    goto NEXT();
}

=back

=cut

###############################################################################

=head2 Control flow

The control flow opcodes check conditions and manage program flow.

=over 4

=cut

########################################

=item B<branch>(label INT)

Branch forward or backward by the amount in $1.

=cut

inline op branch (label INT) :base_loop {
  goto OFFSET($1);
}


=item B<branch_cs>(in STR)

Intersegment branch to location in fixup table named $1.

=cut

inline op branch_cs (in STR) :base_loop,check_event {
    char * const label = string_to_cstring(interpreter, $1);
    struct PackFile_FixupEntry *fe = PackFile_find_fixup_entry(interpreter,
	    enum_fixup_label, label);
    if (!fe)
	internal_exception(1, "branch_cs: fixup for '%s' not found", label);
    else {
	interpreter->resume_offset = fe->offset;
        Parrot_switch_to_cs(interpreter, fe->seg, 1);
    }
    string_cstring_free(label);
    interpreter->resume_flag = 2;
    goto ADDRESS(0);
}

########################################

=item B<bsr>(label INT)

Branch to the location specified by $1. Push the current location onto the call
stack for later returning.

=cut

inline op bsr (label INT) :base_core,check_event {
  stack_push(interpreter, &CONTEXT(interpreter->ctx)->control_stack, expr NEXT(),  STACK_ENTRY_DESTINATION, STACK_CLEANUP_NULL);
  goto OFFSET($1);
}

=item B<ret>()

Pop the location off the top of the call stack and go there.

=cut

inline op ret() {
  goto POP();
}


########################################

=item B<jsr>(label INT)

Jump to the location specified by register $1. Push the current
location onto the call stack for later returning.

=cut

inline op jsr(label INT) :base_core,check_event {
  opcode_t * loc;
  stack_push(interpreter, &CONTEXT(interpreter->ctx)->control_stack, expr NEXT(),  STACK_ENTRY_DESTINATION, STACK_CLEANUP_NULL);
  loc = INTVAL2PTR(opcode_t *, $1);
  goto ADDRESS(loc);
}


########################################

=item B<jump>(label INT)

Jump to the address held in register $1.

=cut

inline op jump(label INT) :base_loop {
  opcode_t * const loc = INTVAL2PTR(opcode_t *, $1);
  goto ADDRESS(loc);
}

########################################

=item B<enternative>()

Internal opcode used to jump from normal bytecode into a JITted version.

=cut

op enternative() {
  goto ADDRESS(( run_native(interpreter, CUR_OPCODE, interpreter->code->base.data) ));
}

=back

=cut

###############################################################################

=head2 Conditional branch operations

These operations perform a conditional relative branch. If the condition is
met, the branch happens, otherwise control falls to the next operation.

=over 4

=cut

########################################

=item B<if>(in INT, labelconst INT)

=item B<if>(in NUM, labelconst INT)

=item B<if>(in PMC, labelconst INT)

=item B<if>(in STR, labelconst INT)

Check register $1. If true, branch by $2.

=cut

inline op if(in INT, labelconst INT) {
  if ($1 != 0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

inline op if(in NUM, labelconst INT) {
  if ($1 != 0.0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op if (in STR, labelconst INT) {
  if (string_bool(interpreter, $1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op if(in PMC, labelconst INT) {
  if ($1->vtable->get_bool(interpreter, $1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}

########################################

=item B<unless>(in INT, labelconst INT)

=item B<unless>(in NUM, labelconst INT)

=item B<unless>(in PMC, labelconst INT)

=item B<unless>(in STR, labelconst INT)

Check register $1. If false, branch by $2.

=cut

inline op unless(in INT, labelconst INT) {
  if ($1 == 0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

inline op unless(in NUM, labelconst INT) {
  if ($1 == 0.0) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op unless (in STR, labelconst INT) {
  if (!string_bool(interpreter, $1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}

op unless(in PMC, labelconst INT) {
  if (!$1->vtable->get_bool(interpreter, $1)) {
    goto OFFSET($2);
  }
  goto NEXT();
}

=back

=cut

###############################################################################

=head2 Subroutine  operations

These operations are used to generate and call subroutines and
continuations.

=over 4

=cut

########################################

=item B<invokecc>(in PMC)

Call the subroutine in $1 and generate a new return continuation, if needed.
E.g. a NCI subroutine, which executes code in some C library will not
create a continuation, neither the not-first call to a coroutine.

=item B<invoke>(in PMC, in PMC)

Call the subroutine in $1 and use continuation $2.

=item B<yield>()

Yield results from a coroutine.

=item B<tailcall>(in PMC)

Call the subroutine in $1 and use the current continuation as the subs
continuation.

=item B<returncc>()

Return from the sub or method via the current continuation.

=item B<newclosure>(out PMC, in PMC)

Create a closure of the given subroutine PMC by cloning the sub's state.

=cut

inline op invokecc(in PMC) {
  opcode_t *dest;
  PMC * const p = $1;
  dest = expr NEXT();
  interpreter->current_object = NULL;
  interpreter->current_cont = NEED_CONTINUATION;
  dest = (opcode_t *)p->vtable->invoke(interpreter, p, dest);
  goto ADDRESS(dest);
}

inline op invoke(in PMC, in PMC) {
  opcode_t *dest;
  PMC * const p = $1;

  interpreter->current_object = NULL;
  interpreter->current_cont = $2;
  dest = (opcode_t *)p->vtable->invoke(interpreter, p, expr NEXT());
  goto ADDRESS(dest);
}

inline op yield() {
  opcode_t *dest = expr NEXT();
  PMC * const p = CONTEXT(interpreter->ctx)->current_sub;
  dest = (opcode_t *)p->vtable->invoke(interpreter, p, dest);
  goto ADDRESS(dest);
}

inline op tailcall(in PMC) {
  opcode_t *dest;
  PMC * const p = $1;
  dest = expr NEXT();
  interpreter->current_cont = CONTEXT(interpreter->ctx)->current_cont;
  PObj_get_FLAGS(interpreter->current_cont) |= SUB_FLAG_TAILCALL;
  dest = (opcode_t *)p->vtable->invoke(interpreter, p, dest);
  goto ADDRESS(dest);
}

inline op returncc() {
  PMC * const p = CONTEXT(interpreter->ctx)->current_cont;
  opcode_t * const dest = (opcode_t *)p->vtable->invoke(interpreter, p, expr NEXT());
  goto ADDRESS(dest);
}

inline op newclosure(out PMC, in PMC) {
  $1 = parrot_new_closure(interpreter, $2);
  goto NEXT();
}

=back

=head2 Function argument opcode

Implementations of function argument and params handling

=over 4

=item B<set_args>(inconst PMC /* , ... */)

Define arguments for the next function call.

=item B<get_results>(inconst PMC /* , ... */)

Define return values for the next function call.

=item B<get_params>(inconst PMC /* , ... */)

Define function parameters for this subroutine.

=item B<set_returns>(inconst PMC /* , ... */)

Define return results for the subroutine return statement.

For all of these opcodes the passed in PMC constant is the string
representation of a fixed integer array with one flag word per argument.
The flags are documented currently in F<include/parrrot/enum.h> only.

After this argument a variable amount of arguments must follow according
to the elements of the signature array.

=cut


op set_args(inconst PMC) {
    opcode_t * const this = CUR_OPCODE;
    PMC * const signature = $1;
    INTVAL argc;

    /* for now just point to the opcode */
    interpreter->current_args = this;
    argc = SIG_ELEMS(signature);
    goto OFFSET(argc + 2);
}

op get_results(inconst PMC) {
    opcode_t * const this = CUR_OPCODE;
    PMC * const signature = $1;
    INTVAL argc;

    CONTEXT(interpreter->ctx)->current_results = this;
    argc = SIG_ELEMS(signature);
    goto OFFSET(argc + 2);
}

op get_params(inconst PMC) {
    opcode_t * const this = CUR_OPCODE;
    parrot_context_t *caller_ctx, *ctx;
    PMC *ccont;
    opcode_t *pc;

    interpreter->current_params = this;
    ctx = CONTEXT(interpreter->ctx);
    ccont = ctx->current_cont;

    caller_ctx = ctx->caller_ctx;
    pc = parrot_pass_args(interpreter, caller_ctx, ctx,
	    PARROT_OP_get_params_pc);
    if (PObj_get_FLAGS(ccont) & SUB_FLAG_TAILCALL) {
	PObj_get_FLAGS(ccont) &= ~SUB_FLAG_TAILCALL;
	--ctx->recursion_depth;
	ctx->caller_ctx = caller_ctx->caller_ctx;
	/* ordinarily, this will free the context immediately, but not if the
	   sub created a closure (or continuation, or . . .).  */
	Parrot_free_context(interpreter, caller_ctx, 0);
        interpreter->current_args = NULL;
    }
    goto ADDRESS(pc);
}

op set_returns(inconst PMC) {
    opcode_t * const this = CUR_OPCODE;
    parrot_context_t *ctx;
    PMC *ccont;
    PMC *signature = $1;
    INTVAL argc;

    interpreter->current_returns = this;
    ctx = CONTEXT(interpreter->ctx);
    ccont = ctx->current_cont;

    if (PMC_cont(ccont)->address) {
	/* else its from runops_fromc */
	parrot_context_t * const caller_ctx = PMC_cont(ccont)->to_ctx;
	if (! caller_ctx) {
	    real_exception(interpreter, NULL, INVALID_OPERATION,
			   "null caller_ctx for ccont %p", ccont);
	}
	parrot_pass_args(interpreter, ctx, caller_ctx,
		PARROT_OP_get_results_pc);
    }
    argc = SIG_ELEMS(signature);
    goto OFFSET(argc + 2);
}

=item B<result_info>(out PMC)

Returns the get_results signature PMC of the caller. This PMC is a
FixedIntegerPMCArray. The number of elements of this PMC is equal to the number
of return values that are expected.  The individual bits per entry are
specified in F<docs/pdds/pdd03_calling_conventions.pod>.

=cut

inline op result_info(out PMC) {
    /* Get context of callee from return continuation. */
    PMC * const cc = CONTEXT(interpreter->ctx)->current_cont;
    PMC *sig = NULL;
    if (cc && PMC_cont(cc)->to_ctx) {
	/* caller context has results */
        opcode_t * const results = PMC_cont(cc)->to_ctx->current_results;
        if (results) {
	    /* get results PMC index and get PMC. */
	    sig = PF_CONST(PMC_cont(cc)->seg, results[1])->u.key;
	}
    }

    /* If no elements, hand back empty array; otherwise PMC. */
    if (!sig)
        $1 = pmc_new(interpreter, enum_class_FixedIntegerArray);
    else
        $1 = sig;
    goto NEXT();
}

=back

=head2 Address manipulation

=for clarity

########################################

=cut

=over 4

=item B<set_addr>(out INT, labelconst INT)

Sets register $1 to the current address plus the offset $2.

=item B<set_addr>(in PMC, labelconst INT)

Sets PMC in register $1 to the current address plus the offset $2.

=item B<set_addr>(in PMC, labelvar INT)

Sets PMC in register $1 to the absolute address $2 obtained from B<get_addr>.

=item B<get_addr>(out INT, in PMC)

Sets $1 to the absolute address of the Sub PMC $2.

=cut

inline op set_addr(out INT, labelconst INT) {
  $1 = PTR2OPCODE_T(CUR_OPCODE + $2);
  goto NEXT();
}

inline op set_addr(in PMC, labelconst INT) {
  $1->vtable->set_pointer(interpreter, $1, (CUR_OPCODE + $2));
  goto NEXT();
}

inline op set_addr(in PMC, labelvar INT) {
  $1->vtable->set_pointer(interpreter, $1, (void* )$2);
  goto NEXT();
}

inline op get_addr(out INT, in PMC) {
  $1 = (INTVAL)$2->vtable->get_pointer(interpreter, $2);
  goto NEXT();
}

=back

=cut

########################################

=head2 Exception handling

=over 4

=item B<push_eh>(labelconst INT)

Create an exception handler for the given catch label and push it onto
the control stack.

=item B<clear_eh>()

Clear out the most recently placed exception.

=item B<throw>(in PMC)

Throw the exception in $1.

=item B<rethrow>(in PMC)

Only valid inside an exception handler. Rethrow the exception $1.

=item B<die>(in INT, in INT)

Die with severity $1 and error $2. If severity is .EXCEPT_DOOMED,
call _exit($2). The latter isn't catchable.

=item B<exit>(in INT)

Exit the interpreter with exit_status $1. If you want to communicate an
extended exit status, create an exception with severity B<EXCEPT_exit>
and throw it.

=item B<pushmark>(in INT)

Push a mark labeled $1 onto the control stack.

=item B<popmark>(in INT)

Pop all items off the control stack to the given mark.

=item B<pushaction>(in PMC)

Push the given Sub PMC $1 onto the control stack. If the control stack
is unwound due to a C<popmark>, subroutine return, or an exception, the
subroutine will be invoked with an integer argument: C<0> means a normal
return; C<1> means an exception has been raised.

=cut

inline op push_eh(labelconst INT) {
  PMC * const eh = pmc_new(interpreter, enum_class_Exception_Handler);
  VTABLE_set_pointer(interpreter, eh, CUR_OPCODE + $1);
  push_exception(interpreter, eh);
  goto NEXT();
}

inline op clear_eh() {
  pop_exception(interpreter);
  goto NEXT();
}

inline op throw(in PMC) {
  opcode_t * const ret = expr NEXT();
  opcode_t * const dest = (opcode_t *)throw_exception(interpreter, $1, ret);
  goto ADDRESS(dest);
}

inline op rethrow(in PMC) {
  opcode_t * const dest = (opcode_t *)rethrow_exception(interpreter, $1);
  goto ADDRESS(dest);
}

inline op die(in INT, in INT) {
  if ($1 == EXCEPT_doomed)
    _exit($2);
  do_exception(interpreter, $1, $2);
  restart NEXT();
}

inline op exit(in INT) {
  do_exception(interpreter, EXCEPT_exit, $1);
  restart NEXT();
}

inline op pushmark(in INT) {
  Parrot_push_mark(interpreter, $1);
  goto NEXT();
}

inline op popmark(in INT) {
  Parrot_pop_mark(interpreter, $1);
  goto NEXT();
}

inline op pushaction(in PMC) {
  Parrot_push_action(interpreter, $1);
  goto NEXT();
}

=back

=cut

###############################################################################

=head2 Interpreter operations

These operations inspect or modify the interpreter itself, possibly
affecting its subsequent operation.

=over 4

=cut

########################################

=item B<debug>(in INT)

If $1 is zero, turn off debugging. Otherwise turn debug flag $1 on.

=cut

inline op debug(in INT) {
  if ($1 != 0) { Interp_debug_SET(interpreter,   $1); }
  else         { Interp_debug_CLEAR(interpreter, PARROT_ALL_DEBUG_FLAGS); }
  restart NEXT();
}


########################################

=item B<bounds>(in INT)

If $1 is zero, turn off byte code bounds checking. Otherwise turn it on.

=cut

inline op bounds(in INT) {
  if ($1 != 0) { Parrot_set_flag(interpreter,   PARROT_BOUNDS_FLAG); }
  else         { Interp_flags_CLEAR(interpreter, PARROT_BOUNDS_FLAG); }
  restart NEXT();
}


########################################

=item B<profile>(in INT)

If $1 is zero, turn off profiling. Otherwise turn it on.

=cut

inline op profile(in INT) {
  if ($1 != 0) { Parrot_set_flag(interpreter,   PARROT_PROFILE_FLAG); }
  else         { Interp_flags_CLEAR(interpreter, PARROT_PROFILE_FLAG); }
  restart NEXT();
}


########################################

=item B<trace>(in INT)

If $1 is zero, turn off tracing. Otherwise turn trace flag $1 on.

=cut

inline op trace(in INT) {
  if ($1 != 0) { Parrot_set_trace(interpreter,   $1); }
  else         { Parrot_clear_trace(interpreter, PARROT_ALL_TRACE_FLAGS); }
  restart NEXT();
}

########################################

=item B<gc_debug>(in INT)

If $1 is zero, turn off GC_DEBUG. Otherwise turn it on.

=cut

inline op gc_debug(in INT) {
  if ($1 != 0) { Interp_flags_SET(interpreter,   PARROT_GC_DEBUG_FLAG); }
  else         { Interp_flags_CLEAR(interpreter, PARROT_GC_DEBUG_FLAG); }
  goto NEXT();
}

########################################

=item B<interpinfo>

Fetch some piece of information about the interpreter and put it in $1.
Possible values for $2 are defined in F<runtime/parrot/include/interpinfo.pasm>.
Below are listed the valid constants for each return value.

=over 4

=item B<interpinfo>(out INT, in INT)

.TOTAL_MEM_ALLOC, .DOD_RUNS, .COLLECT_RUNS, .ACTIVE_PMCS, .ACTIVE_BUFFERS,
.TOTAL_PMCS, .TOTAL_BUFFERS, .HEADER_ALLOCS_SINCE_COLLECT,
.MEM_ALLOCS_SINCE_COLLECT, .TOTAL_COPIED, .IMPATIENT_PMCS, .LAZY_DOD_RUNS,
.EXTENDED_PMCS

=item B<interpinfo>(out PMC, in INT)

.CURRENT_SUB, .CURRENT_CONT, .CURRENT_OBJECT, .NAMESPACE_ROOT, .CURRENT_LEXPAD

=item B<interpinfo>(out STR, in INT)

.CURRENT_METHOD

=back

=cut

op interpinfo(out INT, in INT) {
  $1 = interpinfo(interpreter, $2);
  goto NEXT();
}

op interpinfo(out PMC, in INT) {
  $1 = interpinfo_p(interpreter, $2);
  goto NEXT();
}

op interpinfo(out STR, in INT) {
  $1 = interpinfo_s(interpreter, $2);
  goto NEXT();
}

=item B<warningson>(in INT)

Turns on warnings categories. Categories already turned on will
stay on. Initial setting is currently all warnings off.
Current categories are (include "warnings.pasm"):

=over 4

=item .PARROT_WARNINGS_UNDEF_FLAG

=item .PARROT_WARNINGS_IO_FLAG

=item .PARROT_WARNINGS_PLATFORM_FLAG

=item .PARROT_WARNINGS_ALL_FLAG

=back

To turn on multiple categories, OR the category numbers together.

=cut

inline op warningson(in INT) {
  PARROT_WARNINGS_on(interpreter, $1);
  goto NEXT();
}

=item B<warningsoff>(in INT)

Turns off warnings categories.  Categories already turned off will
stay off.  See the documentation for B<warningson> for category
numbers.

=cut

inline op warningsoff(in INT) {
  PARROT_WARNINGS_off(interpreter, $1);
  goto NEXT();
}

=item B<errorson>(in INT)

Turns on error categories. Categories already turned on will
stay on.
Current categories are (include "errors.pasm"):

=over 4

=item .PARROT_ERRORS_GLOBALS_FLAG

Throw an exception, if global doesn't exist, default on.

=item .PARROT_ERRORS_OVERFLOW_FLAG

Throw math overflow instead of promoting to BigInt, default off.

=item .PARROT_ERRORS_PARAM_COUNT_FLAG

Throw exception on argument <-> param count mismatch, default off

=item .PARROT_ERRORS_RESULT_COUNT_FLAG

Throw exception on return <-> result count mismatch, default off

=item .PARROT_ERRORS_ALL_FLAG

=back

To turn on multiple categories, OR the category numbers together.

=cut

inline op errorson(in INT) {
  PARROT_ERRORS_on(interpreter, $1);
  goto NEXT();
}

=item B<errorsoff>(in INT)

Turns off errors categories.  Categories already turned off will
stay off.  See the documentation for B<errorson> for category
numbers.

=cut

inline op errorsoff(in INT) {
  PARROT_ERRORS_off(interpreter, $1);
  goto NEXT();
}

########################################

=item B<runinterp>(in PMC, label INT)

Run the code starting at offset $2 within interpreter $1.

=item B<getinterp>(out PMC)

Get the current ParrotInterpreter.

=cut

op runinterp(in PMC, label INT) {
  Interp * const new_interp = (Interp *)PMC_data($1);
  Interp_flags_SET(new_interp, PARROT_EXTERN_CODE_FLAG);
  new_interp->code = interpreter->code;
  runops(new_interp, REL_PC + $2);
  goto NEXT();
}

op getinterp(out PMC) {
  $1 = VTABLE_get_pmc_keyed_int(interpreter, interpreter->iglobals,
         IGLOBALS_INTERPRETER);
  goto NEXT();
}

#######################################



=back

=cut

###############################################################################

=head2 Dead Object Detection/Garbage Collection

Opcodes that interact with the DOD and GC subsystems.

=over 4

=cut

########################################

=item B<sweep>(inconst INT)

0 ...  Trigger a DOD run only if there are things that have flagged
       themselves as really needing to be collected.
1 ...  Trigger a dead object detection (DOD) sweep unconditionally.

=cut

op sweep(inconst INT) {
  if ($1)
    Parrot_do_dod_run(interpreter, 0);
  else
    if (interpreter->arena_base->num_early_DOD_PMCs)
      Parrot_do_dod_run(interpreter, DOD_lazy_FLAG);
  goto NEXT();
}

=item B<collect>()

Trigger a garbage collection.

=cut

op collect() {
  Parrot_go_collect(interpreter);
  goto NEXT();
}

=item B<sweepoff>()

Disable DOD sweeps. (Nestable)

=cut

op sweepoff() {
  Parrot_block_DOD(interpreter);
  goto NEXT();
}

=item B<sweepon>()

Re-enable DOD sweeps.

=cut

op sweepon() {
  Parrot_unblock_DOD(interpreter);
  goto NEXT();
}

=item B<collectoff>()

Disable GC runs (nestable).

=cut

op collectoff() {
  Parrot_block_GC(interpreter);
  goto NEXT();
}

=item B<collecton>()

Re-enable GC.

=cut

op collecton() {
  Parrot_unblock_GC(interpreter);
  goto NEXT();
}

=item B<needs_destroy>(in PMC)

Mark the PMC wanting destruction as soon as possible, i.e.
when unused during the lazy sweep, triggered by "sweep 0".

=cut

op needs_destroy(in PMC) {
   PObj_needs_early_DOD_SET($1);
   ++interpreter->arena_base->num_early_DOD_PMCs;
  goto NEXT();
}

=back

###############################################################################

=head2 Native Call Interface

Opcodes for interfacing with C functions in shared libraries.

=over 4

=cut

########################################

=item B<loadlib>(out PMC, in STR)

Load a dynamic link library named $2 and store it in $1.

=item B<dlfunc>(out PMC, in PMC, in STR, in STR)

Look up symbol $3 in library $2 with signature $4, and put the
corresponding sub object in $1. Note that you need the signature so we
can build or find an appropriate thunking function.

=item B<dlvar>(out PMC, in PMC, in STR)

Look up symbol $3 in library $2. We assume that this is actually a
variable address rather than a function address, and build an
unmanagedstruct PMC and stick the address into its data pointer.

=item B<compile>(out PMC, in PMC, in STR)

Don't use compile - just invoke the compiler.

=item B<compreg>(out PMC, in STR)

Get a compiler for source type $2.

=item B<compreg>(in STR, in PMC)

Register the sub $2 as a compiler for source type $1.
$2 is either a NCI PMC with signature "pIt" or a PASM Sub.

=item B<new_callback>(out PMC, in PMC, in PMC, in STR)

Create a callback stub $1 for PASM subroutine $2 with userdata $3 and
function signature $4.

=cut

inline op loadlib(out PMC, in STR) {

  $1 = Parrot_load_lib(interpreter, $2, NULL);
  goto NEXT();
}

op dlfunc (out PMC, in PMC, in STR, in STR) {
  char * const name = string_to_cstring(interpreter, ($3));

  funcptr_t p = D2FPTR(Parrot_dlsym(PMC_IS_NULL($2) ? 
	NULL : PMC_data($2), name));
  string_cstring_free(name);
  if (p == NULLfunc) {
      const char * err = Parrot_dlerror();
      Parrot_warn(interpreter, PARROT_WARNINGS_UNDEF_FLAG,
	 "Symbol '%s' not found: %s\n", name, err ? err : "unknown reason");
      $1 = pmc_new(interpreter, enum_class_Undef);
  }
  else {
      $1 = pmc_new(interpreter, enum_class_NCI);
      $1->vtable->set_pointer_keyed_str(interpreter, $1, $4, F2DPTR(p));
      PObj_get_FLAGS($1) |= PObj_private1_FLAG;
  }
  goto NEXT();
}

op dlvar (out PMC, in PMC, in STR) {
  char * const name = string_to_cstring(interpreter, ($3));

  void * const p = Parrot_dlsym(PMC_IS_NULL($2) ? NULL : PMC_data($2), name);
  string_cstring_free(name);
  if (p == NULL) {
      const char * const err = Parrot_dlerror();
      Parrot_warn(interpreter, PARROT_WARNINGS_UNDEF_FLAG,
	 "Symbol '%s' not found: %s\n", name, err ? err : "unknown reason");
      $1 = pmc_new(interpreter, enum_class_Undef);
  }
  else {
      /* At this point we have the symbol's address. We just need to build
         a PMC with it so we can get and set the value */
      $1 = pmc_new(interpreter, enum_class_UnManagedStruct);
      PMC_data($1) = p;
  }
  goto NEXT();
}

inline op compile(out PMC, in PMC, in STR) {
  internal_exception(1, "don't use compile - just invoke the compiler");
  goto NEXT();
}

inline op compreg(in STR, in PMC) {
  PMC * const compreg_hash = VTABLE_get_pmc_keyed_int(interpreter,
      interpreter->iglobals, IGLOBALS_COMPREG_HASH);
  VTABLE_set_pmc_keyed_str(interpreter, compreg_hash, $1, $2);
  goto NEXT();
}

inline op compreg(out PMC, in STR) {
  PMC * const compreg_hash = VTABLE_get_pmc_keyed_int(interpreter,
      interpreter->iglobals, IGLOBALS_COMPREG_HASH);
  $1 = VTABLE_get_pmc_keyed_str(interpreter, compreg_hash, $2);
  goto NEXT();
}

op new_callback(out PMC, in PMC, in PMC, in STR) {
  $1 = Parrot_make_cb(interpreter, $2, $3, $4);
  goto NEXT();
}

=back

=cut

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001-2006, The Perl Foundation.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut
