/*
** var.ops
*/

VERSION = PARROT_VERSION;

=head1 NAME

var.ops - Variable Ops

=head1 DESCRIPTION

These operations deal with both lexical and global variables,
as well as the symbol tables that contain them.

=cut

###############################################################################

=head2 Lexical variable ops

Operations to create, modify and delete lexical variables.

=over 4

=cut

########################################

=item B<store_lex>(in STR, in PMC)

Store object $2 as lexical symbol $1. The opcode might succeed
or throw an exception on unknown lexical names depending on the
implementation of the LexPad PMC.
Parrot's LexPad throws an exception for unknown names.


=cut

op store_lex(in STR, in PMC) {
    parrot_context_t *ctx = CONTEXT(interpreter->ctx);
    STRING *lex_name = $1;
    PMC *lex_pad = Parrot_find_pad(interpreter, lex_name, ctx);
    if (PMC_IS_NULL(lex_pad)) {
	real_exception(interpreter, NULL, LEX_NOT_FOUND,
		"Lexical '%Ss' not found", lex_name);
    }
    VTABLE_set_pmc_keyed_str(interpreter, lex_pad, lex_name, $2);
    goto NEXT();
}

########################################

=item B<find_lex>(out PMC, in STR)

Find the lexical variable named $2 and store it in $1. This
opcode either throws an exception or returns a Null PMC for the failure case,
depending on the implementation of the LexPad PMC. Parrot's
standard LexPad throws and exception for non-existing names.

=cut

op find_lex(out PMC, in STR) {
    parrot_context_t *ctx = CONTEXT(interpreter->ctx);
    STRING *lex_name = $2;
    PMC *result = NULL;
    PMC *lex_pad = Parrot_find_pad(interpreter, lex_name, ctx);
    if (!PMC_IS_NULL(lex_pad))
	result = VTABLE_get_pmc_keyed_str(interpreter, lex_pad, lex_name);
    if (!result) {
	real_exception(interpreter, NULL, LEX_NOT_FOUND,
		"Lexical '%Ss' not found", lex_name);
    }
    $1 = result;
    goto NEXT();
}


=back

=cut

###############################################################################

=head2 Global variable ops

Operations to modify global variables

=over 4

=cut

########################################

=item B<store_global>(in STR, in PMC)

Store global $2 as global symbol $1

=item B<store_global>(in STR, in STR, in PMC)

Store global $3 as global symbol $2 in namespace $1. If namespace $1 doesn't
exist it is created.

=item B<store_global>(in PMC, in STR, in PMC)

Store global $3 as global symbol $2 in namespace $1.


=cut

op store_global(in STR, in PMC) {
    Parrot_store_global(interpreter, NULL, $1, $2);
    goto NEXT();
}

op store_global(in STR, in STR, in PMC) {
    Parrot_store_global(interpreter, $1, $2, $3);
    goto NEXT();
}

op store_global(in PMC, in STR, in PMC) {
    VTABLE_set_pmc_keyed_str(interpreter, $1, $2, $3);
    goto NEXT();
}

########################################

=item B<find_global>(out PMC, in STR)

Find the global named $2 and store it in $1. If the global doesn't exist
either throws an exception or sets $1 to the Null PMC, depending on current
errors settings. See B<errorson>.

=item B<find_global>(out PMC, in STR, in STR)

Find the global named $3 in namespace $2 and store it in $1. If the
global doesn't exist either throws an exception or sets $1 to the Null PMC,
depending on current errors settings. See B<errorson>.

If $3 is NULL the namespace hash for namespace $2 is returned.

=item B<find_global>(out PMC, in PMC, in STR)

Find the global named $3 in the namespace specified by $2
and store it in $1. If the global doesn't exist either throws an
exception or sets $1 to the Null PMC, depending on current errors settings.
See B<errorson>.

=cut

op find_global(out PMC, in STR) {
    opcode_t * next;
    if (!$2)
	internal_exception(1, "Tried to get null global.");

    next = expr NEXT();
    $1 = Parrot_get_global(interpreter, NULL, $2, next);
    goto NEXT();
}

op find_global(out PMC, in STR, in STR) {
    opcode_t * next;
    if (!$2)
	internal_exception(1, "Tried to get null class.");

    next = expr NEXT();
    $1 = Parrot_get_global(interpreter, $2, $3, next);
    goto NEXT();
}

op find_global(out PMC, in PMC, in STR) {
    opcode_t * next;
    if (PMC_IS_NULL($2))
	internal_exception(1, "Tried to get from null namespace.");
    if (!$3)
	internal_exception(1, "Tried to get null global.");

    next = expr NEXT();
    $1 = Parrot_get_global_p(interpreter, $2, $3);
    goto NEXT();
}

=item B<find_name>(out PMC, in STR)

Find the name $2 in lexical, current, global, or builtin namespace and
store it in $1. If the name doesn't exist
either throws an exception or sets $1 to PMCNULL, depending on current
errors settings. See B<errorson>.

=cut

op find_name(out PMC, in STR) {
    opcode_t * next;
    if (!$2)
	internal_exception(1, "Tried to get null name");

    next = expr NEXT();
    $1 = Parrot_get_name(interpreter, $2);
    goto NEXT();
}

=back

=cut

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2001-2004 The Perl Foundation.  All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut
