/*
Copyright (C) 2001-2007, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/timer.pmc - Timer

=head1 SYNOPSIS

    new P0, 'Timer'
    set P0[.PARROT_TIMER_SEC],     I_seconds       # whole seconds
    set P0[.PARROT_TIMER_USEC],    I_micro seconds # and/or micro seconds
    set P0[.PARROT_TIMER_NSEC],    N_seconds_frac  # or fraction in seconds
    set P0[.PARROT_TIMER_REPEAT],  I_repeat        # 0 = one shot ...
    set P0[.PARROT_TIMER_HANDLER], P_sub           # set handler sub PMC
    invoke P0                                      # start timer
    set P0[.PARROT_TIMER_RUNNING], 1               # same

    new P0, 'Timer', P1                            # set everything

    set I0, P0[.PARROT_TIMER_SEC]                  # query current timer status
    set N0, P0[.PARROT_TIMER_NSEC]
    ...
    set P0[.PARROT_TIMER_RUNNING], 0               # turn timer off


=head1 DESCRIPTION

This is the Timer base class

Running timers are kept in a linked list. Each timer has a tick count,
which gets decremented if the system timer expires. If the tick count
reaches zero, the timer handler gets invoked via Parrot's event handling
code.

The Timer resolution is operating system dependent. It's only guaranteed
that the Timer will fire some time after the programmed interval.

The Timer stops after invoking the handler (repeat + 1) times. To create a
Timer that will run forever, set "repeat" to -1. Turning the Timer off
preserves set values; the Timer is not destroyed.

When setting both C<PARROT_TIMER_SEC> and C<PARROT_TIMER_USEC> it must
be done in that sequence, whole seconds first. If a timer is constructed
with an initializer and it should be run immediately, the
C<PARROT_TIMER_RUNNING> value has to be in the last key of the
initializer.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

/* interface constants */
/* &gen_from_enum(timer.pasm) */
typedef enum {
    PARROT_TIMER_SEC,
    PARROT_TIMER_USEC,
    PARROT_TIMER_NSEC,
    PARROT_TIMER_REPEAT,
    PARROT_TIMER_RUNNING,
    PARROT_TIMER_HANDLER,
    PARROT_TIMER_MAX
} parrot_timer_enum_t;
/* &end_gen */

/*

=item C<static void
add_timer(PARROT_INTERP, PMC *pmc)>

Adds a new timer event to the event queue.

=cut

*/

static void
add_timer(PARROT_INTERP, NOTNULL(PMC *pmc))
{
    const parrot_timer_event * const t = (parrot_timer_event *)PMC_data(pmc);

    if (!PMC_IS_NULL(t->sub))
        Parrot_new_timer_event(interp, pmc, t->abs_time,
            t->interval, t->repeat, t->sub, EVENT_TYPE_TIMER);
}

/*

=item C<static void
del_timer(PARROT_INTERP, PMC *pmc)>

Deletes the timer event.

=cut

*/

static void
del_timer(PARROT_INTERP, NOTNULL(PMC *pmc))
{
   Parrot_del_timer_event(interp, pmc);
}


pmclass Timer does event need_ext {

/*

=item C<void init()>

Initializes the timer.

=cut

*/

    void init() {
        /*
         * t->abs_time actually is relative, its converted to an
         * absolute time, when the timer is started
         */
        parrot_timer_event * const t = mem_allocate_zeroed_typed(parrot_timer_event);
        PMC_data(SELF)               = t;
        PObj_active_destroy_SET(SELF);
        ++INTERP->arena_base->num_early_DOD_PMCs;
    }

/*

=item C<void init_pmc(PMC *init)>

See F<docs/pdds/pdd02_vtables.pod> for initializers.

=cut

*/

    void init_pmc(PMC *init) {
        const INTVAL n = VTABLE_get_integer(INTERP, init);
        INTVAL       i;

        SELF.init();

        for (i = 0; i < n; i += 2) {
            const INTVAL key = VTABLE_get_integer_keyed_int(INTERP, init, i);
            switch (key) {
                case PARROT_TIMER_SEC:
                case PARROT_TIMER_USEC:
                case PARROT_TIMER_REPEAT:
                case PARROT_TIMER_RUNNING:
                    {
                    const INTVAL val = VTABLE_get_integer_keyed_int(INTERP, init, i+1);
                    SELF.set_integer_keyed_int(key, val);
                    }
                    break;
                case PARROT_TIMER_NSEC:
                    {
                    const FLOATVAL nval = VTABLE_get_number_keyed_int(INTERP, init, i+1);
                    SELF.set_number_keyed_int(key, nval);
                    }
                    break;
                case PARROT_TIMER_HANDLER:
                    {
                    PMC * const pval = VTABLE_get_pmc_keyed_int(INTERP, init, i+1);
                    SELF.set_pmc_keyed_int(key, pval);
                    }
                    break;
                default:
                    break;
            }
        }
    }

/*

=item C<void destroy()>

Destroys the timer.

=cut

*/

    void destroy() {
        parrot_timer_event * const t = (parrot_timer_event *)PMC_data(SELF);
        del_timer(INTERP, SELF);
        mem_sys_free(t);
    }

/*

=item C<INTVAL get_integer_keyed_int(INTVAL key)>

Returns the timer info for C<key>.

=cut

*/

    INTVAL get_integer_keyed_int(INTVAL key) {
        const parrot_timer_event * const t = (parrot_timer_event *)PMC_data(SELF);

        switch (key) {
            case PARROT_TIMER_SEC:
                return (INTVAL)t->abs_time;
            case PARROT_TIMER_USEC:
                return (INTVAL)((t->abs_time - (INTVAL)t->abs_time) *1000000.0);
            case PARROT_TIMER_REPEAT:
                return (INTVAL) t->repeat;
            case PARROT_TIMER_RUNNING:
                return 0;
            default:
                return -1;
        }
    }

/*

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Returns the PMC associated with C<key>.

=cut

*/

    PMC *get_pmc_keyed_int(INTVAL key) {
        const parrot_timer_event * const t = (parrot_timer_event *)PMC_data(SELF);

        if (key == PARROT_TIMER_HANDLER)
            return t->sub;

        return PMCNULL;
    }

/*

=item C<FLOATVAL get_number_keyed_int(INTVAL key)>

Returns the number associated with C<key>.

=cut

*/

    FLOATVAL get_number_keyed_int(INTVAL key) {
        const parrot_timer_event * const t = (parrot_timer_event *)PMC_data(SELF);

        if (key == PARROT_TIMER_NSEC)
            return t->abs_time;

        return -1.0;
    }

/*

=item C<void set_integer_keyed_int(INTVAL key, INTVAL value)>

Sets the value associated with C<key> to C<value>.

=cut

*/

    void set_integer_keyed_int(INTVAL key, INTVAL value) {
        parrot_timer_event * const t = (parrot_timer_event *)PMC_data(SELF);

        switch (key) {
            case PARROT_TIMER_SEC:
                t->abs_time = value;
                break;
            case PARROT_TIMER_USEC:
                t->abs_time += value / 1000000.0;
                break;
            case PARROT_TIMER_REPEAT:
                t->repeat = value;
                break;
            case PARROT_TIMER_RUNNING:
                if (value)
                    add_timer(INTERP, SELF);
                else
                    del_timer(INTERP, SELF);
                break;
            default:
                real_exception(INTERP, NULL, INVALID_OPERATION,
                    "Unknown timer type in Timer.set_integer_keyed_int: %d",
                    key);
        }
    }

/*

=item C<void set_pmc_keyed_int(INTVAL key, PMC *value)>

Sets the PMC associated with C<key> to C<*value>.

=cut

*/

    void set_pmc_keyed_int(INTVAL key, PMC *value) {
        parrot_timer_event * const t = (parrot_timer_event *)PMC_data(SELF);

        if (key == PARROT_TIMER_HANDLER)
            t->sub = value;
    }

/*

=item C<opcode_t *invoke(void *next)>

Adds the timer to the event queue.

=cut

*/

    opcode_t *invoke(void *next) {
        add_timer(INTERP, SELF);
        return (opcode_t *)next;
    }

/*

=item C<void set_number_keyed_int(INTVAL key, FLOATVAL value)>

Sets the floating-point value associated with C<key> to C<value>.

=cut

*/

    void set_number_keyed_int(INTVAL key, FLOATVAL value) {
        parrot_timer_event * const t = (parrot_timer_event *)PMC_data(SELF);

        if (key == PARROT_TIMER_NSEC)
            t->abs_time = value;
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
