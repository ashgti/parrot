/*
Copyright (C) 2009, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/callsignaturereturns.pmc - resizable array for typed pointers

=head1 DESCRIPTION

This class stores typed pointers used to fill results in CallSignature.


=head1 SYNOPSIS

  # VTABLEs are too tight to implement something more beautiful

  # Create signature
  rets = new CallSignatureReturns
  rets.set_pointer_keyed_int(0, &intval);
  rest.push_integer(PARROT_ARG_INTVAL);

  rets.set_pointer_keyed_int(1, &floatval);
  rest.push_integer(PARROT_ARG_FLOATVAL);

  rets.set_pointer_keyed_int(2, &string);
  rest.push_integer(PARROT_ARG_STRING);

  rets.set_pointer_keyed_int(3, &pmc);
  rest.push_integer(PARROT_ARG_PMC);

  # Fill
  rets.set_integer_keyed_int(intval, 0);
  rets.set_number_keyed_int(floatval, 1);
  rets.set_string_keyed_int(string, 2);
  rets.set_pmc_keyed_int(pmc, 3);

CallSignatureReturns will behave like CPointer with autocasting values.

Up to 8 returns use FixedSizeAllocator. Switch to malloc/free after.

=head2 Functions

=over 4

=cut

*/

static void **
allocate_initial_values(PARROT_INTERP, ARGIN(PMC *SELF))
{
    void **values = (void **)Parrot_gc_allocate_fixed_size_storage(interp,
                                 8 * sizeof (void *));

    SETATTR_CallSignatureReturns_resize_threshold(interp, SELF, 8);
    return values;
}


/* mask off lower two bits (1 + 2 = 3) for pointer tags */
#define TAG_BITS 3
#define UNTAG_CELL(c) INTVAL2PTR(void *, (PTR2INTVAL(c)) & ~TAG_BITS)
#define CELL_TYPE_MASK(c) (PTR2INTVAL(c)) & TAG_BITS

pmclass CallSignatureReturns auto_attrs provides array {
    ATTR void     **values;             /* stored pointers */
    ATTR INTVAL     size;               /* number of stored elements */
    ATTR INTVAL     resize_threshold;   /* max size before resizing array */

/*

=item C<void init()>

Initialize the CallSignatureReturns PMC.

=cut

*/

    VTABLE void init() {
        PObj_custom_destroy_SET(SELF);
    }


/*

=item C<void destroy()>

Destroy CallSignatureReturns.

=cut

*/

    VTABLE void destroy() {
        void    **values;

        GET_ATTR_values(INTERP, SELF, values);

        if (values) {
            INTVAL    resize_threshold;
            GET_ATTR_resize_threshold(INTERP, SELF, resize_threshold);

            if (resize_threshold == 8)
                Parrot_gc_free_fixed_size_storage(INTERP,
                    8 * sizeof (void *), values);
            else
                mem_sys_free(values);
        }
    }


/*

=item C<void set_integer_native(INTVAL size)>

Resizes the array to C<size> elements.

=cut

*/

    VTABLE void set_integer_native(INTVAL size) {
        void    **values = NULL;
        INTVAL    resize_threshold;

        GET_ATTR_values(INTERP, SELF, values);
        GET_ATTR_resize_threshold(INTERP, SELF, resize_threshold);

        /* Empty. Allocate 8 elements (arbitary number) */
        if (!values) {
            values = allocate_initial_values(INTERP, SELF);
            SET_ATTR_values(INTERP, SELF, values);
            SET_ATTR_size(INTERP, SELF, size);
        }
        else if (size <= resize_threshold) {
            SET_ATTR_size(INTERP, SELF, size);
            return;
        }
        else {
            void   *old_values;
            INTVAL  cur = resize_threshold;

            /* Switch to system allocator */
            if (cur == 8) {
                old_values = values;
                values     = mem_allocate_n_typed(8, void *);
                memcpy(values, old_values, 8 * sizeof (void *));
            }

            if (cur < 8192)
                cur = size < 2 * cur ? 2 * cur : size;
            else {
                INTVAL needed = size - cur;
                cur          += needed + 4096;
                cur          &= ~0xfff;
            }

            mem_realloc_n_typed(values, cur, void *);

            SET_ATTR_values(INTERP, SELF, values);
            SET_ATTR_size(INTERP, SELF, size);
            SET_ATTR_resize_threshold(INTERP, SELF, cur);
        }
    }


/*

=item C<INTVAL elements()>

Returns the number of elements in the array.

=cut

*/

    VTABLE INTVAL elements() {
        INTVAL size;
        GET_ATTR_size(INTERP, SELF, size);
        return size;
    }


/*

=item C<void set_pointer_keyed_int(INTVAL key, void *value)>

Sets the pointer at position key.  The pointer should point to a storage
location for a return value -- it must be a pointer to an INTVAL, FLOATVAL,
PMC, or STRING storage location.

=cut

*/

    VTABLE void set_pointer_keyed_int(INTVAL key, void *value) {
        void   **values;
        INTVAL   size;

        GET_ATTR_values(INTERP, SELF, values);
        GET_ATTR_size(INTERP,   SELF, size);

        if (!values) {
            if (key < 8) {
                values = allocate_initial_values(INTERP, SELF);
                SET_ATTR_values(INTERP, SELF, values);
                SET_ATTR_size(INTERP, SELF, key + 1);
            }
            else {
                STATICSELF.set_integer_native(key + 1);
                GET_ATTR_values(INTERP, SELF, values);
            }
        }
        else if (key >= size)
            STATICSELF.set_integer_native(key + 1);

        values[key] = value;
    }

/*

=item C<void push_integer(INTVAL value)>

Set type of last pushed pointer.

=cut

*/

    VTABLE void push_integer(INTVAL type) {
        void  **values;
        INTVAL  idx;

        GET_ATTR_size(INTERP, SELF, idx);

        /* last index is size - 1, of course */
        idx--;

        PARROT_ASSERT((type >= 0 && type < 4) || !"Wrong pointer type");

        GET_ATTR_values(INTERP, SELF, values);

        values[idx] = INTVAL2PTR(void *,
            PTR2INTVAL(UNTAG_CELL(values[idx])) | type);
    }


/*

=item C<void set_integer_keyed_int(INTVAL key, INTVAL value)>

=item C<void set_number_keyed_int(INTVAL key, FLOATVAL value)>

=item C<void set_string_keyed_int(INTVAL key, STRING *value)>

=item C<void set_pmc_keyed_int(INTVAL key, PMC *value)>

Sets the value of the element at index C<key> to C<value>, casting if
necessary.

=cut

*/

    VTABLE void set_integer_keyed_int(INTVAL key, INTVAL value) {
        void *cell = STATICSELF.get_pointer_keyed_int(key);
        void *ptr  = UNTAG_CELL(cell);

        switch ((Call_bits_enum_t)CELL_TYPE_MASK(cell)) {
            case PARROT_ARG_INTVAL:
                *(INTVAL *)ptr = value;
                break;
            case PARROT_ARG_FLOATVAL:
                *(FLOATVAL *)ptr = value;
                break;
            case PARROT_ARG_STRING:
                *(STRING **)ptr = Parrot_str_from_int(INTERP, value);
                break;
            case PARROT_ARG_PMC:
                *(PMC **)ptr = get_integer_pmc(INTERP, value);
                break;
            default:
                PARROT_ASSERT(!"Impossible type");
        }
    }

    VTABLE void set_number_keyed_int(INTVAL key, FLOATVAL value) {
        void *cell = STATICSELF.get_pointer_keyed_int(key);
        void *ptr  = UNTAG_CELL(cell);

        switch ((Call_bits_enum_t)CELL_TYPE_MASK(cell)) {
            case PARROT_ARG_INTVAL:
                *(INTVAL *)ptr = value;
                break;
            case PARROT_ARG_FLOATVAL:
                *(FLOATVAL *)ptr = value;
                break;
            case PARROT_ARG_STRING:
                *(STRING **)ptr = Parrot_str_from_num(INTERP, value);
                break;
            case PARROT_ARG_PMC:
                *(PMC **)ptr = get_number_pmc(INTERP, value);
                break;
            default:
                PARROT_ASSERT(!"Impossible type");
        }
    }

    VTABLE void set_string_keyed_int(INTVAL key, STRING *value) {
        void *cell = STATICSELF.get_pointer_keyed_int(key);
        void *ptr  = UNTAG_CELL(cell);

        switch ((Call_bits_enum_t)CELL_TYPE_MASK(cell)) {
            case PARROT_ARG_INTVAL:
                *(INTVAL *)ptr = Parrot_str_to_int(INTERP, value);
                break;
            case PARROT_ARG_FLOATVAL:
                *(FLOATVAL *)ptr = Parrot_str_to_num(INTERP, value);
                break;
            case PARROT_ARG_STRING:
                *(STRING **)ptr = value;
                break;
            case PARROT_ARG_PMC:
                *(PMC **)ptr = STRING_IS_NULL(value) ?
                    PMCNULL :
                    get_string_pmc(INTERP, value);
                break;
            default:
                PARROT_ASSERT(!"Impossible type");
        }
    }

    VTABLE void set_pmc_keyed_int(INTVAL key, PMC *value) {
        void *cell = STATICSELF.get_pointer_keyed_int(key);
        void *ptr  = UNTAG_CELL(cell);

        switch ((Call_bits_enum_t)CELL_TYPE_MASK(cell)) {
            case PARROT_ARG_INTVAL:
                *(INTVAL *)ptr = VTABLE_get_integer(INTERP, value);
                break;
            case PARROT_ARG_FLOATVAL:
                *(FLOATVAL *)ptr = VTABLE_get_number(INTERP, value);
                break;
            case PARROT_ARG_STRING:
                *(STRING **)ptr = VTABLE_get_string(INTERP, value);
                break;
            case PARROT_ARG_PMC:
                *(PMC **)ptr = value;
                break;
            default:
                PARROT_ASSERT(!"Impossible type");
        }
    }

/*

=item C<void *get_string_keyed_int(INTVAL key)>

Gets raw pointer for result.

=cut

*/

    VTABLE STRING *get_string_keyed_int(INTVAL key) {
        void *cell  = STATICSELF.get_pointer_keyed_int(key);
        void *ptr   = UNTAG_CELL(cell);
        return (STRING *)ptr;
    }


/*

=item C<void *get_pointer_keyed_int(INTVAL key)>

Gets raw pointer for result.

=cut

*/

    VTABLE void *get_pointer_keyed_int(INTVAL key) {
        void   **values;
        INTVAL   size;

        GET_ATTR_size(INTERP, SELF, size);
        PARROT_ASSERT((key < size) || !"Wrong index");

        GET_ATTR_values(INTERP, SELF, values);
        return values[key];
    }
}


/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd03_calling_conventions.pod>.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
