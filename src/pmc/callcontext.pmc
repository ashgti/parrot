/*
Copyright (C) 2001-2009, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/callcontext.pmc - Interpreter Context.

=head1 DESCRIPTION

Stores context of execution. Currently we store pointer to Parrot_Context
structure in PMC_data.

=head2 Vtable Functions

=over 4

=cut

*/


#include "parrot/packfile.h"
#include "pmc_sub.h"

/* mask off lower two bits (1 + 2 = 3) for pointer tags */
#define TAG_BITS 3
#define UNTAG_CELL(c) INTVAL2PTR(Pcc_cell *, (PTR2INTVAL(c)) & ~TAG_BITS)

#define CELL_INT(c)     UNTAG_CELL(c)->u.i
#define CELL_FLOAT(c)   UNTAG_CELL(c)->u.n
#define CELL_STRING(c)  UNTAG_CELL(c)->u.s
#define CELL_PMC(c)     UNTAG_CELL(c)->u.p

#define NEXT_CELL(c) UNTAG_CELL(c)->next
#define FREE_CELL(i, c) \
    Parrot_gc_free_fixed_size_storage((i), sizeof (Pcc_cell), (UNTAG_CELL(c)))

#define CELL_TYPE_MASK(c) (PTR2INTVAL(c)) & 3
#define INTCELL    0
#define FLOATCELL  1
#define STRINGCELL 2
#define PMCCELL    3

#define SET_CELL_INT(c) \
        INTVAL2PTR(Pcc_cell *, PTR2INTVAL(UNTAG_CELL(c)) | INTCELL)

#define SET_CELL_FLOAT(c) \
        INTVAL2PTR(Pcc_cell *, PTR2INTVAL(UNTAG_CELL(c)) | FLOATCELL)

#define SET_CELL_STRING(c) \
        INTVAL2PTR(Pcc_cell *, PTR2INTVAL(UNTAG_CELL(c)) | STRINGCELL)

#define SET_CELL_PMC(c) \
        INTVAL2PTR(Pcc_cell *, PTR2INTVAL(UNTAG_CELL(c)) | PMCCELL)

#define ALLOC_CELL(i) \
    (Pcc_cell *)Parrot_gc_allocate_fixed_size_storage((i), sizeof (Pcc_cell))

#define INIT_CELL_INT(c)    INTVAL2PTR(Pcc_cell *, PTR2INTVAL(c) | INTCELL)
#define INIT_CELL_FLOAT(c)  INTVAL2PTR(Pcc_cell *, PTR2INTVAL(c) | FLOATCELL)
#define INIT_CELL_STRING(c) INTVAL2PTR(Pcc_cell *, PTR2INTVAL(c) | STRINGCELL)
#define INIT_CELL_PMC(c)    INTVAL2PTR(Pcc_cell *, PTR2INTVAL(c) | PMCCELL)

#define CREATE_INTVAL_CELL(i)   INIT_CELL_INT(ALLOC_CELL(i))

#define CREATE_FLOATVAL_CELL(i) INIT_CELL_FLOAT(ALLOC_CELL(i))

#define CREATE_STRING_CELL(i)   INIT_CELL_STRING(ALLOC_CELL(i))

#define CREATE_PMC_CELL(i)      INIT_CELL_PMC(ALLOC_CELL(i))

#define APPEND_CELL(SELF, cell) \
    do { \
        Parrot_Context * const a = PMC_data_typed(SELF, Parrot_Context*); \
        NEXT_CELL(cell) = NULL; \
        (a)->num_positionals++; \
        if ((a)->positionals) { \
            Pcc_cell *c = (a)->positionals; \
            while (NEXT_CELL(c)) { \
                c = NEXT_CELL(c); \
            } \
            NEXT_CELL(c) = (cell); \
        } \
        else \
            (a)->positionals = (cell); \
    } while (0)

#define PREPEND_CELL(SELF, cell) \
    do { \
        Parrot_Context * const a = PMC_data_typed(SELF, Parrot_Context*); \
        a->num_positionals++; \
        NEXT_CELL(cell) = a->positionals; \
        a->positionals  = (cell); \
    } while (0)

/* TODO: could use get_cell_at */
static Pcc_cell *
pop_cell(PARROT_INTERP, ARGIN(PMC *SELF))
{
    Parrot_Context * const attrs = PMC_data_typed(SELF, Parrot_Context*);
    Pcc_cell *cell = attrs->positionals;
    Pcc_cell *prev = NULL;

    /* no cells */
    if (!cell)
        return NULL;

    attrs->num_positionals--;

    /* one cell */
    if (!NEXT_CELL(cell)) {
        attrs->positionals = NULL;
        return cell;
    }

    while (cell) {
        if (!NEXT_CELL(cell)) {
            NEXT_CELL(prev) = NULL;
            return cell;
        }

        prev = cell;
        cell = NEXT_CELL(cell);
    }

    /* should abort here */
    attrs->num_positionals++;
    return NULL;
}

static Pcc_cell *
shift_cell(PARROT_INTERP, ARGIN(PMC *SELF))
{
    Parrot_Context * const attrs = PMC_data_typed(SELF, Parrot_Context*);
    Pcc_cell *cell = attrs->positionals;

    /* no cells */
    if (!cell)
        return NULL;

    attrs->num_positionals--;

    /* one cell */
    if (!NEXT_CELL(cell))
        attrs->positionals = NULL;
    else
        attrs->positionals = NEXT_CELL(cell);

    return cell;
}

static Pcc_cell *
get_cell_at(PARROT_INTERP, ARGIN(PMC *SELF), INTVAL key)
{
    Parrot_Context * const attrs = PMC_data_typed(SELF, Parrot_Context*);
    Pcc_cell *cell = attrs->positionals;
    INTVAL    i;

    if (key > attrs->num_positionals)
        return NULL;

    while (key) {
        /* XXX: shouldn't happen */
        if (!NEXT_CELL(cell))
            return NULL;

        cell = NEXT_CELL(cell);
        key--;
    }

    return cell;

}

static INTVAL
autobox_intval(PARROT_INTERP, Pcc_cell *cell)
{
    switch (CELL_TYPE_MASK(cell)) {
        case INTCELL:
            return CELL_INT(cell);
        case FLOATCELL:
            return (INTVAL)CELL_FLOAT(cell);
        case STRINGCELL:
            return CELL_STRING(cell) ? Parrot_str_to_int(interp, CELL_STRING(cell)) : 0;
        case PMCCELL:
            return PMC_IS_NULL(CELL_PMC(cell))
                    ? 0
                    : VTABLE_get_integer(interp, CELL_PMC(cell));
        default:
            break;
    }

    /* exception */
    return 0;
}

static FLOATVAL
autobox_floatval(PARROT_INTERP, Pcc_cell *cell)
{
    switch (CELL_TYPE_MASK(cell)) {
        case INTCELL:
            return (FLOATVAL)CELL_INT(cell);
        case FLOATCELL:
            return CELL_FLOAT(cell);
        case STRINGCELL:
            return CELL_STRING(cell) ? Parrot_str_to_num(interp, CELL_STRING(cell)) : 0.0;
        case PMCCELL:
            return PMC_IS_NULL(CELL_PMC(cell))
                    ? 0.0
                    : VTABLE_get_number(interp, CELL_PMC(cell));
        default:
            break;
    }

    /* exception */
    return 0.0;
}

static STRING *
autobox_string(PARROT_INTERP, Pcc_cell *cell)
{
    switch (CELL_TYPE_MASK(cell)) {
        case INTCELL:
            return Parrot_str_from_int(interp, CELL_INT(cell));
        case FLOATCELL:
            return Parrot_str_from_num(interp, CELL_FLOAT(cell));
        case STRINGCELL:
            return CELL_STRING(cell);
        case PMCCELL:
            return PMC_IS_NULL(CELL_PMC(cell))
                    ? NULL
                    : VTABLE_get_string(interp, CELL_PMC(cell));
        default:
            break;
    }

    /* exception */
    return NULL;
}

static PMC *
autobox_pmc(PARROT_INTERP, Pcc_cell *cell)
{
    PMC *result = PMCNULL;

    /* TODO: respect HLL types? */
    switch (CELL_TYPE_MASK(cell)) {
        case INTCELL:
            result = pmc_new(interp, enum_class_Integer);
            VTABLE_set_integer_native(interp, result, CELL_INT(cell));
            break;
        case FLOATCELL:
            result = pmc_new(interp, enum_class_Float);
            VTABLE_set_number_native(interp, result, CELL_FLOAT(cell));
            break;
        case STRINGCELL:
            result = pmc_new(interp, enum_class_String);
            VTABLE_set_string_native(interp, result, CELL_STRING(cell));
            break;
        case PMCCELL:
            return CELL_PMC(cell);
        default:
            /* exception */
            break;
    }

    return result;
}

static Hash *
get_hash(PARROT_INTERP, ARGIN(PMC *SELF))
{
    Parrot_Context * const attrs = PMC_data_typed(SELF, Parrot_Context*);

    if (!attrs->hash)
        attrs->hash = parrot_new_hash(interp);

    return attrs->hash;
}

static void
mark_positionals(PARROT_INTERP, ARGIN(Pcc_cell *c))
{
    while (c) {
        switch (CELL_TYPE_MASK(c)) {
            case STRINGCELL:
                if (CELL_STRING(c))
                    Parrot_gc_mark_STRING_alive(interp, CELL_STRING(c));
                break;
            case PMCCELL:
                if (!PMC_IS_NULL(CELL_PMC(c)))
                    Parrot_gc_mark_PMC_alive(interp, CELL_PMC(c));
                break;
            case INTCELL:
            case FLOATCELL:
            default:
                break;
        }

        c = NEXT_CELL(c);
    }
}

/* don't look now, but here goes encapsulation.... */
static void
mark_hash(PARROT_INTERP, ARGIN(Hash *h))
{
    UINTVAL entries = h->entries;
    INTVAL  i;

    for (i = h->mask; i >= 0; --i) {
        HashBucket *b = h->bi[i];

        while (b) {
            Parrot_gc_mark_STRING_alive(interp, (STRING *)b->key);
            mark_positionals(interp, (Pcc_cell *)b->value);
            b = b->next;
        }

    }
}

static PMC *
get_named_names(PARROT_INTERP, ARGIN(PMC *SELF))
{
    Parrot_Context * const attrs = PMC_data_typed(SELF, Parrot_Context*);
    PMC *result = PMCNULL;

    /* yes, this *looks* risky, but it's a Parrot STRING hash internally */
    if (attrs->hash && attrs->hash->entries) {
        UINTVAL i, j = 0;
        result  = pmc_new(interp, enum_class_FixedStringArray);
        VTABLE_set_integer_native(interp, result, attrs->hash->entries);

        for (i = 0; i <= attrs->hash->mask; i++) {
            HashBucket *b = attrs->hash->bi[i];

            while (b) {
                VTABLE_set_string_keyed_int(interp, result,
                    j++, (STRING *)b->key);
                b = b->next;
            }
        }
    }

    return result;
}

pmclass CallContext {

/*

=item C<void init()>

Initialize new Context. See C<Parrot_alloc_context>.

=cut

*/

    VTABLE void init() {
        PMC_data(SELF) = NULL;
        PObj_custom_mark_destroy_SETALL(SELF);
    }


/*

=item C<void mark()>

Mark Context as alive.

=cut

*/

    VTABLE void mark()
    {
        Parrot_Context * const ctx = PMC_data_typed(SELF, Parrot_Context*);
        UINTVAL i;

        /* If Context wasn't initialised just return */
        if (!ctx)
            return;

        Parrot_gc_mark_PMC_alive(INTERP, ctx->caller_ctx);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->lex_pad);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->outer_ctx);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->current_sub);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->handlers);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->current_cont);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->current_object);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->current_namespace);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->results_signature);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->current_sig);

        Parrot_gc_mark_PMC_alive(INTERP, ctx->results);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->type_tuple);
        Parrot_gc_mark_STRING_alive(INTERP, ctx->short_sig);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->arg_flags);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->return_flags);
        if (ctx->hash)
            mark_hash(INTERP, ctx->hash);

        if (ctx->positionals)
            mark_positionals(INTERP, ctx->positionals);

        if (!ctx->n_regs_used)
            return;

        for (i = 0; i < ctx->n_regs_used[REGNO_PMC]; ++i) {
            PMC *p = ctx->bp_ps.regs_p[-1L-(i)];
            /* Original code from CTX_REG_PMC */
            if (p)
                Parrot_gc_mark_PMC_alive(interp, p);
        }

        for (i = 0; i < ctx->n_regs_used[REGNO_STR]; ++i) {
            STRING *s = ctx->bp_ps.regs_s[i];
            if (s)
                Parrot_gc_mark_STRING_alive(interp, s);
        }
    }

/*

=item C<void destroy()>

Destroy Context and memory allocated by C<Parrot_alloc_context>.

=cut

*/

    VTABLE void destroy() {
        /* We own this pointer */
        Parrot_Context * const ctx = PMC_data_typed(SELF, Parrot_Context*);

        if (!ctx)
            return;

        if (ctx->num_positionals) {
            Pcc_cell *c = ctx->positionals;

            while (c) {
                Pcc_cell *to_free = c;
                c = NEXT_CELL(c);
                FREE_CELL(interp, to_free);
            }
        }

        if (ctx->hash) {
            UINTVAL i;

            for (i = 0; i <= ctx->hash->mask; i++) {
                HashBucket *b = ctx->hash->bi[i];

                while (b) {
                    FREE_CELL(interp, (Pcc_cell *)b->value);
                    b = b->next;
                }
            }

            parrot_hash_destroy(interp, ctx->hash);
        }

        Parrot_gc_free_fixed_size_storage(interp,
                Parrot_pcc_calculate_context_size(INTERP, ctx->n_regs_used),
                ctx);

        PMC_data(SELF) = NULL;
    }

/*

=item C<void *get_pointer()>

Return pointer to underlying Parrot_Context structure.

=cut

*/

    VTABLE void *get_pointer() {
        return PMC_data(SELF);
    }

/*

=item C<void set_pointer(void *)>

Set new Parrot_Context structure.

=cut

*/
    VTABLE void set_pointer(void *context) {
        PMC_data(SELF) = context;
    }

/*

=item C<PMC *get_pmc_keyed_str(STRING *key)>

Introspection interface. C<key> can be:

    caller_ctx          ... return Caller Context
    lex_pad             ... return LexPad
    outer_ctx           ... return Outer Context
    current_sub         ... return current Sub
    handlers            ... return list of ExceptioHandlers
    current_cont        ... return current Continuation
    current_object      ... return current Object (if in method call)
    current_namespace   ... return current Namespace
=cut

*/
    VTABLE PMC *get_pmc_keyed_str(STRING *key) {
        Parrot_Context *ctx = PMC_data_typed(SELF, Parrot_Context*);

        if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "caller_ctx")))
            return ctx->caller_ctx;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "lex_pad")))
            return ctx->lex_pad;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "outer_ctx")))
            return ctx->outer_ctx;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_sub")))
            return ctx->current_sub;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_cont")))
            return ctx->current_cont;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_object")))
            return ctx->current_object;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_namespace")))
            return ctx->current_namespace;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "handlers")))
            return ctx->handlers;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "results_signature")))
            return ctx->results_signature;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_HLL")))
            /* This function from src/hash.c. */
            /* We probably have to move it to more suitable place */
            return get_integer_pmc(INTERP, ctx->current_HLL);
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_hll")))
            return get_string_pmc(INTERP, Parrot_get_HLL_name(INTERP, ctx->current_HLL));

        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_ATTRIB_NOT_FOUND,
                "No such item %Ss", key);
    }

    VTABLE PMC *get_pmc_keyed(PMC *key) {
        return STATICSELF.get_pmc_keyed_str(VTABLE_get_string(INTERP, key));
    }

/*

=item C<void set_string_native(STRING *value)>

Sets the short signature for the CallSignature.

=cut

*/

    VTABLE void set_string_native(STRING *value) {
        Parrot_Context * const attrs = PMC_data_typed(SELF, Parrot_Context*);
        attrs->short_sig = value;
    }

/*

=item C<STRING *get_string()>

Returns the short signature for the CallSignature.

=cut

*/

    VTABLE STRING *get_string() {
        Parrot_Context * const attrs = PMC_data_typed(SELF, Parrot_Context*);
        STRING   *res = attrs->short_sig;
        Pcc_cell *c   = attrs->positionals;

        if (res)
            return res;

        res = Parrot_str_new(INTERP, NULL, attrs->num_positionals);

        while (c) {
            switch (CELL_TYPE_MASK(c)) {
                case INTCELL:
                    res = Parrot_str_append(INTERP, res, CONST_STRING(INTERP, "I"));
                    break;
                case FLOATCELL:
                    res = Parrot_str_append(INTERP, res, CONST_STRING(INTERP, "N"));
                    break;
                case STRINGCELL:
                    res = Parrot_str_append(INTERP, res, CONST_STRING(INTERP, "S"));
                    break;
                case PMCCELL:
                    res = Parrot_str_append(INTERP, res, CONST_STRING(INTERP, "P"));
                    break;
                default:
                    PARROT_ASSERT(!"Impossible flag");
                    break;
            }
            c = NEXT_CELL(c);
        }
        /* TODO Add named args to signature */
        /* After fixind build_MMD_type_tuple to use raw arguments instead of signature */

        attrs->short_sig = res;

        return res;
    }

/*

=item C<void set_pmc(PMC *value)>

Sets a fixed-size array of integer types (a type tuple) for the CallSignature.

=cut

*/

    VTABLE void set_pmc(PMC *value) {
        Parrot_Context * const attrs = PMC_data_typed(SELF, Parrot_Context*);
        attrs->type_tuple = value;
    }

/*

=item C<PMC *get_pmc()>

Returns a fixed-size array of integer types (a type tuple) for the
CallSignature.

=cut

*/

    VTABLE PMC *get_pmc() {
        Parrot_Context * const attrs = PMC_data_typed(SELF, Parrot_Context*);

        if (PMC_IS_NULL(attrs->type_tuple)) {
            attrs->type_tuple = Parrot_mmd_build_type_tuple_from_sig_obj(INTERP, SELF);
        }

        return attrs->type_tuple;

    }

/*

=item C<void set_attr_str(STRING *key, PMC *value)>

Set a PMC value for an attribute by string name.

=over

=item results

Stores the return signature, an array of PMCs.

=item arg_flags

Stores a set of flags for the call signature arguments, an array of
integers.

=item return_flags

Stores a set of flags for the call signature return arguments, an array
of integers.

=back

=cut

*/

    VTABLE void set_attr_str(STRING *key, PMC *value) {
        Parrot_Context * const attrs = PMC_data_typed(SELF, Parrot_Context*);

        if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "results"))) {
            attrs->results = value;
        }
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "returns"))) {
            attrs->results = value;
        }
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "arg_flags"))) {
            attrs->arg_flags = value;
        }
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "return_flags"))) {
            attrs->return_flags = value;
        }
        else {
            /* If unknown attribute name, throw an exception. */
            Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_ATTRIB_NOT_FOUND,
                "No such attribute '%S'", key);
        }
    }

/*

=item C<PMC *get_attr_str(STRING *key)>

Get a PMC value for an attribute by string name.

=over

=item results

Retrieves the return signature, an array of PMCs.

=item arg_flags

Retrieves the flags for the call signature arguments, an array of
integers.

=item return_flags

Retrieves the flags for the call signature return arguments, an array of
integers.

=item named

Retrieves the hash of named arguments.

=back

=cut

*/

    VTABLE PMC *get_attr_str(STRING *key) {
        Parrot_Context *ctx = PMC_data_typed(SELF, Parrot_Context*);

        if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "named"))) {
            return get_named_names(INTERP, SELF);
        }
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "results"))) {
            return ctx->results;
        }
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "returns"))) {
            /* Yes, it's not a typo */
            return ctx->results;
        }
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "arg_flags"))) {
            return ctx->arg_flags;
        }
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "return_flags"))) {
            return ctx->return_flags;
        }
        else {
            /* If unknown attribute name, throw an exception. */
            Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_ATTRIB_NOT_FOUND,
                "No such attribute '%S'", key);
        }

        return PMCNULL;
    }

/*

=item C<PMC *backtrace>

Gets a representation of the backtrace starting from this Context.
Returns an array of hashes. Each array element represents a caller in
the backtrace, the most recent caller first. The hash has two keys: C<sub>,
which holds the PMC representing the sub, and C<annotations> which is a hash
of the annotations at the point where the exception was thrown for the current
sub, or for the point of the call a level deeper for the rest.

=cut

*/

    METHOD backtrace(PMC *resume :optional, INTVAL has_resume :opt_flag) {
        PMC *result  = pmc_new(interp, enum_class_ResizablePMCArray);
        PMC *cur_ctx = SELF;
        Parrot_Continuation_attributes *cont = has_resume ? PMC_cont(resume) : NULL;

        /* Get starting context, then loop over them. */
        while (cur_ctx) {
            PMC        *frame       = pmc_new(interp, enum_class_Hash);
            PMC        *annotations = NULL;
            Parrot_Sub_attributes *sub;

            /* Get sub and put it in the hash. */
            PMC *sub_pmc = Parrot_pcc_get_sub(interp, cur_ctx);

            if (!sub_pmc)
                sub_pmc = PMCNULL;

            VTABLE_set_pmc_keyed_str(interp, frame, CONST_STRING(interp, "sub"), sub_pmc);

            /* Look up any annotations and put them in the hash. */
            if (!PMC_IS_NULL(sub_pmc)) {
                PMC_get_sub(interp, sub_pmc, sub);

                if (sub->seg->annotations) {
                    PackFile_ByteCode *seg = sub->seg;
                    opcode_t          *pc  = cont && cur_ctx == cont->to_ctx
                                             ? cont->address
                                             : Parrot_pcc_get_pc(interp, cur_ctx);

                    annotations = PackFile_Annotations_lookup(interp,
                        seg->annotations, pc - seg->base.data,
                        NULL);
                }
            }

            if (!annotations)
                annotations = pmc_new(interp, enum_class_Hash);

            VTABLE_set_pmc_keyed_str(interp, frame, CONST_STRING(interp, "annotations"), annotations);

            /* Push frame and go to next caller. */
            VTABLE_push_pmc(interp, result, frame);
            cur_ctx = Parrot_pcc_get_caller_ctx(interp, cur_ctx);
        }

        RETURN(PMC *result);
    }

    VTABLE INTVAL elements() {
        Parrot_Context const * const attrs = PMC_data_typed(SELF, Parrot_Context*);
        if (!attrs)
            return 0;

        return attrs->num_positionals;
    }

    VTABLE void push_integer(INTVAL value) {
        Pcc_cell *cell = CREATE_INTVAL_CELL(interp);
        APPEND_CELL(SELF, cell);
        CELL_INT(cell) = value;
    }

    VTABLE void push_float(FLOATVAL value) {
        Pcc_cell *cell = CREATE_FLOATVAL_CELL(interp);
        APPEND_CELL(SELF, cell);
        CELL_FLOAT(cell) = value;
    }

    VTABLE void push_string(STRING *value) {
        Pcc_cell *cell = CREATE_STRING_CELL(interp);
        APPEND_CELL(SELF, cell);
        CELL_STRING(cell) = value;
    }

    VTABLE void push_pmc(PMC *value) {
        Pcc_cell *cell = CREATE_PMC_CELL(interp);
        APPEND_CELL(SELF, cell);
        CELL_PMC(cell) = value;
    }

    VTABLE INTVAL pop_integer() {
        Pcc_cell *cell = pop_cell(interp, SELF);

        if (cell) {
            INTVAL result = autobox_intval(interp, cell);
            FREE_CELL(interp, cell);
            return result;
        }

        return 0;
    }

    VTABLE FLOATVAL pop_float() {
        Pcc_cell *cell = pop_cell(interp, SELF);

        if (cell) {
            FLOATVAL result = autobox_floatval(interp, cell);
            FREE_CELL(interp, cell);
            return result;
        }

        return 0.0;
    }

    VTABLE PMC * pop_pmc() {
        Pcc_cell *cell = pop_cell(interp, SELF);

        if (cell) {
            PMC *result = autobox_pmc(interp, cell);
            FREE_CELL(interp, cell);
            return result;
        }

        return PMCNULL;
    }

    VTABLE STRING * pop_string() {
        Pcc_cell *cell = pop_cell(interp, SELF);

        if (cell) {
            STRING *result = autobox_string(interp, cell);
            FREE_CELL(interp, cell);
            return result;
        }

        return NULL;
    }

    VTABLE INTVAL get_integer_keyed_int(INTVAL key) {
        Pcc_cell *cell = get_cell_at(interp, SELF, key);

        if (!cell)
            return 0;

        return autobox_intval(interp, cell);
    }

    VTABLE FLOATVAL get_number_keyed_int(INTVAL key) {
        Pcc_cell *cell = get_cell_at(interp, SELF, key);

        if (!cell)
            return 0.0;

        return autobox_floatval(interp, cell);
    }

    VTABLE STRING * get_string_keyed_int(INTVAL key) {
        Pcc_cell *cell = get_cell_at(interp, SELF, key);

        if (!cell)
            return NULL;

        return autobox_string(interp, cell);
    }

    VTABLE PMC * get_pmc_keyed_int(INTVAL key) {
        Pcc_cell *cell = get_cell_at(interp, SELF, key);

        if (!cell)
            return PMCNULL;

        return autobox_pmc(interp, cell);
    }

    VTABLE void unshift_integer(INTVAL value) {
        Pcc_cell *cell = CREATE_INTVAL_CELL(interp);
        PREPEND_CELL(SELF, cell);
        CELL_INT(cell) = value;
    }

    VTABLE void unshift_float(FLOATVAL value) {
        Pcc_cell *cell = CREATE_FLOATVAL_CELL(interp);
        PREPEND_CELL(SELF, cell);
        CELL_FLOAT(cell) = value;
    }

    VTABLE void unshift_string(STRING *value) {
        Pcc_cell *cell = CREATE_STRING_CELL(interp);
        PREPEND_CELL(SELF, cell);
        CELL_STRING(cell) = value;
    }

    VTABLE void unshift_pmc(PMC *value) {
        Pcc_cell *cell = CREATE_PMC_CELL(interp);
        PREPEND_CELL(SELF, cell);
        CELL_PMC(cell) = value;
    }

    VTABLE INTVAL shift_integer() {
        Pcc_cell *cell = shift_cell(interp, SELF);

        if (cell) {
            INTVAL result = autobox_intval(interp, cell);
            FREE_CELL(interp, cell);
            return result;
        }

        return 0;
    }

    VTABLE FLOATVAL shift_float() {
        Pcc_cell *cell = shift_cell(interp, SELF);

        if (cell) {
            FLOATVAL result = autobox_floatval(interp, cell);
            FREE_CELL(interp, cell);
            return result;
        }

        return 0.0;
    }

    VTABLE STRING * shift_string() {
        Pcc_cell *cell = shift_cell(interp, SELF);

        if (cell) {
            STRING *result = autobox_string(interp, cell);
            FREE_CELL(interp, cell);
            return result;
        }

        return NULL;
    }

    VTABLE PMC * shift_pmc() {
        Pcc_cell *cell = shift_cell(interp, SELF);

        if (cell) {
            PMC *result = autobox_pmc(interp, cell);
            FREE_CELL(interp, cell);
            return result;
        }

        return PMCNULL;
    }

    VTABLE void set_integer_keyed_int(INTVAL key, INTVAL value) {
        Pcc_cell *cell = get_cell_at(interp, SELF, key);

        if (!cell) {
            Parrot_Context const * const attrs = PMC_data_typed(SELF, Parrot_Context*);
            if (key == attrs->num_positionals)
                VTABLE_push_integer(interp, SELF, value);

            /* XXX: else throw exception? */
            return;
        }

        CELL_INT(cell) = value;
    }

    VTABLE void set_number_keyed_int(INTVAL key, FLOATVAL value) {
        Pcc_cell *cell = get_cell_at(interp, SELF, key);

        if (!cell) {
            Parrot_Context const * const attrs = PMC_data_typed(SELF, Parrot_Context*);
            if (key == attrs->num_positionals)
                VTABLE_push_float(interp, SELF, value);

            /* XXX: else throw exception? */
            return;
        }

        CELL_FLOAT(cell) = value;
    }

    VTABLE void set_string_keyed_int(INTVAL key, STRING *value) {
        Pcc_cell *cell = get_cell_at(interp, SELF, key);

        if (!cell) {
            Parrot_Context const * const attrs = PMC_data_typed(SELF, Parrot_Context*);
            if (key == attrs->num_positionals)
                VTABLE_push_string(interp, SELF, value);

            /* XXX: else throw exception? */
            return;
        }

        CELL_STRING(cell) = value;
    }

    VTABLE void set_pmc_keyed_int(INTVAL key, PMC *value) {
        Pcc_cell *cell = get_cell_at(interp, SELF, key);

        if (!cell) {
            Parrot_Context const * const attrs = PMC_data_typed(SELF, Parrot_Context*);
            if (key == attrs->num_positionals)
                VTABLE_push_pmc(interp, SELF, value);

            /* XXX: else throw exception? */
            return;
        }

        CELL_PMC(cell) = value;
    }

    VTABLE void set_integer_keyed_str(STRING *key, INTVAL value) {
        Hash     *hash = get_hash(interp, SELF);
        Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, (void *)key);

        if (!cell) {
            cell = CREATE_INTVAL_CELL(interp);
            parrot_hash_put(interp, hash, (void *)key, (void *)cell);
            NEXT_CELL(cell) = NULL;
        }
        else
            SET_CELL_INT(cell);

        CELL_INT(cell) = value;
    }

    VTABLE void set_number_keyed_str(STRING *key, FLOATVAL value) {
        Hash     *hash = get_hash(interp, SELF);
        Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, (void *)key);

        if (!cell) {
            cell = CREATE_FLOATVAL_CELL(interp);
            parrot_hash_put(interp, hash, (void *)key, (void *)cell);
            NEXT_CELL(cell) = NULL;
        }
        else
            SET_CELL_FLOAT(cell);

        CELL_FLOAT(cell) = value;
    }

    VTABLE void set_string_keyed_str(STRING *key, STRING *value) {
        Hash     *hash = get_hash(interp, SELF);
        Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, (void *)key);

        if (!cell) {
            cell = CREATE_STRING_CELL(interp);
            parrot_hash_put(interp, hash, (void *)key, (void *)cell);
            NEXT_CELL(cell) = NULL;
        }
        else
            SET_CELL_STRING(cell);

        CELL_STRING(cell) = value;
    }

    VTABLE void set_pmc_keyed_str(STRING *key, PMC *value) {
        Hash     *hash = get_hash(interp, SELF);
        Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, (void *)key);

        if (!cell) {
            cell = CREATE_PMC_CELL(interp);
            parrot_hash_put(interp, hash, (void *)key, (void *)cell);
            NEXT_CELL(cell) = NULL;
        }
        else
            SET_CELL_PMC(cell);

        CELL_PMC(cell) = value;
    }

    VTABLE void set_integer_keyed(PMC *key, INTVAL value) {
        Hash     *hash = get_hash(interp, SELF);
        void     *k    = hash_key_from_pmc(interp, hash, key);
        Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, k);

        if (!cell) {
            cell = CREATE_INTVAL_CELL(interp);
            parrot_hash_put(interp, hash, k, (void *)cell);
            NEXT_CELL(cell) = NULL;
        }
        else
            SET_CELL_INT(cell);

        CELL_INT(cell) = value;
    }

    VTABLE void set_number_keyed(PMC *key, FLOATVAL value) {
        Hash     *hash = get_hash(interp, SELF);
        void     *k    = hash_key_from_pmc(interp, hash, key);
        Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, k);

        if (!cell) {
            cell = CREATE_FLOATVAL_CELL(interp);
            parrot_hash_put(interp, hash, k, (void *)cell);
            NEXT_CELL(cell) = NULL;
        }
        else
            SET_CELL_FLOAT(cell);

        CELL_FLOAT(cell) = value;
    }

    VTABLE void set_string_keyed(PMC *key, STRING *value) {
        Hash     *hash = get_hash(interp, SELF);
        void     *k    = hash_key_from_pmc(interp, hash, key);
        Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, k);

        if (!cell) {
            cell = CREATE_STRING_CELL(interp);
            parrot_hash_put(interp, hash, k, (void *)cell);
            NEXT_CELL(cell) = NULL;
        }
        else
            SET_CELL_STRING(cell);

        CELL_STRING(cell) = value;
    }

    VTABLE void set_pmc_keyed(PMC *key, PMC *value) {
        Hash     *hash = get_hash(interp, SELF);
        void     *k    = hash_key_from_pmc(interp, hash, key);
        Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, k);

        if (!cell) {
            cell = CREATE_PMC_CELL(interp);
            parrot_hash_put(interp, hash, k, (void *)cell);
            NEXT_CELL(cell) = NULL;
        }
        else
            SET_CELL_PMC(cell);

        CELL_PMC(cell) = value;
    }

    VTABLE INTVAL get_integer_keyed_str(STRING *key) {
        Hash *hash = get_hash(interp, SELF);

        if (hash) {
            void     *k    = hash_key_from_string(interp, hash, key);
            Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, k);

            if (cell)
                return autobox_intval(interp, cell);
        }

        return 0;
    }

    VTABLE FLOATVAL get_number_keyed_str(STRING *key) {
        Hash *hash = get_hash(interp, SELF);

        if (hash) {
            void     *k    = hash_key_from_string(interp, hash, key);
            Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, k);

            if (cell)
                return autobox_floatval(interp, cell);
        }

        return 0.0;
    }


    VTABLE STRING * get_string_keyed_str(STRING *key) {
        Hash *hash = get_hash(interp, SELF);

        if (hash) {
            void     *k    = hash_key_from_string(interp, hash, key);
            Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, k);

            if (cell)
                return autobox_string(interp, cell);
        }

        return NULL;
    }

    VTABLE PMC * get_pmc_keyed_str(STRING *key) {
        Hash *hash = get_hash(interp, SELF);

        if (hash) {
            void     *k    = hash_key_from_string(interp, hash, key);
            Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, k);

            if (cell)
                return autobox_pmc(interp, cell);
        }

        return PMCNULL;
    }

    VTABLE INTVAL get_integer_keyed(PMC *key) {
        Hash *hash = get_hash(interp, SELF);

        if (hash) {
            void     *k    = hash_key_from_pmc(interp, hash, key);
            Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, k);

            if (cell)
                return autobox_intval(interp, cell);
        }

        return 0;
    }

    VTABLE FLOATVAL get_number_keyed(PMC *key) {
        Hash *hash = get_hash(interp, SELF);

        if (hash) {
            void     *k    = hash_key_from_pmc(interp, hash, key);
            Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, k);

            if (cell)
                return autobox_floatval(interp, cell);
        }

        return 0.0;
    }

    VTABLE STRING * get_string_keyed(PMC *key) {
        Hash *hash = get_hash(interp, SELF);

        if (hash) {
            void     *k    = hash_key_from_pmc(interp, hash, key);
            Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, k);

            if (cell)
                return autobox_string(interp, cell);
        }

        return NULL;
    }

    VTABLE PMC * get_pmc_keyed(PMC *key) {
        Hash *hash = get_hash(interp, SELF);

        if (hash) {
            void     *k    = hash_key_from_pmc(interp, hash, key);
            Pcc_cell *cell = (Pcc_cell *)parrot_hash_get(interp, hash, k);

            if (cell)
                return autobox_pmc(interp, cell);
        }

        return PMCNULL;
    }

    VTABLE INTVAL exists_keyed(PMC *key) {
        Hash *hash = get_hash(interp, SELF);

        if (hash) {
            void     *k = hash_key_from_pmc(interp, hash, key);
            return parrot_hash_exists(interp, hash, k);
        }

        return 0;
    }

    VTABLE INTVAL exists_keyed_str(STRING *key) {
        Hash *hash = get_hash(interp, SELF);

        if (hash) {
            void     *k = hash_key_from_string(interp, hash, key);
            return parrot_hash_exists(interp, hash, k);
        }

        return 0;
    }

    VTABLE INTVAL exists_keyed_int(INTVAL key) {
        Parrot_Context const * const attrs = PMC_data_typed(SELF, Parrot_Context*);

        if (attrs->num_positionals)
            return key < attrs->num_positionals;

        return 0;
    }

}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
