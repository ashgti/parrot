/*
Copyright (C) 2001-2009, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/nci.pmc - Native Call Interface

=head1 DESCRIPTION

The vtable functions for the native C call functions.

=head2 Methods

=over 4

=cut

*/

#include "parrot/nci.h"

typedef INTVAL (*nci_sub_t)(PARROT_INTERP, PMC *);
typedef nci_sub_t nci_jit_sub_t;

#define NCI_raw_FLAG    PObj_private0_FLAG

STRING *pcc_sig_params(PARROT_INTERP, STRING *sig);
STRING *pcc_sig_params(PARROT_INTERP, STRING *sig) {
    size_t sig_len = Parrot_str_byte_length(interp, sig);
    char param_buf[sig_len*2];

    size_t i, j;

    for (i = 1, j = 0; i < sig_len; i++) {
        INTVAL c = Parrot_str_indexed(interp, sig, i);
        if (c > 127) {
            Parrot_ex_throw_from_c_args(interp, NULL,
                    EXCEPTION_JIT_ERROR,
                    "Unknown param type at %d in signature '%S' (way too big)\n", i, sig);
        }
        else {
            switch ((char)c) {
                case 'v':
                case '0':
                case 'J':
                    break;
                case 'N':
                case 'd':
                case 'f':
                    param_buf[j++] = 'N';
                    break;
                case 'I':
                case 'l':
                case 'i':
                case 's':
                case 'c':
                    param_buf[j++] = 'I';
                    break;
                case 'S':
                case 't':
                case 'b':
                case 'B':
                    param_buf[j++] = 'S';
                    break;
                case 'P':
                case 'p':
                case 'V':
                case '2':
                case '3':
                case '4':
                    param_buf[j++] = 'P';
                    break;
                case 'O':
                    param_buf[j++] = 'P';
                    param_buf[j++] = 'i';
                    break;
                case '@':
                    param_buf[j++] = 'P';
                    param_buf[j++] = 's';
                    break;
                default:
                    Parrot_ex_throw_from_c_args(interp, NULL,
                            EXCEPTION_JIT_ERROR,
                            "Unknown param type at %d in signature '%S'\n", i, sig);
            }
        }
    }

    return string_make(interp, param_buf, j, NULL, PObj_constant_FLAG);
}

STRING *pcc_sig_ret(PARROT_INTERP, STRING *sig);
STRING *pcc_sig_ret(PARROT_INTERP, STRING *sig) {
    INTVAL c = Parrot_str_indexed(interp, sig, 0);
    if (c > 127) {
        Parrot_ex_throw_from_c_args(interp, NULL,
                EXCEPTION_JIT_ERROR,
                "Unknown return type at %d in signature '%S' (way too big)\n", 0, sig);
    }
    else {
        switch ((char)c) {
            case 'v':
                return CONST_STRING(interp, "v");
            case 'N':
            case 'f':
            case 'd':
                return CONST_STRING(interp, "N");
            case 'I':
            case 'l':
            case 'i':
            case 's':
            case 'c':
                return CONST_STRING(interp, "I");
            case 'S':
            case 't':
                return CONST_STRING(interp, "S");
            case 'p':
            case 'P':
                return CONST_STRING(interp, "P");
            case '2':
            case '3':
            case '4':
                return CONST_STRING(interp, "P");
            default:
                Parrot_ex_throw_from_c_args(interp, NULL,
                        EXCEPTION_JIT_ERROR,
                        "Unknown return type at %d in signature '%S'\n", 0, sig);
        }
    }
}

/* actually build the NCI thunk */
static nci_sub_t build_func(PARROT_INTERP, PMC *, Parrot_NCI_attributes *);

static
nci_sub_t build_func(PARROT_INTERP, PMC *pmc, Parrot_NCI_attributes *nci_info)
{
    STRING    *key        = nci_info->nci_signature;
    int       jitted      = 0;

    /* Build call function. */
    nci_info->func        = (PMC *)(build_call_func(interp, pmc, key, &jitted));

    return (nci_sub_t)nci_info->func;
}


pmclass NCI auto_attrs {
    /* Signature Attributes */
    ATTR STRING    *nci_signature;          /* The NCI signature */
    ATTR STRING    *pcc_signature_ret;      /* The PCC return signature */
    ATTR STRING    *pcc_signature_param;    /* The PCC param signature */

    /* Function Pointers */
    ATTR void      *func;                   /* Function pointer to call */
    ATTR void      *orig_func;              /* Function pointer being wrapped */

    /* Sub PMC Attributes */
    ATTR INTVAL     arity;                  /* Number of params taken */
    /* MMD Attributes */
    ATTR PMC       *multi_sig;
    ATTR STRING    *long_signature;

/*

=item C<METHOD get_multisig()>

Return the MMD signature PMC, if any or a Null PMC.

=cut

*/

    METHOD get_multisig() {
        PMC *sig;
        GET_ATTR_multi_sig(INTERP, SELF, sig);
        if (sig == NULL) {
            sig = PMCNULL;
        }
        RETURN(PMC *sig);
    }

/*

=item C<METHOD set_raw_nci_ptr(void *func)>

Sets the specified function pointer and raw flag.

=cut

*/

    METHOD make_raw_nci(PMC *func) {
        VTABLE_set_pointer(interp, SELF, (void *)func);
    }

/*

=item C<void init()>

Initializes the NCI with a C<NULL> function pointer.

=cut

*/

    VTABLE void init() {
        /* Mark that we're not a raw NCI. */
        PObj_get_FLAGS(SELF) &= ~NCI_raw_FLAG;
        /* Mark that we have a custom gc marker */
        PObj_custom_mark_SET(SELF);
    }

/*

=item C<void *get_pointer()>

=item C<void set_pointer(void *ptr)>

Get/Set the pointer being wrapped. Setting through this interface sets
the raw flag.

=cut

*/

    VTABLE void set_pointer(void *ptr) {
        SET_ATTR_orig_func(INTERP, SELF, ptr);
        PObj_get_FLAGS(SELF) |= NCI_raw_FLAG;
    }

    VTABLE void *get_pointer() {
        return PARROT_NCI(SELF)->orig_func;
    }

/*

=item C<void set_pointer_keyed_str(STRING *key, void *func)>

Roughly equivalent to C<set_string(key)> and C<set_pointer(func)>.
Setting through this interface clears the raw flag.

=cut

*/

    VTABLE void set_pointer_keyed_str(STRING *key, void *func) {
        SELF.set_string_native(key);
        SELF.set_pointer(func);
        PObj_get_FLAGS(SELF) &= ~NCI_raw_FLAG;
    }

/*

=item C<STRING *get_string()>

=item C<void set_string(STRING *str)>

Get/Set the NCI signature.

=cut

*/

    VTABLE STRING *get_string() {
        return PARROT_NCI(SELF)->nci_signature;
    }

    VTABLE void set_string_native(STRING *str) {
        if (!PObj_constant_TEST(str)) {
            str = Parrot_str_copy(INTERP, str);
        }
        SET_ATTR_nci_signature(INTERP, SELF, str);

        /* set up derivative attributes */
        SET_ATTR_pcc_signature_param(INTERP, SELF, pcc_sig_params(INTERP, str));
        SET_ATTR_pcc_signature_ret(INTERP, SELF, pcc_sig_ret(INTERP, str));
        /* Arity is length of the NCI signature minus one (the return type). */
        SET_ATTR_arity(INTERP, SELF, Parrot_str_byte_length(INTERP, str) - 1);
    }

/*

=item C<void mark()>

Mark any referenced strings and PMCs.

=cut

*/
    VTABLE void mark() {
        if (PARROT_NCI(SELF)) {
            Parrot_NCI_attributes * const nci_info = PARROT_NCI(SELF);

            Parrot_gc_mark_STRING_alive(interp, nci_info->nci_signature);
            Parrot_gc_mark_STRING_alive(interp, nci_info->pcc_signature_param);
            Parrot_gc_mark_STRING_alive(interp, nci_info->pcc_signature_ret);
            Parrot_gc_mark_STRING_alive(interp, nci_info->long_signature);
            Parrot_gc_mark_PMC_alive(interp, nci_info->multi_sig);
        }
    }

/*

=item C<PMC *clone()>

Creates and returns a clone of the NCI.

=cut

*/

    VTABLE PMC *clone() {
        Parrot_NCI_attributes * const nci_info_self = PARROT_NCI(SELF);
        Parrot_NCI_attributes *nci_info_ret;
        void                  *orig_func;

        PMC * const ret     = pmc_new(INTERP, SELF->vtable->base_type);
        nci_info_ret        = PARROT_NCI(ret);

        /* FIXME if data is malloced (JIT/i386!) then we need
         * the length of data here, to memcpy it
         * ManagedStruct or Buffer?
         */
        nci_info_ret->func                  = nci_info_self->func;
        nci_info_ret->orig_func              = nci_info_self->orig_func;
        nci_info_ret->nci_signature         = nci_info_self->nci_signature;
        nci_info_ret->pcc_signature_param   = nci_info_self->pcc_signature_param;
        nci_info_ret->pcc_signature_ret     = nci_info_self->pcc_signature_ret;
        nci_info_ret->long_signature        = nci_info_self->long_signature;
        nci_info_ret->multi_sig             = nci_info_self->multi_sig;
        nci_info_ret->arity                 = nci_info_self->arity;
        PObj_get_FLAGS(ret)                |= (PObj_get_FLAGS(SELF) & 0x7);

        return ret;
    }

/*

=item C<INTVAL defined()>

Returns whether the NCI is defined.

=cut

*/

    VTABLE INTVAL defined() {
        Parrot_NCI_attributes * const nci_info = PARROT_NCI(SELF);
        return nci_info->orig_func != NULL;
    }

/*

=item C<opcode_t *invoke(void *next)>

Calls the associated C function, returning C<*next>. If the invocant is a
class, the PMC arguments are shifted down.

=cut

*/

    VTABLE opcode_t *invoke(void *next) {
        Parrot_NCI_attributes * const nci_info = PARROT_NCI(SELF);
        nci_sub_t                     func;
        char                         *sig_str;
        void                         *orig_func;
        PMC                          *cont;

        GET_ATTR_orig_func(INTERP, SELF, orig_func);
        func = PObj_get_FLAGS(SELF) & NCI_raw_FLAG
            ? (nci_sub_t) D2FPTR(orig_func)
            : (nci_sub_t) D2FPTR(nci_info->func);

        if (!func) {
            /* build the thunk only when necessary */
            func = build_func(interp, SELF, nci_info);

            if (!func)
                Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_INVALID_OPERATION,
                    "attempt to call NULL function");
        }

        func(INTERP, SELF);

        cont = INTERP->current_cont;

        /*
         * If the NCI function was tailcalled, the return result
         * is already passed back to the caller of this frame
         * - see  Parrot_init_ret_nci(). We therefore invoke the
         * return continuation here, which gets rid of this frame
         * and returns the real return address
         */
        if (cont && cont != NEED_CONTINUATION
        && (PObj_get_FLAGS(cont) & SUB_FLAG_TAILCALL)) {
            cont = Parrot_pcc_get_continuation(interp, CURRENT_CONTEXT(interp));
            next = VTABLE_invoke(INTERP, cont, next);
        }

        return (opcode_t *)next;
    }

/*

=item C<INTVAL get_integer()>

Returns the function pointer as an integer.

=cut

*/

    VTABLE INTVAL get_integer() {
        Parrot_NCI_attributes * const nci_info = PARROT_NCI(SELF);
        if (!nci_info->func)
            build_func(INTERP, SELF, nci_info);
        return (INTVAL)nci_info->func;
    }

/*

=item C<INTVAL get_bool()>

Returns the boolean value of the pointer.

=cut

*/

    VTABLE INTVAL get_bool() {
        Parrot_NCI_attributes * const nci_info = PARROT_NCI(SELF);
        return (0 != (INTVAL)nci_info->orig_func);
    }

/*

=item C<METHOD arity()>

Return the arity of the NCI (the number of arguments).

=cut

*/
    METHOD arity() {
        INTVAL arity;
        GET_ATTR_arity(INTERP, SELF, arity);
        RETURN(INTVAL arity);
    }

/*

=item C<INTVAL get_integer_keyed_int(INTVAL key)>

=item C<STRING *get_string_keyed_int(INTVAL key)>

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Accessors for all attributes of this class not otherwise accessible through VTABLES.
Integers are used for keys to make access easier for JIT. These are also available to
PIR from F<runtime/parrot/include/nci.pasm>

=over

=item INTVAL keys

C<PARROT_NCI_ARITY>

=item STRING keys

C<PARROT_NCI_PCC_SIGNATURE_PARAMS>, C<PARROT_NCI_PCC_SIGNATURE_RET>,
C<PARROT_LONG_SIGNATURE>

=item PMC keys

C<PARROT_NCI_MULTI_SIG>

=back

=cut

*/

    VTABLE INTVAL get_integer_keyed_int(INTVAL key) {
        switch (key) {
            case PARROT_NCI_ARITY:
                return PARROT_NCI(SELF)->arity;
            default:
                Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_INVALID_OPERATION,
                    "Bad index for NCI.get_integer_keyed_int()");
        }
    }

    VTABLE STRING *get_string_keyed_int(INTVAL key) {
        switch (key) {
            case PARROT_NCI_PCC_SIGNATURE_PARAMS:
                return PARROT_NCI(SELF)->pcc_signature_param;
            case PARROT_NCI_PCC_SIGNATURE_RET:
                return PARROT_NCI(SELF)->pcc_signature_ret;
            case PARROT_NCI_LONG_SIGNATURE:
                return PARROT_NCI(SELF)->long_signature;
            default:
                Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_INVALID_OPERATION,
                    "Bad index for NCI.get_string_keyed_int()");
        }
    }

    VTABLE PMC *get_pmc_keyed_int(INTVAL key) {
        PMC *retval;
        switch (key) {
            case PARROT_NCI_MULTI_SIG:
                GET_ATTR_multi_sig(INTERP, SELF, retval);
            default:
                Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_INVALID_OPERATION,
                    "Bad index for NCI.get_pmc_keyed_int()");
        }
        if (retval == NULL) {
            retval = PMCNULL;
        }
        return retval;
    }
}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd03_calling_conventions.pod>.

=head1 HISTORY

Initial revision by sean 2002/08/04.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
