/*
Copyright (C) 2001-2005, The Perl Foundation.
$Id: /parrot/cc/src/pmc/resizablepmcarray.pmc 2034 2007-01-14T22:25:58.386168Z tewk  $

=head1 NAME

src/pmc/smop_class.pmc - SMOP Class

=head1 DESCRIPTION

This class, smop_class, implements the class class of the simple meta
object protocol.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"
#define SMOP(o) ((SMOP_Class *) PMC_data(o))

typedef struct SMOP_Class {
    STRING *name;
    STRING *namespace_;
    PMC *_parrotclass;
    PMC *attributes;
    PMC *methods;
    PMC *superclasses;
} SMOP_Class;

static void smop_init(Interp *interp, PMC *self) {
    SMOP_Class *smop = NULL;
    /* But we are a class, really */
    PObj_is_class_SET(self);
    /* turn on marking of the class_data array */
    PObj_data_is_PMC_array_SET(self);
    /* turn on custom destruction since our PMC* array is dynamically allocated */
    PObj_active_destroy_SET(self);

    PMC_data(self) = mem_sys_allocate_zeroed(sizeof(SMOP_Class));
    smop                = SMOP(self);
    smop->attributes    = pmc_new(interp, enum_class_Hash);
    smop->methods       = pmc_new(interp, enum_class_Hash);
    smop->superclasses  = pmc_new(interp, enum_class_Hash);
}

PARROT_API void Parrot_smop_find_class(Interp *interp, PMC *self);
PARROT_API void Parrot_smop_find_class(Interp *interp, PMC *self) {
}



pmclass SMOP_Class need_ext {
/*

=item C<void init()>

Initializes the class flags.

=item C<void init_pmc(PMC *init)>

The actual class creation code, called from C<newclass> opcode. The C<init>
argument is not a PMC* but the C<classname> STRING.

=cut

*/

    void init() {
        smop_init(INTERP, SELF);
    }

    void init_pmc(PMC* args) {
        int i;
        int n = VTABLE_elements(interp, args);

        SELF.init();

        /* invoke accessor for each constructor arg in args */
        for (i=0; i<n; i++); {
            PMC *key = VTABLE_get_pmc_keyed_int(interp, args, i);
            PMC *value = VTABLE_get_pmc_keyed(interp, args, key);
            VTABLE_invoke(interp, key, value);
        }
    }

/*

=item C<void destroy()>

Free the class's attribute array, if any. Also used by ParrotObjects.

=cut

*/
    void destroy() {
            mem_sys_free(PMC_data(SELF));
    }

    PMETHOD void name(PMC *name :optional, int got_name :opt_flag) {
        if (got_name) {
            Parrot_store_global_n(interp, interp->root_namespace, string_from_const_cstring(interp, "class_object", 0), name);
            VTABLE_set_attr_str(interp, SELF, string_from_const_cstring(interp, "namespace",0), CONTEXT(interp->ctx)->current_namespace);
        }
    }

    PMETHOD void new(PMC *args :slurpy :named) {
        PMC *obj;
        STRING* name;
        INTVAL type_id;

        (STRING* name) = PMINVOKE(interp, SELF, "name");
        type_id = pmc_type(interp, name);
        obj = pmc_new_init(interp,type_id, args);
        preturn(PMC *obj)
    }

    PMETHOD void attributes(PMC *attribs :optional, int got_attribs :opt_flag) {
        PMC *rv;
        STRING *method_name = string_from_const_cstring(interp, "add_attribute", 0);
        STRING *attributes_string = string_from_const_cstring(interp, "add_attribute", 0);
        if (got_attribs) {
            int i;
            int n = VTABLE_elements(interp, attribs);

            for (i=0; i<n; i++); {
                PMC *key = VTABLE_get_pmc_keyed_int(interp, attribs, i);
                PMC *value = VTABLE_get_pmc_keyed(interp, attribs, key);
                () = PMINVOKE(interp, pmc, method_name, PMC* key, PMC* value);
            }
        }
        rv = VTABLE_get_attr_str(interp, pmc, attributes_string);
        preturn(PMC *rv)
    }

    PMETHOD void add_attribute(STRING *attribute_name, STRING* attribute_type :optional, int got_type :opt_flag) {
        PMC *attributes;
        PMC *new_attribute = pmc_new(interp, pmc_type(interp, string_from_const_cstring(interp, "SMOP_Attribute", 0)));

        PMINVOKE(interp, pmc, "name", STRING* attribute_name);
        PMINVOKE(interp, SELF, "class", PMC* SELF);

        if (got_type) {
            PMINVOKE(interp, SELF, "type", STRING* attribute_type);
        }

        /* SELF.set_meta_attribute(attribute_name, new_attribute); */
    }

    METHOD void add_superclass(STRING* superclass) {
        /* PMC *newsuper = find_class(superclass); */
    }

    METHOD void set_meta_attribute(STRING* attribute_name, PMC *value) {
        SMOP_Class *smop = SMOP(SELF);
        PMC* attributes = SMOP(SELF)->attributes;
        VTABLE_set_pmc_keyed_str(interp, pmc, attribute_name, pmc);
    }

    METHOD PMC* get_meta_attribute(STRING* attribute_name) {
        SMOP_Class *smop = SMOP(SELF);
        PMC* attributes = SMOP(SELF)->attributes;
        return VTABLE_get_pmc_keyed_str(interp, pmc, attribute_name);
    }
}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd15_objects.pod>.

=head1 HISTORY

Initial version                  - Kevin Tew 2007-02-12

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
