/*
Copyright (C) 2001-2007, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/smop_class.pmc - SMOP Class

=head1 DESCRIPTION

This class, smop_class, implements the class class of the simple meta object protocol.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"
#define SMOP(o) ((SMOP_Class *) PMC_data(o))

typedef struct SMOP_Class {
    STRING *name;
    STRING *namespace_;
    PMC *_parrotclass;
    PMC *attributes;
    PMC *methods;
    PMC *superclasses;
} SMOP_Class;

PARROT_API void Parrot_smop_find_class(Interp *interp, PMC *self);
PARROT_API void Parrot_smop_find_class(Interp *interp, PMC *self) {
}



pmclass SMOP_Class need_ext {
/*

=item C<void init()>

Initializes the class flags.

=item C<void init_pmc(PMC *init)>

The actual class creation code, called from C<newclass> opcode. The C<init>
argument is not a PMC* but the C<classname> STRING.

=cut

*/
    void class_init() {
        if (pass) {
            /*Parrot_SMOP_Class_class_init_2(interp, NULL);*/
        }
    }

    METHOD void class_init_2()
    {
            int i;
            PMC* _class = pmc_new(interp, enum_class_SMOP_Class);
            PMC* class_meta;
            PMC* class_string;
            PMC* attributes = pmc_new(interp, enum_class_ResizablePMCArray);
            const char *attribute_names[] = { "name", "namespace", "_parrotclass",
                "attributes", "methods", "superclasses" };

            for (i=0; i<6; i++) {
                PMC* const attribute = pmc_new(interp, enum_class_SMOP_Attribute);
                STRING * const attrib_name = string_from_const_cstring(interp, attribute_names[i], 0);

                PCCINVOKE(interp, attribute, "name", STRING* attrib_name);
                PCCINVOKE(interp, attribute, "class", PMC* _class);
                VTABLE_push_pmc(interp, attributes, attribute);
            }

            /* we sidestep the MetaModel bootstrap problem by building the MetaClass manually */

            (PMC* class_meta) = PCCINVOKE(interp, _class, "new");
            class_string = pmc_new(interp, enum_class_String);
            VTABLE_set_string_native(interp, class_string,
                    string_from_const_cstring(interp, "Class", 0));
            VTABLE_set_attr_str(interp, class_meta,
                    string_from_const_cstring(interp, attribute_names[0], 0), class_string);
            VTABLE_set_attr_str(interp, class_meta,
                    string_from_const_cstring(interp, attribute_names[2], 0), _class);
            VTABLE_init(interp,class_meta);
            VTABLE_set_attr_str(interp, class_meta,
                    string_from_const_cstring(interp, attribute_names[3], 0), attributes);
            Parrot_store_global_n(interp, interp->root_namespace,
                    string_from_const_cstring(interp, "class_object", 0), class_meta);
    }


    void init() {
        SMOP_Class *smop;
        /* But we are a class, really */
        PObj_is_class_SET(SELF);
        /* turn on marking of the class_data array */
        PObj_data_is_PMC_array_SET(SELF);
        /* turn on custom destruction since our PMC* array is dynamically allocated */
        PObj_active_destroy_SET(SELF);

        PMC_data(SELF) = mem_sys_allocate_zeroed(sizeof(SMOP_Class));
        smop                = SMOP(SELF);
        smop->attributes    = pmc_new(interp, enum_class_Hash);
        smop->methods       = pmc_new(interp, enum_class_Hash);
        smop->superclasses  = pmc_new(interp, enum_class_Hash);
    }

    void init_pmc(PMC* args) {
        int i;
        const int n = VTABLE_elements(interp, args);

        SELF.init();

        /* invoke accessor for each constructor arg in args */
        for (i=0; i<n; i++); {
            PMC * const key = VTABLE_get_pmc_keyed_int(interp, args, i);
            PMC * const value = VTABLE_get_pmc_keyed(interp, args, key);
            VTABLE_invoke(interp, key, value);
        }
    }

/*

=item C<void destroy()>

Free the class's attribute array, if any. Also used by ParrotObjects.

=cut

*/
    void destroy() {
        mem_sys_free(PMC_data(SELF));
    }

    PCCMETHOD void name(PMC *name :optional, int got_name :opt_flag) {
        if (got_name) {
            Parrot_store_global_n(interp, interp->root_namespace,
                    string_from_const_cstring(interp, "class_object", 0), name);
            VTABLE_set_attr_str(interp, SELF, string_from_const_cstring(interp, "namespace",0),
                    CONTEXT(interp->ctx)->current_namespace);
        }
    }

    PCCMETHOD void new(PMC *args :slurpy :named) {
        PMC *obj;
        STRING* name;
        INTVAL type_id;

        (STRING* name) = PCCINVOKE(interp, SELF, "name");
        type_id = pmc_type(interp, name);
        obj = pmc_new_init(interp,type_id, args);
        PCCRETURN(PMC *obj)
    }

    PCCMETHOD void attributes(PMC *attribs :optional, int got_attribs :opt_flag) {
        PMC *rv;
        STRING *method_name = string_from_const_cstring(interp, "add_attribute", 0);
        STRING *attributes_string = string_from_const_cstring(interp, "add_attribute", 0);
        if (got_attribs) {
            int i;
            const int n = VTABLE_elements(interp, attribs);

            for (i=0; i<n; i++); {
                PMC * const key = VTABLE_get_pmc_keyed_int(interp, attribs, i);
                PMC * const value = VTABLE_get_pmc_keyed(interp, attribs, key);
                PCCINVOKE(interp, pmc, method_name, PMC* key, PMC* value);
            }
        }
        rv = VTABLE_get_attr_str(interp, pmc, attributes_string);
        PCCRETURN(PMC *rv)
    }

    PCCMETHOD void add_attribute(STRING *attribute_name,
            STRING* attribute_type :optional, int got_type :opt_flag) {
        PCCINVOKE(interp, pmc, "name", STRING* attribute_name);
        PCCINVOKE(interp, SELF, "class", PMC* SELF);

        if (got_type) {
            PCCINVOKE(interp, SELF, "type", STRING* attribute_type);
        }

        /* SELF.set_meta_attribute(attribute_name, new_attribute); */
    }

    PMC* get_attr_str(STRING* attr_name) {
        return PMCNULL;
    }

    METHOD void add_superclass(STRING* superclass) {
        /* PMC *newsuper = find_class(superclass); */
    }

    METHOD void set_meta_attribute(STRING* attribute_name, PMC *value) {
        VTABLE_set_pmc_keyed_str(interp, pmc, attribute_name, pmc);
    }

    METHOD PMC* get_meta_attribute(STRING* attribute_name) {
        return VTABLE_get_pmc_keyed_str(interp, pmc, attribute_name);
    }
}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd15_objects.pod>.

=head1 HISTORY

Initial version                  - Kevin Tew 2007-02-12

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
