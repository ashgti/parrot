/*
Copyright (C) 2001-2007, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/object.pmc - An instance of a class

=head1 DESCRIPTION

Implements an instance of a class.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "classobject.h"

/* This finds the index of an attribute in an object's attribute store and
 * returns it. Returns -1 if the attribute does not exist. */
static INTVAL
get_attrib_index(PARROT_INTERP, PMC *self, STRING *name)
{
    Parrot_Class * const _class = PARROT_CLASS(self);
    int                  num_classes, i;

    /* First see if we can find it in the cache. */
    if (VTABLE_exists_keyed_str(interp, _class->attrib_cache, name))
        return VTABLE_get_integer_keyed_str(interp, _class->attrib_cache, name);

    /* No hit. We need to walk up the list of parents to try and find the
     * attribute. */
    num_classes = VTABLE_elements(interp, _class->all_parents);

    for (i = 0; i < num_classes; i++) {
        /* Get the class and its attribute metadata hash. */
        PMC * const cur_class = VTABLE_get_pmc_keyed_int(interp,
            _class->all_parents, i);

        /* Build a string representing the fully qualified attribute name. */
        STRING *fq_name = VTABLE_get_string(interp, cur_class);
        fq_name         = string_append(interp, fq_name, name);

        /* Look up. */
        if (VTABLE_exists_keyed_str(interp, _class->attrib_index, fq_name)) {
            /* Found it. Get value, cache it and we're done. */
            const INTVAL index = VTABLE_get_integer_keyed_str(interp,
                _class->attrib_index, fq_name);
            VTABLE_set_integer_keyed_str(interp, _class->attrib_cache, name,
                index);

            return index;
        }
    }

    return -1;
}

pmclass Object need_ext {

/*

=item C<void init()>

Raises an exception; you can only instantiate objects from a class.

=cut

*/

    void init() {
        real_exception(interp, NULL, INVALID_OPERATION,
                "Object must be created by a class.");
    }

/*


=item C<void init_pmc(PMC *class)>

Raises an exception; you can only instantiate objects from a class.

=cut

*/

    void init_pmc(PMC *worreva) {
        real_exception(interp, NULL, INVALID_OPERATION,
                "Object must be created by a class.");
    }

/*

=item C<void destroy()>

Free the object's underlying struct.

=cut

*/
    void destroy() {
        mem_sys_free(PMC_data(SELF));
    }

/*

=item C<STRING *name()>

Returns the fully qualified name of the object's class.

=cut

*/

    STRING *name() {
        PMC * const _class = VTABLE_get_class(interp, SELF);
        STRING * const class_name = VTABLE_get_string(interp, _class);

        return class_name;
    }

/*

=item C<void mark()>

Mark any referenced strings and PMCs.

=cut

*/
    void mark() {
        Parrot_Object * const obj = PARROT_OBJECT(SELF);
        if (obj->_class)
            pobject_lives(interp, (PObj*)obj->_class);
        if (obj->attrib_store)
            pobject_lives(interp, (PObj*)obj->attrib_store);
    }

/*

=item C<PMC *get_attr_str(STRING *name)>

Gets the value of an attribute for this object. Will find the first attribute
of the given name walking up the inheritance tree.

=cut

*/
    PMC *get_attr_str(STRING *name) {
        Parrot_Object * const obj = PARROT_OBJECT(SELF);

        /* Look up the index. */
        const INTVAL index = get_attrib_index(interp, obj->_class, name);

        /* If lookup failed, exception. */
        if (index == -1) {
            real_exception(interp, NULL, ATTRIB_NOT_FOUND,
                "No such attribute '%S'", name);
        }

        return VTABLE_get_pmc_keyed_int(interp, obj->attrib_store, index);
    }

/*

=item C<void set_attr_str(STRING *name, PMC *value)>

Sets the value of an attribute for this object. Will set the first attribute
of the given name walking up the inheritance tree.

=cut

*/
    void set_attr_str(STRING *name, PMC *value) {
        Parrot_Object * const obj = PARROT_OBJECT(SELF);
        const INTVAL index        = get_attrib_index(interp, obj->_class, name);

        /* If lookup failed, exception. */
        if (index == -1)
            real_exception(interp, NULL, ATTRIB_NOT_FOUND,
                "No such attribute '%S'", name);

        VTABLE_set_pmc_keyed_int(interp, obj->attrib_store, index, value);
    }

/*

=item C<PMC *find_method(STRING *name)>

Queries this object's class to find the method with the given name.

=cut

*/
    PMC *find_method(STRING *name) {
        Parrot_Object * const obj = PARROT_OBJECT(SELF);
        Parrot_Class * const _class = PARROT_CLASS(obj->_class);
        PMC *method = PMCNULL;

        /* Walk and search. One day, we'll use the cache first. */
        const int num_classes = VTABLE_elements(interp, _class->all_parents);
        const int all_in_universe = !PObj_HasAlienParents_TEST(obj->_class);
        int alien_parents_pos = VTABLE_elements(interp, _class->attrib_metadata);
        int i;
        for (i = 0; i < num_classes; i++) {
            /* Get the class. */
            PMC * const cur_class = VTABLE_get_pmc_keyed_int(interp, _class->all_parents, i);

            /* If it's from this universe or the class doesn't inherit from
             * anything outside of it... */
            if (all_in_universe || VTABLE_isa(interp, cur_class, CONST_STRING(interp, "Class"))) {
                const Parrot_Class * const class_info = PARROT_CLASS(cur_class);
                if (VTABLE_exists_keyed_str(interp, class_info->methods, name)) {
                    /* Found it! */
                    method = VTABLE_get_pmc_keyed_str(interp, class_info->methods, name);
                    break;
                }
            }
            else {
                /* Delegate the lookup to the class. */
                PMC * const del_class = VTABLE_get_pmc_keyed_int(interp, obj->attrib_store,
                    alien_parents_pos);
                method = VTABLE_find_method(interp, del_class, name);

                if (!PMC_IS_NULL(method)) {
                    /* Found it. However, if we just hand this back and it's
                     * an NCI and we call it, we will get the wrong invocant
                     * passed. Therefore, we need to close the NCI and make it
                     * into a BoundNCI. */
                    if (method->vtable->base_type == enum_class_NCI) {
                        method = VTABLE_clone(interp, method);
                        method->vtable = interp->vtables[enum_class_Bound_NCI];
                        VTABLE_set_pmc(interp, method, del_class);
                    }

                    /* Found a method, so we're done. */
                    break;
                }

                alien_parents_pos++;
            }
        }

        return method;
    }

/*

=item C<PMC *get_class()>

Get the class PMC representing the class that this object is an instance of.

=cut

*/
    PMC *get_class()
    {
        return PARROT_OBJECT(SELF)->_class;
    }

/*

=item C<INTVAL can(STRING *method_name)>

Returns 0 if the class does not have a method with the given name and a
non-zero value if it does.

=cut

*/
    INTVAL can(STRING *method_name)
    {
        /* Just use find_method and see it if finds anything. */
        const PMC * const method = VTABLE_find_method(interp, SELF, method_name);
        return !PMC_IS_NULL(method);
    }

/*

=item C<INTVAL isa(STRING *classname)>

Returns whether the class is or inherits from C<*classname>.

=cut

*/
    INTVAL isa(STRING *classname)
    {
        PMC   *_class;

        if (SUPER(classname))
            return 1;

        _class = VTABLE_get_class(interp, SELF);
        return VTABLE_isa(interp, _class, classname);
    }

}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd15_objects.pod>.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
