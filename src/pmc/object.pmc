/*
Copyright (C) 2001-2007, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/object.pmc - An instance of a class

=head1 DESCRIPTION

Implements an instance of a class.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "classobject.h"

/* This finds the index of an attribute in an object's attribute store and
 * returns it. Returns -1 if the attribute does not exist. */
static INTVAL get_attrib_index(Parrot_Interp interp, PMC *self, STRING *name) {
    Parrot_Class *_class = PARROT_CLASS(self);

    /* If we can't find the attribute, we hand back -1. */
    INTVAL index = -1;

    /* First see if we can find it in the cache. */
    if (VTABLE_exists_keyed_str(interp, _class->attrib_cache, name)) {
        /* Yay! We got a cache hit! */
        index = VTABLE_get_integer_keyed_str(interp, _class->attrib_cache, name);
    }
    else {
        /* No hit. We need to walk up the list of parents to try and find the
         * attribute. */
        int num_classes = VTABLE_elements(interp, _class->all_parents);
        int i;
        for (i = 0; i < num_classes; i++) {
            /* Get the class and its attribute metadata hash. */
            PMC *cur_class = VTABLE_get_pmc_keyed_int(interp, _class->all_parents, i);
            Parrot_Class *class_info = PARROT_CLASS(cur_class);

            /* Build a string representing the fully qualified attribute name. */
            STRING *fq_name = Parrot_Class_get_fq_classname(interp, class_info);
            fq_name = string_append(interp, fq_name, name);

            /* Look up. */
            if (VTABLE_exists_keyed_str(interp, _class->attrib_index, fq_name)) {
                /* Found it. Get value, cache it and we're done. */
                index = VTABLE_get_integer_keyed_str(interp, _class->attrib_index, fq_name);
                VTABLE_set_integer_keyed_str(interp, _class->attrib_cache, name, index);
                break;
            }
        }
    }

    return index;
}


pmclass Object need_ext {

/*

=item C<void init()>

Raises an exception; you can only instantiate objects from a class.

=cut

*/

    void init() {
        real_exception(interp, NULL, INVALID_OPERATION,
                "Object must be created by a class.");
    }

/*


=item C<void init_pmc(PMC *class)>

Raises an exception; you can only instantiate objects from a class.

=cut

*/

    void init_pmc(PMC* worreva) {
        real_exception(interp, NULL, INVALID_OPERATION,
                "Object must be created by a class.");
    }

/*

=item C<void destroy()>

Free the object's underlying struct.

=cut

*/
    void destroy() {
            mem_sys_free(PMC_data(SELF));
    }

/*

=item C<void mark()>

Mark any referenced strings and PMCs.

=cut

*/
    void mark() {
        Parrot_Object *obj = PARROT_OBJECT(SELF);
        if (obj->_class)
            pobject_lives(interp, (PObj*)obj->_class);
        if (obj->attrib_store)
            pobject_lives(interp, (PObj*)obj->attrib_store);
    }

/*

=item C<PMC* get_attr_str(STRING *idx)>

Gets the value of an attribute for this object. Will find the first attribute
of the given name walking up the inheritance tree.

=cut

*/
    PMC* get_attr_str(STRING *name) {
        Parrot_Object *obj = PARROT_OBJECT(SELF);

        /* Look up the index. */
        INTVAL index = get_attrib_index(interp, obj->_class, name);

        /* If lookup failed, exception. */
        if (index == -1) {
            real_exception(interp, NULL, ATTRIB_NOT_FOUND, "No such attribute '%S'", name);
            return PMCNULL;
        }
        else {
            return VTABLE_get_pmc_keyed_int(interp, obj->attrib_store, index);
        }
    }

/*

=item C<void set_attr_str(STRING* name, PMC* value)>

Sets the value of an attribute for this object. Will set the first attribute
of the given name walking up the inheritance tree.

=cut

*/
    void set_attr_str(STRING* name, PMC* value) {
        Parrot_Object *obj = PARROT_OBJECT(SELF);

        /* Look up the index. */
        INTVAL index = get_attrib_index(interp, obj->_class, name);

        /* If lookup failed, exception. */
        if (index == -1) {
            real_exception(interp, NULL, ATTRIB_NOT_FOUND, "No such attribute '%S'", name);
        }
        else {
            VTABLE_set_pmc_keyed_int(interp, obj->attrib_store, index, value);
        }
    }

/*

=item C<PMC* find_method(STRING *method_name)>

Walks the MRO of the class and finds the method with the given name.

=cut

*/
    PMC* find_method(STRING *name)
    {
        Parrot_Object *obj = PARROT_OBJECT(SELF);
        Parrot_Class *_class = PARROT_CLASS(obj->_class);
        PMC *method = PMCNULL;

        /* Walk and search. One day, we'll use the cache first. */
        int num_classes = VTABLE_elements(interp, _class->all_parents);
        int i;
        for (i = 0; i < num_classes; i++) {
            /* Get the class and see if it has the method. */
            PMC *cur_class = VTABLE_get_pmc_keyed_int(interp, _class->all_parents, i);
            Parrot_Class *class_info = PARROT_CLASS(cur_class);
            if (VTABLE_exists_keyed_str(interp, class_info->methods, name)) {
                /* Found it! */
                method = VTABLE_get_pmc_keyed_str(interp, class_info->methods, name);
                break;
            }
        }

        /* Return the method that was found, if any. */
        return method;
    }

/*

=item C<PMC* get_class()>

Get the class PMC representing the class that this object is an instance of.

=cut

*/
    PMC* get_class()
    {
        Parrot_Object *obj = PARROT_OBJECT(SELF);
        return obj->_class;
    }

/*

=item C<INTVAL can(STRING *method_name)>

Returns 0 if the class does not have a method with the given name and a
non-zero value if it does.

=cut

*/
    INTVAL can(STRING *method_name)
    {
        /* Just use find_method and see it if finds anything. */
        PMC *method = VTABLE_find_method(interp, SELF, method_name);
        return !PMC_IS_NULL(method);
    }

}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd15_objects.pod>.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
