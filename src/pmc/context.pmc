/*
Copyright (C) 2001-2009, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/context.pmc - Interpreter Context.

=head1 DESCRIPTION

Stores context of execution. Currently we store pointer to Parrot_Context_attributes
structure in PMC_data.

=head2 Vtable Functions

=over 4

=cut

*/


#include "parrot/packfile.h"
#include "pmc/pmc_sub.h"

pmclass Context auto_attrs {
    ATTR PMC     *caller_ctx;      /* caller context */

    ATTR void    *registers;       /* pointer to allocated registers */
    ATTR Regs_ni  bp;              /* pointers to FLOATVAL & INTVAL */
    ATTR Regs_ps  bp_ps;           /* pointers to PMC & STR */

    /* end common header */
    ATTR UINTVAL  n_regs_used[4];   /* INSP in PBC points to Sub */
    ATTR PMC      *lex_pad;         /* LexPad PMC */
    ATTR PMC      *outer_ctx;       /* outer context, if a closure */

    /* new call scheme and introspective variables */
    ATTR PMC      *current_sub;           /* the Sub we are executing */

    /* for now use a return continuation PMC */
    ATTR PMC      *handlers;              /* local handlers for the context */
    ATTR PMC      *current_cont;          /* the return continuation PMC */
    ATTR PMC      *current_object;        /* current object if a method call */
    ATTR PMC      *current_namespace;     /* The namespace we're currently in */
    ATTR PMC      *results_signature;     /* non-const results signature PMC */
    ATTR opcode_t *current_pc;            /* program counter of Sub invocation */
    ATTR opcode_t *current_results;       /* ptr into code with get_results opcode */
    ATTR PMC      *current_sig;           /* temporary CallSignature PMC for active call */

    /* deref the constants - we need it all the time */
    ATTR struct PackFile_Constant **constants;

    ATTR INTVAL                 current_HLL;     /* see also src/hll.c */

    ATTR UINTVAL                warns;           /* Keeps track of what warnings
                                             * have been activated */
    ATTR UINTVAL                errors;          /* fatals that can be turned off */
    ATTR UINTVAL                trace_flags;
    ATTR UINTVAL                recursion_depth; /* Sub call recursion depth */

    /* code->prederefed.code - code->base.data in opcodes
     * to simplify conversion between code ptrs in e.g. invoke */
    ATTR size_t pred_offset;

/*

=item C<void init()>

Initialize new Context. See C<Parrot_alloc_context>.

=cut

*/

    VTABLE void init() {
        PObj_custom_mark_destroy_SETALL(SELF);
    }


/*

=item C<void mark()>

Mark Context as alive.

=cut

*/

    VTABLE void mark()
    {
        Parrot_Context_attributes * const ctx = PARROT_CONTEXT(SELF);
        UINTVAL i;

        /* If Context wasn't initialised just return */
        if (!ctx)
            return;

        Parrot_gc_mark_PMC_alive(INTERP, ctx->caller_ctx);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->lex_pad);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->outer_ctx);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->current_sub);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->handlers);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->current_cont);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->current_object);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->current_namespace);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->results_signature);
        Parrot_gc_mark_PMC_alive(INTERP, ctx->current_sig);

        if (!ctx->n_regs_used)
            return;

        for (i = 0; i < ctx->n_regs_used[REGNO_PMC]; ++i) {
            PMC *p = ctx->bp_ps.regs_p[-1L-(i)];
            /* Original code from CTX_REG_PMC */
            if (p)
                Parrot_gc_mark_PMC_alive(interp, p);
        }

        for (i = 0; i < ctx->n_regs_used[REGNO_STR]; ++i) {
            STRING *s = ctx->bp_ps.regs_s[i];
            if (s)
                Parrot_gc_mark_STRING_alive(interp, s);
        }
    }

/*

=item C<void destroy()>

Destroy Context and memory allocated by C<Parrot_alloc_context>.

=cut

*/

    VTABLE void destroy() {
        Parrot_pcc_free_registers(INTERP, SELF);
    }

/*

=item C<PMC *get_pmc_keyed_str(STRING *key)>

Introspection interface. C<key> can be:

    caller_ctx          ... return Caller Context
    lex_pad             ... return LexPad
    outer_ctx           ... return Outer Context
    current_sub         ... return current Sub
    handlers            ... return list of ExceptioHandlers
    current_cont        ... return current Continuation
    current_object      ... return current Object (if in method call)
    current_namespace   ... return current Namespace

Deprecated. Use attribute accessors.
=cut

*/
    VTABLE PMC *get_pmc_keyed_str(STRING *key) {
        Parrot_Context_attributes *ctx = PARROT_CONTEXT(SELF);

        if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "caller_ctx")))
            return ctx->caller_ctx;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "lex_pad")))
            return ctx->lex_pad;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "outer_ctx")))
            return ctx->outer_ctx;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_sub")))
            return ctx->current_sub;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_cont")))
            return ctx->current_cont;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_object")))
            return ctx->current_object;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_namespace")))
            return ctx->current_namespace;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "handlers")))
            return ctx->handlers;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "results_signature")))
            return ctx->results_signature;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_HLL")))
            /* This function from src/hash.c. */
            /* We probably have to move it to more suitable place */
            return get_integer_pmc(INTERP, ctx->current_HLL);
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_hll")))
            return get_string_pmc(INTERP, Parrot_get_HLL_name(INTERP, ctx->current_HLL));

        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_ATTRIB_NOT_FOUND,
                "No such item %Ss", key);
    }

    VTABLE PMC *get_pmc_keyed(PMC *key) {
        return STATICSELF.get_pmc_keyed_str(VTABLE_get_string(INTERP, key));
    }

    VTABLE PMC *get_attr_str(STRING *key) {
        Parrot_Context_attributes *ctx = PARROT_CONTEXT(SELF);

        if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "caller_ctx")))
            return ctx->caller_ctx;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "lex_pad")))
            return ctx->lex_pad;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "outer_ctx")))
            return ctx->outer_ctx;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_sub")))
            return ctx->current_sub;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_cont")))
            return ctx->current_cont;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_object")))
            return ctx->current_object;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_namespace")))
            return ctx->current_namespace;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "handlers")))
            return ctx->handlers;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "results_signature")))
            return ctx->results_signature;
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_HLL")))
            /* This function from src/hash.c. */
            /* We probably have to move it to more suitable place */
            return get_integer_pmc(INTERP, ctx->current_HLL);
        else if (Parrot_str_equal(INTERP, key, CONST_STRING(INTERP, "current_hll")))
            return get_string_pmc(INTERP, Parrot_get_HLL_name(INTERP, ctx->current_HLL));

        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_ATTRIB_NOT_FOUND,
                "No such item %Ss", key);
    }

/*

=item C<PMC *backtrace>

Gets a representation of the backtrace starting from this Context.
Returns an array of hashes. Each array element represents a caller in
the backtrace, the most recent caller first. The hash has two keys: C<sub>,
which holds the PMC representing the sub, and C<annotations> which is a hash
of the annotations at the point where the exception was thrown for the current
sub, or for the point of the call a level deeper for the rest.

=cut

*/

    METHOD backtrace(PMC *resume :optional, INTVAL has_resume :opt_flag) {
        PMC *result  = pmc_new(interp, enum_class_ResizablePMCArray);
        PMC *cur_ctx = SELF;
        Parrot_Continuation_attributes *cont = has_resume ? PMC_cont(resume) : NULL;

        /* Get starting context, then loop over them. */
        while (cur_ctx) {
            PMC        *frame       = pmc_new(interp, enum_class_Hash);
            PMC        *annotations = NULL;
            Parrot_Sub_attributes *sub;

            /* Get sub and put it in the hash. */
            PMC *sub_pmc = Parrot_pcc_get_sub(interp, cur_ctx);

            if (!sub_pmc)
                sub_pmc = PMCNULL;

            VTABLE_set_pmc_keyed_str(interp, frame, CONST_STRING(interp, "sub"), sub_pmc);

            /* Look up any annotations and put them in the hash. */
            if (!PMC_IS_NULL(sub_pmc)) {
                PMC_get_sub(interp, sub_pmc, sub);

                if (sub->seg->annotations) {
                    PackFile_ByteCode *seg = sub->seg;
                    opcode_t          *pc  = cont && cur_ctx == cont->to_ctx
                                             ? cont->address
                                             : Parrot_pcc_get_pc(interp, cur_ctx);

                    annotations = PackFile_Annotations_lookup(interp,
                        seg->annotations, pc - seg->base.data,
                        NULL);
                }
            }

            if (!annotations)
                annotations = pmc_new(interp, enum_class_Hash);

            VTABLE_set_pmc_keyed_str(interp, frame, CONST_STRING(interp, "annotations"), annotations);

            /* Push frame and go to next caller. */
            VTABLE_push_pmc(interp, result, frame);
            cur_ctx = Parrot_pcc_get_caller_ctx(interp, cur_ctx);
        }

        RETURN(PMC *result);
    }
}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
