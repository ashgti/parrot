
#include "parrot/packfile.h"

pmclass Context {

    VTABLE void init() {
        PMC_data(SELF) = NULL;
        PObj_custom_mark_destroy_SETALL(SELF);
    }

    VTABLE void mark()
    {
        Parrot_Context * const ctx = PMC_data_typed(SELF, Parrot_Context*);
        PObj *obj;
        int   i;

        obj = (PObj *)ctx->caller_ctx;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->lex_pad;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->outer_ctx;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->current_sub;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->handlers;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->current_cont;
        if (obj && !PObj_live_TEST(obj))
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->current_object;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->current_namespace;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->results_signature;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        if (!ctx->n_regs_used)
            return;

        for (i = 0; i < ctx->n_regs_used[REGNO_PMC]; ++i) {
            obj = (PObj *)CTX_REG_PMC(ctx, i);
            if (obj)
                Parrot_gc_mark_PObj_alive(interp, obj);
        }

        for (i = 0; i < ctx->n_regs_used[REGNO_STR]; ++i) {
            obj = (PObj *)CTX_REG_STR(ctx, i);
            if (obj)
                Parrot_gc_mark_PObj_alive(interp, obj);
        }
    }

    VTABLE void *get_pointer() {
        return PMC_data(SELF);
    }

    VTABLE void set_pointer(void *context) {
        PMC_data(SELF) = context;
    }
}
