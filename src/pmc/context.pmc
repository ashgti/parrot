
#include "parrot/packfile.h"

#if 0
/*

=item C<static void clear_regs(PARROT_INTERP, Parrot_Context *ctx)>

Clears all registers in a context.  PMC and STRING registers contain PMCNULL
and NULL, respectively.  Integer and float registers contain negative flag
values, for debugging purposes.

=cut

*/

static void
clear_regs(PARROT_INTERP, ARGMOD(Parrot_Context *ctx))
{
    ASSERT_ARGS(clear_regs)
    int i;

    /* NULL out registers - P/S have to be NULL for GC
     *
     * if the architecture has 0x := NULL and 0.0 we could memset too
     */

    for (i = 0; i < ctx->n_regs_used[REGNO_PMC]; i++) {
        CTX_REG_PMC(ctx, i) = PMCNULL;
    }

    for (i = 0; i < ctx->n_regs_used[REGNO_STR]; i++) {
        CTX_REG_STR(ctx, i) = NULL;
    }

    if (Interp_debug_TEST(interp, PARROT_REG_DEBUG_FLAG)) {
        /* depending on -D40 we set int and num to be identifiable garbage values */
        for (i = 0; i < ctx->n_regs_used[REGNO_INT]; i++) {
            CTX_REG_INT(ctx, i) = -999;
        }
        for (i = 0; i < ctx->n_regs_used[REGNO_NUM]; i++) {
            CTX_REG_NUM(ctx, i) = -99.9;
        }
    }
}
#endif

pmclass Context {
    ATTR PMC        *caller_ctx;      /* caller context */
    ATTR Regs_ni    bp;              /* pointers to FLOATVAL & INTVAL */
    ATTR Regs_ps    bp_ps;           /* pointers to PMC & STR */
    ATTR INTVAL     n_regs_used[4];   /* INSP in PBC points to Sub */
    ATTR PMC        *lex_pad;          /* LexPad PMC */
    ATTR PMC        *outer_ctx;        /* outer context, if a closure */
    ATTR PMC        *current_sub;           /* the Sub we are executing */
    ATTR PMC      *handlers;              /* local handlers for the context */
    ATTR PMC      *current_cont;          /* the return continuation PMC */
    ATTR PMC      *current_object;        /* current object if a method call */
    ATTR PMC      *current_namespace;     /* The namespace we're currently in */
    ATTR PMC      *results_signature;     /* non-const results signature PMC */
    ATTR opcode_t *current_pc;            /* program counter of Sub invocation */
    ATTR opcode_t *current_results;       /* ptr into code with get_results opcode */
    ATTR struct PackFile_Constant **constants;
    ATTR INTVAL                 current_HLL;     /* see also src/hll.c */
    ATTR UINTVAL                regs_mem_size;   /* memory occupied by registers */
    ATTR UINTVAL                warns;           /* Keeps track of what warnings
                                             * have been activated */
    ATTR UINTVAL                errors;          /* fatals that can be turned off */
    ATTR UINTVAL                trace_flags;
    ATTR UINTVAL                recursion_depth; /* Sub call recursion depth */
    ATTR UINTVAL  pred_offset; /* code->prederefed.code - code->base.data in opcodes
     * to simplify conversion between code ptrs in e.g. invoke */

    VTABLE void init()
    {
        Parrot_Context_attributes * const attrs =
                mem_allocate_zeroed_typed(Parrot_Context_attributes);
        PMC_data(SELF) = attrs;
    }

    // XXX Probably I missed some fields.
    VTABLE void mark()
    {
        Parrot_Context_attributes * const ctx = PARROT_CONTEXT(SELF)->ctx;
        PObj *obj;
        int   i;

        obj = (PObj *)ctx->caller_ctx;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->lex_pad;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->outer_ctx;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->current_sub;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->handlers;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->current_cont;
        if (obj && !PObj_live_TEST(obj))
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->current_object;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->current_namespace;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->results_signature;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        if (!ctx->n_regs_used)
            return;

        for (i = 0; i < ctx->n_regs_used[REGNO_PMC]; ++i) {
            obj = (PObj *)CTX_REG_PMC(ctx, i);
            if (obj)
                Parrot_gc_mark_PObj_alive(interp, obj);
        }

        for (i = 0; i < ctx->n_regs_used[REGNO_STR]; ++i) {
            obj = (PObj *)CTX_REG_STR(ctx, i);
            if (obj)
                Parrot_gc_mark_PObj_alive(interp, obj);
        }
    }

    VTABLE void destroy()
    {
        Parrot_Context_attributes * const attrs = PARROT_CONTEXT(SELF);
        mem_sys_free(attrs);
    }
}
