/*

=item C<static void clear_regs(PARROT_INTERP, Parrot_Context *ctx)>

Clears all registers in a context.  PMC and STRING registers contain PMCNULL
and NULL, respectively.  Integer and float registers contain negative flag
values, for debugging purposes.

=cut

*/

static void
clear_regs(PARROT_INTERP, ARGMOD(Parrot_Context *ctx))
{
    ASSERT_ARGS(clear_regs)
    int i;

    /* NULL out registers - P/S have to be NULL for GC
     *
     * if the architecture has 0x := NULL and 0.0 we could memset too
     */

    for (i = 0; i < ctx->n_regs_used[REGNO_PMC]; i++) {
        CTX_REG_PMC(ctx, i) = PMCNULL;
    }

    for (i = 0; i < ctx->n_regs_used[REGNO_STR]; i++) {
        CTX_REG_STR(ctx, i) = NULL;
    }

    if (Interp_debug_TEST(interp, PARROT_REG_DEBUG_FLAG)) {
        /* depending on -D40 we set int and num to be identifiable garbage values */
        for (i = 0; i < ctx->n_regs_used[REGNO_INT]; i++) {
            CTX_REG_INT(ctx, i) = -999;
        }
        for (i = 0; i < ctx->n_regs_used[REGNO_NUM]; i++) {
            CTX_REG_NUM(ctx, i) = -99.9;
        }
    }
}

pmclass Context {
    ATTR Parrot_Context * ctx;

    VTABLE void init()
    {
        Parrot_Context_attributes * const attrs = mem_sys_allocate_typed(Parrot_Context_attributes);
        PMC_DATA(SELF) = attrs;
    }

    VTABLE void mark()
    {
        Parrot_Context * const ctx = PARROT_CONTEXT(SELF)->ctx;
        PObj *obj;
        int   i;

        obj = (PObj *)ctx->current_sub;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->current_object;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->current_cont;
        if (obj && !PObj_live_TEST(obj))
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->caller_ctx;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->outer_ctx;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->current_namespace;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->lex_pad;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->handlers;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        if (!ctx->n_regs_used)
            return;

        for (i = 0; i < ctx->n_regs_used[REGNO_PMC]; ++i) {
            obj = (PObj *)CTX_REG_PMC(ctx, i);
            if (obj)
                Parrot_gc_mark_PObj_alive(interp, obj);
        }

        for (i = 0; i < ctx->n_regs_used[REGNO_STR]; ++i) {
            obj = (PObj *)CTX_REG_STR(ctx, i);
            if (obj)
                Parrot_gc_mark_PObj_alive(interp, obj);
        }
    }

    VTABLE void destroy()
    {
        Parrot_Context_attributes * const attrs = PARROT_CONTEXT(SELF);
        Parrot_Context * const ctx = attrs->ctx;
        Parrot_free_context(INTERP, ctx);
        mem_sys_free(ctx);
        mem_sys_free(attrs);
    }
}
