/*
Copyright (C) 2001-2009, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/context.pmc - Interpreter Context.

=head1 DESCRIPTION

Stores context of execution. Currently we store pointer to Parrot_Context
structure in PMC_data.

=head2 Vtable Functions

=over 4

=cut

*/


#include "parrot/packfile.h"

pmclass Context auto_attrs {
    ATTR PMC     *caller_ctx;      /* caller context */
    ATTR Regs_ni  bp;              /* pointers to FLOATVAL & INTVAL */
    ATTR Regs_ps  bp_ps;           /* pointers to PMC & STR */

    /* end common header */
    ATTR INTVAL   n_regs_used[4];   /* INSP in PBC points to Sub */
    ATTR PMC      *lex_pad;         /* LexPad PMC */
    ATTR PMC      *outer_ctx;       /* outer context, if a closure */

    /* new call scheme and introspective variables */
    ATTR PMC      *current_sub;           /* the Sub we are executing */

    /* for now use a return continuation PMC */
    ATTR PMC      *handlers;              /* local handlers for the context */
    ATTR PMC      *current_cont;          /* the return continuation PMC */
    ATTR PMC      *current_object;        /* current object if a method call */
    ATTR PMC      *current_namespace;     /* The namespace we're currently in */
    ATTR PMC      *results_signature;     /* non-const results signature PMC */
    ATTR opcode_t *current_pc;            /* program counter of Sub invocation */
    ATTR opcode_t *current_results;       /* ptr into code with get_results opcode */

    /* deref the constants - we need it all the time */
    ATTR PackFile_Constant **constants;

    ATTR INTVAL    current_HLL;     /* see also src/hll.c */

    ATTR UINTVAL   warns;           /* Keeps track of what warnings
                                    * have been activated */
    ATTR UINTVAL   errors;          /* fatals that can be turned off */
    ATTR UINTVAL   trace_flags;
    ATTR UINTVAL   recursion_depth; /* Sub call recursion depth */

    /* code->prederefed.code - code->base.data in opcodes
     * to simplify conversion between code ptrs in e.g. invoke */
    ATTR size_t pred_offset;

/*

=item C<void init()>

Initialize new Context. See C<Parrot_alloc_context>.

=cut

*/

    VTABLE void init() {
        PObj_custom_mark_destroy_SETALL(SELF);
    }


/*

=item C<void mark()>

Mark Context as alive.

=cut

*/

    VTABLE void mark()
    {
        Parrot_Context_attributes * const ctx = PARROT_CONTEXT(SELF);
        PObj *obj;
        int   i;

        /* If Context wasn't initialised just return */
        if (!ctx)
            return;

        obj = (PObj *)ctx->caller_ctx;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->lex_pad;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->outer_ctx;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->current_sub;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->handlers;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->current_cont;
        if (obj && !PObj_live_TEST(obj))
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->current_object;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->current_namespace;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        obj = (PObj *)ctx->results_signature;
        if (obj)
            Parrot_gc_mark_PObj_alive(interp, obj);

        if (!ctx->n_regs_used)
            return;

        for (i = 0; i < ctx->n_regs_used[REGNO_PMC]; ++i) {
            /* Original code from CTX_REG_PMC */
            obj = (PObj *)ctx->bp_ps.regs_p[-1L-(i)];
            if (obj)
                Parrot_gc_mark_PObj_alive(interp, obj);
        }

        for (i = 0; i < ctx->n_regs_used[REGNO_STR]; ++i) {
            obj = (PObj *) ctx->bp_ps.regs_s[i];
            if (obj)
                Parrot_gc_mark_PObj_alive(interp, obj);
        }
    }

/*

=item C<void destroy()>

Destroy Context and memory allocated by C<Parrot_alloc_context>.

=cut

*/

    VTABLE void destroy() {
        /* We own this pointer */
        Parrot_Context_attributes * const ctx = PARROT_CONTEXT(SELF);
        mem_sys_free(ctx);
    }

/*

=item C<void *get_pointer()>

Return pointer to underlying Parrot_Context structure.

=cut

*/

    VTABLE void *get_pointer() {
        return PMC_data(SELF);
    }

/*

=item C<void set_pointer(void *)>

Set new Parrot_Context structure.

=cut

*/
    VTABLE void set_pointer(void *context) {
        PMC_data(SELF) = context;
    }
}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
