/*
Copyright (C) 2003-2008, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/integer.pmc - Integer PMC class

=head1 DESCRIPTION

C<Integer> provides an integer for languages that want a value-restricted
integer type without going to an I register.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

#include "pmc_bigint.h"
/* RT#46619 create MMD headers to in Pmc2c.pm */
/*
extern INTVAL Parrot_BigInt_is_equal_BigInt(PARROT_INTERP, PMC*, PMC*);
extern PMC *Parrot_BigInt_multiply_int(PARROT_INTERP,
        PMC *pmc, INTVAL value, PMC *dest) ;
*/

static PMC*
overflow(PARROT_INTERP, PMC *self, INTVAL b, PMC *dest, int mmd) {
    const INTVAL a = VTABLE_get_integer(interp, self);

    if (PARROT_ERRORS_test(interp, PARROT_ERRORS_OVERFLOW_FLAG))
    Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_ERR_OVERFLOW,
        "Integer overflow");

if (self == dest) {
    /* RT #46621 preserve type system */
    VTABLE_morph(interp, self, enum_class_BigInt);
    VTABLE_set_integer_native(interp, self, a);
    return mmd_dispatch_p_pip(interp, self, b, dest, mmd);
}
else {
    PMC * const temp = VTABLE_get_bignum(interp, self);
    return mmd_dispatch_p_pip(interp, temp, b, dest, mmd);
}
}

static PMC*
overflow_p(PARROT_INTERP, PMC *self, PMC *val, PMC *dest, int mmd) {
const INTVAL a = VTABLE_get_integer(interp, self);

if (PARROT_ERRORS_test(interp, PARROT_ERRORS_OVERFLOW_FLAG))
    Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_ERR_OVERFLOW,
        "Integer overflow");

if (self == dest) {
    VTABLE_morph(interp, self, enum_class_BigInt);
    VTABLE_set_integer_native(interp, self, a);
    return mmd_dispatch_p_ppp(interp, self, val, dest, mmd);
}
else {
    PMC * const temp = VTABLE_get_bignum(interp, self);
    return mmd_dispatch_p_ppp(interp, temp, val, dest, mmd);
}
}

pmclass Integer extends scalar provides integer provides scalar {

/*
=item C<PMC instantiate(PMC *sig)>

Create a new Integer with arguments passed according to pdd03.

=item C<void init()>

Initializes the integer with a default value of C<0>.

=cut

*/
VTABLE PMC *instantiate(PMC *sig) {
    PMC * const ret    = new_pmc_header(INTERP, 0);
    opcode_t   *arg_op = interp->current_args;
    INTVAL      init   = 0;

    ret->vtable        = interp->vtables[SELF->vtable->base_type];

    if (SIG_ELEMS(sig) == 2) {
        switch (SIG_ITEM(sig, 1)) {
            case PARROT_ARG_I:
                init = REG_INT(interp, arg_op[3]);
                break;
            case PARROT_ARG_IC:
                init = arg_op[3];
                break;
            default:
                Parrot_ex_throw_from_c_args(INTERP, NULL, 1,
                        "Integer.instantiate: unhandled initializer");
                break;
        }
    }

    PMC_int_val(ret) = init;
    return ret;
}

VTABLE void init() {
    PMC_int_val(SELF) = 0;
}

/*

=item C<PMC new_from_string(STRING *rep)>

Class method to construct an Integer from the string representation C<rep>.

=cut

*/
VTABLE PMC *new_from_string(STRING *rep, INTVAL flags) {
    const INTVAL type = SELF->vtable->base_type;
    PMC * const res =
        (flags & PObj_constant_FLAG)
            ? constant_pmc_new(INTERP, type)
            : pmc_new(INTERP, type);

    /* RT #46623 bigint overflow */
    PMC_int_val(res) = string_to_int(INTERP, rep);
    return res;
}

/*

=item C<void set_pmc(PMC *value)>

Sets the value of the integer to the value in C<*value>.

=cut

*/

VTABLE void set_pmc(PMC *value) {
    PMC_int_val(SELF) = VTABLE_get_integer(INTERP, value);
}

/*

=item C<void share()>

Sets this PMC as shared and read-only.

=cut

*/
VTABLE void share() {
    /*
     * assume that the access to a long is atomic.
     * integers are most often (1) equal to C longs,
     * not C ints, and this makes a difference in 64-bit
     * platforms where longs are 64-bit but ints are 32-bit.
     * (1) Not equal when integers have been configured
     *     to be software-emulated long longs.
     */
    if (sizeof (INTVAL) != sizeof (long))
        SUPER();
}

/*

=item C<INTVAL get_integer()>

Returns the integer value of the Integer.

=cut

*/
VTABLE INTVAL get_integer() {
    return PMC_int_val(SELF);
}

/*

=item C<INTVAL get_bool()>

Returns the boolean value of the Integer.

=cut

*/
    VTABLE INTVAL get_bool() {
        return SELF.get_integer() ? 1 : 0;
    }

/*

=item C<FLOATVAL get_number()>

Returns the floating-point value of the integer.

=cut

*/
    VTABLE FLOATVAL get_number() {
        return SELF.get_integer();
    }

/*

=item C<PMC *get_bignum()>

Return a new BigInt PMC with the value of C<SELF>.

=cut

*/
VTABLE PMC *get_bignum() {
    const INTVAL val = SELF.get_integer();
    PMC * const  ret = pmc_new(INTERP, enum_class_BigInt);
    VTABLE_set_integer_native(INTERP, ret, val);
    return ret;
}

/*

=item C<STRING *get_string()>

Returns the string value of the integer.

=cut

*/
    VTABLE STRING *get_string() {
        return string_from_int(INTERP, SELF.get_integer());
    }

    VTABLE STRING *get_repr() {
        return string_from_int(INTERP, SELF.get_integer());
    }

/*

=item C<void set_integer_same(PMC *value)>

=item C<void set_integer_native(INTVAL value)>

Sets the value of the integer to the value of the C<Integer> C<*value>.

=cut

*/
VTABLE void set_integer_same(PMC *value) {
    PMC_int_val(SELF) = PMC_int_val(value);
}

VTABLE void set_integer_native(INTVAL value) {
    PMC_int_val(SELF) = value;
}

/*

=item C<void set_number_native(FLOATVAL value)>

Morphs the integer to a C<Float> and sets the value from C<value>.

=item C<void set_bool(INTVAL value)>

Morphs the integer to a C<Boolean> and sets the value from C<value>.

=item C<void set_bigint_int(INTVAL value)>

Morphs the integer to a C<BigInt> and sets the value from C<value>.

=item C<void set_string_native(STRING *value)>

Morphs the integer to a C<String> and sets the value from C<value>.

=cut

*/
VTABLE void set_number_native(FLOATVAL value) {
    SELF.morph(enum_class_Float);
    SELF.set_number_native(value);
}

VTABLE void set_bool(INTVAL value) {
    SELF.morph(enum_class_Boolean);
    SELF.set_bool(value);
}

VTABLE void set_bignum_int(INTVAL value) {
    SELF.morph(enum_class_BigInt);
    SELF.set_integer_native(value);
}

VTABLE void set_string_native(STRING *value) {
    SELF.morph(enum_class_String);
    SELF.set_string_native(value);
}

/*

=item C<PMC *add(PMC *value, PMC *dest)>

=item C<PMC *add_int(INTVAL value, PMC *dest)>

Adds C<value> to the integer and returns the result in C<*dest>.

Please note: the label syntax I<MMD_type:> denote the behavior, if
the right hand value is of that type. The part inside the braces is
converted to a distinct function and gets I<mmd_register>ed for these
two types.

=cut

*/
VTABLE PMC *add(PMC *value, PMC *dest) {
MMD_Integer: {
        /*
         * SELF and value can both be PMCs that inherit
         * from Integer:
         *   cl = subclass "Integer", "MyInt"
         * so we can't used PMC_int_val(SELF) in any of these
         * Integer methods
         *
         * RT #46627
         *   check for exact Integer type
         *   e.g. MMD_Integer_EXACT
         */

        const INTVAL a = SELF.get_integer();
        const INTVAL b = VTABLE_get_integer(INTERP, value);
        const INTVAL c = a + b;

        if ((c^a) >= 0 || (c^b) >= 0) {
            if (!dest)
                dest = pmc_new(INTERP, VTABLE_type(interp, SELF));

            /* need this for e.g. Undef PMC */
            VTABLE_set_integer_native(INTERP, dest, c);
            return dest;
        }
        else
            return overflow(INTERP, SELF, b, dest, MMD_ADD);
    }
MMD_Complex: {
        const INTVAL a = SELF.get_integer();
        if (dest)
            VTABLE_morph(INTERP, dest, VTABLE_type(interp, value));
        else
            dest = pmc_new(INTERP, VTABLE_type(interp, value));

        VTABLE_set_number_native(INTERP, dest,
                a + VTABLE_get_number_keyed_int(INTERP, value, 0));
        VTABLE_set_number_keyed_int(INTERP, dest, 1,
                VTABLE_get_number_keyed_int(INTERP, value, 1));

        return dest;
    }
MMD_BigInt: {
        return overflow_p(INTERP, SELF, value, dest, MMD_ADD);
    }
MMD_DEFAULT: {
        if (!dest)
            dest = pmc_new(INTERP, VTABLE_type(interp, value));

        VTABLE_set_number_native(INTERP, dest,
            SELF.get_integer() + VTABLE_get_number(INTERP, value));
        return dest;
    }
}

VTABLE PMC *add_int(INTVAL b, PMC *dest) {
    const INTVAL a = VTABLE_get_integer(INTERP, SELF);
    const INTVAL c = a + b;

    if ((c^a) >= 0 || (c^b) >= 0) {
        if (!dest)
            dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));

        VTABLE_set_integer_native(INTERP, dest, c);
        return dest;
    }
    else
        return overflow(INTERP, SELF, b, dest, MMD_ADD);
}

/*

=item C<void i_add(PMC *value)>

=item C<void i_add(INTVAL value)>

=item C<void i_add(FLOATVAL value)>

Adds C<value> to C<SELF> inplace.

=cut

*/

VTABLE void i_add(PMC *value) {
MMD_Integer: {
        STATICSELF.i_add_int(VTABLE_get_integer(INTERP, value));
    }
MMD_Complex: {
        const INTVAL a = SELF.get_integer();

        VTABLE_morph(INTERP, SELF, value->vtable->base_type);
        VTABLE_set_number_native(INTERP, SELF,
            SELF.get_integer() + VTABLE_get_number(INTERP, value));
    }
MMD_DEFAULT: {
    VTABLE_set_number_native(INTERP, SELF,
        SELF.get_integer() + VTABLE_get_number(INTERP, value));
    }
}

VTABLE void i_add_int(INTVAL b) {
    const INTVAL a = SELF.get_integer();
    const INTVAL c = a + b;

    if ((c^a) >= 0 || (c^b) >= 0)
        VTABLE_set_integer_native(INTERP, SELF, c);
    else
        overflow(INTERP, SELF, b, SELF, MMD_SUBTRACT);
}

VTABLE void i_add_float(FLOATVAL value) {
    const INTVAL a = SELF.get_integer();
    VTABLE_set_number_native(INTERP, SELF, a + value);
}
/*

=item C<PMC *subtract(PMC *value, PMC *dest)>

Subtracts C<*value> from the integer and returns the result in C<*dest>.
If C<dest> is NULL, a new int PMC is created.

Please note: as C<SELF> or C<value> maybe be subclassed, we have to
call C<get_integer> and C<set_integer_native> always.

=cut

*/
VTABLE PMC *subtract(PMC *value, PMC *dest) {
MMD_Integer: {
        const INTVAL a = SELF.get_integer();
        const INTVAL b = VTABLE_get_integer(INTERP, value);
        const INTVAL c = a - b;

        if ((c^a) >= 0 || (c^~b) >= 0) {
            if (!dest)
                dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));

            VTABLE_set_integer_native(INTERP, dest, c);
            return dest;
        }
        else
            return overflow(INTERP, SELF, b, dest, MMD_SUBTRACT);
    }
MMD_Complex: {
        const INTVAL a = SELF.get_integer();
        if (dest)
            VTABLE_morph(INTERP, dest, value->vtable->base_type);
        else
            dest = pmc_new(INTERP, VTABLE_type(INTERP, value));

        VTABLE_set_number_native(INTERP, dest,
                a - VTABLE_get_number_keyed_int(INTERP, value, 0));
        VTABLE_set_number_keyed_int(INTERP, dest, 1,
                -VTABLE_get_number_keyed_int(INTERP, value, 1));

        return dest;
    }
MMD_BigInt: {
        return overflow_p(INTERP, SELF, value, dest, MMD_SUBTRACT);
    }
MMD_DEFAULT: {
        if (!dest)
            dest = pmc_new(INTERP, VTABLE_type(INTERP, value));

        VTABLE_set_number_native(INTERP, dest,
            SELF.get_integer() - VTABLE_get_number(INTERP, value));
        return dest;
    }
}

/*

=item C<PMC *subtract_int(INTVAL value, PMC *dest)>

Subtracts C<value> from the integer and returns the result in C<*dest>.

=cut

*/
VTABLE PMC *subtract_int(INTVAL b, PMC *dest) {
    const INTVAL a = SELF.get_integer();
    const INTVAL c = a - b;

    if ((c^a) >= 0 || (c^~b) >= 0) {
        if (!dest)
            dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));

        VTABLE_set_integer_native(INTERP, dest, c);
        return dest;
    }
    else
        return overflow(INTERP, SELF, b, dest, MMD_SUBTRACT);
}

/*

=item C<void i_subtract(PMC *value)>

=item C<void i_subtract_int(INTVAL value)>

=item C<void i_subtract_float(FLOATVAL value)>

Subtracts C<value> from C<SELF> inplace.

=cut

*/

VTABLE void i_subtract(PMC *value) {
MMD_Integer: {
        const INTVAL a = SELF.get_integer();
        const INTVAL b = VTABLE_get_integer(INTERP, value);
        const INTVAL c = a - b;

        if ((c^a) >= 0 || (c^~b) >= 0)
            VTABLE_set_integer_native(INTERP, SELF, c);
        else
            overflow(INTERP, SELF, b, SELF, MMD_SUBTRACT);
    }
MMD_Complex: {
        const INTVAL a = SELF.get_integer();

        VTABLE_morph(INTERP, SELF, value->vtable->base_type);
        VTABLE_set_number_native(INTERP, SELF,
                (FLOATVAL)a -
                VTABLE_get_number_keyed_int(INTERP, value, 0));
        VTABLE_set_number_keyed_int(INTERP, SELF, 1,
                -VTABLE_get_number_keyed_int(INTERP, value, 1));
    }
MMD_DEFAULT: {
    VTABLE_set_number_native(INTERP, SELF,
        SELF.get_integer() - VTABLE_get_number(INTERP, value));
    }
}

VTABLE void i_subtract_int(INTVAL b) {
    const INTVAL a = SELF.get_integer();
    const INTVAL c = a - b;

    if ((c^a) >= 0 || (c^~b) >= 0)
        VTABLE_set_integer_native(INTERP, SELF, c);
    else
        overflow(INTERP, SELF, b, SELF, MMD_SUBTRACT);
}

VTABLE void i_subtract_float(FLOATVAL value) {
    const INTVAL a = SELF.get_integer();
    VTABLE_set_number_native(INTERP, SELF, a - value);
}

/*

=item C<PMC *multiply(PMC *value, PMC *dest)>

=item C<PMC *multiply_int(INTVAL value, PMC *dest)>

Multiplies the integer by C<*value> and returns the result in C<*dest>.

=cut

*/
VTABLE PMC *multiply(PMC *value, PMC *dest) {
MMD_Integer: {
        const INTVAL a  = VTABLE_get_integer(INTERP, SELF);
        const INTVAL b  = VTABLE_get_integer(INTERP, value);
        const double cf = (double)a * (double)b;
        const INTVAL c  = a * b;

        if ((double) c == cf) {
            if (!dest)
                dest = pmc_new(INTERP, VTABLE_type(interp, SELF));

            VTABLE_set_integer_native(INTERP, dest, c);
            return dest;
        }
        else
            return overflow(INTERP, SELF, b, dest, MMD_MULTIPLY);
    }
MMD_Complex: {
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                EXCEPTION_INTERNAL_NOT_IMPLEMENTED,
                "RT #46629 mul<Integer, Complex>");
        }
MMD_BigInt:     {
        return Parrot_BigInt_multiply_int(INTERP, value,
                SELF.get_integer(), dest);
    }
MMD_String: {
        return Parrot_Integer_multiply_Integer(INTERP, SELF, value, dest);
    }
MMD_DEFAULT: {
        const FLOATVAL valf = VTABLE_get_number(INTERP, value);
        if (!dest)
            dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));

        VTABLE_set_number_native(INTERP, dest, SELF.get_number() * valf);
        return dest;
    }
}

VTABLE PMC *multiply_int(INTVAL b, PMC *dest) {
    const INTVAL a  = SELF.get_integer();
    const double cf = (double)a * (double)b;
    const INTVAL c  = a * b;

    if ((double) c == cf) {
        if (!dest)
            dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));

        VTABLE_set_integer_native(INTERP, dest, c);
        return dest;
    }
    else
        return overflow(INTERP, SELF, b, dest, MMD_MULTIPLY);
}

/*

=item C<void i_multiply(PMC *value)>

=item C<void i_multiply_int(INTVAL value)>

=item C<void i_multiply_float(FLOATVAL value)>

Multiply C<value> with C<SELF> inplace.

=cut

*/

VTABLE void i_multiply(PMC *value) {
MMD_Integer: {
        STATICSELF.i_multiply_int(VTABLE_get_integer(INTERP, value));
    }
MMD_BigInt: {
        Parrot_BigInt_multiply_int(INTERP, value,
                SELF.get_integer(), SELF);
    }
MMD_Complex: {
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                EXCEPTION_INTERNAL_NOT_IMPLEMENTED,
                "RT #46629 i_mul<Integer, Complex>");
    }
MMD_DEFAULT: {
        VTABLE_set_number_native(INTERP, SELF,
            SELF.get_integer() * VTABLE_get_number(INTERP, value));
    }
}

VTABLE void i_multiply_int(INTVAL b) {
    const INTVAL a  = SELF.get_integer();
    const double cf = (double)a * (double)b;
    const INTVAL c  = a * b;

    if ((double) c == cf)
        SELF.set_integer_native(c);
    else
        overflow(INTERP, SELF, b, SELF, MMD_MULTIPLY);
}

VTABLE void i_multiply_float(FLOATVAL value) {
    const INTVAL a = SELF.get_integer();
    VTABLE_set_number_native(INTERP, SELF, a * value);
}

/*

=item C<PMC *divide(PMC *value, PMC *dest)>

=item C<PMC *divide_int(INTVAL value, PMC *dest)>

=item C<PMC *divide_float(FLOATVAL value, PMC *dest)>

Divides the number by C<value> and returns the result in C<*dest>.

=item C<void i_divide(PMC *value)>

=item C<void i_divide_int(INTVAL value)>

=item C<void i_divide_float(FLOATVAL value)>

Divides C<SELF> by C<value> inplace.

=cut

*/

VTABLE PMC *divide(PMC *value, PMC *dest) {
MMD_BigInt:     {
        return overflow_p(INTERP, SELF, value, dest, MMD_DIVIDE);
    }
MMD_DEFAULT: {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        if (FLOAT_IS_ZERO(d))
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
                "float division by zero");

        if (!dest)
            dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));
        VTABLE_set_number_native(INTERP, dest, SELF.get_number() / d);
        return dest;
    }
}

VTABLE void i_divide(PMC *value) {
MMD_BigInt:     {
         overflow_p(INTERP, SELF, value, SELF, MMD_DIVIDE);
    }
MMD_DEFAULT: {
        FLOATVAL d = VTABLE_get_number(INTERP, value);

        if (FLOAT_IS_ZERO(d))
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
                    "float division by zero");

        VTABLE_set_number_native(INTERP, SELF, SELF.get_number() / d);
    }
}

/*

=item C<PMC *floor_divide(PMC *value, PMC *dest)>

=item C<PMC *floor_divide_int(INTVAL value, PMC *dest)>

=item C<PMC *floor_divide_float(FLOATVAL value, PMC *dest)>

Divides the number by C<value> and returns the result in C<*dest>.

=item C<void i_floor_divide(PMC *value)>

=item C<void i_floor_divide_int(INTVAL value)>

=item C<void i_floor_divide_float(FLOATVAL value)>

Divides C<SELF> by C<value> inplace.

=cut

*/

VTABLE PMC *floor_divide(PMC *value, PMC *dest) {
MMD_BigInt:     {
        return overflow_p(INTERP, SELF, value, dest, MMD_FLOOR_DIVIDE);
    }
MMD_DEFAULT: {
        FLOATVAL d = VTABLE_get_number(INTERP, value);
        FLOATVAL f;

        if (FLOAT_IS_ZERO(d))
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
                    "float division by zero");

        if (!dest)
            dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));

        f = floor(SELF.get_number() / d);
        VTABLE_set_integer_native(INTERP, dest, (INTVAL)f);
        return dest;
    }
}

VTABLE PMC *floor_divide_int(INTVAL value, PMC *dest) {
    FLOATVAL f;

    if (value == 0)
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
            "float division by zero");

    if (!dest)
        dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));

    f = floor(SELF.get_number() / value);
    VTABLE_set_integer_native(INTERP, dest, (INTVAL)f);

    return dest;
}

VTABLE PMC *floor_divide_float(FLOATVAL value, PMC *dest) {
    FLOATVAL f;

    if (FLOAT_IS_ZERO(value))
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
            "float division by zero");

    if (!dest)
        dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));

    f = floor(SELF.get_number() / value);
    VTABLE_set_integer_native(INTERP, dest, (INTVAL)f);

    return dest;
}

VTABLE void i_floor_divide(PMC *value) {
MMD_BigInt:     {
        overflow_p(INTERP, SELF, value, SELF, MMD_FLOOR_DIVIDE);
    }
MMD_DEFAULT: {
        FLOATVAL d = VTABLE_get_number(INTERP, value);
        FLOATVAL f;

        if (FLOAT_IS_ZERO(d))
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
                "float division by zero");

        f = floor(SELF.get_number() / d);
        VTABLE_set_integer_native(INTERP, SELF, (INTVAL)f);
    }
}

VTABLE void i_floor_divide_int(INTVAL value) {
    FLOATVAL f;

    if (value == 0)
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
            "float division by zero");

    f = floor(SELF.get_number() / value);
    VTABLE_set_integer_native(INTERP, SELF, (INTVAL)f);
}

VTABLE void i_floor_divide_float(FLOATVAL value) {
    FLOATVAL f;

    if (FLOAT_IS_ZERO(value))
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
            "float division by zero");

    f = floor(SELF.get_number() / value);
    VTABLE_set_integer_native(INTERP, SELF, (INTVAL)f);
}

/*

=item C<PMC *cmodulus(PMC *value, PMC *dest)>

=item C<PMC *cmodulus(INTVAL value, PMC *dest)>

=item C<PMC *cmodulus(FLOATVAL value, PMC *dest)>

Calculates the value of the number C-style C<mod> C<value> and returns
the result in C<dest>.

=item C<void i_cmodulus(PMC *value)>

=item C<void i_cmodulus(INTVAL value)>

=item C<void i_cmodulus(FLOATVAL value)>

Calculates the value of the number C-style C<mod> C<value> and returns
the result in C<dest>.

=cut

*/

VTABLE PMC *cmodulus(PMC *value, PMC *dest) {
MMD_BigInt: {
        return overflow_p(INTERP, SELF, value, dest, MMD_CMOD);
    }
MMD_DEFAULT: {
        INTVAL d = VTABLE_get_integer(INTERP, value);

        if (d == 0)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
                "int cmodulus by zero");

        if (!dest)
            dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));

        VTABLE_set_integer_native(INTERP, dest,
                SELF.get_integer() % d);
        return dest;
    }
}

VTABLE PMC *cmodulus_float(FLOATVAL value, PMC *dest) {
    FLOATVAL f;
    INTVAL   self_val;

    if (FLOAT_IS_ZERO(value))
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
            "int cmodulus by zero");

    if (!dest)
        dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));

    /* make the cast explicit, in two steps to satisfy picky compilers */
    self_val = SELF.get_integer();
    f        = fmod((FLOATVAL)self_val, value);

    VTABLE_set_integer_native(INTERP, dest, (INTVAL)f);

    return dest;
}

VTABLE PMC *cmodulus_int(INTVAL value, PMC *dest) {
    if (value == 0)
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
            "int cmodulus by zero");

    if (!dest)
        dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));
    VTABLE_set_integer_native(INTERP, dest,
            SELF.get_integer() % value);
    return dest;
}

VTABLE void i_cmodulus(PMC *value) {
MMD_BigInt: {
         overflow_p(INTERP, SELF, value, SELF, MMD_CMOD);
    }
MMD_DEFAULT: {
        const INTVAL d = VTABLE_get_integer(INTERP, value);

        if (d == 0)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
                "int cmodulus by zero");

        VTABLE_set_integer_native(INTERP, SELF,
                SELF.get_integer() % d);
    }
}

VTABLE void i_cmodulus_int(INTVAL value) {
    if (value == 0)
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
            "int cmodulus by zero");

    VTABLE_set_integer_native(INTERP, SELF,
            SELF.get_integer() % value);
}

VTABLE void i_cmodulus_float(FLOATVAL value) {
    FLOATVAL f;
    INTVAL   self_val;

    if (FLOAT_IS_ZERO(value))
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
            "int cmodulus by zero");

    /* make the cast explicit, in two steps to satisfy picky compilers */
    self_val = SELF.get_integer();
    f        = fmod((FLOATVAL)self_val, value);

    VTABLE_set_integer_native(INTERP, SELF, (INTVAL)f);
}

/*

=item C<PMC *modulus(PMC *value, PMC *dest)>

=item C<PMC *modulus(INTVAL value, PMC *dest)>

=item C<PMC *modulus(FLOATVAL value, PMC *dest)>

Calculates the value of corrected C<mod> C<value> and returns
the result in C<dest>. See also ops/math.ops.

=item C<void i_modulus(PMC *value)>

=item C<void i_modulus(INTVAL value)>

=item C<void i_modulus(FLOATVAL value)>

Calculates modulus inplace

=cut

*/

VTABLE PMC *modulus(PMC *value, PMC *dest) {
MMD_BigInt: {
        return overflow_p(INTERP, SELF, value, dest, MMD_MOD);
    }
MMD_DEFAULT: {
        const INTVAL d = VTABLE_get_integer(INTERP, value);

        if (d == 0)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
                "int modulus by zero");

        if (!dest)
            dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));

        VTABLE_set_integer_native(INTERP, dest,
                intval_mod(SELF.get_integer(), d));
        return dest;
    }
}

VTABLE PMC *modulus_int(INTVAL value, PMC *dest) {
    if (value == 0)
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
            "int modulus by zero");

    if (!dest)
        dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));

    VTABLE_set_integer_native(INTERP, dest,
            intval_mod(SELF.get_integer(), value));
    return dest;
}

VTABLE PMC *modulus_float(FLOATVAL value, PMC *dest) {
    if (FLOAT_IS_ZERO(value))
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
            "int modulus by zero");

    if (!dest)
        dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));

    VTABLE_set_integer_native(INTERP, dest,
            intval_mod(SELF.get_integer(), (INTVAL)value));
    return dest;
}
VTABLE void i_modulus(PMC *value) {
MMD_BigInt: {
         overflow_p(INTERP, SELF, value, SELF, MMD_MOD);
    }
MMD_DEFAULT: {
        const INTVAL d = VTABLE_get_integer(INTERP, value);

        if (d == 0)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
                "int modulus by zero");

        VTABLE_set_integer_native(INTERP, SELF,
                intval_mod(SELF.get_integer(), d));
    }
}

VTABLE void i_modulus_int(INTVAL value) {
    if (value == 0)
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
            "int modulus by zero");

    VTABLE_set_integer_native(INTERP, SELF,
            intval_mod(SELF.get_integer() , value));
}

VTABLE void i_modulus_float(FLOATVAL value) {
    if (FLOAT_IS_ZERO(value))
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_DIV_BY_ZERO,
            "int modulus by zero");

    VTABLE_set_integer_native(INTERP, SELF,
            intval_mod(SELF.get_integer() , (INTVAL)value));
}

/*

=item C<PMC *pow(PMC *value, PMC *dest)>

=item C<PMC *pow_int(INTVAL value, PMC *dest)>

Return SELF to the C<value>th power and return result in C<dest>.

=item C<void i_pow(PMC *value)>

=item C<void i_pow_int(INTVAL value)>

Raise SELF to the C<value>th power.

RT #46631 Complex and BigInt rhs.

=cut

*/
VTABLE PMC *pow(PMC *value, PMC *dest) {
    const INTVAL v = VTABLE_get_integer(INTERP, value);
    return STATICSELF.pow_int(v, dest);
}

VTABLE PMC *pow_int(INTVAL b, PMC *dest) {
    const INTVAL a      = SELF.get_integer();
    const INTVAL orig_b = b;
    INTVAL       r;

    if (b < 0)
        return SUPER(b, dest);

    r = 1;

    if (a) {
        INTVAL temp = a;
        while (b > 0) {
            INTVAL prev = r;
            if (b & 1) {
                r *= temp;
                if (r / temp != prev)
                    return overflow(INTERP, SELF, orig_b, dest, MMD_POW);
            }

            b >>= 1;
            if (!b)
                break;

            prev  = temp;
            temp *= temp;

            if (prev != 0 && temp / prev != prev)
                return overflow(INTERP, SELF, orig_b, dest, MMD_POW);
        }
    }

    if (!dest)
        dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));

    VTABLE_set_integer_native(INTERP, dest, r);
    return dest;

}

VTABLE void i_pow(PMC *value) {
    STATICSELF.pow(value, SELF);
}

VTABLE void i_pow_int(INTVAL value) {
    STATICSELF.pow_int(value, SELF);
}

/*

=item C<INTVAL is_equal(PMC *value)>

The C<==> operation.

=cut

*/
VTABLE INTVAL is_equal(PMC *value) {
MMD_BigInt: {
        PMC * const temp = pmc_new(INTERP, enum_class_BigInt);
        VTABLE_set_integer_native(INTERP, temp, SELF.get_integer());
        return Parrot_BigInt_is_equal_BigInt(INTERP, temp, value);
    }
MMD_DEFAULT: {
    return (VTABLE_get_integer(INTERP, SELF) ==
        VTABLE_get_integer(INTERP, value));
    }
}

/*

=item C<INTVAL cmp(PMC *value)>

Returns the result of comparing the integer with C<*value>.

=cut

*/
VTABLE INTVAL cmp(PMC *value) {
MMD_String: {
            FLOATVAL fdiff =
                SELF.get_number() - VTABLE_get_number(INTERP, value);
            if (FLOAT_IS_ZERO(fdiff)) {
                const INTVAL idiff =
                    SELF.get_integer() - VTABLE_get_integer(INTERP, value);
                return idiff > 0 ? 1 : idiff < 0 ? -1 : 0;
            }
            else {
                return fdiff > 0 ? 1 : -1;
            }
    }
MMD_Float: {
            const FLOATVAL diff =
                SELF.get_number() - VTABLE_get_number(INTERP, value);
            return diff > 0 ? 1 : diff < 0 ? -1 : 0;
        }
MMD_DEFAULT: {
            /* int or undef */
            const INTVAL selfval = SELF.get_integer();
            const INTVAL other = VTABLE_get_integer(INTERP, value);
            return selfval > other ? 1 : selfval < other ? -1 : 0;
        }
}

/*

=item C<INTVAL cmp_num(PMC *value)>

Returns the result of numerically comparing the integer with C<*value>.

=cut

*/
VTABLE INTVAL cmp_num(PMC *value) {
MMD_String: {
            FLOATVAL fdiff =
                SELF.get_number() - VTABLE_get_number(INTERP, value);

            if (FLOAT_IS_ZERO(fdiff)) {
                const INTVAL idiff =
                    SELF.get_integer() - VTABLE_get_integer(INTERP, value);
                return idiff > 0 ? 1 : idiff < 0 ? -1 : 0;
            }
            else {
                return fdiff > 0 ? 1 : -1;
            }
        }
MMD_Float: {
            const FLOATVAL diff =
                SELF.get_number() - VTABLE_get_number(INTERP, value);
            return diff > 0 ? 1 : diff < 0 ? -1 : 0;
        }
MMD_DEFAULT: {
            /* int or undef */
            const INTVAL diff =
                SELF.get_integer() - VTABLE_get_integer(INTERP, value);
            return diff > 0 ? 1 : diff < 0 ? -1 : 0;
        }
}

/*

=item C<void increment()>

Increments the integer.

=cut

*/
VTABLE void increment() {
    /* RT #46633 overflow */
    PMC_int_val(SELF) ++;
}

/*

=item C<void decrement()>

Decrements the integer.

=cut

*/
VTABLE void decrement() {
    /* RT #46633 overflow */
    PMC_int_val(SELF) --;
}
/*

=item C<PMC *absolute(PMC *dest)>

=item C<void absolute()>

Sets C<dest> to the absolute value of SELF.

=cut

*/

VTABLE PMC *absolute(PMC *dest) {
    const INTVAL a = abs(SELF.get_integer());

    /* RT #46635 overlflow for -maxint */
    if (!dest)
        dest = pmc_new(INTERP, VTABLE_type(INTERP, SELF));

    VTABLE_set_integer_native(INTERP, dest, a);
    return dest;

}

VTABLE void i_absolute() {
    const INTVAL a = abs(SELF.get_integer());
    VTABLE_set_integer_native(INTERP, SELF, a);
}

/*

=item C<STRING *get_as_base(INTVAL base)>

Converts and returns the integer in base C<base>.
C<base> must be between 2 and 36, inclusive.

=cut

*/

METHOD get_as_base(INTVAL base) {
    char buf[128];
    STRING *result;

    if ((base < 2) || (base > 36))
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_OUT_OF_BOUNDS,
            "get_as_base: base out of bounds");

        result = int_to_str(interp, buf,
                (HUGEINTVAL)VTABLE_get_integer(INTERP, SELF), base);
        RETURN(STRING *result);
    }

/*

=item C<void freeze(visit_info *info)>

Used to archive the integer.

=cut

*/
    VTABLE void freeze(visit_info *info) {
        IMAGE_IO * const io = info->image_io;
        SUPER(info);
        VTABLE_push_integer(INTERP, io, PMC_int_val(SELF));
    }

/*

=item C<void thaw(visit_info *info)>

Used to unarchive the integer.

=cut

*/
    VTABLE void thaw(visit_info *info) {
        IMAGE_IO * const io = info->image_io;
        SUPER(info);
        if (info->extra_flags == EXTRA_IS_NULL)
            PMC_int_val(SELF) = VTABLE_shift_integer(INTERP, io);
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
