/*
Copyright (C) 2005-2007, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/namespace.pmc - NameSpace PMC

=head1 DESCRIPTION

These are the vtable functions for the namespace PMC.

=head2 Data

  PMC_struct_val       ... the hash, bucket->value is a
                           var/sub, a namespace, or a FixedPMCarray
                           of 2 PMCs (namespace, sub/var) slots
  PMC_pmc_val          ... parent namespace
  PMC_data             ... Namespace information struct (name, class/role)

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

/*
 * Typically a named slot contains either another namespace or a
 * var/sub (not both).
 * In case that the bucket->value is occupied, a FixedPMCArray is
 * created, and the items are moved over to that extra storage.
 * The array is flagged with FPA_is_ns_ext to distinguish it from a
 * plain array variable.
 *
 * This could easily expand to a full-fledged typed namespace if needed.
 */

typedef enum {
    NS_slot_ns,
    NS_slot_var_sub,         /* unspecified ~half-raw slot */
    NS_max_slots
} NS_slot_enum;

#define FPA_is_ns_ext PObj_private0_FLAG
#define NS_HASH(pmc) ((Hash *)PMC_struct_val(pmc))


/* We store extra information about the namespace in a struct, which we will
 * hang off the PMC_data slot. */
typedef struct Parrot_NSInfo {
    STRING *name;     /* Name of this namespace part. */
    PMC    *_class;   /* The class or role attached to this namespace. */
    PMC    *methods;  /* A Hash of methods, keyed on the method name. This
                       * goes away when the methods are sucked in by a
                       * class. */
    PMC    *vtable;   /* A Hash of vtable subs, keyed on the vtable index */
} Parrot_NSInfo;

/* Macro for easy access to the namespace info. */
#define PARROT_NSINFO(o) ((Parrot_NSInfo *) PMC_data(o))

pmclass NameSpace extends Hash does hash need_ext no_ro {

/*

=item C<void init()>

Initialize a C<NameSpace> PMC by calling C<Hash.init> and clearing
other fields.

=cut

*/

    void init() {
        SUPER();                             /* _struct_val := Hash */
        PMC_pmc_val(SELF)           = NULL;  /* parent */
        PMC_data(SELF)              = mem_allocate_zeroed_typed(Parrot_NSInfo);
        PARROT_NSINFO(SELF)->vtable = PMCNULL;
    }

/*

=item C<void mark()>

Marks the namespace as live.

=cut

*/
    void mark() {
        Parrot_NSInfo *nsinfo = PARROT_NSINFO(SELF);
        SUPER();
        if (PMC_pmc_val(SELF))
            pobject_lives(INTERP, (PObj *)PMC_pmc_val(SELF));
        if (nsinfo->name)
            pobject_lives(INTERP, (PObj *)nsinfo->name);
        if (nsinfo->_class)
            pobject_lives(INTERP, (PObj *)nsinfo->_class);
        if (nsinfo->vtable)
            pobject_lives(INTERP, (PObj *)nsinfo->vtable);
        if (nsinfo->methods)
            pobject_lives(INTERP, (PObj *)nsinfo->methods);
    }

/*

=item C<void destroy()>

Frees the namespace info struct.

=cut

*/
    void destroy() {
        mem_sys_free(PARROT_NSINFO(SELF));
        SUPER();
    }

/*

=item C<PMC *get_class()>

Returns the class or role PMC that is associated with this namespace.

=cut

*/

    PMC *get_class()
    {
        Parrot_NSInfo *nsinfo    = PARROT_NSINFO(SELF);
        return nsinfo->_class;
    }

/*

=item C<void set_pmc_keyed_str(STRING *key, PMC *value)>

Sets C<*value> as the namespace item for C<*key>. This is part of the
raw interface. If the PMC C<value> is exactly a NameSpace, C<SELF>
will be set as the parent of that namespace and the name C<key> of
C<value> is stored too.

=item C<void set_pmc_keyed(PMC *key, PMC *value)>

If C<key> is a simple key, it works like above. If C<key> is an array
of strings or a chained key, add all components to the namespace.

=item C<PMC *get_pmc_keyed(PMC *key)>

Return the given namespace or PMCNULL. C<key> is either an array of
strings, or a possibly nested key.

=item C<PMC *get_pmc_keyed_str(STRING *key)>

Return the given namespace item or PMCNULL. If the named item is either
a NameSpace or a var, the NameSpace is returned.

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Return a Sub representing an overridden vtable entry or PMCNULL.  This is not
really a public API.

=cut

*/

    void set_pmc_keyed_str(STRING *key, PMC *value) {
        const int   val_is_NS =
            value->vtable->base_type == enum_class_NameSpace;
        PMC        *new_tuple = NULL;
        HashBucket *b         =
            parrot_hash_get_bucket(INTERP, NS_HASH(SELF), key);

        /* If it's a sub... */
        if (value->vtable->base_type == enum_class_Sub) {
            Parrot_NSInfo *nsinfo    = PARROT_NSINFO(SELF);
            PMC           *vtable    = nsinfo->vtable;
            Parrot_sub    *sub       = PMC_sub(value);
            PMC * const classobj = VTABLE_get_class(interp, SELF);

            /* Handle vtable methods with two underscores at the start. */
            if (sub->vtable_index == -1) {
                if (string_str_index(interp, key,
                    CONST_STRING(interp, "__"), 0) == 0) {
                    STRING * const meth_name = string_substr(interp, key, 2,
                        string_length(interp, key) - 2, NULL, 0);
                    sub->vtable_index        =
                        Parrot_get_vtable_index(interp, meth_name);
                }
            }

            if (sub->vtable_index != -1) {
                /* Insert it in class, if there is a class */
                if (!PMC_IS_NULL(classobj) && PObj_is_class_TEST(classobj))
                    VTABLE_add_vtable_override(interp, classobj, key, value);

                /* Otherwise, store it in the namespace for the class to
                 * retrieve later */
                else {
                    /* If we don't have a place to hang vtable methods, make one. */
                    if (PMC_IS_NULL(vtable))
                        nsinfo->vtable = vtable = pmc_new(interp, enum_class_Hash);

                    /* Insert it. */
                    VTABLE_set_pmc_keyed_int(INTERP, vtable,
                        sub->vtable_index, value);
                }
            }

            if (sub->comp_flags & SUB_COMP_FLAG_METHOD) {
                /* Insert it in class, if there is a class */
                if (!PMC_IS_NULL(classobj) && PObj_is_class_TEST(classobj))
                    VTABLE_add_method(interp, classobj, key, value);

                /* Otherwise, store it in the namespace for the class to
                 * retrieve later */
                else {
                    /* If we don't have a place to hang methods, make one. */
                    if (PMC_IS_NULL(nsinfo->methods))
                        nsinfo->methods = pmc_new(interp, enum_class_Hash);

                    /* Insert it. */
                    VTABLE_set_pmc_keyed_str(INTERP, nsinfo->methods, key, value);
                }
            }

            /* If it's anonymous, we're done. */
            if (PObj_get_FLAGS(value) & SUB_FLAG_PF_ANON)
                return;
        }

        /* If it's an NCI method */
        if (value->vtable->base_type == enum_class_NCI) {
            Parrot_NSInfo *nsinfo    = PARROT_NSINFO(SELF);
            PMC * const classobj = VTABLE_get_class(interp, SELF);

            /* Insert it in class, if there is a class */
            if (!PMC_IS_NULL(classobj) && PObj_is_class_TEST(classobj))
                VTABLE_add_method(interp, classobj, key, value);

            /* Otherwise, store it in the namespace for the class to
             * retrieve later */
            else {
                /* If we don't have a place to hang methods, make one. */
                if (PMC_IS_NULL(nsinfo->methods))
                    nsinfo->methods = pmc_new(interp, enum_class_Hash);

                /* Insert it. */
                VTABLE_set_pmc_keyed_str(INTERP, nsinfo->methods, key, value);
            }
        }

        /* If it's a multi-sub... */
        if (value->vtable->base_type == enum_class_MultiSub) {

            if (VTABLE_elements(interp, value) > 0) {
                Parrot_NSInfo *nsinfo    = PARROT_NSINFO(SELF);
                PMC * const classobj = VTABLE_get_class(interp, SELF);

                /* Extract the first alternate and check if it is a method */
                Parrot_sub *sub = PMC_sub(VTABLE_get_pmc_keyed_int(interp, value, 0));

                if (sub->comp_flags & SUB_COMP_FLAG_METHOD) {
                    /* Insert it in class, if there is a class */
                    if (!PMC_IS_NULL(classobj) && PObj_is_class_TEST(classobj))
                        VTABLE_add_method(interp, classobj, key, value);

                    /* Otherwise, store it in the namespace for the class to
                     * retrieve later */
                    else {
                        /* If we don't have a place to hang methods, make one. */
                        if (PMC_IS_NULL(nsinfo->methods))
                            nsinfo->methods = pmc_new(interp, enum_class_Hash);

                        /* Insert it. */
                        VTABLE_set_pmc_keyed_str(INTERP, nsinfo->methods, key, value);
                    }

                    SUPER(key, value);
                }
            }
        }

        if (!b)
            SUPER(key, value);
        else {
            PMC *old = (PMC *)b->value;

            if ((old->vtable->base_type == enum_class_NameSpace) == val_is_NS) {
                /* simple ns or simple var/sub changed */
                SUPER(key, value);
            }
            else if ((PObj_get_FLAGS(old) & FPA_is_ns_ext) &&
                    old->vtable->base_type == enum_class_FixedPMCArray) {
                /* we have a tuple extension already */
                VTABLE_set_pmc_keyed_int(INTERP, old,
                        val_is_NS ? NS_slot_ns : NS_slot_var_sub,
                        value);
            }
            else {
                /* create new tuple */
                new_tuple = pmc_new(INTERP, enum_class_FixedPMCArray);

                /* flag it as special */
                PObj_get_FLAGS(new_tuple) |= FPA_is_ns_ext;

                /* for a fully typed namespace, we'd need 3 or 4 */
                VTABLE_set_integer_native(INTERP, new_tuple, NS_max_slots);
            }
        }

        if (val_is_NS) {
            /* TODO - this hack needs to go */
            Parrot_NSInfo *nsinfo = PARROT_NSINFO(value);
            PMC_pmc_val(value)    = SELF;  /* set parent */
            nsinfo->name          = key;   /* and name */

            if (new_tuple) {
                VTABLE_set_pmc_keyed_int(INTERP, new_tuple, NS_slot_ns, value);
                VTABLE_set_pmc_keyed_int(INTERP, new_tuple, NS_slot_var_sub,
                                         (PMC *)b->value);
                b->value = new_tuple;
                /* distinction from a plain FPA, which doesn't extend the
                 * namespace storage
                 */
            }
        }
        else if (new_tuple) {
            VTABLE_set_pmc_keyed_int(INTERP, new_tuple, NS_slot_ns,
                (PMC *)b->value);
            VTABLE_set_pmc_keyed_int(INTERP, new_tuple, NS_slot_var_sub, value);
            b->value = new_tuple;
        }
    }

    void set_pmc_keyed(PMC *key, PMC *value) {
        PMC    *ns = SELF;
        STRING *part;

        if (key->vtable->base_type == enum_class_String) {
            SELF.set_pmc_keyed_str(VTABLE_get_string(INTERP, key), value);
            return;
        }

        if (key->vtable->base_type == enum_class_Key) {
            while (1) {
                part = key_string(INTERP, key);
                key  = key_next(INTERP, key);

                if (!key) {
                    Parrot_set_global(INTERP, ns, part, value);
                    return;
                }

                ns = Parrot_make_namespace_keyed_str(INTERP, ns, part);
            }
        }

        if (key->vtable->base_type == enum_class_ResizableStringArray) {
            INTVAL elements = VTABLE_elements(interp, key);
            INTVAL i;
            for (i = 0; i < elements; ++i)  {
                part = VTABLE_get_string_keyed_int(interp, key, i);

                if ((i + 1) >= elements) { /* Last entry in the array */
                    Parrot_set_global(INTERP, ns, part, value);
                    return;
                }

                ns = Parrot_make_namespace_keyed_str(INTERP, ns, part);
            }
        }

        real_exception(INTERP, NULL, E_NameError,
            "Invalid namespace key in set_pmc_keyed");
    }

    PMC *get_pmc_keyed_str(STRING *key) {
        PMC *ns = (PMC *)parrot_hash_get(INTERP, NS_HASH(SELF), key);

        if (!ns)
            return PMCNULL;

        if ((PObj_get_FLAGS(ns) & FPA_is_ns_ext) &&
                ns->vtable->base_type == enum_class_FixedPMCArray)
            ns = VTABLE_get_pmc_keyed_int(INTERP, ns, NS_slot_ns);

        return ns;
    }

    PMC *get_pmc_keyed(PMC *key) {
        PMC    *ns = SELF;
        STRING *part;

        if (key->vtable->base_type == enum_class_String)
            return SELF.get_pmc_keyed_str(VTABLE_get_string(INTERP, key));

        if (key->vtable->base_type == enum_class_Key) {
            while (key) {
                part = key_string(INTERP, key);
                key  = key_next(INTERP, key);

                if (!key)
                    return VTABLE_get_pmc_keyed_str(INTERP, ns, part);

                ns = Parrot_get_namespace_keyed_str(INTERP, ns, part);

                if (PMC_IS_NULL(ns))
                    return PMCNULL;
            }

            return ns;
        }

        real_exception(INTERP, NULL, E_NameError,
            "Invalid namespace key in get_pmc_keyed_str");
    }

    PMC *get_pmc_keyed_int(INTVAL key) {
        Parrot_NSInfo *nsinfo = PARROT_NSINFO(SELF);
        PMC           *vtable = nsinfo->vtable;

        if (PMC_IS_NULL(vtable))
            return PMCNULL;

        return VTABLE_get_pmc_keyed_int(interp, vtable, key);
    }

/*

=item C<void *get_pointer_keyed_str(STRING *key)>

=item C<void *get_pointer_keyed(PMC *key)>

Return the given namespace item or PMCNULL. If the named item is either
a NameSpace or a var, the var is returned.

TOTAL KLUDGE.  ON THE CHOPPING BLOCK.

=cut

*/

    void *get_pointer_keyed_str(STRING *key) {
        PMC *ns = (PMC *)parrot_hash_get(INTERP, NS_HASH(SELF), key);

        if (PMC_IS_NULL(ns))
            return PMCNULL;

        if ((PObj_get_FLAGS(ns) & FPA_is_ns_ext) &&
                ns->vtable->base_type == enum_class_FixedPMCArray)
            ns = VTABLE_get_pmc_keyed_int(INTERP, ns, NS_slot_var_sub);

        return ns;
    }

    void *get_pointer_keyed(PMC *key) {
        PMC    *ns = SELF;
        STRING *part;

        if (PMC_IS_NULL(key))
          return PMCNULL;

        if (key->vtable->base_type == enum_class_String)
            return SELF.get_pointer_keyed_str(VTABLE_get_string(INTERP, key));

        if (key->vtable->base_type == enum_class_Key) {
            while (key) {
                part = key_string(INTERP, key);
                key  = key_next(INTERP, key);

                if (!key)
                    return VTABLE_get_pointer_keyed_str(INTERP, ns, part);

                ns = Parrot_get_namespace_keyed_str(INTERP, ns, part);

                if (PMC_IS_NULL(ns))
                    return PMCNULL;
            }

            return ns;
        }

        if (key->vtable->base_type == enum_class_ResizableStringArray) {
            INTVAL elements = VTABLE_elements(interp, key);
            INTVAL i;
            for (i = 0; i < elements; ++i)  {
                part = VTABLE_get_string_keyed_int(interp, key, i);

                if ((i + 1) >= elements) /* Last entry in the array */
                    return VTABLE_get_pointer_keyed_str(INTERP, ns, part);

                ns = Parrot_get_namespace_keyed_str(INTERP, ns, part);

                if (PMC_IS_NULL(ns))
                    return PMCNULL;
            }
            return ns;
        }

        real_exception(INTERP, NULL, E_NameError,
            "Invalid namespace key in get_pointer_keyed");
    }

/*

=item C<STRING *get_string()>

Return the name of this namespace part.

=cut

*/

    STRING *get_string() {
        Parrot_NSInfo *nsinfo = PARROT_NSINFO(SELF);
        return nsinfo->name;
    }

/*

=back

=head2 Methods

=over 4

=cut

*/

/*

=item C<METHOD void PMC *add_namespace(STRING *name, PMC *namespace)>

Stores the given namespace under this namespace, with the given name.  Throws
an invalid type exception if C<namespace> is not a NameSpace PMC or subclass.

=cut

*/

    METHOD void add_namespace(STRING *name, PMC *_namespace) {
        STRING *s_ns = CONST_STRING(INTERP, "NameSpace");

        if (!VTABLE_isa(INTERP, _namespace, s_ns))
            real_exception(INTERP, NULL, E_TypeError,
                "Invalid type %d in add_namespace()",
                _namespace->vtable->base_type);

        VTABLE_set_pmc_keyed_str(INTERP, SELF, name, _namespace);
    }

/*

/*

=item C<METHOD void PMC *add_sub(STRING *name, PMC *sub)>

Stores the given sub under this namespace, with the given name.  Throws an
invalid type exception if C<sub> is not a Sub PMC or subclass.

=cut

*/

    METHOD void add_sub(STRING *name, PMC *sub) {
        STRING *s_sub = CONST_STRING(INTERP, "Sub");

        if (!VTABLE_isa(INTERP, sub, s_sub))
            real_exception(INTERP, NULL, E_TypeError,
                "Invalid type %d in add_sub()", sub->vtable->base_type);

        VTABLE_set_pmc_keyed_str(INTERP, SELF, name, sub);
    }

/*

/*

=item C<METHOD void PMC *add_var(STRING *name, PMC *var)>

Stores the given sub under this namespace, with the given name.

=cut

*/

    METHOD void add_var(STRING *name, PMC *var) {
        VTABLE_set_pmc_keyed_str(INTERP, SELF, name, var);
    }

/*

=item C<METHOD PMC *get_name()>

Returns the name of the namespace as an array of strings.

  $P2 = $P3.'get_name'()
  $S0 = join '::', $P2            # '::Foo::Bar'

=cut

*/

    METHOD PMC *get_name() {
        PMC *ar = pmc_new(INTERP, enum_class_ResizableStringArray);
        PMC *ns = SELF;

        while (ns) {
            Parrot_NSInfo *nsinfo = PARROT_NSINFO(ns);
            VTABLE_unshift_string(INTERP, ar, nsinfo->name);
            ns = PMC_pmc_val(ns);
        }

        /* remove the NULL string of the namespace root */
        VTABLE_shift_string(INTERP, ar);

        return ar;
    }
/*

=item C<METHOD PMC *find_namespace(STRING *name)>

Return the namespace with the given name.

=cut

*/

    METHOD PMC *find_namespace(STRING *key) {
        STRING *s_ns = CONST_STRING(INTERP, "NameSpace");
        PMC    *ns   = (PMC *)parrot_hash_get(INTERP, NS_HASH(SELF), key);

        if (!ns)
            return PMCNULL;

        /* it's a NameSpace */
        if (VTABLE_isa(INTERP, ns, s_ns))
            return ns;

        return PMCNULL;
    }

/*

=item C<METHOD PMC *find_sub(STRING *name)>

Return the Sub PMC with the given name.

=cut

*/

    METHOD PMC *find_sub(STRING *key) {
        STRING *s_sub = CONST_STRING(INTERP, "Sub");
        PMC    *sub   = (PMC *)parrot_hash_get(INTERP, NS_HASH(SELF), key);

        if (!sub)
            return PMCNULL;

        /* it's a Sub */
        if (VTABLE_isa(INTERP, sub, s_sub))
            return sub;

        return PMCNULL;
    }

/*

=item C<METHOD PMC *find_var(STRING *name)>

Return the PMC with the given name.

=cut

*/

    METHOD PMC *find_var(STRING *key) {
        PMC *val = (PMC *)parrot_hash_get(INTERP, NS_HASH(SELF), key);

        if (!val)
            return PMCNULL;

        return val;
    }

/*

=item C<METHOD PMC *del_namespace(STRING *name)>

Deletes the contained NameSpace PMC with the given name.  Throws an invalid
type exception if the item to delete is not a NameSpace PMC or subclass, and
does not delete the PMC.

=cut

*/

    METHOD void del_namespace(STRING *name) {
        Hash   *hash = NS_HASH(SELF);
        PMC    *ns   = (PMC *)parrot_hash_get(INTERP, hash, name);
        STRING *s_ns = CONST_STRING(INTERP, "NameSpace");

        if (PMC_IS_NULL(ns))
            return;

        if (!VTABLE_isa(INTERP, ns, s_ns)) {
            char *item_name = string_to_cstring(INTERP, name);
            real_exception(INTERP, NULL, E_TypeError,
                "Invalid type %d for '%s' in del_namespace()",
                ns->vtable->base_type, item_name);

            /* leak! */
            string_cstring_free(item_name);
        }

        parrot_hash_delete(INTERP, hash, name);
    }

/*

=item C<METHOD PMC *del_sub(STRING *name)>

Deletes the contained Sub PMC with the given name.  Throws an invalid type
exception if the item to delete is not a Sub PMC or subclass, and does not
delete the PMC.

=cut

*/

    METHOD void del_sub(STRING *name) {
        Hash   *hash  = NS_HASH(SELF);
        PMC    *sub   = (PMC *)parrot_hash_get(INTERP, hash, name);
        STRING *s_sub = CONST_STRING(INTERP, "Sub");

        if (PMC_IS_NULL(sub))
            return;

        if (!VTABLE_isa(INTERP, sub, s_sub)) {
            char *item_name = string_to_cstring(INTERP, name);
            real_exception(INTERP, NULL, E_TypeError,
                "Invalid type %d for '%s' in del_sub()",
                sub->vtable->base_type, item_name);

            /* leak! */
            string_cstring_free(item_name);
        }

        parrot_hash_delete(INTERP, hash, name);
    }

/*

=item C<METHOD PMC *del_var(STRING *name)>

Deletes the contained variable-like PMC with the given name.

=cut

*/

    METHOD void del_var(STRING *name) {
        parrot_hash_delete(INTERP, NS_HASH(SELF), name);
    }

/*

=item C<METHOD PMC *get_sym(STRING *name)>

Return the symbol (var or sub) with the given name. This can be used
to retrieve symbols, if a NameSpace with the same name exists.

=cut

*/

    METHOD PMC *get_sym(STRING *key) {
        PMC *ns = (PMC *)parrot_hash_get(INTERP, NS_HASH(SELF), key);

        if (!ns)
            return PMCNULL;

        /* it's a NameSpace */
        if (ns->vtable == SELF->vtable)
            return PMCNULL;

        if ((PObj_get_FLAGS(ns) & FPA_is_ns_ext) &&
                ns->vtable->base_type == enum_class_FixedPMCArray)
            ns = VTABLE_get_pmc_keyed_int(INTERP, ns, NS_slot_var_sub);

        return ns;
    }

/*

=item C<METHOD void export_to(PMC *dest, PMC *what)>

Export items from this NameSpace into the C<dest> NameSpace. The items to
export are named in C<what>, which may be an array of strings, a hash, or null.
If C<what> is an array of strings, interpretation of items in an array follows
the conventions of the source (exporting) namespace.
If C<what> is a hash, the keys correspond to the names in the source namespace,
and the values correspond to the names in the destination namespace.
if a hash value is null or an empty string, the name in the hash key is used.
A null C<what> requests the 'default' set of items.
Any other type passed in C<what> throws an exception.

NOTE: exporting 'default' set of items is not yet implemented.

=cut

*/

    METHOD void export_to(PMC *dest, PMC *what) {
        STRING *s_hash  = CONST_STRING(interp, "hash");
        STRING *s_array = CONST_STRING(interp, "array");

        if (PMC_IS_NULL(dest)) {
            real_exception(interp, NULL, 0,
                    "destination namespace not specified");
            return;
        }

        if (PMC_IS_NULL(what) || !VTABLE_elements(interp, what)) {
            real_exception(interp, NULL, 0,
                    "exporting default object set not yet implemented");
            return;
        }

        /* if "what" does "hash", we extract string key/value pairs,
         * lookup the object with the name specified in the key,
         * and export it with the name specified as value. */
        if (VTABLE_does(INTERP, what, s_hash)) {
            PMC * const  iter = VTABLE_get_iter(interp, what);
            const INTVAL n    = VTABLE_elements(interp, what);
            INTVAL       i;

            for (i = 0; i < n; ++i) {
                STRING *dest_name;
                PMC    *object;
                STRING *src_name = VTABLE_shift_string(interp, iter);

                if (STRING_IS_NULL(src_name) || STRING_IS_EMPTY(src_name)) {
                    real_exception(interp, NULL, 0,
                        "source object name not specified");
                    return;
                }

                if (PMC_IS_NULL(VTABLE_get_pmc_keyed_str(interp, what, src_name))) {
                    dest_name = src_name;
                }
                else {
                    dest_name = VTABLE_get_string_keyed_str(interp, what, src_name);
                    if (STRING_IS_NULL(dest_name) || STRING_IS_EMPTY(dest_name))
                        dest_name = src_name;
                }

                object = VTABLE_get_pmc_keyed_str(interp, SELF, src_name);

                if (PMC_IS_NULL(object)) {
                    real_exception(interp, NULL, 0,
                            "object '%s' not found in current namespace",
                            string_to_cstring(interp, src_name));
                    return;
                }

                VTABLE_set_pmc_keyed_str(interp, dest, dest_name, object);
            }
        }
        else if (VTABLE_does(INTERP, what, s_array)) {
            const INTVAL n = VTABLE_elements(interp, what);
            INTVAL       i;

            for (i = 0; i < n; ++i) {
                PMC    *object;
                STRING *name = VTABLE_get_string_keyed_int(interp, what, i);

                if (STRING_IS_NULL(name) || STRING_IS_EMPTY(name)) {
                    real_exception(interp, NULL, 0, "object name not specified");
                    return;
                }

                object = VTABLE_get_pmc_keyed_str(interp, SELF, name);

                if (PMC_IS_NULL(object)) {
                    real_exception(interp, NULL, 0,
                            "object '%s' not found in current namespace",
                            string_to_cstring(interp, name));
                    return;
                }

                VTABLE_set_pmc_keyed_str(interp, dest, name, object);
            }
        }
        else {
            real_exception(interp, NULL, 0,
                "can't handle argument of type %s", what->vtable->base_type);
        }
    }

/*

=item C<METHOD PMC *get_parent()>

Return the parent NameSpace or PMCNULL, if none.

=cut

*/

    METHOD PMC *get_parent() {
        return PMC_pmc_val(SELF) ? PMC_pmc_val(SELF) : PMCNULL;
    }

/*

=item C<PCCMETHOD get_class()>

Returns the class or role PMC that is associated with this namespace.

=cut

*/

    PCCMETHOD get_class() {
        Parrot_NSInfo *nsinfo    = PARROT_NSINFO(SELF);
        PMC           *ret_class = nsinfo->_class;

        if (PMC_IS_NULL(ret_class))
            ret_class = PMCNULL;

        PCCRETURN(PMC *ret_class);
    }

/*

=item C<PCCMETHOD set_class(PMC *class_or_role)>

Sets the class or role PMC that is associated with this namespace.

=cut

*/

    PCCMETHOD set_class(PMC *class_or_role) {
        Parrot_NSInfo *nsinfo = PARROT_NSINFO(SELF);
        nsinfo->_class        = class_or_role;
    }

/*

=item C<PCCMETHOD get_associated_methods()>

Gets the Hash of methods associated with this namespace and removes it from
the namespace.

=cut

*/

    PCCMETHOD get_associated_methods() {
        Parrot_NSInfo *nsinfo      = PARROT_NSINFO(SELF);
        PMC           *ret_methods = nsinfo->methods;
        nsinfo->methods            = PMCNULL;

        PCCRETURN(PMC *ret_methods);
    }

/*

=item C<PCCMETHOD get_associated_vtable_methods()>

Gets the Hash of vtable methods associated with this namespace and removes it
from the namespace.

=cut

*/

    PCCMETHOD get_associated_vtable_methods() {
        Parrot_NSInfo *nsinfo      = PARROT_NSINFO(SELF);
        PMC           *ret_methods = nsinfo->vtable;
        nsinfo->vtable             = PMCNULL;

        PCCRETURN(PMC *ret_methods);
    }

}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd21_namespaces.pod>

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
