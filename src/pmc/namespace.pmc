/*
Copyright: 2005 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

src/pmc/namespace.pmc - NameSpace PMC

=head1 DESCRIPTION

These are the vtable functions for the namespace PMC.

=head2 Data

  PMC_struct_val       ... the hash, bucket->value is an array
                           of 3 PMCs (namespace, sub, var) slot ???
  PMC_pmc_val          ... parent namespace
  PMC_data             ... name STRING of this namespace part 

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"
#include <assert.h>

pmclass NameSpace extends Hash need_ext {

/*

=item C<voit init()>

Initialze a C<NameSpace> PMC by calling C<Hash.init> and clearing
other fields.

=cut

*/

    void init() {
        SUPER();                        /* _struct_val := Hash */
        PMC_pmc_val(SELF) = NULL;       /* parent */
        PMC_data(SELF)    = NULL;       /* namespace name */
    }

/*

=item C<void set_pmc_keyed_str(STRING *key, PMC *value)>

Sets C<*value> as the namespace item for C<*key>. This is part of the
raw interface. If the PMC C<value> is exactly a NameSpace, C<SELF>
will be set as the parent of that namespace and the name C<key> of
C<value> is stored too.

=item C<void set_pmc_keyed(PMC *key, PMC *value)>

If C<key> is a simple key, it works like above. If C<key> is an array
of strings or a chained key, add all components to the namespace.

=item C<PMC* get_pmc_keyed(PMC *key)> 

Return the given namespace or PMCNULL. C<key> is either an array of 
strings, or a possibly nested key.

=cut

*/

    void set_pmc_keyed_str(STRING *key, PMC *value) {
        SUPER(key, value);
        if (value->vtable->base_type == enum_class_NameSpace) {
            PMC_pmc_val(value) = SELF;  /* set parent */
            PMC_data(value)    = key;   /* and name */
        }
    }

    void set_pmc_keyed(PMC *key, PMC *value) {
        switch (PObj_get_FLAGS(key) & KEY_type_FLAGS) {
            case KEY_string_FLAG:
                SELF.set_pmc_keyed_str(key_string(INTERP, key), value);
                if (!key_next(INTERP, key))
                    break;
            default:
                assert("not yet" == NULL);
        }
    }

    /* XXX Hash would return Undef, which is probably wrong */
    PMC* get_pmc_keyed_str (STRING* key) {
        HashBucket *b = hash_get_bucket(INTERP, 
                (Hash*) PMC_struct_val(SELF), key);
        return b->value;
    }
    
    PMC* get_pmc_keyed(PMC *key) {
        PMC *ns = SELF;
        STRING *part;
        INTVAL i, n;
        
        if (key->vtable->base_type == enum_class_Key) {
            while (key) {
                part = key_string(INTERP, key);
                ns = VTABLE_get_pmc_keyed_str(INTERP, ns, part);
                if (!ns)
                    return PMCNULL;
                key = key_next(INTERP, key);
            }
            return ns;
        }
        n = VTABLE_elements(INTERP, key);
        if (!n)
            return PMCNULL;
        for (i = 0; i < n; ++i) {
            part = VTABLE_get_string_keyed_int(INTERP, key, i);
            ns = VTABLE_get_pmc_keyed_str(INTERP, ns, part);
            if (!ns)
                return PMCNULL;
        }
        return ns;
    }

/*

=item C<STRING* get_string()>

Return the name of this namespace part.

=cut

*/

    STRING* get_string() {
        return PMC_data(SELF);
    }

/*

=back

=head2 Methods

=over 4

=cut

*/

/*

=item C<METHOD PMC* name()>

Returns the name of the namespace as an array of strings.

XXX Should the NULL String of namespace root be included?
    See also t/pmc/namespace_20.pir.  

  $P2 = $P3.'name'()
  $S0 = join '::', $P2            # '::Foo::Bar'

=cut

*/

    METHOD PMC* name() {
        PMC *ar, *ns;

        ar = pmc_new(INTERP, enum_class_ResizableStringArray);
        ns = SELF;
        while (ns) {
            VTABLE_unshift_string(INTERP, ar, PMC_data(ns));
            ns = PMC_pmc_val(ns);
        }
        return ar;
    }
}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd21_namespaces.pod>

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
