/*
Copyright (C) 2005, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/namespace.pmc - NameSpace PMC

=head1 DESCRIPTION

These are the vtable functions for the namespace PMC.

=head2 Data

  PMC_struct_val       ... the hash, bucket->value is either a
                           var/sub or a namespace, of a FixedPMCarray
                           of 2 PMCs (namespace, sub/var) slots
  PMC_pmc_val          ... parent namespace
  PMC_data             ... Namespace information struct (name, class/role)

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"
#include <assert.h>

/*
 * Typically a named slot either contains another namespace or a
 * var/sub (not both).
 * In case that the bucket->value is occupied, a FixedPMCArray is
 * created, and the items are moved over to that extra storage.
 * The array is flagged with FPA_is_ns_ext to distinguish it from a
 * plain array variable.
 *
 * This could easily expanded to a full-fledged typed namespace if needed.
 */

enum {
    NS_slot_ns,
    NS_slot_var_sub,         /* unspecified ~half-raw slot */
    NS_max_slots
} NS_slot_enum;

#define FPA_is_ns_ext PObj_private0_FLAG


/* We store extra information about the namespace in a struct, which we will
 * hang off the PMC_data slot. */
typedef struct Parrot_NSInfo {
    STRING *name;  /* Name of this namespace part. */
    PMC *_class;   /* The class or role attached to this namespace. */
} Parrot_NSInfo;

/* Macro for easy access to the namespcae info. */
#define PARROT_NSINFO(o) ((Parrot_NSInfo *) PMC_data(o))


pmclass NameSpace extends Hash does hash need_ext no_ro {

/*

=item C<void init()>

Initialize a C<NameSpace> PMC by calling C<Hash.init> and clearing
other fields.

=cut

*/

    void init() {
        SUPER();                        /* _struct_val := Hash */
        PMC_pmc_val(SELF) = NULL;       /* parent */
        PMC_data(SELF)    = mem_allocate_zeroed_typed(Parrot_NSInfo);
    }

/*

=item C<void mark()>

Marks the namespace as live.

=cut

*/
    void mark() {
        Parrot_NSInfo *nsinfo = PARROT_NSINFO(SELF);
        SUPER();
        if (PMC_pmc_val(SELF))
            pobject_lives(INTERP, (PObj*)PMC_pmc_val(SELF));
        if (nsinfo->name)
            pobject_lives(INTERP, (PObj*)nsinfo->name);
        if (nsinfo->_class)
            pobject_lives(INTERP, (PObj*)nsinfo->_class);
    }

/*

=item C<void destroy()>

Frees the namespace info struct.

=cut

*/
    void destroy() {
        mem_sys_free(PARROT_NSINFO(SELF));
        SUPER();
    }

/*

=item C<void set_pmc_keyed_str(STRING *key, PMC *value)>

Sets C<*value> as the namespace item for C<*key>. This is part of the
raw interface. If the PMC C<value> is exactly a NameSpace, C<SELF>
will be set as the parent of that namespace and the name C<key> of
C<value> is stored too.

=item C<void set_pmc_keyed(PMC *key, PMC *value)>

If C<key> is a simple key, it works like above. If C<key> is an array
of strings or a chained key, add all components to the namespace.

=item C<PMC* get_pmc_keyed(PMC *key)>

Return the given namespace or PMCNULL. C<key> is either an array of
strings, or a possibly nested key.

=item C<PMC* get_pmc_keyed_str(PMC *key)>

Return the given namespace item or PMCNULL. If the named item is either
a NameSpace or a var, the NameSpace is returned.

=cut

*/

    void set_pmc_keyed_str(STRING *key, PMC *value) {
        const int val_is_NS = value->vtable->base_type == enum_class_NameSpace;
        PMC        *new_tuple = NULL;
        HashBucket *b         =
            parrot_hash_get_bucket(INTERP, (Hash*) PMC_struct_val(SELF), key);

        if (!b)
            SUPER(key, value);
        else {
            PMC *old = (PMC *)b->value;

            if ((old->vtable->base_type == enum_class_NameSpace) == val_is_NS) {
                /* simple ns or simple var/sub changed */
                SUPER(key, value);
            }
            else if ((PObj_get_FLAGS(old) & FPA_is_ns_ext) &&
                    old->vtable->base_type == enum_class_FixedPMCArray) {
                /* we have a tuple extension already */
                VTABLE_set_pmc_keyed_int(INTERP, old,
                        val_is_NS ? NS_slot_ns : NS_slot_var_sub,
                        value);
            }
            else {
                /* creat new tuple */
                new_tuple = pmc_new(INTERP, enum_class_FixedPMCArray);

                /* flag it as special */
                PObj_get_FLAGS(new_tuple) |= FPA_is_ns_ext;

                /* for a fully typed namespace, we'd need 3 or 4 */
                VTABLE_set_integer_native(INTERP, new_tuple, NS_max_slots);
            }
        }

        if (val_is_NS) {
            /* TODO - this hack needs to go */
            Parrot_NSInfo *nsinfo = PARROT_NSINFO(value);
            PMC_pmc_val(value)    = SELF;  /* set parent */
            nsinfo->name          = key;   /* and name */

            if (new_tuple) {
                VTABLE_set_pmc_keyed_int(INTERP, new_tuple, NS_slot_ns,
                                         value);
                VTABLE_set_pmc_keyed_int(INTERP, new_tuple, NS_slot_var_sub,
                                         (PMC *)b->value);
                b->value = new_tuple;
                /* distinction from a plain FPA, which doesn't extend the
                 * namespace storage
                 */
            }
        }
        else if (new_tuple) {
            VTABLE_set_pmc_keyed_int(INTERP, new_tuple, NS_slot_ns,
                (PMC *)b->value);
            VTABLE_set_pmc_keyed_int(INTERP, new_tuple, NS_slot_var_sub, value);
            b->value = new_tuple;
        }
    }

    void set_pmc_keyed(PMC *key, PMC *value) {
        PMC *ns = SELF;
        STRING *part;

        if (key->vtable->base_type == enum_class_String) {
            SELF.set_pmc_keyed_str(VTABLE_get_string(INTERP, key), value);
            return;
        }

        if (key->vtable->base_type == enum_class_Key) {
            while (1) {
                part = key_string(INTERP, key);
                key = key_next(INTERP, key);
                if (!key) {
                    Parrot_set_global(INTERP, ns, part, value);
                    return;
                }
                ns = Parrot_make_namespace_keyed_str(INTERP, ns, part);
            }
        }

        real_exception(INTERP, NULL, E_NameError, "Invalid namespace key");
    }

    PMC* get_pmc_keyed_str(STRING *key) {
        PMC *ns = (PMC *)parrot_hash_get(INTERP, (Hash *)PMC_struct_val(SELF),
                                         key);
        if (!ns)
            return PMCNULL;

        if ((PObj_get_FLAGS(ns) & FPA_is_ns_ext) &&
                ns->vtable->base_type == enum_class_FixedPMCArray)
            ns = VTABLE_get_pmc_keyed_int(INTERP, ns, NS_slot_ns);

        return ns;
    }

    PMC* get_pmc_keyed(PMC *key) {
        PMC *ns = SELF;
        STRING *part;

        if (key->vtable->base_type == enum_class_String) {
            return SELF.get_pmc_keyed_str(VTABLE_get_string(INTERP, key));
        }

        if (key->vtable->base_type == enum_class_Key) {
            while (key) {
                part = key_string(INTERP, key);
                key = key_next(INTERP, key);
                if (!key)
                    return VTABLE_get_pmc_keyed_str(INTERP, ns, part);
                ns = Parrot_get_namespace_keyed_str(INTERP, ns, part);
                if (PMC_IS_NULL(ns))
                    return PMCNULL;
            }
            return ns;
        }

        real_exception(INTERP, NULL, E_NameError, "Invalid namespace key");
        /* NOTREACHED */
        return PMCNULL;
    }

/*

=item C<void* get_pointer_keyed_str(STRING *key)>

=item C<void* get_pointer_keyed(PMC *key)>

Return the given namespace item or PMCNULL. If the named item is either
a NameSpace or a var, the var is returned.

TOTAL KLUDGE.  ON THE CHOPPING BLOCK.

=cut

*/

    void* get_pointer_keyed_str(STRING *key) {
        PMC *ns = (PMC *)parrot_hash_get(INTERP, (Hash *)PMC_struct_val(SELF),
                                        key);
        if (!ns)
            return PMCNULL;

        if ((PObj_get_FLAGS(ns) & FPA_is_ns_ext) &&
                ns->vtable->base_type == enum_class_FixedPMCArray)
            ns = VTABLE_get_pmc_keyed_int(INTERP, ns, NS_slot_var_sub);

        return ns;
    }

    void* get_pointer_keyed(PMC *key) {
        PMC *ns = SELF;
        STRING *part;

        if (key->vtable->base_type == enum_class_String) {
            return SELF.get_pointer_keyed_str(VTABLE_get_string(INTERP, key));
        }

        if (key->vtable->base_type == enum_class_Key) {
            while (key) {
                part = key_string(INTERP, key);
                key = key_next(INTERP, key);
                if (!key)
                    return VTABLE_get_pointer_keyed_str(INTERP, ns, part);
                ns = Parrot_get_namespace_keyed_str(INTERP, ns, part);
                if (PMC_IS_NULL(ns))
                    return PMCNULL;
            }
            return ns;
        }

        real_exception(INTERP, NULL, E_NameError, "Invalid namespace key");
        /* NOTREACHED */
        return PMCNULL;
    }

/*

=item C<STRING* get_string()>

Return the name of this namespace part.

=cut

*/

    STRING* get_string() {
        Parrot_NSInfo *nsinfo = PARROT_NSINFO(SELF);
        return nsinfo->name;
    }

/*

=back

=head2 Methods

=over 4

=cut

*/

/*

=item C<METHOD void PMC* add_namespace(STRING *name, PMC *namespace)>

Stores the given namespace under this namespace, with the given name.  Throws
an invalid type exception if C<namespace> is not a NameSpace PMC or subclass.

*/

    METHOD void add_namespace(STRING *name, PMC *_namespace) {
        STRING *s_ns = CONST_STRING(INTERP, "NameSpace");
        if (!VTABLE_isa(INTERP, _namespace, s_ns))
            real_exception(INTERP, NULL, E_TypeError,
                "Invalid type %d in add_namespace()",
                _namespace->vtable->base_type);

        VTABLE_set_pmc_keyed_str(INTERP, SELF, name, _namespace);
        return;
    }

/*

/*

=item C<METHOD void PMC* add_sub(STRING *name, PMC *sub)>

Stores the given sub under this namespace, with the given name.  Throws an
invalid type exception if C<sub> is not a Sub PMC or subclass.

*/

    METHOD void add_sub(STRING *name, PMC *sub) {
        STRING *s_sub = CONST_STRING(INTERP, "Sub");
        if (!VTABLE_isa(INTERP, sub, s_sub))
            real_exception(INTERP, NULL, E_TypeError,
                "Invalid type %d in add_sub()", sub->vtable->base_type);

        VTABLE_set_pmc_keyed_str(INTERP, SELF, name, sub);
        return;
    }

/*

/*

=item C<METHOD void PMC* add_var(STRING *name, PMC *var)>

Stores the given sub under this namespace, with the given name.

*/

    METHOD void add_var(STRING *name, PMC *var) {
        VTABLE_set_pmc_keyed_str(INTERP, SELF, name, var);
        return;
    }

/*

=item C<METHOD PMC* get_name()>

Returns the name of the namespace as an array of strings.

  $P2 = $P3.'get_name'()
  $S0 = join '::', $P2            # '::Foo::Bar'

=cut

*/

    METHOD PMC* get_name() {
        PMC *ar, *ns;

        ar = pmc_new(INTERP, enum_class_ResizableStringArray);
        ns = SELF;
        while (ns) {
            Parrot_NSInfo *nsinfo = PARROT_NSINFO(ns);
            VTABLE_unshift_string(INTERP, ar, nsinfo->name);
            ns = PMC_pmc_val(ns);
        }

        /* remove the NULL string of the namespace root */
        VTABLE_shift_string(INTERP, ar);

        return ar;
    }
/*

=item C<METHOD PMC* find_namespace(STRING* name)>

Return the namespace with the given name.

=cut

*/

    METHOD PMC* find_namespace(STRING* key) {
        STRING *s_ns = CONST_STRING(INTERP, "NameSpace");
        PMC    *ns   = (PMC *)parrot_hash_get(INTERP,
                                (Hash *)PMC_struct_val(SELF), key);

        if (!ns)
            return PMCNULL;

        /* it's a NameSpace */
        if (VTABLE_isa(INTERP, ns, s_ns))
            return ns;

        return PMCNULL;
    }

/*

=item C<METHOD PMC* find_sub(STRING *name)>

Return the Sub PMC with the given name.

=cut

*/

    METHOD PMC* find_sub(STRING *key) {
        STRING *s_sub = CONST_STRING(INTERP, "Sub");
        PMC    *sub   = (PMC *)parrot_hash_get(INTERP,
                            (Hash *)PMC_struct_val(SELF), key);

        if (!sub)
            return PMCNULL;

        /* it's a Sub */
        if (VTABLE_isa(INTERP, sub, s_sub))
            return sub;

        return PMCNULL;
    }

/*

=item C<METHOD PMC* find_var(STRING *name)>

Return the PMC with the given name.

=cut

*/

    METHOD PMC* find_var(STRING *key) {
        PMC *val = (PMC *)parrot_hash_get(INTERP,
                    (Hash *)PMC_struct_val(SELF), key);

        if (!val)
            return PMCNULL;

        return val;
    }

/*

=item C<METHOD PMC* del_namespace(STRING *name)>

Deletes the contained NameSpace PMC with the given name.  Throws an invalid
type exception if the item to delete is not a NameSpace PMC or subclass, and
does not delete the PMC.

=cut

*/

    METHOD void del_namespace(STRING *name) {
        Hash   *hash = (Hash *)PMC_struct_val(SELF);
        PMC    *ns   = (PMC  *)parrot_hash_get(INTERP, hash, name);
        STRING *s_ns = CONST_STRING(INTERP, "NameSpace");

        if ( PMC_IS_NULL(ns) )
            return;

        if (!VTABLE_isa(INTERP, ns, s_ns)) {
            char *item_name = string_to_cstring(INTERP, name);
            real_exception(INTERP, NULL, E_TypeError,
                "Invalid type %d for '%s' in del_namespace()",
                ns->vtable->base_type, item_name);
            string_cstring_free(item_name);
        }

        parrot_hash_delete(INTERP, hash, name);
    }

/*

/*

=item C<METHOD PMC* del_sub(STRING *name)>

Deletes the contained Sub PMC with the given name.  Throws an invalid type
exception if the item to delete is not a Sub PMC or subclass, and does not
delete the PMC.

=cut

*/

    METHOD void del_sub(STRING *name) {
        Hash   *hash  = (Hash *)PMC_struct_val(SELF);
        PMC    *sub   = (PMC  *)parrot_hash_get(INTERP, hash, name);
        STRING *s_sub = CONST_STRING(INTERP, "Sub");

        if ( PMC_IS_NULL(sub) )
            return;

        if (!VTABLE_isa(INTERP, sub, s_sub)) {
            char *item_name = string_to_cstring(INTERP, name);
            real_exception(INTERP, NULL, E_TypeError,
                "Invalid type %d for '%s' in del_sub()",
                sub->vtable->base_type, item_name);
            string_cstring_free(item_name);
        }

        parrot_hash_delete(INTERP, hash, name);
    }

/*

=item C<METHOD PMC* del_var(STRING* name)>

Deletes the contained variable-like PMC with the given name.

=cut

*/

    METHOD void del_var(STRING* name) {
        parrot_hash_delete(INTERP, (Hash*) PMC_struct_val(SELF), name);
    }

/*

=item C<METHOD PMC* get_sym(STRING* name)>

Return the symbol (var or sub) with the given name. This can be used
to retrieve symbols, if a NameSpace with the same name exists.

=cut

*/

    METHOD PMC* get_sym(STRING *key) {
        PMC *ns = (PMC *)parrot_hash_get(INTERP,
            (Hash *)PMC_struct_val(SELF), key);

        if (!ns)
            return PMCNULL;

        /* it's a NameSpace */
        if (ns->vtable == SELF->vtable)
            return PMCNULL;

        if ((PObj_get_FLAGS(ns) & FPA_is_ns_ext) &&
                ns->vtable->base_type == enum_class_FixedPMCArray)
            ns = VTABLE_get_pmc_keyed_int(INTERP, ns, NS_slot_var_sub);

        return ns;
    }

/*

=item C<METHOD void export_to(PMC *dest, PMC *what)>

Export items from this NameSpace into the C<dest> NameSpace. The items to
export are named in C<what>, which may be an array of strings, a hash, or null.
If C<what> is an array of strings, interpretation of items in an array follows
the conventions of the source (exporting) namespace.
If C<what> is a hash, the keys correspond to the names in the source namespace,
and the values correspond to the names in the destination namespace.
if a hash value is null or an empty string, the name in the hash key is used.
A null C<what> requests the 'default' set of items.
Any other type passed in C<what> throws an exception.

NOTE: exporting 'default' set of items is not yet implemented.

=cut

*/

    METHOD void export_to(PMC* dest, PMC* what) {
        STRING *s_hash  = CONST_STRING(interp, "hash");
        STRING *s_array = CONST_STRING(interp, "array");

        if (PMC_IS_NULL(dest)) {
            real_exception(interp, NULL, 0,
                    "destination namespace not specified");
            return;
        }

        if (PMC_IS_NULL(what) || !VTABLE_elements(interp, what)) {
            real_exception(interp, NULL, 0,
                    "exporting default object set not yet implemented");
            return;
        }

        /* if "what" does "hash", we extract string key/value pairs,
         * lookup the object with the name specified in the key,
         * and export it with the name specified as value. */
        if (VTABLE_does(INTERP, what, s_hash)) {
            PMC * const  iter = VTABLE_get_iter(interp, what);
            const INTVAL n    = VTABLE_elements(interp, what);
            INTVAL       i;

            for (i = 0; i < n; ++i) {
                STRING *src_name;
                STRING *dest_name;
                PMC    *object;

                src_name = VTABLE_shift_string(interp, iter);
                if (STRING_IS_NULL(src_name) || STRING_IS_EMPTY(src_name)) {
                    real_exception(interp, NULL, 0, "source object name not specified");
                    return;
                }

                if (PMC_IS_NULL(VTABLE_get_pmc_keyed_str(interp, what, src_name))) {
                    dest_name = src_name;
                }
                else {
                    dest_name = VTABLE_get_string_keyed_str(interp, what, src_name);
                    if (STRING_IS_NULL(dest_name) || STRING_IS_EMPTY(dest_name)) {
                        dest_name = src_name;
                    }
                }

                object = VTABLE_get_pmc_keyed_str(interp, SELF, src_name);
                if (PMC_IS_NULL(object)) {
                    real_exception(interp, NULL, 0,
                            "object '%s' not found in current namespace",
                            string_to_cstring(interp, src_name));
                    return;
                }

                VTABLE_set_pmc_keyed_str(interp, dest, dest_name, object);
            }
        }
        else if (VTABLE_does(INTERP, what, s_array)) {
            const INTVAL n = VTABLE_elements(interp, what);
            INTVAL i;

            for (i = 0; i < n; ++i) {
                STRING *name;
                PMC    *object;

                name = VTABLE_get_string_keyed_int(interp, what, i);
                if (STRING_IS_NULL(name) || STRING_IS_EMPTY(name)) {
                    real_exception(interp, NULL, 0, "object name not specified");
                    return;
                }

                object = VTABLE_get_pmc_keyed_str(interp, SELF, name);
                if (PMC_IS_NULL(object)) {
                    real_exception(interp, NULL, 0,
                            "object '%s' not found in current namespace",
                            string_to_cstring(interp, name));
                    return;
                }

                VTABLE_set_pmc_keyed_str(interp, dest, name, object);
            }
        }
        else {
            real_exception(interp, NULL, 0,
                    "can't handle argument of type %s", what->vtable->base_type);
        }
    }

/*

=item C<METHOD PMC* get_parent()>

Return the parent NameSpace or PMCNULL, if none.

=cut

*/

    METHOD PMC* get_parent() {
        return PMC_pmc_val(SELF) ? PMC_pmc_val(SELF) : PMCNULL;
    }

/*

=item C<PCCMETHOD PMC* get_class()>

Returns the class or role PMC that is associated with this namespace.

=cut

*/

    PCCMETHOD void get_class()
    {
        Parrot_NSInfo *nsinfo = PARROT_NSINFO(SELF);
        PMC *ret_class = nsinfo->_class;
        PCCRETURN(PMC *ret_class);
    }

/*

=item C<PCCMETHOD void set_class(PMC *class_or_role)>

Sets the class or role PMC that is associated with this namespace.

=cut

*/

    PCCMETHOD void set_class(PMC *class_or_role)
    {
        Parrot_NSInfo *nsinfo = PARROT_NSINFO(SELF);
        nsinfo->_class        = class_or_role;
    }

}
/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd21_namespaces.pod>

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
