/*
Copyright: 2005 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

src/pmc/namespace.pmc - NameSpace PMC

=head1 DESCRIPTION

These are the vtable functions for the namespace PMC.

=head2 Data

  PMC_struct_val       ... the hash, bucket->value is either a
                           var/sub or a namespace, of a FixedPMCarray
                           of 2 PMCs (namespace, sub/var) slots
  PMC_pmc_val          ... parent namespace
  PMC_data             ... name STRING of this namespace part 

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"
#include <assert.h>

/*
 * Typically a named slot either contains another namespace or a
 * var/sub (not both). 
 * In case that the bucket->value is occupied, a FixedPMCArray is
 * created, and the items are moved over to that extra storage.
 * The array is flagged with FPA_is_ns_ext to distinguish it from a
 * plain array variable.
 *
 * This could easily expanded to a full-fledged typed namespace if needed. 
 */

enum {
    NS_slot_ns,
    NS_slot_var_sub,         /* unspecified ~half-raw slot */
    NS_max_slots
} NS_slot_enum;

#define FPA_is_ns_ext PObj_private0_FLAG

pmclass NameSpace extends Hash need_ext {

/*

=item C<voit init()>

Initialze a C<NameSpace> PMC by calling C<Hash.init> and clearing
other fields.

=cut

*/

    void init() {
        SUPER();                        /* _struct_val := Hash */
        PMC_pmc_val(SELF) = NULL;       /* parent */
        PMC_data(SELF)    = NULL;       /* namespace name */
    }

/*

=item C<void mark()>

Marks the namespace as live.

=cut

*/
    void mark() {
        SUPER();
        if (PMC_pmc_val(SELF))
            pobject_lives(INTERP, (PObj*)PMC_pmc_val(SELF));
        if (PMC_data(SELF))
            pobject_lives(INTERP, (PObj*)PMC_data(SELF));
    }

/*

=item C<void set_pmc_keyed_str(STRING *key, PMC *value)>

Sets C<*value> as the namespace item for C<*key>. This is part of the
raw interface. If the PMC C<value> is exactly a NameSpace, C<SELF>
will be set as the parent of that namespace and the name C<key> of
C<value> is stored too.

=item C<void set_pmc_keyed(PMC *key, PMC *value)>

If C<key> is a simple key, it works like above. If C<key> is an array
of strings or a chained key, add all components to the namespace.

=item C<PMC* get_pmc_keyed(PMC *key)> 

Return the given namespace or NULL. C<key> is either an array of 
strings, or a possibly nested key.

=item C<PMC* get_pmc_keyed_str(PMC *key)> 

Return the given namespace item or NULL. If the named item is either
a NameSpace or a var, the NameSpace is returned.

=cut

*/

    void set_pmc_keyed_str(STRING *key, PMC *value) {
        PMC *tuple = NULL;
        HashBucket *b = hash_get_bucket(INTERP, 
                (Hash*) PMC_struct_val(SELF), key);
        int val_is_NS = value->vtable->base_type == enum_class_NameSpace;
        if (PMC_IS_NULL(value))
            real_exception(INTERP, NULL, E_NameError,
                    "Attempt to set NULL namespace (part)");
        if (!b)
            SUPER(key, value);
        else {
            PMC *old = b->value;
            if (old->vtable->base_type == enum_class_NameSpace &&
                    val_is_NS) {
                SUPER(key, value);      /* ns changed */
            }
            else if (old->vtable->base_type != enum_class_NameSpace &&
                    !val_is_NS) {
                SUPER(key, value);      /* var/sub changed */
            }
            else if ((PObj_get_FLAGS(old) & FPA_is_ns_ext) &&
                    old->vtable->base_type == enum_class_FixedPMCArray) {
                /* we have a tuple extension already */
                VTABLE_set_pmc_keyed_int(INTERP, old, 
                        val_is_NS ? NS_slot_ns : NS_slot_var_sub, value);
            }
            else {
                /* creat new tuple */
                tuple = pmc_new(INTERP, enum_class_FixedPMCArray);
                /* flag it as special */
                PObj_get_FLAGS(tuple) |= FPA_is_ns_ext;
                /* for a fully typed namespace, we'd need 3 or 4 */
                VTABLE_set_integer_native(INTERP, tuple, NS_max_slots);
            }
        }
        if (val_is_NS) {
            PMC_pmc_val(value) = SELF;  /* set parent */
            PMC_data(value)    = key;   /* and name */
            if (tuple) {
                VTABLE_set_pmc_keyed_int(INTERP, tuple, NS_slot_ns, value);
                VTABLE_set_pmc_keyed_int(INTERP, tuple, NS_slot_var_sub, 
                        b->value);
                b->value = tuple;
                /* distinction from a plain FPA, which doesn't extend the
                 * namespace storage
                 */
            }
        }
        else if (tuple) {
            VTABLE_set_pmc_keyed_int(INTERP, tuple, NS_slot_ns, b->value);
            VTABLE_set_pmc_keyed_int(INTERP, tuple, NS_slot_var_sub, value);
            b->value = tuple;
        }
    }

    void set_pmc_keyed(PMC *key, PMC *value) {
        PMC *ns = SELF, *next;
        STRING *part;
        INTVAL i, n;
        if (key->vtable->base_type == enum_class_Key) {
            while (1) {
                part = key_string(INTERP, key);
                key = key_next(INTERP, key);
                next = VTABLE_get_pmc_keyed_str(INTERP, ns, part);
                if (key) {
                    if (!next || 
                            next->vtable->base_type != enum_class_NameSpace) {
                        next = pmc_new(interpreter, enum_class_NameSpace);
                        VTABLE_set_pmc_keyed_str(INTERP, ns, part, next);
                    }
                }
                else {
                    VTABLE_set_pmc_keyed_str(INTERP, ns, part, value);
                    break;
                }
                ns = next;
            }
            return;
        }
        n = VTABLE_elements(INTERP, key);
        if (!n)
            real_exception(INTERP, NULL, E_NameError,
                    "Empty namespace array");
        for (i = 0; ; ++i) {
            part = VTABLE_get_string_keyed_int(INTERP, key, i);
            next = VTABLE_get_pmc_keyed_str(INTERP, ns, part);
            if (i < n - 1) {
                if (!next || next->vtable->base_type != enum_class_NameSpace) {
                    next = pmc_new(interpreter, enum_class_NameSpace);
                    VTABLE_set_pmc_keyed_str(INTERP, ns, part, next);
                }
            }
            else {
                VTABLE_set_pmc_keyed_str(INTERP, ns, part, value);
                break;
            }
            ns = next;
        }
    }

    PMC* get_pmc_keyed_str (STRING* key) {
        PMC *ns = hash_get(INTERP, 
                (Hash*) PMC_struct_val(SELF), key);
        if (!ns)
            return NULL;
        if ((PObj_get_FLAGS(ns) & FPA_is_ns_ext) &&
                ns->vtable->base_type == enum_class_FixedPMCArray)
            ns = VTABLE_get_pmc_keyed_int(INTERP, ns, NS_slot_ns);
        return ns;
    }
    
    PMC* get_pmc_keyed(PMC *key) {
        PMC *ns = SELF;
        STRING *part;
        INTVAL i, n;
        
        if (key->vtable->base_type == enum_class_Key) {
            while (key) {
                part = key_string(INTERP, key);
                ns = VTABLE_get_pmc_keyed_str(INTERP, ns, part);
                if (!ns)
                    return NULL;
                key = key_next(INTERP, key);
            }
            return ns;
        }
        n = VTABLE_elements(INTERP, key);
        if (!n)
            return NULL;
        for (i = 0; i < n; ++i) {
            part = VTABLE_get_string_keyed_int(INTERP, key, i);
            ns = VTABLE_get_pmc_keyed_str(INTERP, ns, part);
            if (!ns)
                return NULL;
        }
        return ns;
    }

/*

=item C<void* get_pointer_keyed_str(PMC *key)> 

Return the given namespace item or NULL. If the named item is either
a NameSpace or a var, the var is returned.

=cut

*/

    void* get_pointer_keyed_str (STRING* key) {
        PMC *ns = hash_get(INTERP, 
                (Hash*) PMC_struct_val(SELF), key);
        if (!ns)
            return NULL;
        if ((PObj_get_FLAGS(ns) & FPA_is_ns_ext) &&
                ns->vtable->base_type == enum_class_FixedPMCArray)
            ns = VTABLE_get_pmc_keyed_int(INTERP, ns, NS_slot_var_sub);
        return ns;
    }
    
/*

=item C<STRING* get_string()>

Return the name of this namespace part.

=cut

*/

    STRING* get_string() {
        return PMC_data(SELF);
    }

/*

=back

=head2 Methods

=over 4

=cut

*/

/*

=item C<METHOD PMC* name()>

Returns the name of the namespace as an array of strings.

XXX Should the NULL String of namespace root be included?
    See also t/pmc/namespace_20.pir.  

  $P2 = $P3.'name'()
  $S0 = join '::', $P2            # '::Foo::Bar'

=cut

*/

    METHOD PMC* name() {
        PMC *ar, *ns;

        ar = pmc_new(INTERP, enum_class_ResizableStringArray);
        ns = SELF;
        while (ns) {
            VTABLE_unshift_string(INTERP, ar, PMC_data(ns));
            ns = PMC_pmc_val(ns);
        }
        return ar;
    }
}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd21_namespaces.pod>

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
