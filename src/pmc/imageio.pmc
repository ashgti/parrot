/*
Copyright (C) 2010 Parrot Foundation.
$Id$

=head1 NAME

src/pmc/imageio.pmc - ImageIO PMC

=head1 DESCRIPTION

Freezes and thaws other PMCs.

*/

#define GROW_TO_16_BYTE_BOUNDARY(size) ((size) + ((size) % 16 ? 16 - (size) % 16 : 0))

/* when thawing a string longer then this size, we first do a GC run and then
 * block GC - the system can't give us more headers */

#define THAW_BLOCK_GC_SIZE 100000

/* preallocate freeze image for aggregates with this estimation */
#define FREEZE_BYTES_PER_ITEM 9

/* macros/constants to handle packing/unpacking of PMC IDs and flags
 * the 2 LSBs are used for flags, all other bits are used for PMC ID
 */
#define PackID_new(id, flags)       (((UINTVAL)(id) * 4) | ((UINTVAL)(flags) & 3))
#define PackID_get_PMCID(id)        ((UINTVAL)(id) / 4)
#define PackID_set_PMCID(lv, id)    (lv) = PackID_new((id), PackID_get_FLAGS(lv))
#define PackID_get_FLAGS(id)        ((UINTVAL)(id) & 3)
#define PackID_set_FLAGS(lv, flags) (lv) = PackID_new(PackID_get_PMCID(lv), (flags))

enum {
    enum_PackID_normal     = 0,
    enum_PackID_seen       = 1,
};

PARROT_INLINE
static opcode_t
GET_VISIT_CURSOR(PMC *pmc){
    char  *buf = (char *)Buffer_bufstart(PARROT_IMAGEIO(pmc)->buffer);
    size_t pos = PARROT_IMAGEIO(pmc)->pos;
    return buf + pos;
}

PARROT_INLINE
static void
SET_VISIT_CURSOR(PMC *pmc, char *cursor) {
    char *bufstart  = (char *)Buffer_bufstart(PARROT_IMAGEIO(pmc)->buffer);
    PARROT_IMAGEIO(pmc)->pos = (cursor - bufstart);
}

PARROT_INLINE
static void
INC_VISIT_CURSOR(PMC *pmc, UINTVAL inc) {
    PARROT_IMAGEIO(pmc)->pos += inc;
}

#define BYTECODE_SHIFT_OK(pmc) PARROT_ASSERT( \
    PARROT_IMAGEIO(pmc)->pos <= PARROT_IMAGEIO(pmc)->input_length )



/*
static void ensure_buffer_size(PARROT_INTERP, PMC *io, size_t len)

Checks the size of the buffer to see if it can accommodate 'len' more
bytes. If not, expands the buffer.

*/

PARROT_INLINE
static void
ensure_buffer_size(PARROT_INTERP, ARGIN(PMC *io), size_t len)
{
    Buffer *buf         = PARROT_IMAGEIO(io)->buffer;
    const size_t used   = PARROT_IMAGEIO(io)->pos;
    const int need_free = Buffer_buflen(buf) - used - len;

    /* grow by factor 1.5 or such */
    if (need_free <= 16) {
        size_t new_size = (size_t) (Buffer_buflen(buf) * 1.5);
        if (new_size < Buffer_buflen(buf) - need_free + 512)
            new_size = Buffer_buflen(buf) - need_free + 512;
        Parrot_gc_reallocate_buffer_storage(interp, buf, new_size);
        PARROT_ASSERT(Buffer_buflen(buf) - used - len >= 15);
    }

#ifndef DISABLE_GC_DEBUG
    Parrot_gc_compact_memory_pool(INTERP);
#endif

}

pmclass ImageIO auto_attrs {
    ATTR visit_f          visit_pmc_now;
    ATTR Buffer          *buffer;         /* buffer to store the image */
    ATTR size_t           pos;            /* current read/write position in buffer */
    ATTR size_t           input_length;
    ATTR INTVAL           what;
    ATTR PMC            **thaw_ptr;       /* where to thaw a new PMC */
    ATTR PMC             *seen;           /* seen hash */
    ATTR PMC             *todo;           /* todo list */
    ATTR PMC             *id_list;        /* seen list used by thaw */
    ATTR UINTVAL          id;             /* freze ID of PMC */
    ATTR INTVAL           extra_flags;    /* concerning to extra */
    ATTR struct PackFile *pf;

/*

=head1 VTABLES

=over 4

=cut

*/

/*

=item C<void init()>

Initializes the PMC.

=cut

*/
    VTABLE void init() {
        PARROT_IMAGEIO(SELF)->thaw_ptr    = NULL;
        PARROT_IMAGEIO(SELF)->buffer      = NULL;
        PARROT_IMAGEIO(SELF)->todo        = pmc_new(INTERP, enum_class_Array);
        PARROT_IMAGEIO(SELF)->seen        = PMCNULL;
        PARROT_IMAGEIO(SELF)->id_list     = PMCNULL;
        PARROT_IMAGEIO(SELF)->id          = 0;
        PARROT_IMAGEIO(SELF)->extra_flags = EXTRA_IS_NULL;
        PARROT_IMAGEIO(SELF)->pf          = PackFile_new(INTERP, 0);

        PObj_custom_mark_destroy_SETALL(SELF);
    }


/*

=item C<void destroy()>

Destroys the PMC.

=cut

*/
    VTABLE void destroy() {
        PackFile_destroy(INTERP, PARROT_IMAGEIO(SELF)->pf);
    }

/*

=item C<void mark()>

Marks the PMC as alive.

=cut

*/
    VTABLE void mark() {
        Parrot_gc_mark_PObj_alive(INTERP, PARROT_IMAGEIO(SELF)->buffer);
        Parrot_gc_mark_PMC_alive(INTERP, PARROT_IMAGEIO(SELF)->todo);
        Parrot_gc_mark_PMC_alive(INTERP, PARROT_IMAGEIO(SELF)->seen);
        Parrot_gc_mark_PMC_alive(INTERP, PARROT_IMAGEIO(SELF)->id_list);
    }

/*

=item C<STRING *get_string()>

Returns the content of the image as a string.

=cut

*/

    VTABLE STRING *get_string() {
        return Parrot_str_new_from_buffer(INTERP, 
                                          PARROT_IMAGEIO(SELF)->buffer,
                                          PARROT_IMAGEIO(SELF)->pos);
    }
/*

/*

=item C<VTABLE void set_pointer()>

Sets the location where to thaw a new PMC.

=cut

*/

VTABLE void set_pointer(void* value) {
    PARROT_IMAGEIO(SELF)->thaw_ptr = value;
}

/*

=item C<VTABLE INTVAL get_integer()>

Returns the flags describing the visit action

=cut

*/

VTABLE INTVAL get_integer() {
    return PARROT_IMAGEIO(SELF)->what;
}

/*

=item C<VTABLE void push_integer(INTVAL v)>

Pushes the integer C<v> onto the end of the image.

=cut

*/

VTABLE void push_integer(INTVAL v) {
    size_t len = PF_size_integer() * sizeof (opcode_t);
    ensure_buffer_size(interp, SELF, len);
    SET_VISIT_CURSOR(SELF, PF_store_integer(GET_VISIT_CURSOR(SELF), v));
}


/*

=item C<VTABLE void push_float(FLOATVAL v)>

Pushes the float C<v> onto the end of the image.

=cut

*/

VTABLE void push_float(FLOATVAL v)
{
    size_t len = PF_size_number() * sizeof (opcode_t);
    ensure_buffer_size(interp, SELF, len);
    SET_VISIT_CURSOR(SELF, PF_store_number(GET_VISIT_CURSOR(SELF), &v));
}


/*

=item C<VTABLE void push_string(STRING *v)>

Pushes the string C<*v> onto the end of the image.

=cut

*/

VTABLE void push_string(STRING *v)
{
    size_t len = PF_size_string(v) * sizeof (opcode_t);
    ensure_buffer_size(INTERP, SELF, len);
    SET_VISIT_CURSOR(SELF, PF_store_string(GET_VISIT_CURSOR(SELF), v));
}

/*

=item C<VTABLE void push_pmc(PMC *v)>

Pushes a reference to pmc C<*v> onto the end of the image. If C<*v>
hasn't been seen yet, it is also pushed onto the todo list.

=cut

*/

VTABLE void push_pmc(PMC *v) {
    PARROT_IMAGEIO(SELF)->thaw_ptr = &v;
    (PARROT_IMAGEIO(SELF)->visit_pmc_now)(INTERP, v, SELF);
}

/*

=item C<VTABLE INTVAL shift_integer()>

Removes and returns an integer from the start of the image.

=cut

*/

VTABLE INTVAL shift_integer()
{
    opcode_t *pos  = GET_VISIT_CURSOR(SELF);
    const INTVAL i = PF_fetch_integer(PARROT_IMAGEIO(SELF)->pf, (const opcode_t **)&pos);
    SET_VISIT_CURSOR(SELF, pos);
    BYTECODE_SHIFT_OK(SELF);
    return i;
}


/*

=item C<VTABLE FLOATVAL shift_number()>

Removes and returns an number from the start of the image.

=cut

*/

VTABLE FLOATVAL shift_number() {
    opcode_t *pos    = GET_VISIT_CURSOR(SELF);
    const FLOATVAL f = PF_fetch_number(PARROT_IMAGEIO(SELF)->pf, (const opcode_t **)&pos);
    SET_VISIT_CURSOR(SELF, pos);
    BYTECODE_SHIFT_OK(SELF);
    return f;
}


/*

=item C<VTABLE STRING* shift_string()>

Removes and returns a string from the start of the image.

=cut

*/

VTABLE STRING *shift_string()
{
    opcode_t *pos    = GET_VISIT_CURSOR(SELF);
    STRING * const s = PF_fetch_string(interp, PARROT_IMAGEIO(SELF)->pf, (const opcode_t **)&pos);
    SET_VISIT_CURSOR(SELF, pos);
    BYTECODE_SHIFT_OK(SELF);
    return s;
}

/*

=item C<static PMC *shift_opcode_pmc(PARROT_INTERP, visit_info *io)>

Removes and returns a reference to a pmc from the start of the C<*io> "stream".

=cut

*/

VTABLE PMC *shift_pmc() {
    PMC *result;
    PARROT_IMAGEIO(SELF)->thaw_ptr = &result;
    (PARROT_IMAGEIO(SELF)->visit_pmc_now)(interp, NULL, PARROT_IMAGEIO(SELF));
    return result;
}

VTABLE void set_pmc(PMC *p)
{
        UINTVAL header_length = GROW_TO_16_BYTE_BOUNDARY(PACKFILE_HEADER_BYTES);

        PARROT_IMAGEIO(SELF)->what = VISIT_FREEZE_NORMAL;
        PARROT_IMAGEIO(SELF)->visit_pmc_now  = visit_todo_list_freeze;
        create_buffer(INTERP, p, SELF);
        ensure_buffer_size(INTERP, SELF, header_length);
        mem_sys_memcopy(GET_VISIT_CURSOR(SELF),
            PARROT_IMAGEIO(SELF)->pf->header, PACKFILE_HEADER_BYTES);
        INC_VISIT_CURSOR(SELF, header_length);

        PARROT_IMAGEIO(SELF)->seen = pmc_new(INTERP, enum_class_Hash);
        VTABLE_set_pointer(INTERP, PARROT_IMAGEIO(SELF)->seen,
            parrot_new_intval_hash(INTERP));

        visit_loop_todo_list(INTERP, p, SELF);
}

VTABLE void set_string_native(STRING *image) {
        UINTVAL header_length = GROW_TO_16_BYTE_BOUNDARY(PACKFILE_HEADER_BYTES);
        int unpacked_length;

        PARROT_IMAGEIO(SELF)->what          = VISIT_THAW_NORMAL;
        PARROT_IMAGEIO(SELF)->visit_pmc_now = visit_todo_list_thaw;
        PARROT_IMAGEIO(SELF)->buffer        = (Buffer *)image;

        PARROT_ASSERT(image->_bufstart == image->strstart);

        SET_VISIT_CURSOR(SELF, Buffer_bufstart(PARROT_IMAGEIO(SELF)->buffer));
        PARROT_IMAGEIO(SELF)->input_length = image->strlen;

        PARROT_IMAGEIO(SELF)->pf->options |= PFOPT_PMC_FREEZE_ONLY;
        unpacked_length = PackFile_unpack(interp, PARROT_IMAGEIO(SELF)->pf,
            GET_VISIT_CURSOR(SELF), PARROT_IMAGEIO(SELF)->input_length);

        if (!unpacked_length) {
            Parrot_ex_throw_from_c_args(interp, NULL,
                    EXCEPTION_INVALID_STRING_REPRESENTATION,
                    "PackFile header failed during unpack");
        }
        else {
            INC_VISIT_CURSOR(SELF, header_length);
        }

        visit_loop_todo_list(interp, pmc, SELF);
}

/*

=back

=cut

*/

}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
