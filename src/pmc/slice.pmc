/*
Copyright (C) 2004-2008, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/slice.pmc - Slice PMC

=head1 DESCRIPTION

These are the vtable functions for the slice PMC class.

A Slice PMC isa Key PMC, holding a chain of start and/or end values
for slice ranges. Private flags define the meaning of the values:

  [ s .. e ]    s .. KEY_start_slice_FLAG; e .. KEY_end_slice_FLAG
  [ x,     ]    KEY_start_slice_FLAG | KEY_end_slice_FLAG
  [  .. e  ]    KEY_inf_slice_FLAG   | KEY_end_slice_FLAG
  [ s ..   ]    KEY_start_slice_FLAG | KEY_inf_slice_FLAG

Infinite ranges are currently implemented for Array and PerlString only.

Run

  $ parrot -d2000 slice.pasm

to see slice constant flags.

During initialization above key chain gets converted to parrot_range_t
structures.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

#define VALID_RANGE(r) ((r) && ((INTVAL)(r) != -1))
#define RVal_int(u) (u).i
#define RVal_str(u) (u).s


/*
 * create range_t structure
 *
 * set the Slice iter state to initial, first position
 * no backwards iterations for now
 *
 * XXX self is a key chain (PMC constant), which shouldn't be modified
 *     finally this stuff should be call from packfiles thaw
 *
 */
static void
set_slice_start(PARROT_INTERP, PMC *self, PMC *key, PMC *agg)
{
    parrot_range_t *range = mem_allocate_typed(parrot_range_t);

    /*
     * when this PMC gets created with init(), this flag should get set if and
     * only if there's a slice range allocated for it -- that is, if this
     * function gets called
     */
    PObj_custom_mark_destroy_SETALL(self);

    PMC_struct_val(self)  = range;

next_range:
    range->next           = NULL;
    RVal_int(range->step) = 1;

    if (key_type(interp, key) & KEY_integer_FLAG) {
        range->type = enum_type_INTVAL;

        /* integer key */
        if ((PObj_get_FLAGS(key) &
                (KEY_start_slice_FLAG | KEY_end_slice_FLAG)) ==
                (KEY_start_slice_FLAG | KEY_end_slice_FLAG)) {
            /* start == end */
            RVal_int(range->start)   =
                RVal_int(range->end) = key_integer(interp, key);
        }
        else if ((PObj_get_FLAGS(key) &
                    (KEY_inf_slice_FLAG | KEY_end_slice_FLAG)) ==
                (KEY_inf_slice_FLAG | KEY_end_slice_FLAG)) {
            /*
             * first range is ".. end"
             * start at index 0
             * */
            RVal_int(range->start) = 0;
            RVal_int(range->end)   = key_integer(interp, key);
        }
        else {
            /*
             * else start at range value
             */
            RVal_int(range->start) = key_integer(interp, key);
            if ((PObj_get_FLAGS(key) &
                (KEY_inf_slice_FLAG | KEY_start_slice_FLAG)) ==
                (KEY_inf_slice_FLAG | KEY_start_slice_FLAG)) {
                /* last range "start .." */
                RVal_int(range->end) = VTABLE_elements(interp, agg) - 1;
                if (PMC_data(key))
                    Parrot_ex_throw_from_c_args(interp, NULL, 1,
                        "Illegal range after start..");
            }
            else {
                /* must have end in next key */
                key = PMC_data_typed(key, PMC *);

                if (!key)
                    Parrot_ex_throw_from_c_args(interp, NULL, 1,
                        "no end range specified");

                RVal_int(range->end) = key_integer(interp, key);
            }
        }

        if (agg->vtable->base_type == enum_class_Slice)
            --RVal_int(range->end);
        RVal_int(range->cur) = RVal_int(range->start);

range_end:
        key = PMC_data_typed(key, PMC *);

        if (key) {
            parrot_range_t * const n = mem_allocate_typed(parrot_range_t);
            range->next       = n;
            range             = n;
            goto next_range;
        }
        return;
    }
    else {
        if (PObj_get_FLAGS(key) & KEY_inf_slice_FLAG)
            Parrot_ex_throw_from_c_args(interp, NULL, 1,
               "unlimited slice range for hash not implemented");

        range->type = enum_type_STRING;

        /*
         * string assumed
         * start at value
         */
        RVal_str(range->start)   =
            RVal_str(range->cur) =
            key_string(interp, key);

        if ((PObj_get_FLAGS(key) &
                    (KEY_start_slice_FLAG | KEY_end_slice_FLAG)) ==
                    (KEY_start_slice_FLAG | KEY_end_slice_FLAG)) {
            /* start == end */
            RVal_str(range->end) = RVal_str(range->start);
        }
        else {
            /* must have end in next key */
            key = PMC_data_typed(key, PMC *);

            if (!key)
                Parrot_ex_throw_from_c_args(interp, NULL, 1,
                    "no end range specified");

            RVal_str(range->end) = key_string(interp, key);
        }
        goto range_end;
    }
}

/*
 * increment Slice value according to range and/or advance to
 * next range PMC in Key chain
 */
static void
set_slice_next(PARROT_INTERP, ARGMOD(PMC *self))
{
    parrot_range_t * const r = (parrot_range_t *)PMC_struct_val(self);

    if (!VALID_RANGE(r))
        Parrot_ex_throw_from_c_args(interp, NULL, CONTROL_ERROR,
            "StopIteration");

    if (r->type == enum_type_INTVAL) {
        RVal_int(r->cur) += RVal_int(r->step);
        if (RVal_int(r->step) > 0) {
            if (RVal_int(r->cur) > RVal_int(r->end)) {
                parrot_range_t *n;
next_range:
                n = r->next;
                mem_sys_free(r);

                PMC_struct_val(self) = n;

                if (!n)
                    PMC_int_val(self) = -1;
            }
        }
        else {
            if (RVal_int(r->cur) < RVal_int(r->end))
                goto next_range;
        }
    }
    else {
        STRING * const cur = RVal_str(r->cur);
        STRING * const end = RVal_str(r->end);

        if (Parrot_str_compare(interp, cur, end) < 0)
            RVal_str(r->cur) = string_increment(interp, cur);
        else
            goto next_range;
    }
}

pmclass Slice need_ext extends Key {

    VTABLE void init() {
        PMC_struct_val(SELF) = NULL;
        PMC_pmc_val(SELF)    = NULL;
    }

    VTABLE void mark() {
        parrot_range_t * const r = (parrot_range_t *)PMC_struct_val(SELF);

        if (PMC_pmc_val(SELF))
            pobject_lives(INTERP, (PObj *)PMC_pmc_val(SELF));

        /*
         * the pointer must not be null, or at the end of iteration and it must
         * point to STRINGs.  Note that r->step is always the integer value 1.
         */
        if (VALID_RANGE(r) && r->type == enum_type_STRING) {
            if (RVal_str(r->start))
                pobject_lives(INTERP, (PObj *)RVal_str(r->start));
            if (RVal_str(r->end))
                pobject_lives(INTERP, (PObj *)RVal_str(r->end));
            if (RVal_str(r->cur))
                pobject_lives(INTERP, (PObj *)RVal_str(r->cur));
        }
    }

    VTABLE void init_pmc(PMC *key) {
        SELF.init();

        /*
         * that's actually the KEY_number_FLAG - but I can't hardly
         * imagine that we get keyed by FLOATVAL slices on
         * arrays
         */
        PObj_get_FLAGS(SELF) |= PObj_private1_FLAG;
        PObj_custom_mark_destroy_SETALL(SELF);
        set_slice_start(INTERP, SELF, key, SELF);
    }

    VTABLE void destroy() {
        parrot_range_t *r = (parrot_range_t *)PMC_struct_val(SELF);

        /* iteration ended - all is freed */
        if ((INTVAL)r == -1)
            return;

        while (r) {
            parrot_range_t * const n = r->next;
            mem_sys_free(r);
            r = n;
        }
    }

    VTABLE PMC *clone() {
        Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INTERNAL_NOT_IMPLEMENTED,
            "Unimplemented");
    }

/*

=item C<INTVAL get_integer()>

Get the next integer key from the current slice range.

=item C<STRING *get_string()>

Get the next string key from the current slice range.

=cut

*/

    VTABLE INTVAL get_integer() {
        const parrot_range_t * const r = (parrot_range_t *)PMC_struct_val(SELF);

        if (!VALID_RANGE(r))
            Parrot_ex_throw_from_c_args(INTERP, NULL, CONTROL_ERROR,
                "StopIteration");

        return RVal_int(r->cur);
    }

    VTABLE STRING *get_string() {
        const parrot_range_t * const r = (parrot_range_t *)PMC_struct_val(SELF);

        return RVal_str(r->cur);
    }

/*

=item C<PMC *slice(PMC *key)>

=item C<PMC *get_iter()>

A slice can serve as its own iterator, yielding values [start .. end-1].
This is used for implementing Pythons xrange()

=cut

*/

    VTABLE PMC *slice(PMC *key, INTVAL f) {
        PMC *iter;

        if (f)
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                "Slice: Unknown slice type");

        iter                 = pmc_new_init(INTERP, enum_class_Iterator, SELF);
        PMC_struct_val(iter) = key;
        return iter;
    }

    VTABLE PMC *get_iter() {
        PMC * const iter     = pmc_new_init(INTERP, enum_class_Iterator, SELF);
        PMC_struct_val(iter) = SELF;
        return iter;
    }

    VTABLE INTVAL elements() {
        const parrot_range_t * const r = (parrot_range_t *)PMC_struct_val(SELF);
        /* only start .. end supported so:
         * TODO check flags somewhere
         * */
        return RVal_int(r->start) - RVal_int(r->end);
    }

    VTABLE INTVAL get_integer_keyed(PMC *key) {
        const parrot_range_t * const r = (parrot_range_t *)PMC_struct_val(key);
        return RVal_int(r->cur);
    }

    VTABLE STRING *get_string_keyed(PMC *key) {
        const INTVAL v = VTABLE_get_integer(INTERP, key);
        return Parrot_str_from_int(INTERP, v);
    }

    VTABLE PMC *get_pmc_keyed(PMC *key) {
        const parrot_range_t * const r = (parrot_range_t *)PMC_struct_val(key);
        PMC * const res   = PMC_pmc_val(SELF);
        PMC_int_val(res)  = RVal_int(r->cur);

        return res;
    }
/*

=item C<PMC *nextkey_keyed(PMC *agg, INTVAL what)>

Prepare slice PMC SELF for iteration over the passed aggregate or
advance to next position in the range, depending on what.

=cut

*/
    VTABLE PMC *nextkey_keyed(PMC *agg, INTVAL what) {
        PMC *ret = SELF;

        switch (what) {
            case ITERATE_FROM_START:
            case ITERATE_FROM_START_KEYS:    /* reset key */

                /* xrange implementation - the slice PMC itself serves as the
                 * aggregate. It's already initialized. */
                if (!agg)
                    return SELF;

                /*
                 * need a new Slice PMC that holds the state
                 * especially PMC_data() must be zero
                 *
                 * aggregate call get_integer/get_string on this
                 * PMC, because it's marked being a Key PMC
                 */
                ret = pmc_new(INTERP, enum_class_Slice);
                PObj_get_FLAGS(ret) |= KEY_pmc_FLAG;

                /* set start value */
                set_slice_start(INTERP, ret, SELF, agg);
                break;

                /* we are passed now the new PMC we created above */
            case ITERATE_GET_NEXT:
                set_slice_next(INTERP, SELF);
                break;
            default:
                Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_INTERNAL_NOT_IMPLEMENTED,
                    "No backward iteration on slices yet");
                break;
        }

        return ret;
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
