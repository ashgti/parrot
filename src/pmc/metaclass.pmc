/*
Copyright (C) 2001-2007, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/metaclass.pmc - Metaclass - defines a class

=head1 DESCRIPTION

This class implements the basic Parrot metaclass, used for describing a
class.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"
#define PARROT_METACLASS(o) ((Parrot_MetaClass *) PMC_data(o))

typedef struct Parrot_MetaClass {
    STRING *name;         /* The name of the class. */
    PMC *namespace;       /* The namespace it's linked to, if any. */
    int instantiated;     /* Any instantiations since last modification? */
    PMC *parents;         /* Immediate parent classes. */
    PMC *all_parents;     /* Cached list of ourself and all parents, in MRO order. */
    PMC *roles;           /* An array of roles. */
    PMC *methods;         /* Hash of method names to methods in this class. */
    PMC *vtable_methods;  /* Hash of Parrot v-table methods we override. */
    PMC *attrib_metadata; /* Hash of attributes in this class to metadata. */
    PMC *attrib_index;    /* Lookup table for attributes in this and parents. */
    PMC *attrib_cache;    /* Cache of visible attrib names to indexes. */
} Parrot_MetaClass;

pmclass MetaClass need_ext {
    /* This functions builds the attribute index (table to map class name and
     * attribute name to an index) for the current class. Note: we have to
     * make this a method so we can use PMINVOKE for now. XXX Fix that. */
    METHOD void build_attrib_index() {
        Parrot_MetaClass *class = PARROT_METACLASS(SELF);
        int num_classes = VTABLE_elements(interp, class->all_parents);
        int i;
        int cur_index = 0;
        PMC *table = pmc_new(interp, enum_class_Hash);

        /* We will go over the list of all parents to construct the table. */
        for (i = 0; i < num_classes; i++) {
           /* Get the class and its attribute metadata hash. */
            PMC *cur_class = VTABLE_get_pmc_keyed_int(interp, class->all_parents, i);
            Parrot_MetaClass *class_info = PARROT_METACLASS(cur_class);
            PMC *attribs = class_info->attrib_metadata;
            PMC *iter = VTABLE_get_iter(interp, attribs);

            /* Iterate over the attributes. */
            while (VTABLE_get_bool(interp, iter)) {
                /* Get attribute. */
                PMC *cur_attrib = VTABLE_get_pmc_keyed(interp, attribs,
                    VTABLE_shift_pmc(interp, iter));
                STRING *attrib_name;

                /* Get fully qualified class name. */
                /* XXX BAD AND WRONG! Need to call method properly! */
                PMC *fq_name;
                if (!PMC_IS_NULL(class_info->namespace))
                    fq_name = Parrot_NameSpace_get_name(interp, class_info->namespace);
                else
                    fq_name = pmc_new(interp, enum_class_ResizableStringArray);

                /* Get attribute name and append it. */
                (STRING *attrib_name) = PMINVOKE(interp, cur_attrib, "name");
                printf("arg %s\n", string_to_cstring(interp, attrib_name));
                VTABLE_push_string(interp, fq_name, attrib_name);

                /* Insert into hash, along with index. */
                VTABLE_set_integer_keyed(interp, table, fq_name, cur_index);
                cur_index++;
            }
        }

        /* Store built table and invalidate cache. */
        class->attrib_index = table;
        class->attrib_cache = pmc_new(interp, enum_class_Hash);
    }

/*

=item C<void init()>

Initializes the class.

=item C<void init_pmc(PMC *name)>

The actual class creation code, called from C<newclass> opcode. The C<init>
argument should stringify to the C<classname>. The class will be attatched to
the current namespace.

=cut

*/

    void init() {
        Parrot_MetaClass *class = NULL;

        /* Custom DOD mark and destory. */
        PObj_custom_mark_SET(SELF);
        PObj_active_destroy_SET(SELF);

        /* We are a class. */
        PObj_is_class_SET(SELF);

        /* Init the class object. */
        class = mem_sys_allocate_zeroed(sizeof(Parrot_MetaClass));
/*        class->name = 'MetaClass'; */
        class->namespace = PMCNULL;
        class->parents = pmc_new(interp, enum_class_ResizablePMCArray);
        class->all_parents = pmc_new(interp, enum_class_ResizablePMCArray);
        class->roles = pmc_new(interp, enum_class_ResizablePMCArray);
        class->methods = pmc_new(interp, enum_class_Hash);
        class->vtable_methods = pmc_new(interp, enum_class_Hash);
        class->attrib_metadata = pmc_new(interp, enum_class_Hash);
        class->attrib_index = PMCNULL;
        class->attrib_cache = PMCNULL;

        /* We put ourself on the all parents list. */
        VTABLE_push_pmc(interp, class->all_parents, SELF);

        PMC_data(SELF) = class;
    }

    void init_pmc(PMC* name) {
        Parrot_MetaClass *class = NULL;

        /* Set up the object. */
        SELF.init();

        /* Set name and namespace. */
        class = PARROT_METACLASS(SELF);
        class->name = VTABLE_get_string(interp, name);
        class->namespace = CONTEXT(interp->ctx)->current_namespace;
    }

/*

=item C<void destroy()>

Free the memory associated with the underlying struct.

=cut

*/
    void destroy() {
            mem_sys_free(PMC_data(SELF));
    }

/*

=item C<void mark()>

Mark any referenced strings and PMCs.

=cut

*/
    void mark() {
        Parrot_MetaClass *class = PARROT_METACLASS(SELF);
        if (class->namespace)
            pobject_lives(interp, (PObj*)class->namespace);
        if (class->parents)
            pobject_lives(interp, (PObj*)class->parents);
        if (class->all_parents)
            pobject_lives(interp, (PObj*)class->all_parents);
        if (class->roles)
            pobject_lives(interp, (PObj*)class->roles);
        if (class->methods)
            pobject_lives(interp, (PObj*)class->methods);
        if (class->vtable_methods)
            pobject_lives(interp, (PObj*)class->vtable_methods);
        if (class->attrib_metadata)
            pobject_lives(interp, (PObj*)class->attrib_metadata);
        if (class->attrib_index)
            pobject_lives(interp, (PObj*)class->attrib_index);
        if (class->attrib_cache)
            pobject_lives(interp, (PObj*)class->attrib_cache);
    }


/*

=item C<void attributes()>

Return the attributes Hash PMC.

=cut

*/
    PMETHOD void attributes() {
        Parrot_MetaClass *class = PARROT_METACLASS(SELF);
        PMC *ret_attrib_metadata = class->attrib_metadata;
        preturn(PMC *ret_attrib_metadata);
    }


/*

=item C<void add_attribute()>

Add an attribute to the class. Requires a name and, optionally, a type.

=cut

*/
    PMETHOD void add_attribute(STRING *attribute_name, STRING* attribute_type :optional, int got_type :opt_flag) {
        Parrot_MetaClass *class = PARROT_METACLASS(SELF);
        PMC *new_attribute = pmc_new(interp, enum_class_MetaAttribute);

        /* Set name and type. */
        PMINVOKE(interp, new_attribute, "name", STRING* attribute_name);
        if (got_type) {
            PMINVOKE(interp, new_attribute, "type", STRING* attribute_type);
        }

        /* If we've been instantiated already, need a new class. */
        /* if (class->instantiated) ... */

        /* Enter the attribute in the attributes array. */
        VTABLE_set_pmc_keyed_str(interp, class->attrib_metadata, attribute_name, new_attribute);
    }

/*

=item C<void name()>

Sets the name of the class.

=cut

*/
    PMETHOD void name(STRING *name :optional, int got_name :opt_flag) {
        Parrot_MetaClass *class = PARROT_METACLASS(SELF);
        STRING *ret_name = NULL;

        if (got_name) {
            /* Set class name. */
            class->name = name;
        }

        ret_name = class->name;
        preturn(STRING *ret_name);
    }

/*

=item C<void namespace()>

With a parameter, sets the namespace for the class. Expects a fully
qualified namespace to be specified as a key. If you already have linked another
namespace with this class, this link will be broken and the new namespace
specified will be linked to this class.

=cut

*/
    PMETHOD void namespace(PMC *namespace :optional, int got_name :opt_flag) {
        Parrot_MetaClass *class = PARROT_METACLASS(SELF);
        PMC *ret_namespace = NULL;

        if (got_name) {
            /* Check namespace is a key. */
            if (namespace->vtable->base_type != enum_class_Key)
            {
                real_exception(interp, NULL, E_NameError, "Namespace must be a key");
                return;
            }

            /* If we already have a namespace, it shouldn't refer to the
               class any more. */
            if (class->namespace)
            {
                /* XXX */
            }

            /* Set namespace. */
            class->namespace = Parrot_get_namespace_keyed(interp,
                interp->HLL_namespace, namespace);

            /* XXX Link namespace to this class; currently missing slot for that. */
        }

        ret_namespace = class->namespace;
        preturn(PMC *ret_namespace);
    }

/*

=item C<void new()>

Creates an instance of the object.

=cut

*/
    PMETHOD void new(PMC *args :slurpy :named) {
        Parrot_MetaClass *class = PARROT_METACLASS(SELF);
        PMC *obj;

        /* Ensure we've built attributes list. */
        if (PMC_IS_NULL(class->attrib_index))
            Parrot_MetaClass_build_attrib_index(interp, SELF);

        /* Set instantiated flag. */
        class->instantiated = 1;

        /* Create object. */
        obj = pmc_new_init(interp, enum_class_Object, SELF);

        /* XXX Call constructor with the supplied arguments? */

        preturn(PMC *obj)
     }


/*

=item C<void parents()>

Return the parents array PMC.

=cut

*/
    PMETHOD void parents() {
        Parrot_MetaClass *class = PARROT_METACLASS(SELF);
        PMC *ret_parents = class->parents;
        preturn(PMC *ret_parents);
    }


/*

=item C<void roles()>

Return the roles array PMC.

=cut

*/
    PMETHOD void roles() {
        Parrot_MetaClass *class = PARROT_METACLASS(SELF);
        PMC *ret_roles = class->roles;
        preturn(PMC *ret_roles);
    }


} /* END pmclass */

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd15_objects.pod>.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
