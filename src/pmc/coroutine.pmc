/*
Copyright (C) 2001-2008, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/coroutine.pmc - Co-Routine PMC

=head1 DESCRIPTION

C<Coroutine> extends C<Sub> to provide a subroutine that can
stop in the middle, and start back up later at the point at which it
stopped. See the L<Glossary|docs/glossary.pod> for more information.

=head2 Flags

=over 4

=item private0 call flip flop

=item private3 restore current sub after "flop".  Used by generators.

=back

=head2 Methods

=over 4

=cut

*/

#include "parrot/oplib/ops.h"

static void
print_sub_name(PARROT_INTERP, PMC *sub_pmc)
{
    /* It's actually a Parrot_coro, but this avoids casting warnings. */
    Parrot_Sub_attributes *co = PARROT_SUB(sub_pmc);
    Interp      * const tracer = (interp->pdb && interp->pdb->debugger) ?
        interp->pdb->debugger :
        interp;

    Parrot_io_eprintf(tracer, "# %s coro '%Ss'",
        !(PObj_get_FLAGS(sub_pmc) & SUB_FLAG_CORO_FF) ?
        "Calling" : "yielding from",
        Parrot_full_sub_name(interp, sub_pmc));

    if (co->ctx && (PObj_get_FLAGS(sub_pmc) & SUB_FLAG_CORO_FF)) {
        Parrot_io_eprintf(tracer, " to '%Ss'",
                Parrot_full_sub_name(interp,
                    CONTEXT_FIELD(interp, Parrot_cx_get_caller_ctx(interp, co->ctx), current_sub)));
    }

    Parrot_io_eprintf(tracer, "\n# ");
    print_pbc_location(interp);
}

pmclass Coroutine extends Sub {
    ATTR PackFile_ByteCode *caller_seg;  /* bytecode segment */
    ATTR opcode_t *address;           /* next address to run - toggled each time */

/*

=item C<void init()>

Initializes the coroutine.

=item C<PMC *clone()>

Clone the coroutine.

=cut

*/

    VTABLE void init() {
        Parrot_Coroutine_attributes *attrs =
            mem_allocate_zeroed_typed(Parrot_Coroutine_attributes);

        attrs->seg = INTERP->code;
        attrs->ctx = NULL;
        PMC_data(SELF) = attrs;

        PObj_custom_mark_destroy_SETALL(SELF);
    }


/*

=item C<PMC * clone()>

Clones the coroutine.

=cut

*/

    VTABLE PMC *clone() {
        PMC         * const ret      = pmc_new(INTERP, SELF->vtable->base_type);
        Parrot_Coroutine_attributes *sub = PARROT_COROUTINE(SELF);
        Parrot_Coroutine_attributes *coro_sub = PARROT_COROUTINE(ret);

        PObj_custom_mark_destroy_SETALL(ret);

        memcpy(coro_sub, sub, sizeof (Parrot_Coroutine_attributes));

        coro_sub->name      = Parrot_str_copy(INTERP, coro_sub->name);

        return ret;
    }

/*

=item C<opcode_t *invoke(void *next)>

Swaps the "context".

=cut

*/

    VTABLE opcode_t *invoke(void *next) {
        PackFile_ByteCode  *wanted_seg;
        Parrot_Coroutine_attributes *co = PARROT_COROUTINE(SELF);
        opcode_t    * dest     = co->address;

        if (Interp_trace_TEST(INTERP, PARROT_TRACE_SUB_CALL_FLAG))
            print_sub_name(INTERP, SELF);

        if (!co->ctx) {
            PMC *caller_ctx;
            PMC *ctx;
            PMC *ccont;

            ccont = INTERP->current_cont;

            if (ccont == NEED_CONTINUATION)
                ccont = (PMC *)new_ret_continuation_pmc(interp,
                                                       (opcode_t *)next);

            if (PObj_get_FLAGS(ccont) & SUB_FLAG_TAILCALL)
                Parrot_ex_throw_from_c_args(INTERP, NULL, CONTROL_ERROR,
                        "tail call to coro not allowed");

            /* first time set current sub, cont, object */
            caller_ctx = CONTEXT(interp);
            ctx        = Parrot_set_new_context(INTERP, co->n_regs_used);

            co->ctx                   = ctx;

            CONTEXT_FIELD(INTERP, ctx, caller_ctx)          = caller_ctx;
            PMC_cont(ccont)->from_ctx                       = ctx;
            CONTEXT_FIELD(INTERP, ctx, current_sub)         = SELF;
            CONTEXT_FIELD(INTERP, ctx, current_HLL)         = co->HLL_id;
            CONTEXT_FIELD(INTERP, ctx, current_namespace)   = co->namespace_stash;
            CONTEXT_FIELD(INTERP, ctx, current_cont)        = ccont;
            CONTEXT_FIELD(INTERP, ctx, current_object)      = NULL;
            INTERP->current_object                  = NULL;
            INTERP->current_cont                    = NULL;

            /* create pad if needed */
            if (!PMC_IS_NULL(co->lex_info)) {
                Parrot_cx_set_lex_pad(INTERP, ctx, pmc_new_init(INTERP,
                        Parrot_get_ctx_HLL_type(interp, enum_class_LexPad),
                        co->lex_info));
                VTABLE_set_pointer(INTERP, Parrot_cx_get_lex_pad(INTERP, ctx), ctx);
            }

            PObj_get_FLAGS(SELF) |= SUB_FLAG_CORO_FF;
            wanted_seg            = co->seg;
            co->caller_seg        = INTERP->code;
            co->address           = co->seg->base.data + co->start_offs;
        }

        /* if calling the Coro we need the segment of the Coro */
        else if (!(PObj_get_FLAGS(SELF) & SUB_FLAG_CORO_FF)) {
            PMC *ccont;
            PMC *ctx;

            PObj_get_FLAGS(SELF) |= SUB_FLAG_CORO_FF;
            wanted_seg            = co->seg;

            /* remember segment of caller */
            co->caller_seg        = INTERP->code;
            ctx                   = co->ctx;

            /* and the recent call context */
            ccont                   = CONTEXT_FIELD(INTERP, ctx, current_cont);
            PMC_cont(ccont)->to_ctx = CONTEXT(interp);
            Parrot_cx_set_caller_ctx(interp, ctx, CONTEXT(interp));

            /* set context to coro context */
            CONTEXT(interp) = ctx;
        }
        else {
            PMC *ccont;
            PMC *ctx;

            PObj_get_FLAGS(SELF) &= ~SUB_FLAG_CORO_FF;
            /* switch back to last remembered code seg and context */

            wanted_seg            = co->caller_seg;
            ccont                 = CONTEXT_FIELD(INTERP, co->ctx, current_cont);
            ctx                   = PMC_cont(ccont)->to_ctx;

            if (! ctx) {
                /* This still isn't quite right, but it beats segfaulting.  See
                   the "Call an exited coroutine" case in t/pmc/coroutine.t; the
                   problem is that the defunct coroutine yields up one more
                   result before we get here.  -- rgr, 7-Oct-06.
                */
                Parrot_ex_throw_from_c_args(INTERP, NULL, CONTROL_ERROR,
                               "Cannot resume dead coroutine.");
            }

            CONTEXT(interp) = ctx;
        }

        /* toggle address */
        dest        = co->address;
        co->address = (opcode_t *)next;

        if (INTERP->code != wanted_seg)
            Parrot_switch_to_cs(INTERP, wanted_seg, 1);

        return dest;
    }

/*

=item C<void mark()>

Marks the coroutine as live.

=cut

*/

    VTABLE void mark() {
        Parrot_Coroutine_attributes *co = PARROT_COROUTINE(SELF);

        /* co->ctx marked in SUPER(), so do not mark here */
        if (co) {
            SUPER();
        }
    }
}

/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
