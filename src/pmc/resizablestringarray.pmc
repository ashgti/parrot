/*
Copyright (C) 2001-2005, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/resizablestringarray.pmc - resizable array for strings only

=head1 DESCRIPTION

ResizableStringArray implements a resizeable array which stores Parrot
strings only. Any ints or floats assigned to elements of the array will
first be converted to String PMCs and then to native Parrot strings.
PMCs assigned to to elements of the array will be stringified by having
their C<get_string> method called.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass ResizableStringArray extends FixedStringArray need_ext does array {

/*

=item C<STRING *get_string_keyed_int(INTVAL key)>

Returns the Parrot string value of the element at index C<key>.

=cut

*/

    STRING* get_string_keyed_int (INTVAL key) {
        STRING **data;
        if (key < 0)
        {
            INTVAL size = DYNSELF.elements();
            if (key < -size)
                real_exception(INTERP, NULL, E_IndexError,
                    "ResizableStringArray: index out of bounds!");
            else
                key += size;
        }
        if(key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);

        data = (STRING**)PMC_data(SELF);
        return data[key];
    }

/*

=item C<void set_string_keyed_int(INTVAL key, STRING *value)>

Sets the Parrot string value of the element at index C<key> to C<value>.

=cut

*/

    void set_string_keyed_int (INTVAL key, STRING* value) {
        STRING **data;
        if (key < 0)
        {
            INTVAL size = DYNSELF.elements();
            if (key < -size)
                real_exception(INTERP, NULL, E_IndexError,
                    "ResizableStringArray: index out of bounds!");
            else
                key += size;
        }
        if(key >= PMC_int_val(SELF))
            DYNSELF.set_integer_native(key+1);

        data = (STRING**)PMC_data(SELF);
        DOD_WRITE_BARRIER(INTERP, SELF, data[key], value);
        data[key] = value;
    }

/*

=item C<void push_string (STRING* value)>

Extends the array by adding an element of value C<*value> to the end of
the array.

=cut

*/

    void push_string (STRING* value) {
        INTVAL nextix = DYNSELF.elements();
        DYNSELF.set_string_keyed_int(nextix, value);
    }

/*

=item C<STRING* pop_string()>

Removes and returns the last element in the array.

=cut

*/

    STRING* pop_string() {
        INTVAL size;
        STRING* value;

        size = PMC_int_val(SELF);
        if (size == 0) {
            real_exception(INTERP, NULL, E_IndexError,
                    "ResizableStringArray: Can't pop from an empty array!");
        }
        value = DYNSELF.get_string_keyed_int(size-1);
        DYNSELF.set_integer_native(size - 1);
        return value;
    }

/*

=item C<PMC* pop_pmc()>

Removes and returns the last element in the array.

=cut

*/

    PMC* pop_pmc() {
        STRING *strval = DYNSELF.pop_string();
        PMC    *value  = pmc_new(INTERP, enum_class_String);

        VTABLE_set_string_native(INTERP, value, strval);

        return value;
    }

/*

=item C<INTVAL pop_integer()>

Removes and returns the last element in the array.

=cut

*/

    INTVAL pop_integer() {
        PMC   *pmcval = DYNSELF.pop_pmc();
        INTVAL value  = VTABLE_get_integer(INTERP, pmcval);
        return value;
    }

/*

=item C<FLOATVAL pop_float()>

Removes and returns the last element in the array.

=cut

*/

    FLOATVAL pop_float() {
        PMC     *pmcval = DYNSELF.pop_pmc();
        FLOATVAL value  = VTABLE_get_number(INTERP, pmcval);
        return value;
    }

/*

=item C<void set_integer_native(INTVAL size)>

Resizes the array to C<size> elements.

=cut

*/

    void set_integer_native (INTVAL size) {
        if (size < 0)
            real_exception(INTERP, NULL, E_IndexError,
                    "ResizableStringArray: Can't resize!");

        if(!PMC_data(SELF)) {
            /* empty - used fixed routine */
            if (size < 8) {
                SUPER(8);
                PMC_int_val(SELF) = size;
                PMC_int_val2(SELF) = 8;
            }
            else {
                SUPER(size);
                PMC_int_val2(SELF) = size;
            }
        }
        else if (size <= PMC_int_val2(SELF)) {
            /* zero out anything that was previously allocated
             * if we're growing the array */
            INTVAL oldsize = PMC_int_val(SELF);
            if (size > oldsize) {
                STRING **data   = (STRING**)PMC_data(SELF);
                INTVAL i;
                for (i=oldsize; i<size; i++)
                    data[i] = NULL;
            }

            PMC_int_val(SELF) = size;
            /* we could shrink here if necessary */
            return;
        }
        else {
            INTVAL i, cur;
            i = cur = PMC_int_val2(SELF);
            if (cur < 8192)
                cur = size < 2 * cur ? 2 * cur : size;
            else {
                cur = size + 4096;
                cur &= ~0xfff;
            }
            PMC_data(SELF) = mem_sys_realloc(PMC_data(SELF),
                    cur * sizeof(STRING*));
            for (; i < cur; i++)
                ((STRING**)PMC_data(SELF))[i] = NULL;
            PMC_int_val2(SELF) = cur;
            PMC_int_val(SELF) = size;
        }
    }

/*

=item C<PMC *clone()>

Creates and returns a copy of the array.

=cut

*/

    PMC* clone () {
        PMC *copy = SUPER();
        /* copy trimmed extra space */
        PMC_int_val2(copy) = PMC_int_val(SELF);
        return copy;
    }

/*

=item C<STRING* shift_string()>

Removes and returns an item from the start of the array.

=cut

*/

    STRING* shift_string () {
        INTVAL size;
        STRING* value;

        size = PMC_int_val(SELF);
        if (size == 0)
            real_exception(INTERP, NULL, E_IndexError,
                    "ResizableStringArray: Can't shift from an empty array!");

        value = DYNSELF.get_string_keyed_int(0);
        DYNSELF.delete_keyed_int(0);
        return value;
    }

/*

=item C<PMC* shift_pmc()>

Removes and returns the first element in the array.

=cut

*/

    PMC* shift_pmc() {
        STRING *strval = DYNSELF.shift_string();
        PMC    *value  = pmc_new(INTERP, enum_class_String);

        VTABLE_set_string_native(INTERP, value, strval);

        return value;
    }

/*

=item C<INTVAL shift_integer()>

Removes and returns the first element in the array.

=cut

*/

    INTVAL shift_integer() {
        PMC   *pmcval = DYNSELF.shift_pmc();
        INTVAL value  = VTABLE_get_integer(INTERP, pmcval);
        return value;
    }

/*

=item C<FLOATVAL shift_float()>

Removes and returns the first element in the array.

=cut

*/

    FLOATVAL shift_float() {
        PMC     *pmcval = DYNSELF.shift_pmc();
        FLOATVAL value  = VTABLE_get_number(INTERP, pmcval);
        return value;
    }


/*

=item C<void push_pmc (PMC *value)>

Extends the array by adding an element of value C<*value> to the end of
the array.

=cut

*/

    void push_pmc(PMC *value) {
        STRING *strvalue = VTABLE_get_string(INTERP, value);
        DYNSELF.push_string(strvalue);
    }

/*

=item C<void push_integer (INTVAL value)>

Extends the array by adding an element of value C<*value> to the end of
the array.

=cut

*/

    void push_integer(INTVAL value) {
        PMC *ret;
        STRING *val;

        ret = pmc_new(INTERP, enum_class_String);
        VTABLE_set_integer_native(INTERP, ret, value);
        val = VTABLE_get_string(INTERP, ret);
        DYNSELF.push_string(val);
    }

/*

=item C<void push_float (FLOAT value)>

Extends the array by adding an element of value C<*value> to the end of
the array.

=cut

*/

    void push_float(FLOATVAL value) {
        PMC *ret;
        STRING *val;

        ret = pmc_new(INTERP, enum_class_String);
        VTABLE_set_number_native(INTERP, ret, value);
        val = VTABLE_get_string(INTERP, ret);
        DYNSELF.push_string(val);
    }

/*

=item C<PMC* shift_pmc()>

Removes and returns a String PMC from the start of the array.

=cut

*/

    PMC* shift_pmc () {
        INTVAL size;
        PMC *ret;
        STRING* value;

        size = PMC_int_val(SELF);
        if (size == 0)
            real_exception(INTERP, NULL, E_IndexError,
                    "ResizableStringArray: Can't shift from an empty array!");

        value = DYNSELF.get_string_keyed_int(0);
        ret = pmc_new(INTERP, enum_class_String);
        VTABLE_set_string_native(INTERP, ret, value);
        DYNSELF.delete_keyed_int(0);
        return ret;
    }

/*

=item C<void unshift_string(STRING *value)>

Extends the array by adding an element of value C<*value> to the start
of the array.

=cut

*/

    void unshift_string (STRING *value) {
        STRING **data;
        INTVAL size, i;

        size = PMC_int_val(SELF);
        data = (STRING**)PMC_data(SELF);

        DYNSELF.set_integer_native(size + 1);
        data = PMC_data(SELF);
        for (i = size; i; --i)
            data[i] = data[i - 1];
        DYNSELF.set_string_keyed_int(0, value);
    }


/*

=item C<void unshift_pmc (PMC *value)>

Extends the array by adding an element of value C<*value> to the front of
the array.

=cut

*/

    void unshift_pmc(PMC *value) {
        STRING *strvalue = VTABLE_get_string(INTERP, value);
        DYNSELF.unshift_string(strvalue);
    }

/*

=item C<void unshift_integer (INTVAL value)>

Extends the array by adding an element of value C<*value> to the front of
the array.

=cut

*/

    void unshift_integer(INTVAL value) {
        PMC *ret;
        STRING *val;

        ret = pmc_new(INTERP, enum_class_String);
        VTABLE_set_integer_native(INTERP, ret, value);
        val = VTABLE_get_string(INTERP, ret);
        DYNSELF.unshift_string(val);
    }

/*

=item C<void unshift_float (FLOAT value)>

Extends the array by adding an element of value C<*value> to the front of
the array.

=cut

*/

    void unshift_float(FLOATVAL value) {
        PMC *ret;
        STRING *val;

        ret = pmc_new(INTERP, enum_class_String);
        VTABLE_set_number_native(INTERP, ret, value);
        val = VTABLE_get_string(INTERP, ret);
        DYNSELF.unshift_string(val);
    }

/*

=item C<void delete_keyed_int(INTVAL key)>

Converts C<key> to a PMC key and calls C<delete_keyed()> with it.

=cut

*/

    void delete_keyed_int (INTVAL key) {
        STRING **data;
        INTVAL size, i;
        size = PMC_int_val(SELF);

        data = PMC_data(SELF);
        for (i = key; i < size - 1; ++i)
            data[i] = data[i + 1];
        DYNSELF.set_integer_native(size - 1);
    }

/*

=item C<void delete_keyed(PMC* key)>

Removes the element at C<*key>.

=cut

*/

    void delete_keyed (PMC* key) {
        STRING **data;
        INTVAL size, idx, i;
        size = PMC_int_val(SELF);
        idx = key_integer(INTERP, key);

        data = PMC_data(SELF);
        for (i = idx; i < size - 1; ++i)
            data[i] = data[i + 1];
        DYNSELF.set_integer_native(size - 1);
    }
}



/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd17_basic_types.pod>.

=head1 HISTORY

Initial version                  - Matt Fowles 2004-06-11
Changed allocator to double size - Matt Fowles 2004-06-15
Added push_string                - Bernhard Schmalhofer 2004-10-17
moved available size to int_val2 - Matt Fowles 2005-07-22

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
