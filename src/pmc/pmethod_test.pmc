/*
Copyright (C) 2001-2006, The Perl Foundation.
$Id: hash.pmc 15414 2006-11-12 02:47:59Z chip $

=head1 NAME

src/pmc/pmethod_test.pmc - PMETHOD_Test PMC

=head1 DESCRIPTION


=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"
#include <assert.h>
#include <pmc_fixedintegerarray.h>


/* Albeit the Hash PMC doesn't use PMC_data, it needs the next_for_GC pointer
 * We would get recursive marking of a deeply nested HoHoH...
 */
pmclass PMETHOD_Test need_ext does hash {

/*

=item C<void init()>

Initializes the instance.

=item C<void destroy()>

Free hash structure.

=cut

=item C<void mark()>

Marks the hash as live.

=cut

*/

    METHOD void test_method ()
    {
        PIO_printf(interp, "test_method\n");
    }
    PMETHOD void test_method0( int a1 )
    {
        PIO_printf(interp, "test_method0\n");
        PIO_printf(interp, "%d\n", a1);
    }
    PMETHOD void test_method1( int a1, int a2, int a3, int a4, int a5, int a6)
    {
        PIO_printf(interp, "test_method1\n");
        PIO_printf(interp, "%d,%d,%d,%d,%d,%d\n", a1, a2, a3, a4, a5, a6);
    }
    PMETHOD void test_method2( int a1 :optional, int a1o :opt_flag, PMC *slurpy_pos :slurpy)
    {
        STRING* kevin = string_from_cstring(interp, "KEVIN", 0);
        PIO_printf(interp, "test_method2\n");
        PIO_printf(interp, "%d, %d, %Ss %Ss\n", a1, a1o, VTABLE_name(interp, slurpy_pos), VTABLE_get_repr(interp,slurpy_pos));

        preturn(int 1000, STRING* kevin);
    }
    PMETHOD void test_method3(PMC* a1 :named["a1name"], PMC* a2  :named["a2name"])
    {
        PIO_printf(interp, "test_method3\n");
        PIO_printf(interp, "%Ps, %Ps\n", a1, a2);
    }
    PMETHOD void test_method4( int george :optional, int g_f :opt_flag, PMC *slurpy_pos :slurpy, PMC *slurpy_named :slurpy :named )
    {
        PIO_printf(interp, "test_method4\n");
    }
}

/*

=back

=head1 SEE ALSO

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
