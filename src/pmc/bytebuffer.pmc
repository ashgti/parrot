/*
Copyright (C) 2010, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/bytebuffer.pmc - A byte buffer

=head1 DESCRIPTION

C<ByteBuffer> provides a resizable byte buffer with random access to
individual bytes and conversions from and to parrot strings.

=cut

*/

/* HEADERIZER HFILE: none */
/* HEADERIZER BEGIN: static */
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */

pmclass ByteBuffer auto_attrs {
    ATTR INTVAL allocated_size;
    ATTR INTVAL size;
    ATTR unsigned char *content;

/*

=head2 Vtable functions

=over 4

=item C<void init()>
Create an empty buffer

=item C<void init_int()>
Create a buffer of initial_size capacity.

=item C<void destroy()>
Free the buffer when destroying.

=cut

*/

    VTABLE void init() {
        PObj_custom_destroy_SET(SELF);
    }

    VTABLE void init_int(INTVAL initial_size) {
        unsigned char *content;
        STATICSELF.init();
        SET_ATTR_size(INTERP, SELF, initial_size);
        SET_ATTR_allocated_size(INTERP, SELF, initial_size);
        content = (unsigned char *)Parrot_gc_allocate_memory_chunk(INTERP, initial_size);
        SET_ATTR_content(INTERP, SELF, content);
    }

    VTABLE void destroy() {
        unsigned char *content;
        GET_ATTR_content(INTERP, SELF, content);
        Parrot_gc_free_memory_chunk(INTERP, content);
    }

/*

=item C<INTVAL elements()>
Get current size.

=cut

*/

    VTABLE INTVAL elements() {
        INTVAL size;
        GET_ATTR_size(INTERP, SELF, size);
        return size;
    }

} /* pmclass end */

/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
