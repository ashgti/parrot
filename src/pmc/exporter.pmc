/*
Copyright (C) 2007, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/exporter.pmc - Export globals from one namespace to another

=head1 DESCRIPTION

Exports globals from one namespace to another. Exporter always uses
the typed namespace interface, as outlined in
F<docs/pdds/pdd21_namespaces.pod>.

Exporter is not derived from any other PMC, and does not provide any
standard interface--its interface consists solely of non-vtable methods.

=head2 Structure

The Exporter PMC structure (C<Parrot_Exporter>) consists of three items:

=over 4

=item C<ns_src>

The source namespace -- a NameSpace PMC.
A Null PMC is allocated during initialization.

=item C<ns_dest>

The destination namespace -- a NameSpace PMC.
A PMC representing the current namespace is allocated upon initialization.

=item C<globals>

The globals to export -- a ResizableStringArray.
A Null PMC is allocated during initialization.

=cut

*/

#include "parrot/parrot.h"
#define PARROT_EXPORTER(e) ((Parrot_Exporter *) PMC_data(e))

typedef struct Parrot_Exporter {
    PMC *ns_src;
    PMC *ns_dest;
    PMC *globals;
} Parrot_Exporter;


/*

=back

=head2 Functions

=over 4

=cut

*/

pmclass Exporter
    need_ext {


/*

=item C<void init()>

Initializes an Exporter PMC.

=cut

*/

    void init() {
        Parrot_Exporter *exp = NULL;

        /* Set flags for custom DOD mark and destroy. */
        PObj_custom_mark_SET(SELF);
        PObj_active_destroy_SET(SELF);

        /* Set up the object. */
        exp            = mem_sys_allocate_zeroed(sizeof (Parrot_Exporter));
        exp->ns_src    = PMCNULL;
        exp->ns_dest   = CONTEXT(interp->ctx)->current_namespace;
        exp->globals   = PMCNULL;
        PMC_data(SELF) = exp;
    }


/*

=item C<void destroy()>

Free the memory associated with the object's underlying struct.

=cut

*/

    void destroy() {
            mem_sys_free(PMC_data(SELF));
    }


/*

=item C<void mark()>

Mark referenced strings and PMCs in the structure as live.

=cut

*/

    void mark() {
        Parrot_Exporter *exp = PARROT_EXPORTER(SELF);
        if (exp->ns_src)
            pobject_lives(interp, (PObj*)exp->ns_src);
        if (exp->ns_dest)
            pobject_lives(interp, (PObj*)exp->ns_dest);
        if (exp->globals)
            pobject_lives(interp, (PObj*)exp->globals);
    }


/*

=back

=head2 Methods

=over 4

=item C<PCCMETHOD void
    source(PMC *src :optional, int got_src :opt_flag)>

Accessor for the source NameSpace object (C<ns_src>.)
Sets the value if C<src> is passed, otherwise returns the value.
Throws an exception if a non-NameSpace PMC is passed.

=cut

*/

    PCCMETHOD void source(PMC *src :optional, int got_src :opt_flag) {
        Parrot_Exporter *exp = PARROT_EXPORTER(SELF);

        if (got_src) {
            if (src->vtable->base_type != enum_class_NameSpace) {
                real_exception(interp, NULL, 0,
                        "source must be a NameSpace PMC");
                return;
            }

            exp->ns_src = src;
        }
        else {
            PMC *tmp_ns_src;
            tmp_ns_src = exp->ns_src;
            PCCRETURN(PMC *tmp_ns_src);
        }
    }


/*

=item C<PCCMETHOD void
    destination(PMC *dest :optional, int got_dest :opt_flag)>

Accessor for the destination NameSpace object (C<ns_dest>.)
Sets the value if C<dest> is passed, otherwise returns the value.
Throws an exception if a non-NameSpace PMC is passed.

=cut

*/

    PCCMETHOD void destination(PMC *dest :optional, int got_dest :opt_flag) {
        Parrot_Exporter *exp = PARROT_EXPORTER(SELF);

        if (got_dest) {
            if (dest->vtable->base_type != enum_class_NameSpace) {
                real_exception(interp, NULL, 0,
                        "destination must be a NameSpace PMC");
                return;
            }
            exp->ns_dest = dest;
        }
        else {
            PMC *tmp_ns_dest;
            tmp_ns_dest = exp->ns_dest;
            PCCRETURN(PMC *tmp_ns_dest);
        }
    }


/*

=item C<PCCMETHOD void
    globals(PMC *glb :optional, int got_glb :opt_flag)>

Accessor for the array of globals to export (C<globals>.)
Sets the array if C<glb> is passed, otherwise returns the value.
If C<glb> is a String, it is split on ascii whitespace.
If C<glb> is a FixedStringArray, it is cloned and set.

=cut

*/

    PCCMETHOD void globals(PMC *glb :optional, int got_glb :opt_flag) {
        Parrot_Exporter *exp = PARROT_EXPORTER(SELF);
        PMC *ret_globals;
        STRING *s_str = CONST_STRING(interp, "String");
        STRING *s_arr = CONST_STRING(interp, "array");

        if (got_glb) {
            if (PMC_IS_NULL(glb))
                exp->globals = PMCNULL;
            else if (VTABLE_isa(interp, glb, s_str))
                exp->globals = string_split(interp,
                        CONST_STRING(interp, " "),
                        VTABLE_get_string(interp, glb));
            else if (VTABLE_does(interp, glb, s_arr))
                exp->globals = VTABLE_clone(interp, glb);
            else
                 real_exception(interp, NULL, 0,
                     "Invalid type %d in globals()", glb->vtable->base_type);
         }
         else {
            if (PMC_IS_NULL(exp->globals)) {
                PCCRETURN(PMC *PMCNULL);
            }
            else {
                ret_globals = VTABLE_clone(interp, exp->globals);
                PCCRETURN(PMC *ret_globals);
            }
        }
    }


/*

=item C<PCCMETHOD void
    add_global(PMC *global :optional, int has_global :opt_flag)>

Add C<global> to the array of globals (C<globals>.)
Sets the array if C<global> is passed, otherwise does nothing.

=cut

*/

    PCCMETHOD void add_global(PMC *global :optional, int has_global :opt_flag) {
        Parrot_Exporter *exp = PARROT_EXPORTER(SELF);
        if (has_global) {
            if (PMC_IS_NULL(exp->globals))
                exp->globals = pmc_new(interp, enum_class_ResizableStringArray);

            VTABLE_push_string(interp, exp->globals,
                    VTABLE_get_string(interp, global));
        }
    }


/*

=item C<PCCMETHOD void
    import(PMC *dest :optional :named["destination"], int got_dest :opt_flag,
        PMC *src :optional :named["source"],      int got_src :opt_flag,
        PMC *globals :optional :named["globals"], int got_globals :opt_flag)>

Import C<globals> from the C<src> namespace to the C<dest> namespace.
If C<src>, C<dest>, or C<globals> are passed, they will override
the current value.
C<import> follows the semantics of the C<export_to> method
of the C<NameSpace> PMC. in particular, if a NULL value is passed
for C<globals>, the default set of items will be imported.
Throws an exception upon error.

=cut

*/

    PCCMETHOD void import(PMC *dest :optional :named["destination"], int got_dest :opt_flag,
            PMC *src :optional :named["source"], int got_src :opt_flag,
            PMC *globals :optional :named["globals"], int got_globals :opt_flag) {

        Parrot_Exporter *exp = PARROT_EXPORTER(SELF);
        PMC *ns_src, *ns_dest, *ns_globals;

        if (got_src)
            PCCINVOKE(interp, SELF, "source", PMC *src);
        if (got_dest)
            PCCINVOKE(interp, SELF, "destination", PMC *dest);
        if (got_globals)
            PCCINVOKE(interp, SELF, "globals", PMC *globals);

        if (PMC_IS_NULL(exp->ns_src)) {
            real_exception(interp, NULL, 0, "source namespace not set");
            return;
        }
        if (PMC_IS_NULL(exp->ns_dest)) {
            real_exception(interp, NULL, 0, "destination namespace not set");
            return;
        }

        ns_src     = exp->ns_src;
        ns_dest    = exp->ns_dest;
        ns_globals = exp->globals;

        PCCINVOKE(interp, ns_src, "export_to", PMC *ns_dest, PMC *ns_globals);
    }


} /* end pmclass Exporter */

/*

=back

=head1 STABILITY

Unstable. This PMC is under active development; major portions of the
interface have not yet been completed.

=head1 SEE ALSO

F<docs/pdds/pdd17_basic_types.pod>, F<docs/pdds/pdd21_namespaces.pod>.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
