/*
Copyright (C) 2007, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/exporter.pmc - Export globals from one namespace to another

=head1 SYNOPSIS

You can use Exporter in PIR to import subs from a library. At its simplest:

 .sub main :main
     load_bytecode 'Test/More.pir'
     .local pmc exporter, test_ns
     test_ns = get_namespace ['Test::More']
     exporter = new 'Exporter'
     exporter.'import'( test_ns :named('source'), 'plan ok' :named('globals') )
     plan(1)
     ok(1, 'exporter has imported the requested functions')
 .end

Fancier options exist which allow you to import to an alternate namespace,
or export globals so they can be called using a different name. See
F<t/pmc/exporter.t> for examples.

=head1 DESCRIPTION

Exports globals from one namespace to another. Exporter always uses
the typed namespace interface, as outlined in
F<docs/pdds/pdd21_namespaces.pod>.

Exporter is not derived from any other PMC, and does not provide any
vtable interface--its interface consists solely of non-vtable methods.

=head2 Structure

The Exporter PMC structure (C<Parrot_Exporter>) consists of three items:

=over 4

=item C<ns_src>

The source namespace -- a NameSpace PMC.
A Null PMC is allocated during initialization.

=item C<ns_dest>

The destination namespace -- a NameSpace PMC.
A PMC representing the current namespace is allocated upon initialization.

=item C<globals>

The globals to export -- a PMC that implements the hash interface, or Null.
A Null PMC is allocated during initialization.

=cut

*/

#include "parrot/parrot.h"
#define PARROT_EXPORTER(e) ((Parrot_Exporter *) PMC_data(e))

typedef struct Parrot_Exporter {
    PMC *ns_src;
    PMC *ns_dest;
    PMC *globals;
} Parrot_Exporter;


/*

=back

=head2 Functions

=over 4

=cut

*/

pmclass Exporter
    need_ext {


/*

=item C<void init()>

Initializes an Exporter PMC.

=cut

*/

    void init() {
        Parrot_Exporter *exp = NULL;

        /* Set up the object. */
        exp            = mem_allocate_zeroed_typed(Parrot_Exporter);
        exp->ns_src    = PMCNULL;
        exp->ns_dest   = CONTEXT(interp->ctx)->current_namespace;
        exp->globals   = PMCNULL;
        PMC_data(SELF) = exp;

        /* Set flags for custom DOD mark and destroy. */
        PObj_custom_mark_SET(SELF);
        PObj_active_destroy_SET(SELF);
    }


/*

=item C<void destroy()>

Free the memory associated with the object's underlying struct.

=cut

*/

    void destroy() {
            mem_sys_free(PMC_data(SELF));
    }


/*

=item C<void mark()>

Mark referenced strings and PMCs in the structure as live.

=cut

*/

    void mark() {
        Parrot_Exporter *exp = PARROT_EXPORTER(SELF);
        if (exp->ns_src)
            pobject_lives(interp, (PObj*)exp->ns_src);
        if (exp->ns_dest)
            pobject_lives(interp, (PObj*)exp->ns_dest);
        if (exp->globals)
            pobject_lives(interp, (PObj*)exp->globals);
    }


/*

=back

=head2 Methods

=over 4

=item C<PCCMETHOD void
    source(PMC *src :optional, int got_src :opt_flag)>

Accessor for the source NameSpace object (C<ns_src>.)
Sets the value if C<src> is passed, otherwise returns the value.
Throws an exception if a non-NameSpace PMC is passed.

=cut

*/

    PCCMETHOD void source(PMC *src :optional, int got_src :opt_flag) {
        Parrot_Exporter *exp = PARROT_EXPORTER(SELF);

        if (got_src) {
            if (src->vtable->base_type != enum_class_NameSpace) {
                real_exception(interp, NULL, 0,
                        "source must be a NameSpace PMC");
                PCCRETURN();
            }
            exp->ns_src = src;
        }
        else {
            PMC *tmp_ns_src;
            tmp_ns_src = exp->ns_src;
            PCCRETURN(PMC *tmp_ns_src);
        }
    }


/*

=item C<PCCMETHOD void
    destination(PMC *dest :optional, int got_dest :opt_flag)>

Accessor for the destination NameSpace object (C<ns_dest>.)
Sets the value if C<dest> is passed, otherwise returns the value.
Throws an exception if a non-NameSpace PMC is passed.

=cut

*/

    PCCMETHOD void destination(PMC *dest :optional, int got_dest :opt_flag) {
        Parrot_Exporter *exp = PARROT_EXPORTER(SELF);

        if (got_dest) {
            if (dest->vtable->base_type != enum_class_NameSpace) {
                real_exception(interp, NULL, 0,
                        "destination must be a NameSpace PMC");
                PCCRETURN();
            }
            exp->ns_dest = dest;
        }
        else {
            PMC *tmp_ns_dest;
            tmp_ns_dest = exp->ns_dest;
            PCCRETURN(PMC *tmp_ns_dest);
        }
    }


/*

=item C<PCCMETHOD void
    globals(PMC *glb :optional, int got_glb :opt_flag)>

Accessor for the globals to export (C<globals>.)
Sets the value if C<glb> is passed, otherwise returns the value.
If C<glb> is a String, it is split on ascii whitespace, and each array member
is added as a hash key.
If C<glb> implements the array interface, each member is added as a hash key.
if C<glb> implements the hash interface, it is assigned to Exporter's
C<globals> attribute.
Throws an exception if an unknown PMC type is passed.

=cut

*/

    PCCMETHOD void globals(PMC *glb :optional, int got_glb :opt_flag) {
        Parrot_Exporter *exp    = PARROT_EXPORTER(SELF);
        STRING          *s_str  = CONST_STRING(interp, "String");
        STRING          *s_arr  = CONST_STRING(interp, "array");
        STRING          *s_hash = CONST_STRING(interp, "hash");

        if (got_glb) {
            STRING * const s_empty      = CONST_STRING(interp, "");
            PMC           *temp_globals = pmc_new(interp, enum_class_Hash);

            if (PMC_IS_NULL(glb)) {
                temp_globals = PMCNULL;
            }
            else if (VTABLE_isa(interp, glb, s_str) || (VTABLE_does(interp, glb, s_arr))) {
                PMC    *glb_array;
                INTVAL n, i;

                if (VTABLE_isa(interp, glb, s_str))
                    glb_array = string_split(interp,
                            CONST_STRING(interp, " "),
                            VTABLE_get_string(interp, glb));
                else
                    glb_array = glb;

                n = VTABLE_elements(interp, glb_array);

                if (n == 0)
                    temp_globals = PMCNULL;

                for(i = 0; i < n; i++) {
                    STRING * const item = VTABLE_get_string_keyed_int(interp, glb_array, i);
                    VTABLE_set_string_keyed_str(interp, temp_globals, item, s_empty);
                }
            }
            else if (VTABLE_does(interp, glb, s_hash)) {
                if (VTABLE_elements(interp, glb) == 0)
                    temp_globals = PMCNULL;
                else
                    temp_globals = glb;
            }
            else {
                real_exception(interp, NULL, 0,
                    "Invalid type %d in globals()", glb->vtable->base_type);
                PCCRETURN();
            }

            exp->globals = temp_globals;
         }
         else {
            if (PMC_IS_NULL(exp->globals)) {
                PCCRETURN(PMC *PMCNULL);
            }
            else {
                PMC *tmp_globals;
                tmp_globals = exp->globals;
                PCCRETURN(PMC *tmp_globals);
            }
        }
    }


/*

=item C<PCCMETHOD void
    import(PMC *dest :optional :named["destination"], int got_dest :opt_flag,
        PMC *src     :optional :named["source"],  int got_src :opt_flag,
        PMC *globals :optional :named["globals"], int got_globals :opt_flag)>

Import C<globals> from the C<src> namespace to the C<dest> namespace.
If C<src>, C<dest>, or C<globals> are passed, they override the current value.
C<import> follows the semantics of the C<export_to> method
of the C<NameSpace> PMC. in particular, if a NULL value is passed
for C<globals>, the default set of items will be imported.
Throws an exception upon error.

=cut

*/

    PCCMETHOD void import(PMC *dest :optional :named["destination"], int got_dest :opt_flag,
            PMC *src     :optional :named["source"],  int got_src :opt_flag,
            PMC *globals :optional :named["globals"], int got_globals :opt_flag) {

        Parrot_Exporter *exp = PARROT_EXPORTER(SELF);
        PMC *ns_src, *ns_dest, *ns_globals;

        if (got_src)
            PCCINVOKE(interp, SELF, "source", PMC *src);
        if (got_dest)
            PCCINVOKE(interp, SELF, "destination", PMC *dest);
        if (got_globals)
            PCCINVOKE(interp, SELF, "globals", PMC *globals);

        if (PMC_IS_NULL(exp->ns_src)) {
            real_exception(interp, NULL, 0, "source namespace not set");
            PCCRETURN();
        }
        if (PMC_IS_NULL(exp->ns_dest)) {
            real_exception(interp, NULL, 0, "destination namespace not set");
            PCCRETURN();
        }

        ns_src     = exp->ns_src;
        ns_dest    = exp->ns_dest;
        ns_globals = exp->globals;

        PCCINVOKE(interp, ns_src, "export_to", PMC *ns_dest, PMC *ns_globals);
    }


} /* end pmclass Exporter */

/*

=back

=head1 STABILITY

Unstable. This PMC is under active development; major portions of the
interface have not yet been completed.

=head1 SEE ALSO

F<docs/pdds/pdd17_basic_types.pod>, F<docs/pdds/pdd21_namespaces.pod>.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
