/*
Copyright (C) 2001-2007, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/class.pmc - defines a class

=head1 DESCRIPTION

This class implements the Class PMC, as outlined in
F<docs/pdds/pdd15_objects.pod>.

Class is not derived from any other PMC.

=head2 Structure

The Role PMC structure (C<Parrot_Role>) consists of five items:

=over 4

=item C<name>

The name of the class -- a STRING.
An empty STRING is allocated during initialization.

=item C<namespace>

The namespace the class is associated with, if any.
A Null PMC is allocated during initialization.

=item C<instantiated>

A flag denoting whether this class has been instantiated since last modification.
A native integer with value zero is allocated during initialization.

=item C<parents>

An array of immediate parent classes.
An empty ResizablePMCArray PMC is allocated during initialization.

=item C<all_parents>

A cached array of ourself and all parent classes, in MRO order.
A ResizablePMCArray PMC is allocated during initialization,
and is populated with the current class.

=item C<roles>

An array of the roles this class has been composed from.
An empty ResizablePMCArray PMC is allocated during initialization.

=item C<methods>

A directory of method names and method bodies this class provides.
An empty Hash PMC is allocated during initialization.

=item C<vtable_overrides>

A directory of vtable method names and method bodies this class overrides.
An empty Hash PMC is allocated during initialization.

=item C<attrib_metadata>

A directory of attribute names and attribute metadata this class contains.
An empty Hash PMC is allocated during initialization.

=item C<attrib_index>

A lookup table for attributes in this class and parents.
A Null PMC is allocated during initialization.

=item C<attrib_cache>

A cache of visible attribute names to attribute indexes.
A Null PMC is allocated during initialization.

=item C<resolve_method>

A list of method names the class provides used for name conflict resolution.
An empty ResizablePMCArray PMC is allocated during initialization.

=cut

*/

#define PARROT_IN_OBJECTS_C /* To get the vtable.h imports we want. */
#include "parrot/parrot.h"
#include "parrot/oo_private.h"
#include "pmc_namespace.h"

/* This function builds the attribute index (table to map class name and
 * attribute name to an index) for the current class. */
static void
build_attrib_index(PARROT_INTERP, PMC *self)
{
    Parrot_Class * const _class      = PARROT_CLASS(self);
    int                  cur_index   = 0;
    PMC * const          table       = pmc_new(interp, enum_class_Hash);
    const int            num_classes =
        VTABLE_elements(interp, _class->all_parents);
    int                  i;

    /* We will go over the list of all parents to construct the table. */
    for (i = 0; i < num_classes; i++) {
       /* Get the class and check that it respects the standard class interface
        * (if not we don't know how it stores its attributes, so we'll have to
        * delegate the lookup). */
        PMC *cur_class = VTABLE_get_pmc_keyed_int(interp, _class->all_parents,
            i);

        if (PObj_is_class_TEST(cur_class)) {
            /* The attribute metadata hash. */
            Parrot_Class *class_info = PARROT_CLASS(cur_class);
            PMC          *attribs    = class_info->attrib_metadata;
            PMC          *iter       = VTABLE_get_iter(interp, attribs);

            /* Build a string representing the fully qualified class name. */
            /* Retrieve the fully qualified class name for the class. */
            STRING *fq_class         = VTABLE_get_string(interp, cur_class);

            /* Iterate over the attributes. */
            while (VTABLE_get_bool(interp, iter)) {
                /* Get attribute. */
                PMC    *cur_attrib  = VTABLE_get_pmc_keyed_str(interp, attribs,
                    VTABLE_shift_string(interp, iter));
                STRING *full_key    = string_copy(interp, fq_class);

                /* Get attribute name and append it to the key. */
                STRING *attrib_name = VTABLE_get_string_keyed_str(
                    interp, cur_attrib, string_from_literal(interp, "name"));

                full_key = string_append(interp, full_key, attrib_name);

                /* Insert into hash, along with index. */
                VTABLE_set_integer_keyed_str(interp, table, full_key, cur_index);
                cur_index++;
            }
        }
    }

    /* Store built table and invalidate cache. */
    _class->attrib_index = table;
    _class->attrib_cache = pmc_new(interp, enum_class_Hash);
}

/*
 * This function throws an exception if a PMC or class with the same name
 * already exists in the global type registry. The global type registry will go
 * away eventually, but this allows the new object metamodel to interact with
 * the old one until it does.
 */

static void
fail_if_type_exists(PARROT_INTERP, PMC *name)
{
    INTVAL      type;

    PMC * const classname_hash = interp->class_hash;
    PMC * const type_pmc       = (PMC *)VTABLE_get_pointer_keyed(interp,
                                        classname_hash, name);
    if (PMC_IS_NULL(type_pmc) ||
            type_pmc->vtable->base_type == enum_class_NameSpace)
        type = 0;
    else
        type = VTABLE_get_integer(interp, type_pmc);

    if (type > enum_type_undef) {
        /* RT#46091 get printable name */
        real_exception(interp, NULL, INVALID_OPERATION,
                "Class %Ss already registered!\n",
                VTABLE_get_string(interp, name));
    }

    if (type < enum_type_undef)
        real_exception(interp, NULL, INVALID_OPERATION,
                "native type with name '%s' already exists - "
                "can't register Class", data_types[type].name);
}

/* This function registers a type in the global registry, first checking if it
 * already exists. The global type registry will go away eventually, but this
 * allows the new object metamodel to interact with the old one until it does.
 */
static INTVAL
register_type(PARROT_INTERP, PMC *name) {
    INTVAL  type;
    PMC    *classname_hash, *item;

    if (PMC_IS_NULL(name))
        real_exception(interp, NULL, INVALID_OPERATION,
                "Can't register type without a name!\n");

    /* First check if the type already exists */
    fail_if_type_exists(interp, name);

    /* Type doesn't exist, so go ahead and register it. Lock interpreter so
     * pt_shared_fixup() can safely do a type lookup. */
    LOCK_INTERPRETER(interp);
    classname_hash = interp->class_hash;
    type           = interp->n_vtable_max++;

    /* Have we overflowed the table? */
    if (type >= interp->n_vtable_alloced)
        parrot_realloc_vtables(interp);

    /* set entry in name->type hash */
    item              = pmc_new(interp, enum_class_Integer);
    PMC_int_val(item) = type;
    VTABLE_set_pmc_keyed(interp, classname_hash, name, item);

    UNLOCK_INTERPRETER(interp);

    return type;
}


/* Takes a hash and initializes the class based on it. */
static void
init_class_from_hash(PARROT_INTERP, PMC *self, PMC *info)
{
    Parrot_Class *_class      = PARROT_CLASS(self);
    STRING       *name_str    = string_from_literal(interp, "name");
    STRING       *parents_str = string_from_literal(interp, "parents");
    STRING       *methods_str = string_from_literal(interp, "methods");
    STRING       *roles_str   = string_from_literal(interp, "roles");
    STRING       *attrs_str   = string_from_literal(interp, "attributes");
    PMC          *old_ns;
    INTVAL        i, type_num;

    /* Ensure we actually have some initialization info. */
    if (PMC_IS_NULL(info))
        return;

    /* Take a copy of the current namespace the class is attached to. */
    old_ns = _class->_namespace;

    /* Check if we have a name/namespace. */
    if (VTABLE_exists_keyed_str(interp, info, name_str)) {

        STRING *new_name;
        PMC    *new_namespace;
        PMC    *name_arg = VTABLE_get_pmc_keyed_str(interp, info, name_str);
        VTABLE *new_vtable;

        /* If we were passed a namespace PMC, set the namespace attribute
         * directly. Otherwise, lookup or create the appropriate namespace. */
        if (name_arg->vtable->base_type == enum_class_NameSpace) {
            new_namespace = name_arg;
            name_arg = Parrot_NameSpace_nci_get_name(interp, new_namespace);
        }
        else {
            PMC *hll_ns = VTABLE_get_pmc_keyed_int(interp,
                    interp->HLL_namespace, CONTEXT(interp->ctx)->current_HLL);
            new_namespace = Parrot_make_namespace_keyed(interp, hll_ns, name_arg);
        }

        if (PMC_IS_NULL(new_namespace))
            real_exception(interp, NULL, INVALID_OPERATION,
                "Failed to set namespace for class.");

        /* Set the name of the class to the name of the innermost namespace
         * associated with the class.
         */
        new_name = VTABLE_get_string(interp, new_namespace);

        if (STRING_IS_NULL(new_name) || STRING_IS_EMPTY(new_name))
              real_exception(interp, NULL, INVALID_OPERATION,
                "Failed to set name for class.");

        _class->_namespace = new_namespace;
        _class->name       = new_name;

        /* At this point we know the class isn't anonymous */
        CLASS_is_anon_CLEAR(self);

        /* Register a type number for the class. */
        type_num = register_type(interp, name_arg);

        /* Link the type number with the class's vtable. */
        new_vtable = Parrot_clone_vtable(interp, self->vtable);
        new_vtable->base_type     = type_num;
        new_vtable->pmc_class     = self;
        new_vtable->whoami        = VTABLE_get_string(interp, self);
        new_vtable->mro           = _class->all_parents;
        _class->id                = type_num;

        /* Store the class's vtable in the global table */
        interp->vtables[type_num] = new_vtable;
    }

    /* If we were attached to a namespace and are now attached to a new one,
     * need to unset ourselves in the old namespace. */
    if (!PMC_IS_NULL(old_ns) && _class->_namespace != old_ns)
        Parrot_PCCINVOKE(interp, old_ns,
            string_from_literal(interp, "set_class"), "P->", PMCNULL);

    /* Link namespace to this class, if there is one. */
    if (!PMC_IS_NULL(_class->_namespace))
        Parrot_PCCINVOKE(interp, _class->_namespace,
            string_from_literal(interp, "set_class"), "P->", self);

    /* Initialize resolve_method. */
    if (VTABLE_exists_keyed_str(interp, info,
        string_from_literal(interp, "resolve_method"))) {
        /* Set it. */
        _class->resolve_method = VTABLE_get_pmc_keyed_str(interp, info,
            string_from_literal(interp, "resolve_method"));
    }

    /* Initialize parents, if we have any. */
    if (VTABLE_exists_keyed_str(interp, info, parents_str)) {
        /* Loop over parents array and add them. */
        PMC * const parent_list = VTABLE_get_pmc_keyed_str(interp, info,
            parents_str);
        const int  parent_count = VTABLE_elements(interp, parent_list);

        for (i = 0; i < parent_count; i++)
            VTABLE_add_parent(interp, self,
                VTABLE_get_pmc_keyed_int(interp, parent_list, i));
    }

    /* Initialize roles, if we have any. */
    if (VTABLE_exists_keyed_str(interp, info, roles_str)) {
        /* Loop over roles array and compose them. */
        PMC * const role_list  = VTABLE_get_pmc_keyed_str(interp, info,
            roles_str);
        const int   role_count = VTABLE_elements(interp, role_list);

        for (i = 0; i < role_count; i++)
            VTABLE_add_role(interp, self,
                VTABLE_get_pmc_keyed_int(interp, role_list, i));
    }

    /* Initialize attributes, if we have any. */
    if (VTABLE_exists_keyed_str(interp, info, attrs_str)) {
        /* Loop over attributes array and add them. */
        PMC * const attrs_name_list = VTABLE_get_pmc_keyed_str(interp, info,
            attrs_str);
        const int   attrib_count    = VTABLE_elements(interp, attrs_name_list);

        for (i = 0; i < attrib_count; i++) {
            STRING * const attr_name = VTABLE_get_string_keyed_int(interp,
                attrs_name_list, i);
            VTABLE_add_attribute(interp, self, attr_name, PMCNULL);
        }
    }

    /* Initialize methods. */
    if (VTABLE_exists_keyed_str(interp, info, methods_str)) {
        /* Get the methods hash. */
        PMC * const methods = VTABLE_get_pmc_keyed_str(interp, info,
            methods_str);

        /* Iterate over the list of methods. */
        PMC * const iter    = VTABLE_get_iter(interp, methods);

        while (VTABLE_get_bool(interp, iter)) {
            /* Add the method. */
            STRING * const method_name = VTABLE_shift_string(interp, iter);
            PMC    * const method_pmc  = VTABLE_get_pmc_keyed_str(interp,
                methods, method_name);
            VTABLE_add_method(interp, self, method_name, method_pmc);
        }
    }

    /* Extract any methods from the namespace */
    Parrot_oo_extract_methods_from_namespace(interp, self);
}

static void
initialize_parents(PARROT_INTERP, PMC *object, PMC *all_parents)
{
    INTVAL  parent_index = VTABLE_elements(interp, all_parents) - 1;
    STRING *name         = string_from_literal(interp, "init");

    /* Loop through the parents in reverse MRO order. */
    for (; parent_index >= 0; parent_index--) {
        PMC *meth;
        PMC * const parent = VTABLE_get_pmc_keyed_int(interp,
            all_parents, parent_index);

        /* PMCProxy parents store an instance to delegate to */
        if (parent->vtable->base_type == enum_class_PMCProxy) {
            PMC * proxy = VTABLE_instantiate(interp, parent, PMCNULL);
            VTABLE_set_attr_keyed(interp, object, parent,
                    string_from_literal(interp, "proxy"), proxy);
        }

        meth = Parrot_oo_find_vtable_override_for_class(interp, parent, name);
        if (!PMC_IS_NULL(meth)) {
            Parrot_run_meth_fromc_args(interp, meth,
                    object, name, "v");
        }
    }
}

static void
initialize_parents_pmc(PARROT_INTERP, PMC *object, PMC *all_parents, PMC *init)
{
    INTVAL  parent_index = VTABLE_elements(interp, all_parents) - 1;
    STRING *name         = string_from_literal(interp, "init_pmc");

    /* Loop through the parents in reverse MRO order. */
    for (; parent_index >= 0; parent_index--) {
        PMC *meth;
        PMC * const parent = VTABLE_get_pmc_keyed_int(interp,
            all_parents, parent_index);

        /* PMCProxy parents store an instance to delegate to */
        if (parent->vtable->base_type == enum_class_PMCProxy) {
            PMC * proxy = VTABLE_instantiate(interp, parent, init);
            VTABLE_set_attr_keyed(interp, object, parent,
                    string_from_literal(interp, "proxy"), proxy);
        }

        meth = Parrot_oo_find_vtable_override_for_class(interp, parent, name);
        if (!PMC_IS_NULL(meth)) {
            Parrot_run_meth_fromc_args(interp, meth,
                    object, name, "vP", init);
        }
    }
}


/*

=back

=head2 Functions

=over 4

=cut

*/

pmclass Class
    need_ext {


/*

=item C<void init()>

Initializes a Class PMC.

=item C<void init_pmc(PMC *init_data)>

The actual class creation code, called from C<newclass> opcode.  The C<init>
argument may either be the name of the class, or a hash of initialization
arguments.  The class is attatched to the current HLL namespace.

=cut

*/

    void init() {
        Parrot_Class *_class    = mem_allocate_zeroed_typed(Parrot_Class);

        /* Set flags for custom DOD mark and destroy. */
        PObj_custom_mark_SET(SELF);
        PObj_active_destroy_SET(SELF);

        /* Set up the object. */
        PMC_data(SELF)          = _class;
        _class->id              = 0;
        _class->name            = CONST_STRING(interp, "");
        _class->_namespace      = PMCNULL;
        _class->instantiated    = 0;
        _class->parents         = pmc_new(interp, enum_class_ResizablePMCArray);
        _class->all_parents     = pmc_new(interp, enum_class_ResizablePMCArray);
        _class->roles           = pmc_new(interp, enum_class_ResizablePMCArray);
        _class->methods         = pmc_new(interp, enum_class_Hash);
        _class->vtable_overrides  = pmc_new(interp, enum_class_Hash);
        _class->attrib_metadata = pmc_new(interp, enum_class_Hash);
        _class->attrib_index    = PMCNULL;
        _class->attrib_cache    = PMCNULL;
        _class->vtable_cache    = PMCNULL; /* only used for STM */
        _class->resolve_method  = pmc_new(interp, enum_class_ResizablePMCArray);

        /* We put ourself on the all parents list. */
        VTABLE_push_pmc(interp, _class->all_parents, SELF);

        /* We are a class. */
        PObj_is_class_SET(SELF);

        /* By default we're anonymous. */
        CLASS_is_anon_SET(SELF);
    }

    void init_pmc(PMC *init_data) {
        PMC           *arg;
        const INTVAL   arg_type = VTABLE_type(interp, init_data);
        STRING * const name_str = CONST_STRING(interp, "name");

        /* Set up the object. */
        SELF.init();

        /* fast attempt to determine init_data type */
        switch (arg_type) {
            case enum_class_String:
            case enum_class_Key:
            case enum_class_NameSpace:
            case enum_class_ResizableStringArray:
                arg = pmc_new(interp, enum_class_Hash);
                VTABLE_set_pmc_keyed_str(interp, arg, name_str, init_data);
                break;

            case enum_class_Hash:
                arg = init_data;
                break;

            /* slow attempt to determine init_data type */
            default:
                if (VTABLE_isa(interp, init_data, CONST_STRING(interp, "String"))
                 || VTABLE_isa(interp, init_data, CONST_STRING(interp, "Key"))
                 || VTABLE_isa(interp, init_data, CONST_STRING(interp, "ResizableStringArray"))) {
                    arg = pmc_new(interp, enum_class_Hash);
                    VTABLE_set_pmc_keyed_str(interp, arg, name_str, init_data);
                }

                if (VTABLE_isa(interp, init_data, CONST_STRING(interp, "Hash"))) {
                    arg = init_data;
                }
                else {
                    real_exception(INTERP, NULL, E_NameError,
                            "Invalid class name key in init_pmc for Class");
                }
                break;
        }

        /* Initialize the class with the supplied data. */
        init_class_from_hash(interp, SELF, arg);
    }

/*

=item C<PMC *subclass(PMC *name)>

Creates a subclass, optionally with a given C<name>.

=cut

*/

    PMC *subclass(PMC *name) {
        PMC *child_class;

        /* Create a new class. Set the classname, if we have one. */
        if (PMC_IS_NULL(name)) {
            child_class = pmc_new(interp, enum_class_Class);
        }
        else {
            PMC *naming_hash = pmc_new(interp, enum_class_Hash);
            VTABLE_set_pmc_keyed_str(interp, naming_hash, CONST_STRING(interp, "name"), name);
            child_class      = pmc_new_init(interp, enum_class_Class,
                naming_hash);
        }

        /* Make the new class a subclass of the current class */
        VTABLE_add_parent(interp, child_class, SELF);

        return child_class;
    }

/*

/*

=item C<void destroy()>

Free the memory associated with the object's underlying struct.

=cut

*/

    void destroy() {
        mem_sys_free(PMC_data(SELF));
    }

/*

=item C<STRING *get_string()>

Return the name of the class (without the HLL namespace).

=cut

*/

    STRING *get_string() {
        Parrot_Class * const  _class    = PARROT_CLASS(SELF);
        PMC                  *_namespace = _class->_namespace;
        PMC                  *names;

        if (!PMC_IS_NULL(_namespace)) {
            /* Call the 'get_name' method on the class's associated namespace
             * to retrieve a fully qualified list of names, then join the list
             * with a semicolon.
             */
            names = Parrot_NameSpace_nci_get_name(interp, _namespace);

            if (!PMC_IS_NULL(names))
                /* remove the HLL namespace name */
                VTABLE_shift_string(INTERP, names);
                return string_join(interp, CONST_STRING(interp, ";"), names);
        }

        /* Otherwise, copy the stored string name of the class. */
        return string_copy(interp, _class->name);
    }

/*

=item C<void mark()>

Mark any referenced strings and PMCs in the structure as live.

=cut

*/

    void mark() {
        Parrot_Class * const _class = PARROT_CLASS(SELF);
        if (_class->name)
            pobject_lives(interp, (PObj*)_class->name);
        if (_class->_namespace)
            pobject_lives(interp, (PObj*)_class->_namespace);
        if (_class->parents)
            pobject_lives(interp, (PObj*)_class->parents);
        if (_class->all_parents)
            pobject_lives(interp, (PObj*)_class->all_parents);
        if (_class->roles)
            pobject_lives(interp, (PObj*)_class->roles);
        if (_class->methods)
            pobject_lives(interp, (PObj*)_class->methods);
        if (_class->vtable_overrides)
            pobject_lives(interp, (PObj*)_class->vtable_overrides);
        if (_class->attrib_metadata)
            pobject_lives(interp, (PObj*)_class->attrib_metadata);
        if (_class->attrib_index)
            pobject_lives(interp, (PObj*)_class->attrib_index);
        if (_class->attrib_cache)
            pobject_lives(interp, (PObj*)_class->attrib_cache);
        if (_class->resolve_method)
            pobject_lives(interp, (PObj*)_class->resolve_method);
    }


/*

=item C<void add_attribute(STRING *name, PMC *type)>

Adds the given attribute (C<name>) with an optional C<type>.
Creates a new class if the current class has been instantiated.
Enters the attribute in the C<attributes> array.
Returns an error if an attribute of C<name> already exists.

=cut

*/

    void add_attribute(STRING *name, PMC *type) {
        Parrot_Class * const _class        = PARROT_CLASS(SELF);
        PMC          * const new_attribute = pmc_new(interp, enum_class_Hash);

        /* If we've been instantiated already, need a new class. */
        if (_class->instantiated) {
            /* RT#46093 Unimplemented! */
            real_exception(interp, NULL, E_NotImplementedError,
                "Modifications to already instantiated classes not allowed yet.");
        }

        /* If we already have an attribute of this name, it's an error. */
        if (VTABLE_exists_keyed_str(interp, _class->attrib_metadata, name))
            real_exception(interp, NULL, INVALID_OPERATION,
                "Attribute '%Ss' already exists.", name);

        /* Set name and type. */
        VTABLE_set_string_keyed_str(interp, new_attribute, CONST_STRING(interp, "name"), name);

        if (!PMC_IS_NULL(type))
            VTABLE_set_pmc_keyed_str(interp, new_attribute, CONST_STRING(interp, "type"), type);

        /* Enter the attribute in the attributes array. */
        VTABLE_set_pmc_keyed_str(interp, _class->attrib_metadata, name,
            new_attribute);
    }

/*

=item C<void add_method(STRING *name, PMC *sub)>

Adds the given sub PMC as a method with the given name.

=cut

*/
    void add_method(STRING *name, PMC *sub) {
        Parrot_Class * const _class = PARROT_CLASS(SELF);

        /* If we have already added a method with this name... */
        if (VTABLE_exists_keyed_str(interp, _class->methods, name)) {
            /* RT46095 Need to handle multi methods here. */
            real_exception(interp, NULL, INVALID_OPERATION,
                "A method named '%S' already exists in class '%S'. "
                "It may have been supplied by a role.",
                name, VTABLE_get_string(interp, SELF));
        }

        /* Enter it into the table. */
        VTABLE_set_pmc_keyed_str(interp, _class->methods, name, sub);
    }

/*

=item C<void add_vtable_override(STRING *name, PMC *sub)>

Adds the given sub PMC as a vtable override with the given name.

=cut

*/
    void add_vtable_override(STRING *name, PMC *sub) {
        Parrot_Class * const _class = PARROT_CLASS(SELF);

        /* If we have already added a vtable override with this name... */
        if (VTABLE_exists_keyed_str(interp, _class->vtable_overrides, name))
            real_exception(interp, NULL, INVALID_OPERATION,
                "A vtable override named '%S' already exists in class '%S'. "
                "It may have been supplied by a role.",
                name, VTABLE_get_string(interp, SELF));

        /* Check that the name is actually valid as a vtable override */
        if (Parrot_get_vtable_index(interp, name) == -1)
            real_exception(interp, NULL, METH_NOT_FOUND,
                "'%S' is not a valid vtable function name.", name);

        /* Add it to vtable methods list. */
        VTABLE_set_pmc_keyed_str(interp, _class->vtable_overrides, name, sub);
    }

/*

=item C<void add_parent(PMC *parent)>

Adds the supplied PMC to the list of parents for the class.

=cut

*/
    void add_parent(PMC *parent) {
        Parrot_Class * const _class = PARROT_CLASS(SELF);
        /* get name of the parent being added */
        STRING *parent_name  = VTABLE_get_string(interp, parent);
        /* get number of direct parents */
        int parent_count = VTABLE_elements(interp, _class->parents);
        int index; /* loop iterator */

        /* If we've been instantiated already, need a new class. */
        if (_class->instantiated) {
            /* RT46097 Unimplemented! */
            real_exception(interp, NULL, E_NotImplementedError,
                "Modifications to already instantiated classes not allowed yet.");
            return;
        }

        /* Ensure it really is a class. */
        if (!PObj_is_class_TEST(parent)) {
            real_exception(interp, NULL, E_TypeError, "Parent isn't a Class.");
            return;
        }

        /* RT46099 Check we don't already have this parent. */

        /* iterate over all direct parents, check whether this class already has
         * the parent being added.
         */
        for (index = 0; index < parent_count; index++) {
            /* get the next parent */
            PMC *current_parent = VTABLE_get_pmc_keyed_int(interp,
                                      _class->parents, index);

            /* get the name of the current parent */
            STRING *current_name = VTABLE_get_string(interp, current_parent);

            /* throw an exception if we already have this parent */
            if (string_equal(interp, current_name, parent_name) == 0) {
                real_exception(interp, NULL, INVALID_OPERATION,
                    "The class '%S' already has a parent class '%S'. "
                    "It may have been supplied by a role.",
                    VTABLE_get_string(interp, SELF),
                    parent_name);

            }

        }


        /* Add to the lists of our immediate parents and all parents. */
        VTABLE_push_pmc(interp, _class->parents, parent);
        _class->all_parents = Parrot_ComputeMRO_C3(interp, SELF);

        /* Anonymous classes have no entry in the vtable array */
        if (!CLASS_is_anon_TEST(SELF))
            interp->vtables[VTABLE_type(interp, SELF)]->mro = _class->all_parents;
    }

/*

=item C<void add_role(PMC *role)>

Adds the supplied PMC to the list of roles for the class, provided there are
no conflicts.

=cut

*/
    void add_role(PMC *role) {
        Parrot_Class * const _class = PARROT_CLASS(SELF);

        /* Do the composition. */
        Parrot_ComposeRole(interp, role, PMCNULL, 0, PMCNULL, 0,
                           _class->methods, _class->roles);
    }

/*

=item C<PMC *inspect_str(STRING *what)>

Provides introspection of a specific piece of information about the class. The
available information is:

=over 8

=item name

String PMC containing the name of the class

=item namespace

NameSpace PMC of the the namespace attached to the class

=item attributes

Hash keyed on attribute name, value is hash describing it

=item methods

Hash keyed on method name, value is an invokable PMC. Includes methods composed
in from roles.

=item roles

Array of Role PMCs. Includes roles done by the roles that were composed into
this class.

=item parents

Array of Class PMCs representing the direct parents of this class.

=back

=cut

*/
    PMC *inspect_str(STRING *what) {
        Parrot_Class *_class = PARROT_CLASS(SELF);

        /* What should we return? */
        PMC          *found  = PMCNULL;

        if (string_equal(interp, what, CONST_STRING(interp, "name")) == 0) {
            found = pmc_new(interp, enum_class_String);
            VTABLE_set_string_native(interp, found, _class->name);
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "id")) == 0) {
            found = pmc_new(interp, enum_class_Integer);
            VTABLE_set_integer_native(interp, found, _class->id);
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "namespace")) == 0) {
            /* Should not clone this. */
            return _class->_namespace;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "attributes")) == 0) {
            found = _class->attrib_metadata;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "attrib_index")) == 0) {
            found = _class->attrib_index;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "methods")) == 0) {
            found = _class->methods;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "vtable_overrides")) == 0) {
            found = _class->vtable_overrides;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "parents")) == 0) {
            found = _class->parents;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "all_parents")) == 0) {
            found = _class->all_parents;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "roles")) == 0) {
            found = _class->roles;
        }
        else {
            real_exception(interp, NULL, INVALID_OPERATION,
                "Unknown introspection value '%S'", what);
        }

        /* Clone and return. */
        return PMC_IS_NULL(found) ? PMCNULL : VTABLE_clone(interp, found);
    }

/*

=item C<PMC *inspect()>

Returns a Hash describing the class, with key/value pairs as described in
inspect_str.

=cut

*/
    PMC *inspect() {
        /* Create a hash, then use inspect_str to get all of the data to
         * fill it up with. */
        PMC    *metadata           = pmc_new(interp, enum_class_Hash);
        STRING * const name_str    = CONST_STRING(interp, "name");
        STRING * const ns_str      = CONST_STRING(interp, "namespace");
        STRING * const attrs_str   = CONST_STRING(interp, "attributes");
        STRING * const meths_str   = CONST_STRING(interp, "methods");
        STRING * const parents_str = CONST_STRING(interp, "parents");
        STRING * const roles_str   = CONST_STRING(interp, "roles");

        VTABLE_set_pmc_keyed_str(interp, metadata, name_str,
            VTABLE_inspect_str(interp, SELF, name_str));

        VTABLE_set_pmc_keyed_str(interp, metadata, ns_str,
            VTABLE_inspect_str(interp, SELF, ns_str));

        VTABLE_set_pmc_keyed_str(interp, metadata, attrs_str,
            VTABLE_inspect_str(interp, SELF, attrs_str));

        VTABLE_set_pmc_keyed_str(interp, metadata, meths_str,
            VTABLE_inspect_str(interp, SELF, meths_str));

        VTABLE_set_pmc_keyed_str(interp, metadata, parents_str,
            VTABLE_inspect_str(interp, SELF, parents_str));

        VTABLE_set_pmc_keyed_str(interp, metadata, roles_str,
            VTABLE_inspect_str(interp, SELF, roles_str));

        return metadata;
    }

/*

=item C<PMC *clone()>

Returns an anonymous copy of the class (with no name and no link to a
namespace). Unsets the instantiated flag, allowing modifications.

=cut

*/

    PMC *clone() {
        Parrot_Class *_class = PARROT_CLASS(SELF);

        /* Create the new class PMC, of the same type of this one (we may
         * have been subclassed). */
        PMC          *copy  = pmc_new(interp, SELF->vtable->base_type);

        /* Clone parents, roles, methods, attributes and resolve data. We do
         * not copy name/namespace related stuff (need anonymous clone) or
         * stuff that gets computed on the first instantiation. */

        Parrot_Class *new_class    = PARROT_CLASS(copy);

        new_class->parents         = VTABLE_clone(interp, _class->parents);
        new_class->roles           = VTABLE_clone(interp, _class->roles);
        new_class->methods         = VTABLE_clone(interp, _class->methods);
        new_class->vtable_overrides  = VTABLE_clone(interp,
                                                  _class->vtable_overrides);
        new_class->attrib_metadata = VTABLE_clone(interp,
                                                  _class->attrib_metadata);
        new_class->resolve_method  = VTABLE_clone(interp,
                                                  _class->resolve_method);

        /* Return cloned class. */
        return copy;
    }

/*

=item C<PMC *clone_pmc(PMC *args)>

Makes a copy of the class, then modifies or adds to it based upon the contents
of the supplied initialization data. If a new name or namespace is not supplied
in C<args> then the cloned class will be anonymous. The instantiated flag is
unset to allow further modifications.

=cut

*/

    PMC *clone_pmc(PMC *args) {
        /* Do the standard clone. */
        PMC *copy = DYNSELF.clone();

        init_class_from_hash(interp, copy, args);

        return copy;
    }

/*

=item C<PMC *instantiate(PMC *init)>

Creates a new PMC object of the type of the class and calls init().

=cut

*/

    PMC *instantiate(PMC *init) {
        Parrot_Object *obj_guts  = NULL;
        Parrot_Class  *_class    = PARROT_CLASS(SELF);
        STRING * const class_str = CONST_STRING(interp, "Class");
        PMC           *object    = PMCNULL;
        PMC           *iter;
        INTVAL         i, mro_length;

        /* If we've not been instantiated before... */
        if (!_class->instantiated) {
            int resolve_count;

            /* Check that we have all methods listed in resolve list. */
            resolve_count = VTABLE_elements(interp, _class->resolve_method);
            for (i = 0; i < resolve_count; i++) {
                STRING *check_meth = VTABLE_get_string_keyed_int(interp,
                    _class->resolve_method, i);
                if (!VTABLE_exists_keyed_str(interp, _class->methods, check_meth)) {
                    real_exception(interp, NULL, METH_NOT_FOUND,
                        "The method '%S' was named in the resolve list, but not supplied",
                        check_meth);
                }
            }

            /* Build full parents list.
             * RT#46101 Need pluggable MRO, for now always do C3. */
            _class->all_parents = Parrot_ComputeMRO_C3(interp, SELF);
            if (!CLASS_is_anon_TEST(SELF))
                interp->vtables[VTABLE_type(interp, SELF)]->mro = _class->all_parents;

            build_attrib_index(interp, SELF);

            if (PMC_IS_NULL(_class->attrib_index))
                return object;

            /* See if we have any parents from other universes and if so set a
             * flag stating so. */
            mro_length = VTABLE_elements(interp, _class->all_parents);

            for (i = 0; i < mro_length; i++) {
                PMC * const class_check = VTABLE_get_pmc_keyed_int(interp,
                    _class->all_parents, i);
                if (!VTABLE_isa(interp, class_check, class_str)) {
                    /* Found one; that's enough. */
                    CLASS_has_alien_parents_SET(SELF);
                    break;
                }
            }
        }

        /* Set instantiated flag. */
        _class->instantiated = 1;

        /* Create object. */
        object = pmc_new_noinit(interp, enum_class_Object);

        /* Set custom DOD mark and destroy on the object. */
        PObj_custom_mark_SET(object);
        PObj_active_destroy_SET(object);

        /* Flag that it is an object */
        PObj_is_object_SET(object);

        /* Initialize the object's underlying structure, pointing it to this
         * class. */
        obj_guts               = mem_allocate_zeroed_typed(Parrot_Object);
        obj_guts->_class       = SELF;
        PMC_data(object)       = obj_guts;
        obj_guts->attrib_store = pmc_new(interp, enum_class_ResizablePMCArray);

        if (!PMC_IS_NULL(init)) {
            /* Initialize attributes with the supplied values. */
            iter = VTABLE_get_iter(interp, init);

            while (VTABLE_get_bool(interp, iter)) {
                /* Get name and value. */
                STRING * const attr_name  = VTABLE_shift_string(interp, iter);
                PMC    * const attr_value = VTABLE_get_pmc_keyed_str(interp, init,
                    attr_name);

                /* Set the attribute. */
                VTABLE_set_attr_str(interp, object, attr_name, attr_value);
            }
        }

        /* If we have parents that are out of this class universe, find them
         * in the MRO and create instances of them. */
        if (CLASS_has_alien_parents_TEST(SELF)) {
            mro_length = VTABLE_elements(interp, _class->all_parents);

            for (i = 0; i < mro_length; i++) {
                PMC * const class_check = VTABLE_get_pmc_keyed_int(interp,
                    _class->all_parents, i);

                if (!VTABLE_isa(interp, class_check, class_str)) {
                    /* From another universe. Create instance... */
                    PMC *parent_ins;
                    int  position;

                    parent_ins = VTABLE_instantiate(interp, class_check, PMCNULL);

                    /* Associate it with this class as the real self. */
                    parent_ins->real_self = object;

                    /* ...and tack on end of the attribute store (after all the
                     * slots for attributes). */
                    position = VTABLE_elements(interp, obj_guts->attrib_store);
                    VTABLE_set_pmc_keyed_int(interp, obj_guts->attrib_store,
                        position, parent_ins);
                }
            }
        }

        /* Check for overrides on the init or init_pmc vtable function and call
         * them if they exist */
        if (PMC_IS_NULL(init))
            initialize_parents(interp, object, _class->all_parents);
        else
            initialize_parents_pmc(interp, object, _class->all_parents, init);

        return object;
    }


/*

=item C<INTVAL isa_pmc(PMC *classname)>

Returns whether the class is or inherits from C<*classname>.

=cut

*/

    INTVAL isa_pmc(PMC *lookup) {
        Parrot_Class *_class    = PARROT_CLASS(SELF);
        INTVAL        i, num_classes;
        STRING       *classname;
        PMC          *classobj = PMCNULL;

        if (PMC_IS_NULL(lookup))
            return 0;

        if (SUPER(lookup))
            return 1;

        classobj = Parrot_oo_get_class(interp, lookup);

        if (PMC_IS_NULL(classobj))
            return 0;

        /* Check if the class object is the same as self's class object */
        if (VTABLE_is_same(interp, SELF, classobj))
            return 1;

        classname = VTABLE_get_string(interp, classobj);

        /* Check if the passed name is the same as the stored short name. */
        if (string_equal(interp, classname, _class->name) == 0)
            return 1;

        /* Check if the passed name is the same as the fully qualified name. */
        if (string_equal(interp, classname, VTABLE_get_string(interp, SELF)) == 0)
            return 1;

        /* Iterate over all the parents and check if they respond true
         * for 'isa' on the original comparison.
         */
        num_classes = VTABLE_elements(interp, _class->parents);
        for (i = 0; i < num_classes; i++) {
            PMC *cur_class = VTABLE_get_pmc_keyed_int(interp, _class->parents, i);
            if (VTABLE_isa_pmc(interp, cur_class, lookup))
                return 1;
        }

        return 0;
    }

/*

=item C<INTVAL isa(STRING *classname)>

Returns whether the class is or inherits from C<*classname>.

=cut

*/

    INTVAL isa(STRING *classname) {
        PMC *string_pmc = pmc_new(interp, enum_class_String);
        VTABLE_set_string_native(interp, string_pmc, classname);

        return VTABLE_isa_pmc(interp, SELF, string_pmc);
    }

/*

=item C<INTVAL type()>

Returns the integer type of the class.

=cut

*/

    INTVAL type() {
        Parrot_Class *_class    = PARROT_CLASS(SELF);
        return _class->id;
    }

/*

=item C<void visit(visit_info *info)>

This is used by freeze/thaw to visit the contents of the class.

C<*info> is the visit info, (see F<include/parrot/pmc_freeze.h>).

=cut

*/

    void visit(visit_info *info) {
        INTVAL i, n;
        Parrot_Class * const class_data = PARROT_CLASS(SELF);
        PMC **pos;

        /* 1) visit the attribute description hash */
        pos      = &class_data->attrib_metadata;
        info->thaw_ptr = pos;
        (info->visit_pmc_now)(INTERP, *pos, info);

        /* 2) visit list of parents */
        pos            = &class_data->parents;
        info->thaw_ptr = pos;
        (info->visit_pmc_now)(INTERP, *pos, info);

        /* 3) visit list of roles */
        pos            = &class_data->roles;
        info->thaw_ptr = pos;
        (info->visit_pmc_now)(INTERP, *pos, info);

        /* 4) visit hash of methods */
        pos            = &class_data->methods;
        info->thaw_ptr = pos;
        (info->visit_pmc_now)(INTERP, *pos, info);

        /* 5) visit hash of vtable overrides */
        pos            = &class_data->vtable_overrides;
        info->thaw_ptr = pos;
        (info->visit_pmc_now)(INTERP, *pos, info);

        /* 6) visit list of resolve methods */
        pos            = &class_data->resolve_method;
        info->thaw_ptr = pos;
        (info->visit_pmc_now)(INTERP, *pos, info);

    }

/*

=item C<void freeze(visit_info *info)>

Used to archive the class.

=cut

*/

    void freeze(visit_info *info) {
        IMAGE_IO     *io                = info->image_io;
        Parrot_Class * const class_data = PARROT_CLASS(SELF);
        STRING       * serial_namespace = CONST_STRING(interp, "");

        /* 1) freeze class id */
        VTABLE_push_integer(INTERP, io, class_data->id);

        /* 2) freeze class name */
        VTABLE_push_string(INTERP, io, class_data->name);

        /* 3) serialize namespace name, including HLL */
        if (!PMC_IS_NULL(class_data->_namespace)) {
            PMC *names = Parrot_NameSpace_nci_get_name(interp,
                    class_data->_namespace);
            if (!PMC_IS_NULL(names))
                serial_namespace = string_join(interp, CONST_STRING(interp, ";"), names);
        }
        VTABLE_push_string(INTERP, io, serial_namespace);
    }

/*

=item C<void thaw(visit_info *info)>

Used to unarchive the class.

=cut

*/

    void thaw(visit_info *info) {
        IMAGE_IO *io = info->image_io;

        /* The class might already exist in the interpreter, so create it as an
         * anonymous class and later decide whether to link it into the
         * namespace.
         */

        if (info->extra_flags == EXTRA_IS_PROP_HASH) {
            SUPER(info);
        }
        else if (info->extra_flags == EXTRA_IS_NULL) {
            /* 1) thaw class id */
            INTVAL  id = VTABLE_shift_integer(INTERP, io);

            /* 2) thaw class name */
            STRING *name = VTABLE_shift_string(INTERP, io);

            /* 3) deserialize namespace name, including HLL */
            STRING *serial_namespace = VTABLE_shift_string(INTERP, io);
            PMC    *namespace_array = string_split(INTERP,
                    CONST_STRING(INTERP, ";"), serial_namespace);
            PMC *ns = Parrot_get_namespace_keyed(interp,
                    INTERP->root_namespace, namespace_array);

            /* If the namespace doesn't exist, we create it, and initialize
             * ourselves in it */
            if (PMC_IS_NULL(ns)) {
                ns = Parrot_make_namespace_keyed(interp,
                        INTERP->root_namespace, namespace_array);
                SELF.init_pmc(ns);
            }
            /* If the namespace exists already, we point to it, but otherwise
             * act as an anonymous class. */
            else {
                SELF.init();
                PARROT_CLASS(SELF)->_namespace = ns;
            }

            /* Set the class's short name to the frozen name */
            PARROT_CLASS(SELF)->name = name;

            /* Set the class's id the frozen id */
            PARROT_CLASS(SELF)->id = id;
        }
    }

/*

=item C<void thawfinish(visit_info *info)>

Called after the class has been thawed.

=cut

*/

    void thawfinish(visit_info *info) {
        Parrot_Class  *_class    = PARROT_CLASS(SELF);

        /* Recalculate full MRO from thawed parents */
        _class->all_parents = Parrot_ComputeMRO_C3(interp, SELF);

        /* Rebuild attribute index from thawed attribute metadata */
        build_attrib_index(interp, SELF);
    }

    /* **********************************************************************
     * Below here are non-vtable methods that eventually will go in a role
     * that is composed into here to optionally give a nice interface from
     * PIR (ParrotClass isa Class does ClassMethods or something like this).
     * **********************************************************************/

/*

=item C<void name(STRING *name :optional, int has_name :opt_flag)>

Sets the name of the class, and updates the namespace accoringly.

=cut

*/
    PCCMETHOD name(STRING *name :optional, int has_name :opt_flag) {
        Parrot_Class *_class   = PARROT_CLASS(SELF);
        STRING       *ret_name = NULL;

        if (has_name) {
            /* We'll build a hash just containing the name, then give this to
             * init_class_from_hash - saves some code duplication. */
            PMC *naming_hash = pmc_new(interp, enum_class_Hash);

            VTABLE_set_string_keyed_str(interp, naming_hash, CONST_STRING(interp, "name"), name);
            init_class_from_hash(interp, SELF, naming_hash);
        }

        ret_name = _class->name;
        PCCRETURN(STRING *ret_name);
    }

/*

=item C<void pmc_namespace()>

Gets the namespace that this class is attached to.

=cut

*/
    PCCMETHOD pmc_namespace(PMC *_namespace :optional, int has_name :opt_flag) {
        Parrot_Class *_class        = PARROT_CLASS(SELF);
        PMC          *ret_namespace = _class->_namespace;
        UNUSED(_namespace);
        UNUSED(has_name);
        PCCRETURN(PMC *ret_namespace);
    }

/*

=item C<void resolve_method()>

Sets the list of method names that the class provides to resolve conflicts in
methods from roles. When called with no parameter, returns the list.

=cut

*/
    PCCMETHOD resolve_method(PMC *resolve_list :optional,
                                  int has_list :opt_flag) {
        Parrot_Class *_class   = PARROT_CLASS(SELF);
        PMC          *ret_list = NULL;

        /* Store list. */
        if (has_list)
            _class->resolve_method = resolve_list;

        ret_list = _class->resolve_method;
        PCCRETURN(PMC *ret_list);
    }

/*

=item C<void new(PMC *args :slurpy :named)>

Creates an instance of the object. Initializes any attributes specified in the
parameter list.

=cut

*/
    PCCMETHOD new(PMC *args :slurpy :named) {
        PMC *obj;
        /* Check if any arguments are in the slurpy hash, don't pass an empty
         * hash to instantiate */
        if (VTABLE_elements(interp, args) > 0)
            obj = VTABLE_instantiate(interp, SELF, args);
        else
            obj = VTABLE_instantiate(interp, SELF, PMCNULL);

        PCCRETURN(PMC *obj);
     }

/*

=item C<void attributes()>

Return a hash where the keys are attribute names and the values are hashes
providing a set of key/value pairs describing the attribute.

=cut

*/
    PCCMETHOD attributes() {
        PMC *ret_attrib_metadata = DYNSELF.inspect_str(
            CONST_STRING(interp, "attributes"));

        PCCRETURN(PMC *ret_attrib_metadata);
    }

/*

=item C<void add_attribute()>

Add an attribute to the class. Requires a name and, optionally, a type.

=cut

*/
    PCCMETHOD add_attribute(STRING *attribute_name,
            PMC *attribute_type :optional, int has_type :opt_flag) {
        PMC *type = has_type ? attribute_type : PMCNULL;
        DYNSELF.add_attribute(attribute_name, type);
    }

/*

=item C<void methods()>

Return a hash where the keys are method names and the values are methods.

=cut

*/
    PCCMETHOD methods() {
        PMC *ret_methods = DYNSELF.inspect_str(CONST_STRING(interp, "methods"));

        PCCRETURN(PMC *ret_methods);
    }

/*

=item C<void add_method(STRING *name, PMC *sub)>

Adds the given sub PMC as a method with the given name. Delegates to the
C<add_method> vtable method.

=cut

*/
    PCCMETHOD add_method(STRING *name, PMC *sub,
                              int vtable :optional :named["vtable"],
                              int has_vtable :opt_flag,
                              int anon :optional :named["anon"],
                              int has_anon :opt_flag)
    {
        /* If it's a vtable method... */
        if (has_vtable && vtable) {
            VTABLE_add_vtable_override(interp, SELF, name, sub);
        }

        /* Provided it's not anonymous, add it to the methods list. */
        if (!has_anon || !anon)
            DYNSELF.add_method(name, sub);
    }

/*

=item C<PMC *find_method(STRING *name)>

Walks the MRO of the class and finds the method with the given name.

*/

    PCCMETHOD find_method(STRING *name) {
        Parrot_Class * const  _class    = PARROT_CLASS(SELF);
        int num_classes, i;

        /* Walk and search. One day, we'll use the cache first. */
        num_classes = VTABLE_elements(interp, _class->all_parents);

        for (i = 0; i < num_classes; i++) {
            /* Get the class and see if it has the method. */
            PMC * const cur_class =
                VTABLE_get_pmc_keyed_int(interp, _class->all_parents, i);
            const Parrot_Class * const class_info = PARROT_CLASS(cur_class);

            /* Found it! */
            if (VTABLE_exists_keyed_str(interp, class_info->methods, name)) {
                PMC *ret = VTABLE_get_pmc_keyed_str(interp, class_info->methods,
                    name);
                PCCRETURN(PMC *ret);
            }
        }

        PCCRETURN(PMC *PMCNULL);
    }

/*

=item C<void parents()>

Return the parents array PMC.

=cut

*/
    PCCMETHOD parents() {
        PMC *ret_parents = DYNSELF.inspect_str(CONST_STRING(interp, "parents"));

        PCCRETURN(PMC *ret_parents);
    }

/*

=item C<void add_parent(PMC *parent)>

Adds the supplied PMC to the list of parents for the class.

=cut

*/
    PCCMETHOD add_parent(PMC *parent) {
        DYNSELF.add_parent(parent);
    }

/*

=item C<void roles()>

Return the roles array PMC.

=cut

*/
    PCCMETHOD roles() {
        PMC *ret_roles = DYNSELF.inspect_str(CONST_STRING(interp, "roles"));

        PCCRETURN(PMC *ret_roles);
    }

/*

=item C<void add_role(PMC *role, PMC *exclude :optional :named["exclude"],
PMC *alias :optional :named["alias"])>

Compose a role into a class with the given exclusions and aliases.

=cut

*/
    PCCMETHOD add_role(PMC *role,
            PMC *exclude_method     :optional :named["exclude_method"],
            int has_exclude_method  :opt_flag,
            PMC *alias_method       :optional :named["alias_method"],
            int has_alias_method    :opt_flag) {

        Parrot_Class *_class = PARROT_CLASS(SELF);

        /* Add everything on the resolve list to the exclude list; if we have
         * no exclude list, pass along the resolve list in its place if it has
         * any methods listed in it. */
        if (!has_exclude_method) {
            if (VTABLE_elements(interp, _class->resolve_method) != 0) {
                exclude_method     = _class->resolve_method;
                has_exclude_method = 1;
            }
        }
        else {
            int resolve_count = VTABLE_elements(interp, _class->resolve_method);
            int i;

            for (i = 0; i < resolve_count; i++) {
                STRING *meth_name = VTABLE_get_string_keyed_int(interp,
                    _class->resolve_method, i);
                VTABLE_push_string(interp, exclude_method, meth_name);
            }
        }

        /* Do the composition. */
        Parrot_ComposeRole(interp, role, exclude_method, has_exclude_method,
                           alias_method, has_alias_method,
                           _class->methods, _class->roles);
    }

/*

=item C<void inspect(STRING *what :optional)>

Gets all introspection data for the class or, if the optional string
parameter is supplied, a particular item of introspection data.

=cut

*/
    PCCMETHOD inspect(STRING *what :optional, int has_what :opt_flag) {
        PMC *found;

        /* Just delegate to the appropriate vtable method. */
        if (has_what)
            found = DYNSELF.inspect_str(what);
        else
            found = DYNSELF.inspect();

        PCCRETURN(PMC *found);
    }

/*

=item C<void isa(STRING *class_name)>

Returns true if this object is or derives from the class named in
C<class_name>, false otherwise.

=cut

*/
    PCCMETHOD isa(STRING *class_name) {
        INTVAL isa = DYNSELF.isa(class_name);

        PCCRETURN(INTVAL isa);
    }

/*

=item C<void does(STRING *role_name)>

Returns true if this object or one of its parents performs the named role,
false otherwise.

=cut

*/
    PCCMETHOD does(STRING *role_name) {
        INTVAL i, role_count, isa;
        PMC *role_list = (PMC_data_typed(SELF, Parrot_Class *))->roles;

        if (!role_list)
            PCCRETURN(INTVAL 0);

        role_count = VTABLE_elements(interp, role_list);

        for (i = 0; i < role_count; i++) {
            INTVAL  role_does;
            PMC    *role       = VTABLE_get_pmc_keyed_int(interp, role_list, i);

            (INTVAL role_does) = PCCINVOKE(interp, role, "does",
                                           STRING *role_name);

            if (role_does)
                PCCRETURN(INTVAL 1);
        }

        (INTVAL isa) = PCCINVOKE(interp, SELF, "isa", STRING *role_name);

        PCCRETURN(INTVAL isa);
    }

} /* END pmclass */

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd15_objects.pod>.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
