/*
Copyright (C) 2001-2007, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/class.pmc - defines a class

=head1 DESCRIPTION

This class implements the Class PMC, as outlined in
F<docs/pdds/pdd15_objects.pod>.

Class is not derived from any other PMC.

=head2 Structure

The Role PMC structure (C<Parrot_Role>) consists of five items:

=over 4

=item C<name>

The name of the class -- a STRING.
An empty STRING is allocated during initialization.

=item C<namespace>

The namespace the class is associated with, if any.
A Null PMC is allocated during initialization.

=item C<instantiated>

A flag denoting whether this class has been instantiated since last modification.
A native integer with value zero is allocated during initialization.

=item C<parents>

An array of immediate parent classes.
An empty ResizablePMCArray PMC is allocated during initialization.

=item C<all_parents>

A cached array of ourself and all parent classes, in MRO order.
A ResizablePMCArray PMC is allocated during initialization,
and is populated with the current class.

=item C<roles>

An array of the roles this class has been composed from.
An empty ResizablePMCArray PMC is allocated during initialization.

=item C<methods>

A directory of method names and method bodies this class provides.
An empty Hash PMC is allocated during initialization.

=item C<vtable_overrides>

A directory of vtable method names and method bodies this class overrides.
An empty Hash PMC is allocated during initialization.

=item C<attrib_metadata>

A directory of attribute names and attribute metadata this class contains.
An empty Hash PMC is allocated during initialization.

=item C<attrib_index>

A lookup table for attributes in this class and parents.
A Null PMC is allocated during initialization.

=item C<attrib_cache>

A cache of visible attribute names to attribute indexes.
A Null PMC is allocated during initialization.

=item C<resolve_method>

A list of method names the class provides used for name conflict resolution.
An empty ResizablePMCArray PMC is allocated during initialization.

=cut

*/

#define PARROT_IN_OBJECTS_C /* To get the vtable.h imports we want. */
#include "parrot/parrot.h"
#include "pmc_namespace.h"
#include "classobject.h"

/* This function builds the attribute index (table to map class name and
 * attribute name to an index) for the current class. */
static void
build_attrib_index(PARROT_INTERP, PMC *self)
{
    Parrot_Class * const _class      = PARROT_CLASS(self);
    int                  cur_index   = 0;
    PMC * const          table       = pmc_new(interp, enum_class_Hash);
    STRING       * const class_str   = string_from_cstring(interp, "Class", 5);
    const int            num_classes =
        VTABLE_elements(interp, _class->all_parents);
    int                  i;

    /* We will go over the list of all parents to construct the table. */
    for (i = 0; i < num_classes; i++) {
       /* Get the class and check it's from this class universe (if not we
        * don't know how it stores its attributes, so we'll have to delegate
        * the lookup). */
        PMC *cur_class = VTABLE_get_pmc_keyed_int(interp, _class->all_parents,
            i);

        if (VTABLE_isa(interp, cur_class, class_str)) {
            /* The the attribute metadata hash. */
            Parrot_Class *class_info = PARROT_CLASS(cur_class);
            PMC          *attribs    = class_info->attrib_metadata;
            PMC          *iter       = VTABLE_get_iter(interp, attribs);

            /* Build a string representing the fully qualified class name. */
            /* Retrieve the fully qualified class name for the class. */
            STRING *fq_class         = VTABLE_get_string(interp, cur_class);

            /* Iterate over the attributes. */
            while (VTABLE_get_bool(interp, iter)) {
                /* Get attribute. */
                PMC    *cur_attrib  = VTABLE_get_pmc_keyed_str(interp, attribs,
                    VTABLE_shift_string(interp, iter));
                STRING *full_key    = string_copy(interp, fq_class);

                /* Get attribute name and append it to the key. */
                STRING *attrib_name = VTABLE_get_string_keyed_str(
                    interp, cur_attrib, string_from_cstring(interp, "name", 4));

                full_key = string_append(interp, full_key, attrib_name);

                /* Insert into hash, along with index. */
                VTABLE_set_integer_keyed_str(interp, table, full_key, cur_index);
                cur_index++;
            }
        }
    }

    /* Store built table and invalidate cache. */
    _class->attrib_index = table;
    _class->attrib_cache = pmc_new(interp, enum_class_Hash);
}

/*
 * This function throws an exception if a PMC or class with the same name
 * already exists in the global type registry. The global type registry will go
 * away eventually, but this allows the new object metamodel to interact with
 * the old one until it does.
 */

static void
fail_if_type_exists(PARROT_INTERP, PMC *name)
{
    INTVAL      type;

    PMC * const classname_hash = interp->class_hash;
    PMC * const type_pmc       = (PMC *)VTABLE_get_pointer_keyed(interp,
                                        classname_hash, name);
    if (PMC_IS_NULL(type_pmc) ||
            type_pmc->vtable->base_type == enum_class_NameSpace)
        type = 0;
    else
        type = VTABLE_get_integer(interp, type_pmc);

    if (type > enum_type_undef) {
        /* TODO get printable name */
        real_exception(interp, NULL, INVALID_OPERATION,
                "Class %Ss already registered!\n",
                VTABLE_get_string(interp, name));
    }

    if (type < enum_type_undef)
        real_exception(interp, NULL, INVALID_OPERATION,
                "native type with name '%s' already exists - "
                "can't register Class", data_types[type].name);
}

/* This function registers a type in the global registry, first checking if it
 * already exists. The global type registry will go away eventually, but this
 * allows the new object metamodel to interact with the old one until it does.
 */
static INTVAL
register_type(PARROT_INTERP, PMC *name) {
    INTVAL  type;
    PMC    *classname_hash, *item;

    if (PMC_IS_NULL(name))
        real_exception(interp, NULL, INVALID_OPERATION,
                "Can't register type without a name!\n");

    /* First check if the type already exists */
    fail_if_type_exists(interp, name);

    /* Type doesn't exist, so go ahead and register it. Lock interpreter so
     * pt_shared_fixup() can safely do a type lookup. */
    LOCK_INTERPRETER(interp);
    classname_hash = interp->class_hash;
    type           = interp->n_vtable_max++;

    /* Have we overflowed the table? */
    if (type >= interp->n_vtable_alloced)
        parrot_realloc_vtables(interp);

    /* set entry in name->type hash */
    item              = pmc_new(interp, enum_class_Integer);
    PMC_int_val(item) = type;

    VTABLE_set_pmc_keyed(interp, classname_hash, name, item);
    UNLOCK_INTERPRETER(interp);

    return type;
}


/* Takes a hash and initializes the class based on it. */
static void
init_class_from_hash(PARROT_INTERP, PMC *self, PMC *info)
{
    Parrot_Class *_class      = PARROT_CLASS(self);
    STRING       *name_str    = string_from_cstring(interp, "name",        4);
    STRING       *parents_str = string_from_cstring(interp, "parents",     7);
    STRING       *methods_str = string_from_cstring(interp, "methods",     7);
    STRING       *roles_str   = string_from_cstring(interp, "roles",       5);
    STRING       *attrs_str   = string_from_cstring(interp, "attributes", 10);
    PMC          *old_ns;
    INTVAL        i, type_num;

    /* Ensure we actually have some initialization info. */
    if (PMC_IS_NULL(info))
        return;

    /* Take a copy of the current namespace the class is attached to. */
    old_ns = _class->_namespace;

    /* Check if we have a name/namespace. */
    if (VTABLE_exists_keyed_str(interp, info, name_str)) {

        STRING *new_name;
        PMC    *new_namespace;
        PMC    *name_arg = VTABLE_get_pmc_keyed_str(interp, info, name_str);
        VTABLE *new_vtable;

        /* If we were passed a namespace PMC, set the namespace attribute
         * directly. Otherwise, lookup or create the appropriate namespace. */
        if (VTABLE_isa(interp, name_arg,
                    string_from_literal(interp, "NameSpace")))
            new_namespace = name_arg;
        else
            new_namespace = Parrot_make_namespace_autobase(interp, name_arg);

        if (PMC_IS_NULL(new_namespace))
            real_exception(interp, NULL, INVALID_OPERATION,
                "Failed to set namespace for class.");

        /* Set the name of the class to the name of the innermost namespace
         * associated with the class.
         */
        new_name = VTABLE_get_string(interp, new_namespace);

        if (STRING_IS_NULL(new_name) || STRING_IS_EMPTY(new_name))
              real_exception(interp, NULL, INVALID_OPERATION,
                "Failed to set name for class.");

        _class->_namespace = new_namespace;
        _class->name       = new_name;

        /* Register a type number for the class. */
        type_num = register_type(interp, name_arg);

        /* Link the type number with the class's vtable. */
        new_vtable = Parrot_clone_vtable(interp, self->vtable);
        new_vtable->base_type     = type_num;
        new_vtable->pmc_class     = self;

        /* Store the class's vtable in the global table */
        interp->vtables[type_num] = new_vtable;
    }

    /* If we were attached to a namespace and are now attached to a new one,
     * need to unset ourselves in the old namespace. */
    if (!PMC_IS_NULL(old_ns) && _class->_namespace != old_ns)
        Parrot_PCCINVOKE(interp, old_ns,
            string_from_literal(interp, "set_class"), "P->", PMCNULL);

    /* Link namespace to this class, if there is one. */
    if (!PMC_IS_NULL(_class->_namespace))
        Parrot_PCCINVOKE(interp, _class->_namespace,
            string_from_literal(interp, "set_class"), "P->", self);

    /* Initialize resolve_method. */
    if (VTABLE_exists_keyed_str(interp, info,
        string_from_literal(interp, "resolve_method"))) {
        /* Set it. */
        _class->resolve_method = VTABLE_get_pmc_keyed_str(interp, info,
            string_from_literal(interp, "resolve_method"));
    }

    /* Initialize parents, if we have any. */
    if (VTABLE_exists_keyed_str(interp, info, parents_str)) {
        /* Loop over parents array and add them. */
        PMC * const parent_list = VTABLE_get_pmc_keyed_str(interp, info,
            parents_str);
        const int  parent_count = VTABLE_elements(interp, parent_list);

        for (i = 0; i < parent_count; i++)
            VTABLE_add_parent(interp, self,
                VTABLE_get_pmc_keyed_int(interp, parent_list, i));
    }

    /* Initialize roles, if we have any. */
    if (VTABLE_exists_keyed_str(interp, info, roles_str)) {
        /* Loop over roles array and compose them. */
        PMC * const role_list  = VTABLE_get_pmc_keyed_str(interp, info,
            roles_str);
        const int   role_count = VTABLE_elements(interp, role_list);

        for (i = 0; i < role_count; i++)
            VTABLE_add_role(interp, self,
                VTABLE_get_pmc_keyed_int(interp, role_list, i));
    }

    /* Initialize attributes, if we have any. */
    if (VTABLE_exists_keyed_str(interp, info, attrs_str)) {
        /* Loop over attributes array and add them. */
        PMC * const attrs_name_list = VTABLE_get_pmc_keyed_str(interp, info,
            attrs_str);
        const int   attrib_count    = VTABLE_elements(interp, attrs_name_list);

        for (i = 0; i < attrib_count; i++) {
            STRING * const attr_name = VTABLE_get_string_keyed_int(interp,
                attrs_name_list, i);
            VTABLE_add_attribute(interp, self, attr_name, PMCNULL);
        }
    }

    /* Initialize methods. */
    if (VTABLE_exists_keyed_str(interp, info, methods_str)) {
        /* Get the methods hash. */
        PMC * const methods = VTABLE_get_pmc_keyed_str(interp, info,
            methods_str);

        /* Iterate over the list of methods. */
        PMC * const iter    = VTABLE_get_iter(interp, methods);

        while (VTABLE_get_bool(interp, iter)) {
            /* Add the method. */
            STRING * const method_name = VTABLE_shift_string(interp, iter);
            PMC    * const method_pmc  = VTABLE_get_pmc_keyed_str(interp,
                methods, method_name);
            VTABLE_add_method(interp, self, method_name, method_pmc);
        }
    }
}

static PMC *
find_vtable_override(PARROT_INTERP, PMC *parrot_class, STRING *name)
{
    Parrot_Class * const _class = PARROT_CLASS(parrot_class);

    /* Walk and search for the vtable method. */
    const int num_classes       = VTABLE_elements(interp, _class->all_parents);
    const int all_in_universe   = !PObj_HasAlienParents_TEST(parrot_class);
    /* xxx this isn't used yet
    const int alien_parents_pos = VTABLE_elements(interp,
        _class->attrib_metadata);
    */

    int i;

    for (i = 0; i < num_classes; i++) {
        /* Get the class. */
        PMC * const cur_class =
            VTABLE_get_pmc_keyed_int(interp, _class->all_parents, i);

        /* If it's from this universe or the class doesn't inherit from
         * anything outside of it... */
        if (all_in_universe || VTABLE_isa(interp, cur_class,
                string_from_literal(interp, "Class"))) {
            const Parrot_Class * const class_info = PARROT_CLASS(cur_class);
            if (VTABLE_exists_keyed_str(interp, class_info->vtable_overrides,
                    name)) {
                /* Found it; call. */
                PMC * const meth = VTABLE_get_pmc_keyed_str(interp,
                    class_info->vtable_overrides, name);
                return meth;
            }
        }
        else {
            /* This is the case where a parent is of a type other than Class,
             * but PMCProxy doesn't handle vtable overrides correctly yet. Will
             * have to come back and add it later. */
        }
    }
    return PMCNULL;
}


/*

=back

=head2 Functions

=over 4

=cut

*/

pmclass Class
    need_ext {


/*

=item C<void init()>

Initializes a Class PMC.

=item C<void init_pmc(PMC *init_data)>

The actual class creation code, called from C<newclass> opcode.  The C<init>
argument may either be the name of the class, or a hash of initialization
arguments.  The class is attatched to the current namespace.

=cut

*/

    void init() {
        Parrot_Class *_class    = mem_allocate_zeroed_typed(Parrot_Class);

        /* Set flags for custom DOD mark and destroy. */
        PObj_custom_mark_SET(SELF);
        PObj_active_destroy_SET(SELF);

        /* Set up the object. */
        PMC_data(SELF)          = _class;
        _class->name            = CONST_STRING(interp, "");
        _class->_namespace      = PMCNULL;
        _class->instantiated    = 0;
        _class->parents         = pmc_new(interp, enum_class_ResizablePMCArray);
        _class->all_parents     = pmc_new(interp, enum_class_ResizablePMCArray);
        _class->roles           = pmc_new(interp, enum_class_ResizablePMCArray);
        _class->methods         = pmc_new(interp, enum_class_Hash);
        _class->vtable_overrides  = pmc_new(interp, enum_class_Hash);
        _class->attrib_metadata = pmc_new(interp, enum_class_Hash);
        _class->attrib_index    = PMCNULL;
        _class->attrib_cache    = PMCNULL;
        _class->resolve_method  = pmc_new(interp, enum_class_ResizablePMCArray);

        /* We put ourself on the all parents list. */
        VTABLE_push_pmc(interp, _class->all_parents, SELF);

        /* We are a class. */
        PObj_is_class_SET(SELF);
    }

    void init_pmc(PMC *init_data) {
        PMC           *arg;
        const INTVAL   arg_type = VTABLE_type(interp, init_data);
        STRING * const name_str = CONST_STRING(interp, "name");

        /* Set up the object. */
        SELF.init();

        /* fast attempt to determine init_data type */
        switch (arg_type) {
            case enum_class_String:
            case enum_class_Key:
            case enum_class_NameSpace:
                arg = pmc_new(interp, enum_class_Hash);
                VTABLE_set_pmc_keyed_str(interp, arg, name_str, init_data);
                break;

            case enum_class_Hash:
                arg = init_data;
                break;

            /* slow attempt to determine init_data type */
            default:
                if (VTABLE_isa(interp, init_data, CONST_STRING(interp, "String"))) {
                    arg = pmc_new(interp, enum_class_Hash);
                    VTABLE_set_pmc_keyed_str(interp, arg, name_str, init_data);
                }
                else if (VTABLE_isa(interp, init_data, CONST_STRING(interp, "Key"))) {
                    arg = pmc_new(interp, enum_class_Hash);
                    VTABLE_set_pmc_keyed_str(interp, arg, name_str, init_data);
                }

                if (VTABLE_isa(interp, init_data, CONST_STRING(interp, "Hash"))) {
                    arg = init_data;
                }
                else {
                    arg = pmc_new(interp, enum_class_Hash);
                    VTABLE_set_pmc_keyed_str(interp, arg, name_str, init_data);
                }
                break;
        }

        /* Initialize the class with the supplied data. */
        init_class_from_hash(interp, SELF, arg);
    }

/*

=item C<PMC *subclass(PMC *name)>

Creates a subclass, optionally with a given C<name>.

=cut

*/

    PMC *subclass(PMC *name) {
        PMC *child_class;

        /* Create a new class. Set the classname, if we have one. */
        if (PMC_IS_NULL(name)) {
            child_class = pmc_new(interp, enum_class_Class);
        }
        else {
            PMC *naming_hash = pmc_new(interp, enum_class_Hash);
            VTABLE_set_pmc_keyed_str(interp, naming_hash, CONST_STRING(interp, "name"), name);
            child_class      = pmc_new_init(interp, enum_class_Class,
                naming_hash);
        }

        /* Make the new class a subclass of the current class */
        VTABLE_add_parent(interp, child_class, SELF);

        return child_class;
    }

/*

/*

=item C<void destroy()>

Free the memory associated with the object's underlying struct.

=cut

*/

    void destroy() {
        mem_sys_free(PMC_data(SELF));
    }

/*

=item C<STRING *get_string()>

Return the fully qualified name of the class.

=cut

*/

    STRING *get_string() {
        Parrot_Class * const  _class    = PARROT_CLASS(SELF);
        PMC                  *_namespace = _class->_namespace;
        PMC                  *names;

        if (!PMC_IS_NULL(_namespace)) {
            /* Call the 'get_name' method on the class's associated namespace
             * to retrieve a fully qualified list of names, then join the list
             * with a semicolon.
             */
            names = Parrot_NameSpace_nci_get_name(interp, _namespace);

            if (!PMC_IS_NULL(names))
                return string_join(interp, CONST_STRING(interp, ";"), names);
        }

        /* Otherwise, copy the stored string name of the class. */
        return string_copy(interp, _class->name);
    }

/*

=item C<void mark()>

Mark any referenced strings and PMCs in the structure as live.

=cut

*/

    void mark() {
        Parrot_Class * const _class = PARROT_CLASS(SELF);
        if (_class->name)
            pobject_lives(interp, (PObj*)_class->name);
        if (_class->_namespace)
            pobject_lives(interp, (PObj*)_class->_namespace);
        if (_class->parents)
            pobject_lives(interp, (PObj*)_class->parents);
        if (_class->all_parents)
            pobject_lives(interp, (PObj*)_class->all_parents);
        if (_class->roles)
            pobject_lives(interp, (PObj*)_class->roles);
        if (_class->methods)
            pobject_lives(interp, (PObj*)_class->methods);
        if (_class->vtable_overrides)
            pobject_lives(interp, (PObj*)_class->vtable_overrides);
        if (_class->attrib_metadata)
            pobject_lives(interp, (PObj*)_class->attrib_metadata);
        if (_class->attrib_index)
            pobject_lives(interp, (PObj*)_class->attrib_index);
        if (_class->attrib_cache)
            pobject_lives(interp, (PObj*)_class->attrib_cache);
        if (_class->resolve_method)
            pobject_lives(interp, (PObj*)_class->resolve_method);
    }


/*

=item C<void add_attribute(STRING *name, PMC *type)>

Adds the given attribute (C<name>) with an optional C<type>.
Creates a new class if the current class has been instantiated.
Enters the attribute in the C<attributes> array.
Returns an error if an attribute of C<name> already exists.

=cut

*/

    void add_attribute(STRING *name, PMC *type) {
        Parrot_Class * const _class        = PARROT_CLASS(SELF);
        PMC          * const new_attribute = pmc_new(interp, enum_class_Hash);

        /* If we've been instantiated already, need a new class. */
        if (_class->instantiated) {
            /* XXX Unimplemented! */
            real_exception(interp, NULL, E_NotImplementedError,
                "Modifications to already instantiated classes not allowed yet.");
        }

        /* If we already have an attribute of this name, it's an error. */
        if (VTABLE_exists_keyed_str(interp, _class->attrib_metadata, name))
            real_exception(interp, NULL, INVALID_OPERATION,
                "Attribute '%s' already exists.",
                string_to_cstring(interp, name));

        /* Set name and type. */
        VTABLE_set_string_keyed_str(interp, new_attribute, CONST_STRING(interp, "name"), name);

        if (!PMC_IS_NULL(type))
            VTABLE_set_pmc_keyed_str(interp, new_attribute, CONST_STRING(interp, "type"), type);

        /* Enter the attribute in the attributes array. */
        VTABLE_set_pmc_keyed_str(interp, _class->attrib_metadata, name,
            new_attribute);
    }

/*

=item C<void add_method(STRING *name, PMC *sub)>

Adds the given sub PMC as a method with the given name.

=cut

*/
    void add_method(STRING *name, PMC *sub) {
        Parrot_Class * const _class = PARROT_CLASS(SELF);

        /* If we have already added a method with this name... */
        if (VTABLE_exists_keyed_str(interp, _class->methods, name)) {
            /* XXX Need to handle multi methods here. */
            real_exception(interp, NULL, E_NotImplementedError,
                "A method of this name already exists. It may have been supplied by a role.");
        }

        /* Enter it into the table. */
        VTABLE_set_pmc_keyed_str(interp, _class->methods, name, sub);
    }

/*

=item C<void add_vtable_override(STRING *name, PMC *sub)>

Adds the given sub PMC as a vtable override with the given name.

=cut

*/
    void add_vtable_override(STRING *name, PMC *sub) {
        Parrot_Class * const _class = PARROT_CLASS(SELF);
        char *c_name = string_to_cstring(interp, name);
        int found = 0;
        int i;

        /* If we have already added a vtable override with this name... */
        if (VTABLE_exists_keyed_str(interp, _class->vtable_overrides, name)) {
            real_exception(interp, NULL, E_NotImplementedError,
                "A vtable override of this name already exists. It may have been supplied by a role.");
        }

        /* Check name is a valid vtable method name. */
        for (i = PARROT_VTABLE_LOW; i < NUM_VTABLE_FUNCTIONS; i++) {
            if (strcmp(c_name, Parrot_vtable_slot_names[i] + 2) == 0) {
                found = 1;
                break;
            }
        }
        if (!found)
            real_exception(interp, NULL, METH_NOT_FOUND,
                "'%S' is not a valid vtable function name.", name);

        /* Add it to vtable methods list. */
        VTABLE_set_pmc_keyed_str(interp, _class->vtable_overrides, name, sub);
    }

/*

=item C<void add_parent(PMC *parent)>

Adds the supplied PMC to the list of parents for the class.

=cut

*/
    void add_parent(PMC *parent) {
        Parrot_Class * const _class = PARROT_CLASS(SELF);

        /* If we've been instantiated already, need a new class. */
        if (_class->instantiated) {
            /* XXX Unimplemented! */
            real_exception(interp, NULL, E_NotImplementedError,
                "Modifications to already instantiated classes not allowed yet.");
            return;
        }

        /* Ensure it really is a class. */
        if (!PObj_is_class_TEST(parent)) {
            real_exception(interp, NULL, E_TypeError, "Parent isn't a Class.");
            return;
        }

        /* XXX Check we don't already have this parent. */

        /* Add to the list of our immediate parents. */
        VTABLE_push_pmc(interp, _class->parents, parent);
    }

/*

=item C<void add_role(PMC *role)>

Adds the supplied PMC to the list of roles for the class, provided there are
no conflicts.

=cut

*/
    void add_role(PMC *role) {
        Parrot_Class * const _class = PARROT_CLASS(SELF);

        /* Do the composition. */
        Parrot_ComposeRole(interp, role, PMCNULL, 0, PMCNULL, 0,
                           _class->methods, _class->roles);
    }

/*

=item C<PMC *inspect_str(STRING *what)>

Provides introspection of a specific piece of information about the class. The
available information is:

=over 8

=item name

String PMC containing the name of the class

=item namespace

NameSpace PMC of the the namespace attached to the class

=item attributes

Hash keyed on attribute name, value is hash describing it

=item methods

Hash keyed on method name, value is an invokable PMC. Includes methods composed
in from roles.

=item roles

Array of Role PMCs. Includes roles done by the roles that were composed into
this class.

=item parents

Array of Class PMCs representing the direct parents of this class.

=back

=cut

*/
    PMC *inspect_str(STRING *what) {
        Parrot_Class *_class = PARROT_CLASS(SELF);

        /* What should we return? */
        PMC          *found  = PMCNULL;

        if (string_equal(interp, what, CONST_STRING(interp, "name")) == 0) {
            found = pmc_new(interp, enum_class_String);
            VTABLE_set_string_native(interp, found, _class->name);
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "namespace")) == 0) {
            /* Should not clone this. */
            return _class->_namespace;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "attributes")) == 0) {
            found = _class->attrib_metadata;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "methods")) == 0) {
            found = _class->methods;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "parents")) == 0) {
            found = _class->parents;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "roles")) == 0) {
            found = _class->roles;
        }
        else {
            real_exception(interp, NULL, INVALID_OPERATION,
                "Unknown introspection value '%S'", what);
        }

        /* Clone and return. */
        return PMC_IS_NULL(found) ? PMCNULL : VTABLE_clone(interp, found);
    }

/*

=item C<PMC *inspect()>

Returns a Hash describing the class, with key/value pairs as described in
inspect_str.

=cut

*/
    PMC *inspect() {
        /* Create a hash, then use inspect_str to get all of the data to
         * fill it up with. */
        PMC    *metadata    = pmc_new(interp, enum_class_Hash);
        STRING *name_str    = CONST_STRING(interp, "name");
        STRING *ns_str      = CONST_STRING(interp, "namespace");
        STRING *attrs_str   = CONST_STRING(interp, "attributes");
        STRING *meths_str   = CONST_STRING(interp, "methods");
        STRING *parents_str = CONST_STRING(interp, "parents");
        STRING *roles_str   = CONST_STRING(interp, "roles");

        VTABLE_set_pmc_keyed_str(interp, metadata, name_str,
            VTABLE_inspect_str(interp, SELF, name_str));

        VTABLE_set_pmc_keyed_str(interp, metadata, ns_str,
            VTABLE_inspect_str(interp, SELF, ns_str));

        VTABLE_set_pmc_keyed_str(interp, metadata, attrs_str,
            VTABLE_inspect_str(interp, SELF, attrs_str));

        VTABLE_set_pmc_keyed_str(interp, metadata, meths_str,
            VTABLE_inspect_str(interp, SELF, meths_str));

        VTABLE_set_pmc_keyed_str(interp, metadata, parents_str,
            VTABLE_inspect_str(interp, SELF, parents_str));

        VTABLE_set_pmc_keyed_str(interp, metadata, roles_str,
            VTABLE_inspect_str(interp, SELF, roles_str));

        return metadata;
    }

/*

=item C<PMC *clone()>

Returns an anonymous copy of the class (with no name and no link to a
namespace). Unsets the instantiated flag, allowing modifications.

=cut

*/

    PMC *clone() {
        Parrot_Class *_class = PARROT_CLASS(SELF);

        /* Create the new class PMC, of the same type of this one (we may
         * have been subclassed). */
        PMC          *copy  = pmc_new(interp, SELF->vtable->base_type);

        /* Clone parents, roles, methods, attributes and resolve data. We do
         * not copy name/namespace related stuff (need anonymous clone) or
         * stuff that gets computed on the first instantiation. */

        Parrot_Class *new_class    = PARROT_CLASS(copy);

        new_class->parents         = VTABLE_clone(interp, _class->parents);
        new_class->roles           = VTABLE_clone(interp, _class->roles);
        new_class->methods         = VTABLE_clone(interp, _class->methods);
        new_class->vtable_overrides  = VTABLE_clone(interp,
                                                  _class->vtable_overrides);
        new_class->attrib_metadata = VTABLE_clone(interp,
                                                  _class->attrib_metadata);
        new_class->resolve_method  = VTABLE_clone(interp,
                                                  _class->resolve_method);

        /* Return cloned class. */
        return copy;
    }

/*

=item C<PMC *clone_pmc(PMC *args)>

Makes a copy of the class, then modifies or adds to it based upon the contents
of the supplied initialization data. If a new name or namespace is not supplied
in C<args> then the cloned class will be anonymous. The instantiated flag is
unset to allow further modifications.

=cut

*/

    PMC *clone_pmc(PMC *args) {
        /* Do the standard clone. */
        PMC *copy = DYNSELF.clone();

        init_class_from_hash(interp, copy, args);

        return copy;
    }

/*

=item C<PMC *instantiate(PMC *init)>

Creates a new PMC object of the type of the class and calls init().

=cut

*/

    PMC *instantiate(PMC *init) {
        Parrot_Object *obj_guts  = NULL;
        Parrot_Class  *_class    = PARROT_CLASS(SELF);
        STRING * const class_str = string_from_cstring(interp, "Class", 5);
        PMC           *iter, *object;

        int            i, mro_length;

        object = PMCNULL;

        /* If we've not been instantiated before... */
        if (!_class->instantiated) {
            int resolve_count;

            /* Pull in methods from the namespace, if any. */
            if (!PMC_IS_NULL(_class->_namespace)) {
                PMC *methods, *vtable_overrides;
                PMC *ns = _class->_namespace;

                /* Import any methods. */
                (PMC *methods) = PCCINVOKE(interp, ns,
                    "get_associated_methods");
                if (!PMC_IS_NULL(methods)) {
                    PMC *iter = VTABLE_get_iter(interp, methods);
                    while (VTABLE_get_bool(interp, iter)) {
                        STRING *meth_name = VTABLE_shift_string(interp, iter);
                        PMC *meth_sub = VTABLE_get_pmc_keyed_str(interp, methods,
                            meth_name);
                        VTABLE_add_method(interp, SELF, meth_name, meth_sub);
                    }
                }

                /* Import any vtable methods. */
                (PMC *vtable_overrides) = PCCINVOKE(interp, ns,
                    "get_associated_vtable_methods");
                if (!PMC_IS_NULL(vtable_overrides)) {
                    PMC *iter = VTABLE_get_iter(interp, vtable_overrides);
                    while (VTABLE_get_bool(interp, iter)) {
                        STRING *vtable_index_str = VTABLE_shift_string(interp, iter);
                        PMC *vtable_sub = VTABLE_get_pmc_keyed_str(interp, vtable_overrides,
                            vtable_index_str);
                        /* Look up the name of the vtable function from the index. */
                        INTVAL vtable_index = string_to_int(interp, vtable_index_str);
                        const char * const meth_c = Parrot_vtable_slot_names[vtable_index];
                        STRING *vtable_name = string_from_cstring(interp, meth_c, 0);

                        /* Strip leading underscores in the vtable name */
                        if (string_str_index(interp, vtable_name,
                            CONST_STRING(interp, "__"), 0) == 0) {
                            vtable_name = string_substr(interp, vtable_name, 2,
                                string_length(interp, vtable_name) - 2, NULL, 0);
                        }

                        VTABLE_add_vtable_override(interp, SELF, vtable_name, vtable_sub);
                    }
                }
            }

            /* Check that we have all methods listed in resolve list. */
            resolve_count = VTABLE_elements(interp, _class->resolve_method);
            for (i = 0; i < resolve_count; i++) {
                STRING *check_meth = VTABLE_get_string_keyed_int(interp,
                    _class->resolve_method, i);
                if (!VTABLE_exists_keyed_str(interp, _class->methods, check_meth)) {
                    real_exception(interp, NULL, METH_NOT_FOUND,
                        "The method '%S' was named in the resolve list, but not supplied",
                        check_meth);
                }
            }

            /* Build full parents list.
             * XXX Need pluggable MRO, for now always do C3. */
            _class->all_parents = Parrot_ComputeMRO_C3(interp, SELF);

            build_attrib_index(interp, SELF);

            if (PMC_IS_NULL(_class->attrib_index))
                return object;

            /* See if we have any parents from other universes and if so set a
             * flag stating so. */
            mro_length = VTABLE_elements(interp, _class->all_parents);

            for (i = 0; i < mro_length; i++) {
                PMC * const class_check = VTABLE_get_pmc_keyed_int(interp,
                    _class->all_parents, i);
                if (!VTABLE_isa(interp, class_check, class_str)) {
                    /* Found one; that's enough. */
                    PObj_HasAlienParents_SET(SELF);
                    break;
                }
            }
        }

        /* Set instantiated flag. */
        _class->instantiated = 1;

        /* Create object. */
        object = pmc_new_noinit(interp, enum_class_Object);

        /* Set custom DOD mark and destroy on the object. */
        PObj_custom_mark_SET(object);
        PObj_active_destroy_SET(object);

        /* Initialize the object's underlying structure, pointing it to this
         * class. */
        obj_guts               = mem_allocate_zeroed_typed(Parrot_Object);
        obj_guts->_class       = SELF;
        obj_guts->attrib_store = pmc_new(interp, enum_class_ResizablePMCArray);
        PMC_data(object)       = obj_guts;

        if (!PMC_IS_NULL(init)) {
            /* Initialize attributes with the supplied values. */
            iter = VTABLE_get_iter(interp, init);

            while (VTABLE_get_bool(interp, iter)) {
                /* Get name and value. */
                STRING * const attr_name  = VTABLE_shift_string(interp, iter);
                PMC    * const attr_value = VTABLE_get_pmc_keyed_str(interp, init,
                    attr_name);

                /* Set the attribute. */
                VTABLE_set_attr_str(interp, object, attr_name, attr_value);
            }
        }

        /* If we have parents that are out of this class universe, find them
         * in the MRO and create instances of them. */
        if (PObj_HasAlienParents_TEST(SELF)) {
            mro_length = VTABLE_elements(interp, _class->all_parents);

            for (i = 0; i < mro_length; i++) {
                PMC * const class_check = VTABLE_get_pmc_keyed_int(interp,
                    _class->all_parents, i);

                if (!VTABLE_isa(interp, class_check, class_str)) {
                    /* From another universe. Create instance... */
                    PMC *parent_ins;
                    int  position;

                    parent_ins = VTABLE_instantiate(interp, class_check, PMCNULL);

                    /* Associate it with this class as the real self. */
                    parent_ins->real_self = object;

                    /* ...and tack on end of the attribute store (after all the
                     * slots for attributes). */
                    position = VTABLE_elements(interp, obj_guts->attrib_store);
                    VTABLE_set_pmc_keyed_int(interp, obj_guts->attrib_store,
                        position, parent_ins);
                }
            }
        }

        /* Check for overrides on the init or init_pmc vtable function and call
         * them if they exist */
        if (PMC_IS_NULL(init)) {
            STRING *name = string_from_literal(interp, "init");
            PMC *meth = find_vtable_override(interp, SELF, name);
            if (!PMC_IS_NULL(meth)) {
                Parrot_run_meth_fromc_args(interp, meth,
                        object, name, "v");
            }
        }
        else {
            STRING *name = string_from_literal(interp, "init_pmc");
            PMC *meth = find_vtable_override(interp, SELF, name);
            if (!PMC_IS_NULL(meth)) {
                Parrot_run_meth_fromc_args(interp, meth,
                        object, name, "vP", init);
            }
        }

        return object;
    }


/*

=item C<INTVAL isa(STRING *classname)>

Returns whether the class is or inherits from C<*classname>.

=cut

*/

    INTVAL isa(STRING *classname) {
        Parrot_Class *_class      = PARROT_CLASS(SELF);
        INTVAL        i, num_classes;

        if (SUPER(classname))
            return 1;

        /* Check if the passed name is the same as the stored short name. */
        if (string_equal(interp, classname, _class->name) == 0)
            return 1;

        /* Check if the passed name is the same as the fully qualified name. */
        if (string_equal(interp, classname, VTABLE_get_string(interp, SELF)) == 0)
            return 1;

        /* Iterate over all the parents and check if they respond true
         * for 'isa' on the classname.
         */
        num_classes = VTABLE_elements(interp, _class->parents);
        for (i = 0; i < num_classes; i++) {
            PMC *cur_class = VTABLE_get_pmc_keyed_int(interp, _class->parents, i);
            if (VTABLE_isa(interp, cur_class, classname))
                return 1;
        }

        return 0;
    }

    /* **********************************************************************
     * Below here are non-vtable methods that eventually will go in a role
     * that is composed into here to optionally give a nice interface from
     * PIR (ParrotClass isa Class does ClassMethods or something like this).
     * **********************************************************************/

/*

=item C<void name(STRING *name :optional, int has_name :opt_flag)>

Sets the name of the class, and updates the namespace accoringly.

=cut

*/
    PCCMETHOD name(STRING *name :optional, int has_name :opt_flag) {
        Parrot_Class *_class   = PARROT_CLASS(SELF);
        STRING       *ret_name = NULL;

        if (has_name) {
            /* We'll build a hash just containing the name, then give this to
             * init_class_from_hash - saves some code duplication. */
            PMC *naming_hash = pmc_new(interp, enum_class_Hash);

            VTABLE_set_string_keyed_str(interp, naming_hash, CONST_STRING(interp, "name"), name);
            init_class_from_hash(interp, SELF, naming_hash);
        }

        ret_name = _class->name;
        PCCRETURN(STRING *ret_name);
    }

/*

=item C<void pmc_namespace()>

Gets the namespace that this class is attached to.

=cut

*/
    PCCMETHOD pmc_namespace(PMC *_namespace :optional, int has_name :opt_flag) {
        Parrot_Class *_class        = PARROT_CLASS(SELF);
        PMC          *ret_namespace = _class->_namespace;
        UNUSED(_namespace);
        UNUSED(has_name);
        PCCRETURN(PMC *ret_namespace);
    }

/*

=item C<void resolve_method()>

Sets the list of method names that the class provides to resolve conflicts in
methods from roles. When called with no parameter, returns the list.

=cut

*/
    PCCMETHOD resolve_method(PMC *resolve_list :optional,
                                  int has_list :opt_flag) {
        Parrot_Class *_class   = PARROT_CLASS(SELF);
        PMC          *ret_list = NULL;

        /* Store list. */
        if (has_list)
            _class->resolve_method = resolve_list;

        ret_list = _class->resolve_method;
        PCCRETURN(PMC *ret_list);
    }

/*

=item C<void new(PMC *args :slurpy :named)>

Creates an instance of the object. Initializes any attributes specified in the
parameter list.

=cut

*/
    PCCMETHOD new(PMC *args :slurpy :named) {
        PMC *obj = VTABLE_instantiate(interp, SELF, args);
        PCCRETURN(PMC *obj);
     }

/*

=item C<void attributes()>

Return a hash where the keys are attribute names and the values are hashes
providing a set of key/value pairs describing the attribute.

=cut

*/
    PCCMETHOD attributes() {
        PMC *ret_attrib_metadata = DYNSELF.inspect_str(
            CONST_STRING(interp, "attributes"));

        PCCRETURN(PMC *ret_attrib_metadata);
    }

/*

=item C<void add_attribute()>

Add an attribute to the class. Requires a name and, optionally, a type.

=cut

*/
    PCCMETHOD add_attribute(STRING *attribute_name,
            PMC *attribute_type :optional, int has_type :opt_flag) {
        PMC *type = has_type ? attribute_type : PMCNULL;
        DYNSELF.add_attribute(attribute_name, type);
    }

/*

=item C<void methods()>

Return a hash where the keys are method names and the values are methods.

=cut

*/
    PCCMETHOD methods() {
        PMC *ret_methods = DYNSELF.inspect_str(CONST_STRING(interp, "methods"));

        PCCRETURN(PMC *ret_methods);
    }

/*

=item C<void add_method(STRING *name, PMC *sub)>

Adds the given sub PMC as a method with the given name. Delegates to the
C<add_method> vtable method.

=cut

*/
    PCCMETHOD add_method(STRING *name, PMC *sub,
                              int vtable :optional :named["vtable"],
                              int has_vtable :opt_flag,
                              int anon :optional :named["anon"],
                              int has_anon :opt_flag)
    {
        /* If it's a vtable method... */
        if (has_vtable && vtable) {
            VTABLE_add_vtable_override(interp, SELF, name, sub);
        }

        /* Provided it's not anonymous, add it to the methods list. */
        if (!has_anon || !anon)
            DYNSELF.add_method(name, sub);
    }

/*

=item C<PMC *find_method(STRING *name)>

Walks the MRO of the class and finds the method with the given name.

*/

    PCCMETHOD find_method(STRING *name) {
        Parrot_Class * const  _class    = PARROT_CLASS(SELF);
        PMC                  *_namespace = _class->_namespace;
        int num_classes, i;

        if (  ! PMC_IS_NULL(_namespace)
            &&  VTABLE_exists_keyed_str(interp, _namespace, name)) {
            PMC *ret = VTABLE_get_pmc_keyed_str(interp, _namespace, name);
            PCCRETURN(PMC *ret);
        }

        /* Walk and search. One day, we'll use the cache first. */
        num_classes = VTABLE_elements(interp, _class->all_parents);

        for (i = 0; i < num_classes; i++) {
            /* Get the class and see if it has the method. */
            PMC * const cur_class =
                VTABLE_get_pmc_keyed_int(interp, _class->all_parents, i);
            const Parrot_Class * const class_info = PARROT_CLASS(cur_class);

            /* Found it! */
            if (VTABLE_exists_keyed_str(interp, class_info->methods, name)) {
                PMC *ret = VTABLE_get_pmc_keyed_str(interp, class_info->methods,
                    name);
                PCCRETURN(PMC *ret);
            }
        }

        PCCRETURN(PMC *PMCNULL);
    }

/*

=item C<void parents()>

Return the parents array PMC.

=cut

*/
    PCCMETHOD parents() {
        PMC *ret_parents = DYNSELF.inspect_str(CONST_STRING(interp, "parents"));

        PCCRETURN(PMC *ret_parents);
    }

/*

=item C<void add_parent(PMC *parent)>

Adds the supplied PMC to the list of parents for the class.

=cut

*/
    PCCMETHOD add_parent(PMC *parent) {
        DYNSELF.add_parent(parent);
    }

/*

=item C<void roles()>

Return the roles array PMC.

=cut

*/
    PCCMETHOD roles() {
        PMC *ret_roles = DYNSELF.inspect_str(CONST_STRING(interp, "roles"));

        PCCRETURN(PMC *ret_roles);
    }

/*

=item C<void add_role(PMC *role, PMC *exclude :optional :named["exclude"],
PMC *alias :optional :named["alias"])>

Compose a role into a class with the given exclusions and aliases.

=cut

*/
    PCCMETHOD add_role(PMC *role,
            PMC *exclude_method     :optional :named["exclude_method"],
            int has_exclude_method  :opt_flag,
            PMC *alias_method       :optional :named["alias_method"],
            int has_alias_method    :opt_flag) {

        Parrot_Class *_class = PARROT_CLASS(SELF);

        /* Add everything on the resolve list to the exclude list; if we have
         * no exclude list, pass along the resolve list in its place if it has
         * any methods listed in it. */
        if (!has_exclude_method) {
            if (VTABLE_elements(interp, _class->resolve_method) != 0) {
                exclude_method     = _class->resolve_method;
                has_exclude_method = 1;
            }
        }
        else {
            int resolve_count = VTABLE_elements(interp, _class->resolve_method);
            int i;

            for (i = 0; i < resolve_count; i++) {
                STRING *meth_name = VTABLE_get_string_keyed_int(interp,
                    _class->resolve_method, i);
                VTABLE_push_string(interp, exclude_method, meth_name);
            }
        }

        /* Do the composition. */
        Parrot_ComposeRole(interp, role, exclude_method, has_exclude_method,
                           alias_method, has_alias_method,
                           _class->methods, _class->roles);
    }

/*

=item C<void inspect(STRING *what :optional)>

Gets all introspection data for the class or, if the optional string
parameter is supplied, a particular item of introspection data.

=cut

*/
    PCCMETHOD inspect(STRING *what :optional, int has_what :opt_flag) {
        PMC *found;

        /* Just delegate to the appropriate vtable method. */
        if (has_what)
            found = DYNSELF.inspect_str(what);
        else
            found = DYNSELF.inspect();

        PCCRETURN(PMC *found);
    }

/*

=item C<void isa(STRING *class_name)>

Returns true if this object is or derives from the class named in
C<class_name>, false otherwise.

=cut

*/
    PCCMETHOD isa(STRING *class_name) {
        INTVAL isa = DYNSELF.isa(class_name);

        PCCRETURN(INTVAL isa);
    }

/*

=item C<void does(STRING *role_name)>

Returns true if this object or one of its parents performs the named role,
false otherwise.

=cut

*/
    PCCMETHOD does(STRING *role_name) {
        INTVAL i, role_count, isa;
        PMC *role_list = (PMC_data_typed(SELF, Parrot_Class *))->roles;

        if (!role_list)
            PCCRETURN(INTVAL 0);

        role_count = VTABLE_elements(interp, role_list);

        for (i = 0; i < role_count; i++) {
            INTVAL  role_does;
            PMC    *role       = VTABLE_get_pmc_keyed_int(interp, role_list, i);

            (INTVAL role_does) = PCCINVOKE(interp, role, "does",
                                           STRING *role_name);

            if (role_does)
                PCCRETURN(INTVAL 1);
        }

        (INTVAL isa) = PCCINVOKE(interp, SELF, "isa", STRING *role_name);

        PCCRETURN(INTVAL isa);
    }
} /* END pmclass */

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd15_objects.pod>.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
