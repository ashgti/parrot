/*
Copyright (C) 2001-2007, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/class.pmc - defines a class

=head1 DESCRIPTION

This class implements the basic Parrot class PMC, used for describing a
class.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "pmc_namespace.h"
#define PARROT_CLASS(o) ((Parrot_Class *) PMC_data(o))


/* This is the underlying structure of this PMC. */
typedef struct Parrot_Class {
    STRING *name;         /* The name of the class. */
    PMC *namespace;       /* The namespace it's linked to, if any. */
    int instantiated;     /* Any instantiations since last modification? */
    PMC *parents;         /* Immediate parent classes. */
    PMC *all_parents;     /* Cached list of ourself and all parents, in MRO order. */
    PMC *roles;           /* An array of roles. */
    PMC *methods;         /* Hash of method names to methods in this class. */
    PMC *vtable_methods;  /* Hash of Parrot v-table methods we override. */
    PMC *attrib_metadata; /* Hash of attributes in this class to hashes of metadata. */
    PMC *attrib_index;    /* Lookup table for attributes in this and parents. */
    PMC *attrib_cache;    /* Cache of visible attrib names to indexes. */
    PMC *resolve;         /* List of method names the class provides to resolve
                           * conflicts with methods from roles. */
} Parrot_Class;


/* Build a string representing the fully qualified class name. */
static STRING* get_fq_classname(Parrot_Interp interp, Parrot_Class *class_info) {
    STRING *fq_class = string_from_cstring(interp, "", 0);
    STRING *seperator = string_from_const_cstring(interp, "::", 0);
    if (!PMC_IS_NULL(class_info->namespace)) {
        /* If we have a namespace name, make a key from it's name. */
        /* XXX BAD AND WRONG! Need to call get_name method properly! */
        PMC *fq_name = Parrot_NameSpace_nci_get_name(interp, class_info->namespace);
        int elements = VTABLE_elements(interp, fq_name);
        int j;
        for (j = 0; j < elements; j++) {
            /* Append to class name. */
            fq_class = string_append(interp, fq_class,
                VTABLE_get_string_keyed_int(interp, fq_name, j));
            fq_class = string_append(interp, fq_class, seperator);
        }
    } else if (class_info->name != NULL) {
        /* If we don't have a namespace but we do have a name,
         * use that. XXX Is this sensible? */
        fq_class = string_copy(interp, class_info->name);
    }
    return fq_class;
}

/* This function builds the attribute index (table to map class name and
 * attribute name to an index) for the current class. */
static void build_attrib_index(Parrot_Interp interp, PMC *self) {
    Parrot_Class *class = PARROT_CLASS(self);
    int num_classes = VTABLE_elements(interp, class->all_parents);
    int i;
    int cur_index = 0;
    PMC *table = pmc_new(interp, enum_class_Hash);

    /* We will go over the list of all parents to construct the table. */
    for (i = 0; i < num_classes; i++) {
       /* Get the class and its attribute metadata hash. */
        PMC *cur_class = VTABLE_get_pmc_keyed_int(interp, class->all_parents, i);
        Parrot_Class *class_info = PARROT_CLASS(cur_class);
        PMC *attribs = class_info->attrib_metadata;
        PMC *iter = VTABLE_get_iter(interp, attribs);

        /* Build a string representing the fully qualified class name. */
        STRING *fq_class = get_fq_classname(interp, class_info);

        /* Iterate over the attributes. */
        while (VTABLE_get_bool(interp, iter)) {
            /* Get attribute. */
            PMC *cur_attrib = VTABLE_get_pmc_keyed_str(interp, attribs,
                VTABLE_shift_string(interp, iter));
            STRING *attrib_name;
            STRING *full_key = string_copy(interp, fq_class);

            /* Get attribute name and append it to the key. */
            attrib_name = VTABLE_get_string_keyed_str(interp, cur_attrib,
                string_from_const_cstring(interp, "name", 0));
            full_key = string_append(interp, full_key, attrib_name);

            /* Insert into hash, along with index. */
            VTABLE_set_integer_keyed_str(interp, table, full_key, cur_index);
            cur_index++;
        }
    }

    /* Store built table and invalidate cache. */
    class->attrib_index = table;
    class->attrib_cache = pmc_new(interp, enum_class_Hash);
}


pmclass Class need_ext {
/*

=item C<void init()>

Initializes the class.

=item C<void init_pmc(PMC *name)>

The actual class creation code, called from C<newclass> opcode. The C<init>
argument should stringify to the C<classname>. The class will be attatched to
the current namespace.

=cut

*/

    void init() {
        Parrot_Class *class = NULL;

        /* Custom DOD mark and destroy. */
        PObj_custom_mark_SET(SELF);
        PObj_active_destroy_SET(SELF);

        /* We are a class. */
        PObj_is_class_SET(SELF);

        /* Init the class object. */
        class = mem_sys_allocate_zeroed(sizeof(Parrot_Class));
        class->name = CONST_STRING(interp, "");
        class->namespace = PMCNULL;
        class->parents = pmc_new(interp, enum_class_ResizablePMCArray);
        class->all_parents = pmc_new(interp, enum_class_ResizablePMCArray);
        class->roles = pmc_new(interp, enum_class_ResizablePMCArray);
        class->methods = pmc_new(interp, enum_class_Hash);
        class->vtable_methods = pmc_new(interp, enum_class_Hash);
        class->attrib_metadata = pmc_new(interp, enum_class_Hash);
        class->attrib_index = PMCNULL;
        class->attrib_cache = PMCNULL;
        class->resolve = pmc_new(interp, enum_class_ResizablePMCArray);

        /* We put ourself on the all parents list. */
        VTABLE_push_pmc(interp, class->all_parents, SELF);

        PMC_data(SELF) = class;
    }

    void init_pmc(PMC* name) {
        Parrot_Class *class = NULL;

        /* Set up the object. */
        SELF.init();

        /* Set name and namespace. */
        class = PARROT_CLASS(SELF);
        class->name = VTABLE_get_string(interp, name);
        class->namespace = CONTEXT(interp->ctx)->current_namespace;
    }

/*

=item C<void destroy()>

Free the memory associated with the underlying struct.

=cut

*/
    void destroy() {
            mem_sys_free(PMC_data(SELF));
    }

/*

=item C<void mark()>

Mark any referenced strings and PMCs.

=cut

*/
    void mark() {
        Parrot_Class *class = PARROT_CLASS(SELF);
        if (class->name)
            pobject_lives(interp, (PObj*)class->name);
        if (class->namespace)
            pobject_lives(interp, (PObj*)class->namespace);
        if (class->parents)
            pobject_lives(interp, (PObj*)class->parents);
        if (class->all_parents)
            pobject_lives(interp, (PObj*)class->all_parents);
        if (class->roles)
            pobject_lives(interp, (PObj*)class->roles);
        if (class->methods)
            pobject_lives(interp, (PObj*)class->methods);
        if (class->vtable_methods)
            pobject_lives(interp, (PObj*)class->vtable_methods);
        if (class->attrib_metadata)
            pobject_lives(interp, (PObj*)class->attrib_metadata);
        if (class->attrib_index)
            pobject_lives(interp, (PObj*)class->attrib_index);
        if (class->attrib_cache)
            pobject_lives(interp, (PObj*)class->attrib_cache);
        if (class->resolve)
            pobject_lives(interp, (PObj*)class->resolve);
    }

/*

=item C<void add_attribute(STRING *name, PMC *type)>

Adds the given attribute with an optional type.

=cut

*/
    void add_attribute(STRING *name, PMC *type)
    {
        Parrot_Class *class = PARROT_CLASS(SELF);
        PMC *new_attribute = pmc_new(interp, enum_class_Hash);

        /* If we've been instantiated already, need a new class. */
        if (class->instantiated) {
            /* XXX Unimplemented! */
            real_exception(interp, NULL, E_NotImplementedError,
                "Modifications to already instantiated classes not allowed yet.");
        }

        /* If we've already got an attribute of this name, it's an error. */
        if (VTABLE_exists_keyed_str(interp, class->attrib_metadata, name)) {
            real_exception(interp, NULL, INVALID_OPERATION,
                "An attribute of this name already exists.");
        }

        /* Set name and type. */
        VTABLE_set_string_keyed_str(interp, new_attribute,
            CONST_STRING(interp, "name"), name);
        if (!PMC_IS_NULL(type)) {
            VTABLE_set_pmc_keyed_str(interp, new_attribute,
                CONST_STRING(interp, "type"), type);
        }

        /* Enter the attribute in the attributes array. */
        VTABLE_set_pmc_keyed_str(interp, class->attrib_metadata, name, new_attribute);
    }

/*

=item C<void add_method(STRING *name, PMC *sub)>

Adds the given sub PMC as a method with the given name.

=cut

*/
    void add_method(STRING *name, PMC *sub)
    {
        Parrot_Class *class = PARROT_CLASS(SELF);

        /* If we have already added a method with this name... */
        if (VTABLE_exists_keyed_str(interp, class->methods, name)) {
            /* XXX Need to handle multi methods here. */
            real_exception(interp, NULL, E_NotImplementedError,
                "A method of this name already exists. It may have been supplied by a role.");
        }
        else {
            /* Enter it into the table. */
            VTABLE_set_pmc_keyed_str(interp, class->methods, name, sub);
        }
    }

/*

=item C<void add_parent(PMC *parent)>

Adds the supplied PMC to the list of parents for the class.

=cut

*/
    void add_parent(PMC *parent)
    {
        Parrot_Class *class = PARROT_CLASS(SELF);

        /* If we've been instantiated already, need a new class. */
        if (class->instantiated) {
            /* XXX Unimplemented! */
            real_exception(interp, NULL, E_NotImplementedError,
                "Modifications to already instantiated classes not allowed yet.");
            return;
        }

        /* Ensure it really is a class. */
        if (!PObj_is_class_TEST(parent)) {
            real_exception(interp, NULL, E_TypeError,
                "You can only add a class as a parent to another class.");
            return;
        }

        /* XXX Check we don't already have this parent. */

        /* Add to the list of our immediate parents. */
        VTABLE_push_pmc(interp, class->parents, parent);
    }

/*

=item C<void add_role(PMC *role)>

Adds the supplied PMC to the list of roles for the class, provided there are
no conflicts.

=cut

*/
    void add_role(PMC *role)
    {
        Parrot_Class *class = PARROT_CLASS(SELF);

        /* Do the composition. */
        Parrot_ComposeRole(interp, role, PMCNULL, 0, PMCNULL, 0,
                           class->methods, class->roles);
    }

/*

=item C<PMC* inspect_str(STRING *what)>

Provides introspection of a specific piece of information about the class. The
available information is:

=over 8

=item name

String PMC containing the name of the class

=item namespce

NameSpace PMC of the the namespace attached to the class

=item attributes

Hash keyed on attribute name, value is hash describing it

=item methods

Hash keyed on method name, value is an invokable PMC. Includes methods composed
in from roles.

=item roles

Array of Role PMCs. Includes roles done by the roles that were composed into
this class.

=item parents

Array of Class PMCs representing the direct parents of this class.

=back

=cut

*/
    PMC* inspect_str(STRING *what)
    {
        Parrot_Class *class = PARROT_CLASS(SELF);

        /* What should we return? */
        PMC *found;
        if (string_equal(interp, what, CONST_STRING(interp, "name")) == 0) {
            found = pmc_new(interp, enum_class_String);
            VTABLE_set_string_native(interp, found, class->name);
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "namespace")) == 0) {
            found = class->namespace;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "attributes")) == 0) {
            found = class->attrib_metadata;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "methods")) == 0) {
            found = class->methods;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "parents")) == 0) {
            found = class->parents;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "roles")) == 0) {
            found = class->roles;
        }
        else {
            real_exception(interp, NULL, INVALID_OPERATION,
                "Unknown introspection value '%S'", what);
        }

        /* Clone and return. */
        return VTABLE_clone(interp, found);
    }

/*

=item C<PMC* inspect()>

Returns a Hash describing the class, with key/value pairs as described in
inspect_str.

=cut

*/
    PMC* inspect()
    {
        /* Create a hash, then use inspect_str to get all of the data to
         * fill it up with. */
        PMC *metadata = pmc_new(interp, enum_class_Hash);
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "name"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "name")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "namespace"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "namespace")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "attributes"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "attributes")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "methods"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "methods")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "parents"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "parents")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "roles"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "roles")));
        return metadata;
    }

    /* **********************************************************************
     * Below here are non-vtable methods that eventually will go in a role
     * that is composed into here to optionally give a nice interface from
     * PIR (ParrotClass isa Class does ClassMethods or something like this).
     * **********************************************************************/

/*

=item C<void name(STRING *name :optional, int got_name :opt_flag)>

Sets the name of the class.

=cut

*/
    PCCMETHOD void name(STRING *name :optional, int got_name :opt_flag) {
        Parrot_Class *class = PARROT_CLASS(SELF);
        STRING *ret_name = NULL;

        if (got_name) {
            /* Set class name. */
            class->name = name;
        }

        ret_name = class->name;
        PCCRETURN(STRING *ret_name);
    }

/*

=item C<void namespace(PMC *namespace :optional, int got_name :opt_flag)>

With a parameter, sets the namespace for the class. Expects a fully
qualified namespace to be specified as a key. If you already have linked another
namespace with this class, this link will be broken and the new namespace
specified will be linked to this class.

=cut

*/
    PCCMETHOD void namespace(PMC *namespace :optional, int got_name :opt_flag) {
        Parrot_Class *class = PARROT_CLASS(SELF);
        PMC *ret_namespace = NULL;

        if (got_name) {
            /* Check namespace is a key. */
            if (namespace->vtable->base_type != enum_class_Key)
            {
                real_exception(interp, NULL, E_NameError, "Namespace must be a key");
                return;
            }

            /* If we already have a namespace, it shouldn't refer to the
               class any more. */
            if (class->namespace)
            {
                /* XXX */
            }

            /* Set namespace. */
            class->namespace = Parrot_get_namespace_keyed(interp,
                interp->HLL_namespace, namespace);

            /* XXX Link namespace to this class; currently missing slot for that. */
        }

        ret_namespace = class->namespace;
        PCCRETURN(PMC *ret_namespace);
    }

/*

=item C<void resolve()>

Sets the list of method names that the class provides to resolve conflicts in
methods from roles. When called with no parameter, returns the list.

=cut

*/
    PCCMETHOD void resolve(PMC *resolve_list :optional, int got_list :opt_flag) {
        Parrot_Class *class = PARROT_CLASS(SELF);
        PMC *ret_list = NULL;

        if (got_list) {
            /* Store list. */
            class->resolve = resolve_list;
        }

        ret_list = class->resolve;
        PCCRETURN(PMC *ret_list);
    }

/*

=item C<void new(PMC *args :slurpy :named)>

Creates an instance of the object. Initializes any attributes specified in the
parameter list.

=cut

*/
    PCCMETHOD void new(PMC *args :slurpy :named) {
        Parrot_Class *class = PARROT_CLASS(SELF);
        PMC *obj;
        PMC *iter;

        /* If we've not been instantiated before... */
        if (!class->instantiated) {
            /* Check that we have all methods listed in resolve list. */
            int resolve_count = VTABLE_elements(interp, class->resolve);
            int i;
            for (i = 0; i < resolve_count; i++) {
                STRING *check_meth = VTABLE_get_string_keyed_int(interp,
                    class->resolve, i);
                if (!VTABLE_exists_keyed_str(interp, class->methods, check_meth)) {
                    real_exception(interp, NULL, METH_NOT_FOUND,
                        "The method '%S' was named in the resolve list, but not supplied",
                        check_meth);
                }
            }

            /* Build full parents list.
             * XXX Need pluggable MRO, for now always do C3. */
            class->all_parents = Parrot_ComputeMRO_C3(interp, SELF);

            /* Build attributes index. */
            build_attrib_index(interp, SELF);
            if (PMC_IS_NULL(class->attrib_index))
                return;
        }

        /* Set instantiated flag. */
        class->instantiated = 1;

        /* Create object. */
        obj = pmc_new_init(interp, enum_class_Object, SELF);

        /* Initialize attributes with the supplied values. */
        iter = VTABLE_get_iter(interp, args);
        while (VTABLE_get_bool(interp, iter)) {
            /* Get name and value. */
            STRING *attr_name = VTABLE_shift_string(interp, iter);
            PMC *attr_value = VTABLE_get_pmc_keyed_str(interp, args, attr_name);

            /* Set the attribute. */
            VTABLE_set_attr_str(interp, obj, attr_name, attr_value);
        }

        PCCRETURN(PMC *obj)
     }

/*

=item C<void attributes()>

Return a hash where the keys are attribute names and the values are hashes
providing a set of key/value pairs describing the attribute.

=cut

*/
    PCCMETHOD void attributes() {
        PMC *ret_attrib_metadata = VTABLE_inspect_str(interp, SELF,
            CONST_STRING(interp, "attributes"));
        PCCRETURN(PMC *ret_attrib_metadata);
    }

/*

=item C<void add_attribute()>

Add an attribute to the class. Requires a name and, optionally, a type.

=cut

*/
    PCCMETHOD void add_attribute(STRING *attribute_name,
            PMC* attribute_type :optional, int got_type :opt_flag) {
        VTABLE_add_attribute(interp, SELF, attribute_name,
            got_type ? attribute_type : PMCNULL);
    }

/*

=item C<void methods()>

Return a hash where the keys are method names and the values are methods.

=cut

*/
    PCCMETHOD void methods() {
        PMC *ret_methods = VTABLE_inspect_str(interp, SELF,
            CONST_STRING(interp, "methods"));
        PCCRETURN(PMC *ret_methods);
    }

/*

=item C<void add_method(STRING *name, PMC *sub)>

Adds the given sub PMC as a method with the given name. Delegates to the
C<add_method> vtable method.

=cut

*/
    PCCMETHOD void add_method(STRING *name, PMC *sub)
    {
        VTABLE_add_method(interp, SELF, name, sub);
    }

/*

=item C<void parents()>

Return the parents array PMC.

=cut

*/
    PCCMETHOD void parents() {
        PMC *ret_parents = VTABLE_inspect_str(interp, SELF,
            CONST_STRING(interp, "parents"));
        PCCRETURN(PMC *ret_parents);
    }

/*

=item C<void add_parent(PMC *parent)>

Adds the supplied PMC to the list of parents for the class.

=cut

*/
    PCCMETHOD void add_parent(PMC *parent) {
        VTABLE_add_parent(interp, SELF, parent);
    }

/*

=item C<void roles()>

Return the roles array PMC.

=cut

*/
    PCCMETHOD void roles() {
        PMC *ret_roles = VTABLE_inspect_str(interp, SELF,
            CONST_STRING(interp, "roles"));
        PCCRETURN(PMC *ret_roles);
    }

/*

=item C<void add_role(PMC* role, PMC* exclude :optional :named["exclude"],
PMC* alias :optional :named["alias"])>

Compose a role into a class with the given exclusions and aliases.

=cut

*/
    PCCMETHOD void add_role(PMC* role,
            PMC* exclude :optional :named["exclude"], int got_exclude :opt_flag,
            PMC* alias :optional :named["alias"],     int got_alias :opt_flag) {
        Parrot_Class *class = PARROT_CLASS(SELF);

        /* Add everything on the resolve list to the exclude list; if we have
         * no exclude list, pass along the resolve list in its place if it has
         * any methods listed in it. */
        if (!got_exclude) {
            if (VTABLE_elements(interp, class->resolve) != 0) {
                exclude = class->resolve;
                got_exclude = 1;
            }
        }
        else {
            int resolve_count = VTABLE_elements(interp, class->resolve);
            int i;
            for (i = 0; i < resolve_count; i++) {
                STRING *meth_name = VTABLE_get_string_keyed_int(interp,
                    class->resolve, i);
                VTABLE_push_string(interp, exclude, meth_name);
            }
        }

        /* Do the composition. */
        Parrot_ComposeRole(interp, role, exclude, got_exclude, alias, got_alias,
                           class->methods, class->roles);
    }

/*

=item C<void _get_attrib_index()>

This finds the index of an attribute in an object's attribute store and
returns it. Returns -1 if the attribute does not exist. This method exists
solely for the use of the Object PMC or any PMCs derived from it; the index
will be useless anyway, since only the Object knows what to do with it.

=cut

*/
    PCCMETHOD void _get_attrib_index(STRING *name) {
        Parrot_Class *class = PARROT_CLASS(SELF);

        /* If we can't find the attribute, we hand back -1. */
        int index = -1;

        /* First see if we can find it in the cache. */
        if (VTABLE_exists_keyed_str(interp, class->attrib_cache, name)) {
            /* Yay! We got a cache hit! */
            index = VTABLE_get_integer_keyed_str(interp, class->attrib_cache, name);
        }
        else {
            /* No hit. We need to walk up the list of parents to try and find the
             * attribute. */
            int num_classes = VTABLE_elements(interp, class->all_parents);
            int i;
            for (i = 0; i < num_classes; i++) {
                /* Get the class and its attribute metadata hash. */
                PMC *cur_class = VTABLE_get_pmc_keyed_int(interp, class->all_parents, i);
                Parrot_Class *class_info = PARROT_CLASS(cur_class);

                /* Build a string representing the fully qualified attribute name. */
                STRING *fq_name = get_fq_classname(interp, class_info);
                fq_name = string_append(interp, fq_name, name);

                /* Look up. */
                if (VTABLE_exists_keyed_str(interp, class->attrib_index, fq_name)) {
                    /* Found it. Get value, cache it and we're done. */
                    index = VTABLE_get_integer_keyed_str(interp, class->attrib_index, fq_name);
                    VTABLE_set_integer_keyed_str(interp, class->attrib_cache, name, index);
                    break;
                }
            }
        }

        PCCRETURN(int index);
    }

/*

=item C<void _get_method_pmc(STRING *name)>

This walks the method resolution order and tries to locate a method of the
give name. Returns the first one it finds, or NULL if no method is found.
This method is intended to be used by the Object PMC.

=cut

*/
    PCCMETHOD void _get_method_pmc(STRING *name) {
        Parrot_Class *class = PARROT_CLASS(SELF);

        /* Walk and search. */
        PMC *found = NULL;
        int num_classes = VTABLE_elements(interp, class->all_parents);
        int i;
        for (i = 0; i < num_classes; i++) {
            /* Get the class and see if it has the method. */
            PMC *cur_class = VTABLE_get_pmc_keyed_int(interp, class->all_parents, i);
            Parrot_Class *class_info = PARROT_CLASS(cur_class);
            if (VTABLE_exists_keyed_str(interp, class_info->methods, name)) {
                /* Found it! */
                found = VTABLE_get_pmc_keyed_str(interp, class_info->methods, name);
                break;
            }
        }

        PCCRETURN(PMC *found);
    }


} /* END pmclass */

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd15_objects.pod>.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
