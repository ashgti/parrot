/*
Copyright (C) 2001-2007, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/class.pmc - defines a class

=head1 DESCRIPTION

This class implements the Class PMC, as outlined in
F<docs/pdds/pdd15_objects.pod>.

Class is not derived from any other PMC.

=head2 Structure

The Role PMC structure (C<Parrot_Role>) consists of five items:

=over 4

=item C<name>

The name of the class -- a STRING.
An empty STRING is allocated during initialization.

=item C<namespace>

The namespace the class is associated with, if any.
A Null PMC is allocated during initialization.

=item C<instantiated>

A flag denoting whether this class has been instantiated since last modification.
A native integer with value zero is allocated during initialization.

=item C<parents>

An array of immediate parent classes.
An empty ResizablePMCArray PMC is allocated during initialization.

=item C<all_parents>

A cached array of ourself and all parent classes, in MRO order.
A ResizablePMCArray PMC is allocated during initialization,
and is populated with the current class.

=item C<roles>

An array of the roles this class has been composed from.
An empty ResizablePMCArray PMC is allocated during initialization.

=item C<methods>

A directory of method names and method bodies this class provides.
An empty Hash PMC is allocated during initialization.

=item C<vtable_methods>

A directory of vtable method names and method bodies this class overrides.
An empty Hash PMC is allocated during initialization.

=item C<attrib_metadata>

A directory of attribute names and attribute metadata this class contains.
An empty Hash PMC is allocated during initialization.

=item C<attrib_index>

A lookup table for attributes in this class and parents.
A Null PMC is allocated during initialization.

=item C<attrib_cache>

A cache of visible attribute names to attribute indexes.
A Null PMC is allocated during initialization.

=item C<resolve_method>

A list of method names the class provides used for name conflict resolution.
An empty ResizablePMCArray PMC is allocated during initialization.

=cut

*/

#include "parrot/parrot.h"
#include "pmc_namespace.h"
#include "classobject.h"

/* This function builds the attribute index (table to map class name and
 * attribute name to an index) for the current class. */
static void build_attrib_index(Parrot_Interp interp, PMC *self) {
    Parrot_Class * const _class = PARROT_CLASS(self);
    const int num_classes = VTABLE_elements(interp, _class->all_parents);
    int i;
    int cur_index = 0;
    PMC * const table = pmc_new(interp, enum_class_Hash);

    /* We will go over the list of all parents to construct the table. */
    for (i = 0; i < num_classes; i++) {
       /* Get the class and its attribute metadata hash. */
        PMC *cur_class = VTABLE_get_pmc_keyed_int(interp, _class->all_parents, i);
        Parrot_Class *class_info = PARROT_CLASS(cur_class);
        PMC *attribs = class_info->attrib_metadata;
        PMC *iter = VTABLE_get_iter(interp, attribs);

        /* Build a string representing the fully qualified class name. */
        /* Retrieve the fully qualified class name for the class. */
        STRING *fq_class = VTABLE_get_string(interp, cur_class);

        /* Iterate over the attributes. */
        while (VTABLE_get_bool(interp, iter)) {
            /* Get attribute. */
            PMC *cur_attrib = VTABLE_get_pmc_keyed_str(interp, attribs,
                VTABLE_shift_string(interp, iter));
            STRING *attrib_name;
            STRING *full_key = string_copy(interp, fq_class);

            /* Get attribute name and append it to the key. */
            attrib_name = VTABLE_get_string_keyed_str(interp, cur_attrib,
                string_from_const_cstring(interp, "name", 0));
            full_key = string_append(interp, full_key, attrib_name);

            /* Insert into hash, along with index. */
            VTABLE_set_integer_keyed_str(interp, table, full_key, cur_index);
            cur_index++;
        }
    }

    /* Store built table and invalidate cache. */
    _class->attrib_index = table;
    _class->attrib_cache = pmc_new(interp, enum_class_Hash);
}

/*
 * This function throws an exception if a PMC or class with the same name
 * already exists in the global type registry. The global type registry will go
 * away eventually, but this allows the new object metamodel to interact with
 * the old one until it does.
 */

static void
fail_if_type_exists(Interp *interp, PMC *name)
{
    INTVAL      type;

    PMC * const classname_hash = interp->class_hash;
    PMC * const type_pmc       = (PMC *)VTABLE_get_pointer_keyed(interp,
                                        classname_hash, name);
    if (PMC_IS_NULL(type_pmc) ||
            type_pmc->vtable->base_type == enum_class_NameSpace)
        type = 0;
    else
        type = VTABLE_get_integer(interp, type_pmc);

    if (type > enum_type_undef) {
        /* TODO get printable name */
        real_exception(interp, NULL, INVALID_OPERATION,
                "Class %Ss already registered!\n",
                VTABLE_get_string(interp, name));
    }

    if (type < enum_type_undef)
        real_exception(interp, NULL, INVALID_OPERATION,
                "native type with name '%s' already exists - "
                "can't register Class", data_types[type].name);
}

/* This function registers a type in the global registry, first checking if it
 * already exists. The global type registry will go away eventually, but this
 * allows the new object metamodel to interact with the old one until it does.
 */

static INTVAL
register_type(Parrot_Interp interp, PMC *name)
{
    INTVAL type;
    PMC *classname_hash, *item;

    if (PMC_IS_NULL(name)) {
        real_exception(interp, NULL, INVALID_OPERATION,
                "Can't register type without a name!\n");
    }

    /* First check if the type already exists */
    fail_if_type_exists(interp, name);

    /* Type doesn't exist, so go ahead and register it. Lock interpreter so
     * pt_shared_fixup() can safely do a type lookup. */
    LOCK_INTERPRETER(interp);
    classname_hash = interp->class_hash;
    type = interp->n_vtable_max++;

    /* Have we overflowed the table? */
    if (type >= interp->n_vtable_alloced)
        parrot_realloc_vtables(interp);

    /* set entry in name->type hash */
    item              = pmc_new(interp, enum_class_Integer);
    PMC_int_val(item) = type;
    VTABLE_set_pmc_keyed(interp, classname_hash, name, item);
    UNLOCK_INTERPRETER(interp);
    return type;
}



/* Takes a hash and initializes the class based on it. */
static void init_class_from_hash(Parrot_Interp interp, PMC *self, PMC *info)
{
    Parrot_Class *_class = PARROT_CLASS(self);
    PMC *old_ns;
    INTVAL i, type_num;

    /* Ensure we actually have some initialization info. */
    if (PMC_IS_NULL(info))
        return;

    /* Take a copy of the current namespace the class is attached to. */
    old_ns = _class->_namespace;

    /* Check if we have a name/namespace. */
    if (VTABLE_exists_keyed_str(interp, info,
        string_from_const_cstring(interp, "name", 0))) {

        STRING *new_name;
        PMC *new_namespace;
        PMC *name_arg = VTABLE_get_pmc_keyed_str(interp, info,
            string_from_const_cstring(interp, "name", 0));

        /* If we were passed a namespace PMC, set the namespace attribute
         * directly. Otherwise, lookup or create the appropriate namespace. */
        if (VTABLE_isa(interp, name_arg,
                    string_from_const_cstring(interp, "NameSpace", 0)))
            new_namespace = name_arg;
        else {
            new_namespace = Parrot_make_namespace_autobase(interp, name_arg);
        }
        if (PMC_IS_NULL(new_namespace)) {
            real_exception(interp, NULL, INVALID_OPERATION, "Failed to set namespace for class.");
        }

        /* Set the name of the class to the name of the innermost namespace
         * associated with the class.
         */
        new_name = VTABLE_get_string(interp, new_namespace);
        if (STRING_IS_NULL(new_name) || STRING_IS_EMPTY(new_name)) {
              real_exception(interp, NULL, INVALID_OPERATION, "Failed to set name for class.");
        }

        _class->_namespace = new_namespace;
        _class->name       = new_name;

        /* Register a type number for the class. */
        type_num = register_type(interp, name_arg);

        /* Link the type number with the class's vtable. */
        self->vtable->base_type = type_num;
        interp->vtables[type_num] = self->vtable;
        interp->vtables[type_num]->pmc_class = self;
    }

    /* If we were attached to a namespace and are now attached to a new one,
     * need to unset ourselves in the old namespace. */
    if (!PMC_IS_NULL(old_ns) && _class->_namespace != old_ns)
        Parrot_PCCINVOKE(interp, old_ns,
            string_from_const_cstring(interp, "set_class", 0),
            "P->", PMCNULL);

    /* Link namespace to this class, if there is one. */
    if (!PMC_IS_NULL(_class->_namespace))
        Parrot_PCCINVOKE(interp, _class->_namespace,
            string_from_const_cstring(interp, "set_class", 0),
            "P->", self);

    /* Initialize resolve_method. */
    if (VTABLE_exists_keyed_str(interp, info,
        string_from_const_cstring(interp, "resolve_method", 0))) {
        /* Set it. */
        _class->resolve_method = VTABLE_get_pmc_keyed_str(interp, info,
            string_from_const_cstring(interp, "resolve_method", 0));
    }

    /* Initialize parents, if we have any. */
    if (VTABLE_exists_keyed_str(interp, info,
        string_from_const_cstring(interp, "parents", 0))) {
        /* Loop over parents array and add them. */
        PMC * const parent_list = VTABLE_get_pmc_keyed_str(interp, info,
            string_from_const_cstring(interp, "parents", 0));
        const int parent_count = VTABLE_elements(interp, parent_list);
        for (i = 0; i < parent_count; i++) {
            PMC * const parent = VTABLE_get_pmc_keyed_int(interp, parent_list, i);
            VTABLE_add_parent(interp, self, parent);
        }
    }

    /* Initialize roles, if we have any. */
    if (VTABLE_exists_keyed_str(interp, info,
        string_from_const_cstring(interp, "roles", 0))) {
        /* Loop over roles array and compose them. */
        PMC * const role_list = VTABLE_get_pmc_keyed_str(interp, info,
            string_from_const_cstring(interp, "roles", 0));
        const int role_count = VTABLE_elements(interp, role_list);
        for (i = 0; i < role_count; i++) {
            PMC * const role = VTABLE_get_pmc_keyed_int(interp, role_list, i);
            VTABLE_add_role(interp, self, role);
        }
    }

    /* Initialize attributes, if we have any. */
    if (VTABLE_exists_keyed_str(interp, info,
        string_from_const_cstring(interp, "attributes", 0))) {
        /* Loop over attributes array and add them. */
        PMC * const attrib_name_list = VTABLE_get_pmc_keyed_str(interp, info,
            string_from_const_cstring(interp, "attributes", 0));
        const int attrib_count = VTABLE_elements(interp, attrib_name_list);
        for (i = 0; i < attrib_count; i++) {
            STRING * const attrib_name = VTABLE_get_string_keyed_int(interp,
                attrib_name_list, i);
            VTABLE_add_attribute(interp, self, attrib_name, PMCNULL);
        }
    }

    /* Initialize methods. */
    if (VTABLE_exists_keyed_str(interp, info,
        string_from_const_cstring(interp, "methods", 0))) {
        /* Get the methods hash. */
        PMC * const methods = VTABLE_get_pmc_keyed_str(interp, info,
            string_from_const_cstring(interp, "methods", 0));

        /* Iterate over the list of methods. */
        PMC * const iter = VTABLE_get_iter(interp, methods);
        while (VTABLE_get_bool(interp, iter)) {
            /* Add the method. */
            STRING * const method_name = VTABLE_shift_string(interp, iter);
            PMC * const method_pmc = VTABLE_get_pmc_keyed_str(interp, methods, method_name);
            VTABLE_add_method(interp, self, method_name, method_pmc);
        }
    }
}


/*

=back

=head2 Functions

=over 4

=cut

*/

pmclass Class
    need_ext {


/*

=item C<void init()>

Initializes a Class PMC.

=item C<void init_pmc(PMC *name)>

The actual class creation code, called from C<newclass> opcode.
The C<init> argument must stringify to the name of the class.
The class is attatched to the current namespace.

=cut

*/

    void init() {
        Parrot_Class *_class = NULL;

        /* Set flags for custom DOD mark and destroy. */
        PObj_custom_mark_SET(SELF);
        PObj_active_destroy_SET(SELF);

        /* We are a class. */
        PObj_is_class_SET(SELF);

        /* Set up the object. */
        _class = mem_allocate_zeroed_typed(Parrot_Class);
        _class->name            = CONST_STRING(interp, "");
        _class->_namespace      = PMCNULL;
        _class->instantiated    = 0;
        _class->parents         = pmc_new(interp, enum_class_ResizablePMCArray);
        _class->all_parents     = pmc_new(interp, enum_class_ResizablePMCArray);
        _class->roles           = pmc_new(interp, enum_class_ResizablePMCArray);
        _class->methods         = pmc_new(interp, enum_class_Hash);
        _class->vtable_methods  = pmc_new(interp, enum_class_Hash);
        _class->attrib_metadata = pmc_new(interp, enum_class_Hash);
        _class->attrib_index    = PMCNULL;
        _class->attrib_cache    = PMCNULL;
        _class->resolve_method  = pmc_new(interp, enum_class_ResizablePMCArray);

        /* We put ourself on the all parents list. */
        VTABLE_push_pmc(interp, _class->all_parents, SELF);

        PMC_data(SELF)         = _class;
    }

    void init_pmc(PMC* init_data) {
        Parrot_Class *_class = NULL;
        PMC *arg;
        const INTVAL arg_type = VTABLE_type(interp, init_data);
        STRING * const name_str = CONST_STRING(interp, "name");

        /* Set up the object. */
        SELF.init();

        /* fast attempt to determine init_data type */
        switch (arg_type)
        {
            case enum_class_String:
            case enum_class_Key:
            case enum_class_NameSpace:
                arg = pmc_new(interp, enum_class_Hash);
                VTABLE_set_pmc_keyed_str(interp, arg, name_str, init_data);
                break;

            case enum_class_Hash:
                arg = init_data;
                break;

            /* slow attempt to determine init_data type */
            default:
                if (VTABLE_isa(interp, init_data, CONST_STRING(interp, "String"))) {
                    arg = pmc_new(interp, enum_class_Hash);
                    VTABLE_set_pmc_keyed_str(interp, arg, name_str, init_data);
                }
                else if (VTABLE_isa(interp, init_data, CONST_STRING(interp, "Key"))) {
                    arg = pmc_new(interp, enum_class_Hash);
                    VTABLE_set_pmc_keyed_str(interp, arg, name_str, init_data);
                }

                if (VTABLE_isa(interp, init_data, CONST_STRING(interp, "Hash"))) {
                    arg = init_data;
                }
                else {
                    arg = pmc_new(interp, enum_class_Hash);
                    VTABLE_set_pmc_keyed_str(interp, arg, name_str, init_data);
                }
                break;
        }

        /* Initialize the class with the supplied data. */
        init_class_from_hash(interp, SELF, arg);
    }

/*

=item C<PMC* subclass(PMC* name)>

Creates a subclass, optionally with a given C<name>.

=cut

*/

    PMC* subclass(PMC *name) {
        PMC *child_class;

        /* Create a new class. Set the classname, if we have one. */
        if (PMC_IS_NULL(name)) {
            child_class = pmc_new(interp, enum_class_Class);
        }
        else {
            PMC *naming_hash = pmc_new(interp, enum_class_Hash);
            VTABLE_set_pmc_keyed_str(interp, naming_hash, CONST_STRING(interp, "name"), name);
            child_class = pmc_new_init(interp, enum_class_Class, naming_hash);
        }

        /* Make the new class a subclass of the current class */
        VTABLE_add_parent(interp, child_class, SELF);

        return child_class;
    }

/*

/*

=item C<void destroy()>

Free the memory associated with the object's underlying struct.

=cut

*/

    void destroy() {
            mem_sys_free(PMC_data(SELF));
    }

/*

=item C<STRING* get_string()>

Return the fully qualified name of the class.

=cut

*/

    STRING* get_string() {
        Parrot_Class * const _class = PARROT_CLASS(SELF);
        PMC * namespace = _class->_namespace;
        PMC * names;
        if (!PMC_IS_NULL(namespace)) {
            /* Call the 'get_name' method on the class's associated namespace
             * to retrieve a fully qualified list of names, then join the list
             * with a semicolon.
             */
            STRING * ret_name;
            names = Parrot_NameSpace_nci_get_name(interp, namespace);
            if (!PMC_IS_NULL(names)) {
                ret_name = string_join(interp, CONST_STRING(interp, ";"), names);
                return ret_name;
            }
        }

        /* Otherwise, copy the stored string name of the class. */
        return string_copy(interp, _class->name);
    }

/*

=item C<void mark()>

Mark any referenced strings and PMCs in the structure as live.

=cut

*/

    void mark() {
        Parrot_Class * const _class = PARROT_CLASS(SELF);
        if (_class->name)
            pobject_lives(interp, (PObj*)_class->name);
        if (_class->_namespace)
            pobject_lives(interp, (PObj*)_class->_namespace);
        if (_class->parents)
            pobject_lives(interp, (PObj*)_class->parents);
        if (_class->all_parents)
            pobject_lives(interp, (PObj*)_class->all_parents);
        if (_class->roles)
            pobject_lives(interp, (PObj*)_class->roles);
        if (_class->methods)
            pobject_lives(interp, (PObj*)_class->methods);
        if (_class->vtable_methods)
            pobject_lives(interp, (PObj*)_class->vtable_methods);
        if (_class->attrib_metadata)
            pobject_lives(interp, (PObj*)_class->attrib_metadata);
        if (_class->attrib_index)
            pobject_lives(interp, (PObj*)_class->attrib_index);
        if (_class->attrib_cache)
            pobject_lives(interp, (PObj*)_class->attrib_cache);
        if (_class->resolve_method)
            pobject_lives(interp, (PObj*)_class->resolve_method);
    }


/*

=item C<void add_attribute(STRING *name, PMC *type)>

Adds the given attribute (C<name>) with an optional C<type>.
Creates a new class if the current class has been instantiated.
Enters the attribute in the C<attributes> array.
Returns an error if an attribute of C<name> already exists.

=cut

*/

    void add_attribute(STRING *name, PMC *type)
    {
        Parrot_Class * const _class = PARROT_CLASS(SELF);
        PMC * const new_attribute = pmc_new(interp, enum_class_Hash);

        /* If we've been instantiated already, need a new class. */
        if (_class->instantiated) {
            /* XXX Unimplemented! */
            real_exception(interp, NULL, E_NotImplementedError,
                "Modifications to already instantiated classes not allowed yet.");
        }

        /* If we've already got an attribute of this name, it's an error. */
        if (VTABLE_exists_keyed_str(interp, _class->attrib_metadata, name)) {
            real_exception(interp, NULL, INVALID_OPERATION,
                "An attribute of this name already exists.");
        }

        /* Set name and type. */
        VTABLE_set_string_keyed_str(interp, new_attribute, CONST_STRING(interp, "name"), name);
        if (!PMC_IS_NULL(type)) {
            VTABLE_set_pmc_keyed_str(interp, new_attribute, CONST_STRING(interp, "type"), type);
        }

        /* Enter the attribute in the attributes array. */
        VTABLE_set_pmc_keyed_str(interp, _class->attrib_metadata, name, new_attribute);
    }

/*

=item C<void add_method(STRING *name, PMC *sub)>

Adds the given sub PMC as a method with the given name.

=cut

*/
    void add_method(STRING *name, PMC *sub)
    {
        Parrot_Class * const _class = PARROT_CLASS(SELF);

        /* If we have already added a method with this name... */
        if (VTABLE_exists_keyed_str(interp, _class->methods, name)) {
            /* XXX Need to handle multi methods here. */
            real_exception(interp, NULL, E_NotImplementedError,
                "A method of this name already exists. It may have been supplied by a role.");
        }
        else {
            /* Enter it into the table. */
            VTABLE_set_pmc_keyed_str(interp, _class->methods, name, sub);
        }
    }

/*

=item C<void add_parent(PMC *parent)>

Adds the supplied PMC to the list of parents for the class.

=cut

*/
    void add_parent(PMC *parent)
    {
        Parrot_Class * const _class = PARROT_CLASS(SELF);

        /* If we've been instantiated already, need a new class. */
        if (_class->instantiated) {
            /* XXX Unimplemented! */
            real_exception(interp, NULL, E_NotImplementedError,
                "Modifications to already instantiated classes not allowed yet.");
            return;
        }

        /* Ensure it really is a class. */
        if (!PObj_is_class_TEST(parent)) {
            real_exception(interp, NULL, E_TypeError,
                "You can only add a class as a parent to another class.");
            return;
        }

        /* XXX Check we don't already have this parent. */

        /* Add to the list of our immediate parents. */
        VTABLE_push_pmc(interp, _class->parents, parent);
    }

/*

=item C<void add_role(PMC *role)>

Adds the supplied PMC to the list of roles for the class, provided there are
no conflicts.

=cut

*/
    void add_role(PMC *role)
    {
        Parrot_Class * const _class = PARROT_CLASS(SELF);

        /* Do the composition. */
        Parrot_ComposeRole(interp, role, PMCNULL, 0, PMCNULL, 0,
                           _class->methods, _class->roles);
    }

/*

=item C<PMC* inspect_str(STRING *what)>

Provides introspection of a specific piece of information about the class. The
available information is:

=over 8

=item name

String PMC containing the name of the class

=item namespce

NameSpace PMC of the the namespace attached to the class

=item attributes

Hash keyed on attribute name, value is hash describing it

=item methods

Hash keyed on method name, value is an invokable PMC. Includes methods composed
in from roles.

=item roles

Array of Role PMCs. Includes roles done by the roles that were composed into
this class.

=item parents

Array of Class PMCs representing the direct parents of this class.

=back

=cut

*/
    PMC* inspect_str(STRING *what)
    {
        Parrot_Class *_class = PARROT_CLASS(SELF);

        /* What should we return? */
        PMC          *found  = PMCNULL;

        if (string_equal(interp, what, CONST_STRING(interp, "name")) == 0) {
            found = pmc_new(interp, enum_class_String);
            VTABLE_set_string_native(interp, found, _class->name);
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "namespace")) == 0) {
            /* Should not clone this. */
            return _class->_namespace;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "attributes")) == 0) {
            found = _class->attrib_metadata;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "methods")) == 0) {
            found = _class->methods;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "parents")) == 0) {
            found = _class->parents;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "roles")) == 0) {
            found = _class->roles;
        }
        else {
            real_exception(interp, NULL, INVALID_OPERATION,
                "Unknown introspection value '%S'", what);
        }

        /* Clone and return. */
        return PMC_IS_NULL(found) ? PMCNULL : VTABLE_clone(interp, found);
    }

/*

=item C<PMC* inspect()>

Returns a Hash describing the class, with key/value pairs as described in
inspect_str.

=cut

*/
    PMC* inspect()
    {
        /* Create a hash, then use inspect_str to get all of the data to
         * fill it up with. */
        PMC *metadata = pmc_new(interp, enum_class_Hash);
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "name"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "name")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "namespace"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "namespace")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "attributes"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "attributes")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "methods"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "methods")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "parents"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "parents")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "roles"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "roles")));
        return metadata;
    }

/*

=item C<PMC* clone()>

Returns an anonymous copy of the class (with no name and no link to a
namespace). Unsets the instantiated flag, allowing modifications.

=cut

*/

    PMC* clone()
    {
        Parrot_Class *_class = PARROT_CLASS(SELF);

        /* Create the new class PMC, of the same type of this one (we may
         * have been subclassed). */
        PMC *copy = pmc_new(interp, SELF->vtable->base_type);

        /* Clone parents, roles, methods, attributes and resolve data. We do
         * not copy name/namespace related stuff (need anonymous clone) or
         * stuff that gets computed on the first instantiation. */
        Parrot_Class *new_class = PARROT_CLASS(copy);
        new_class->parents = VTABLE_clone(interp, _class->parents);
        new_class->roles = VTABLE_clone(interp, _class->roles);
        new_class->methods = VTABLE_clone(interp, _class->methods);
        new_class->vtable_methods = VTABLE_clone(interp, _class->vtable_methods);
        new_class->attrib_metadata = VTABLE_clone(interp, _class->attrib_metadata);
        new_class->resolve_method = VTABLE_clone(interp, _class->resolve_method);

        /* Return cloned class. */
        return copy;
    }

/*

=item C<PMC* clone_pmc(PMC *args)>

Makes a copy of the class, then modifies or adds to it based upon the contents
of the supplied initialization data. If a new name or namespace is not supplied
in C<args> then the cloned class will be anonymous. The instantiated flag is
unset to allow further modifications.

=cut

*/

    PMC* clone_pmc(PMC *args)
    {
        /* Do the standard clone. */
        PMC *copy = DYNSELF.clone();

        /* Initialize it with the supplied arguments. */
        init_class_from_hash(interp, copy, args);

        /* Return cloned class. */
        return copy;
    }

    /* **********************************************************************
     * Below here are non-vtable methods that eventually will go in a role
     * that is composed into here to optionally give a nice interface from
     * PIR (ParrotClass isa Class does ClassMethods or something like this).
     * **********************************************************************/

/*

=item C<void name(STRING *name :optional, int got_name :opt_flag)>

Sets the name of the class, and updates the namespace accoringly.

=cut

*/
    PCCMETHOD void name(STRING *name :optional, int got_name :opt_flag) {
        Parrot_Class *_class = PARROT_CLASS(SELF);
        STRING *ret_name = NULL;

        if (got_name) {
            /* We'll build a hash just containing the name, then give this to
             * init_class_from_hash - saves some code duplication. */
            PMC *naming_hash = pmc_new(interp, enum_class_Hash);
            VTABLE_set_string_keyed_str(interp, naming_hash, CONST_STRING(interp, "name"), name);
            init_class_from_hash(interp, SELF, naming_hash);
        }

        ret_name = _class->name;
        PCCRETURN(STRING *ret_name);
    }

/*

=item C<void pmc_namespace()>

Gets the namespace that this class is attached to.

=cut

*/
    PCCMETHOD void pmc_namespace(PMC *_namespace :optional, int got_name :opt_flag) {
        Parrot_Class *_class = PARROT_CLASS(SELF);
        PMC *ret_namespace = _class->_namespace;
        PCCRETURN(PMC *ret_namespace);
    }

/*

=item C<void resolve_method()>

Sets the list of method names that the class provides to resolve conflicts in
methods from roles. When called with no parameter, returns the list.

=cut

*/
    PCCMETHOD void resolve_method(PMC *resolve_list :optional, int got_list :opt_flag) {
        Parrot_Class *_class = PARROT_CLASS(SELF);
        PMC *ret_list = NULL;

        if (got_list) {
            /* Store list. */
            _class->resolve_method = resolve_list;
        }

        ret_list = _class->resolve_method;
        PCCRETURN(PMC *ret_list);
    }

/*

=item C<void new(PMC *args :slurpy :named)>

Creates an instance of the object. Initializes any attributes specified in the
parameter list.

=cut

*/
    PCCMETHOD void new(PMC *args :slurpy :named) {
        Parrot_Class *_class = PARROT_CLASS(SELF);
        PMC *obj;
        PMC *iter;
        Parrot_Object *obj_guts = NULL;

        /* If we've not been instantiated before... */
        if (!_class->instantiated) {
            /* Check that we have all methods listed in resolve list. */
            int resolve_count = VTABLE_elements(interp, _class->resolve_method);
            int i;
            for (i = 0; i < resolve_count; i++) {
                STRING *check_meth = VTABLE_get_string_keyed_int(interp,
                    _class->resolve_method, i);
                if (!VTABLE_exists_keyed_str(interp, _class->methods, check_meth)) {
                    real_exception(interp, NULL, METH_NOT_FOUND,
                        "The method '%S' was named in the resolve list, but not supplied",
                        check_meth);
                }
            }

            /* Build full parents list.
             * XXX Need pluggable MRO, for now always do C3. */
            _class->all_parents = Parrot_ComputeMRO_C3(interp, SELF);

            /* Build attributes index. */
            build_attrib_index(interp, SELF);
            if (PMC_IS_NULL(_class->attrib_index))
                return;
        }

        /* Set instantiated flag. */
        _class->instantiated = 1;

        /* Create object. */
        obj = pmc_new_noinit(interp, enum_class_Object);

        /* Set custom DOD mark and destroy on the object. */
        PObj_custom_mark_SET(obj);
        PObj_active_destroy_SET(obj);

        /* Initialize the object's underlying structure, pointing it to this
         * class. */
        obj_guts = mem_allocate_zeroed_typed(Parrot_Object);
        obj_guts->_class = SELF;
        obj_guts->attrib_store = pmc_new(interp, enum_class_ResizablePMCArray);
        PMC_data(obj) = obj_guts;

        /* Initialize attributes with the supplied values. */
        iter = VTABLE_get_iter(interp, args);
        while (VTABLE_get_bool(interp, iter)) {
            /* Get name and value. */
            STRING *attr_name = VTABLE_shift_string(interp, iter);
            PMC *attr_value = VTABLE_get_pmc_keyed_str(interp, args, attr_name);

            /* Set the attribute. */
            VTABLE_set_attr_str(interp, obj, attr_name, attr_value);
        }

        PCCRETURN(PMC *obj)
     }

/*

=item C<void attributes()>

Return a hash where the keys are attribute names and the values are hashes
providing a set of key/value pairs describing the attribute.

=cut

*/
    PCCMETHOD void attributes() {
        PMC *ret_attrib_metadata = VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "attributes"));
        PCCRETURN(PMC *ret_attrib_metadata);
    }

/*

=item C<void add_attribute()>

Add an attribute to the class. Requires a name and, optionally, a type.

=cut

*/
    PCCMETHOD void add_attribute(STRING *attribute_name,
            PMC* attribute_type :optional, int got_type :opt_flag) {
        VTABLE_add_attribute(interp, SELF, attribute_name,
            got_type ? attribute_type : PMCNULL);
    }

/*

=item C<void methods()>

Return a hash where the keys are method names and the values are methods.

=cut

*/
    PCCMETHOD void methods() {
        PMC *ret_methods = VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "methods"));
        PCCRETURN(PMC *ret_methods);
    }

/*

=item C<void add_method(STRING *name, PMC *sub)>

Adds the given sub PMC as a method with the given name. Delegates to the
C<add_method> vtable method.

=cut

*/
    PCCMETHOD void add_method(STRING *name, PMC *sub)
    {
        VTABLE_add_method(interp, SELF, name, sub);
    }

/*

=item C<void parents()>

Return the parents array PMC.

=cut

*/
    PCCMETHOD void parents() {
        PMC *ret_parents = VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "parents"));
        PCCRETURN(PMC *ret_parents);
    }

/*

=item C<void add_parent(PMC *parent)>

Adds the supplied PMC to the list of parents for the class.

=cut

*/
    PCCMETHOD void add_parent(PMC *parent) {
        VTABLE_add_parent(interp, SELF, parent);
    }

/*

=item C<void roles()>

Return the roles array PMC.

=cut

*/
    PCCMETHOD void roles() {
        PMC *ret_roles = VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "roles"));
        PCCRETURN(PMC *ret_roles);
    }

/*

=item C<void add_role(PMC* role, PMC* exclude :optional :named["exclude"],
PMC* alias :optional :named["alias"])>

Compose a role into a class with the given exclusions and aliases.

=cut

*/
    PCCMETHOD void add_role(PMC* role,
            PMC* exclude_method :optional :named["exclude_method"],
            int got_exclude_method :opt_flag,
            PMC* alias_method :optional :named["alias_method"],
            int got_alias_method :opt_flag) {
        Parrot_Class *_class = PARROT_CLASS(SELF);

        /* Add everything on the resolve list to the exclude list; if we have
         * no exclude list, pass along the resolve list in its place if it has
         * any methods listed in it. */
        if (!got_exclude_method) {
            if (VTABLE_elements(interp, _class->resolve_method) != 0) {
                exclude_method = _class->resolve_method;
                got_exclude_method = 1;
            }
        }
        else {
            int resolve_count = VTABLE_elements(interp, _class->resolve_method);
            int i;
            for (i = 0; i < resolve_count; i++) {
                STRING *meth_name = VTABLE_get_string_keyed_int(interp,
                    _class->resolve_method, i);
                VTABLE_push_string(interp, exclude_method, meth_name);
            }
        }

        /* Do the composition. */
        Parrot_ComposeRole(interp, role, exclude_method, got_exclude_method,
                           alias_method, got_alias_method,
                           _class->methods, _class->roles);
    }

/*

=item C<void inspect(STRING *what :optional)>

Gets all introspection data for the class or, if the optional string
parameter is supplied, a particular item of introspection data.

=cut

*/
    PCCMETHOD void inspect(STRING *what :optional, int got_what :opt_flag) {
        PMC *found;

        /* Just delegate to the appropriate vtable method. */
        if (got_what)
            found = VTABLE_inspect_str(interp, SELF, what);
        else
            found = VTABLE_inspect(interp, SELF);

        PCCRETURN(PMC *found);
    }

/*

=item C<void isa(STRING *class_name)>

Returns true if this object is or derives from the class named in
C<class_name>, false otherwise.

=cut

*/
    PCCMETHOD void isa(STRING *class_name) {
        INTVAL isa = VTABLE_isa(interp, SELF, class_name);

        PCCRETURN(INTVAL isa);
    }

/*

=item C<void does(STRING *role_name)>

Returns true if this object or one of its parents performs the named role,
false otherwise.

=cut

*/
    PCCMETHOD void does(STRING *role_name) {
        INTVAL i, role_count, isa;
        PMC *role_list = (PMC_data_typed(SELF, Parrot_Class *))->roles;

        if (!role_list)
            PCCRETURN(INTVAL 0);

        role_count = VTABLE_elements(interp, role_list);

        for (i = 0; i < role_count; i++) {
            INTVAL  role_does;
            PMC    *role       = VTABLE_get_pmc_keyed_int(interp, role_list, i);

            (INTVAL role_does) = PCCINVOKE(interp, role, "does",
                                           STRING *role_name);

            if (role_does)
                PCCRETURN(INTVAL 1);
        }

        (INTVAL isa) = PCCINVOKE(interp, SELF, "isa", STRING *role_name);

        PCCRETURN(INTVAL isa);
    }
} /* END pmclass */

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd15_objects.pod>.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
