/*
Copyright (C) 2008, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/filehandle.pmc - FileHandle PMC

=head1 DESCRIPTION

The FileHandle PMC performs I/O operations on a source or destination file.

=head2 Vtable Functions

=over 4

=cut

*/

#include "../src/io/io_private.h"

#ifdef PARROT_HAS_READLINE
#ifdef __cplusplus
extern "C" {
#endif
    char *readline(const char *);
    void add_history(const char*);
#ifdef __cplusplus
}
#endif
#endif

pmclass FileHandle {
    ATTR PMC *os_handle;              /* encapsulated OS handle       */
    ATTR INTVAL flags;                /* Filehandle flags             */
    ATTR STRING *filename;            /* The opened path and filename */
    ATTR STRING *mode;                /* The mode string used in open */
    ATTR STRING *encoding;            /* The encoding for read/write  */

/*

=item C<void init()>

Initializes a newly created FileHandle object.

=cut

*/

    VTABLE void init() {
        Parrot_FileHandle_attributes *data_struct =
                mem_allocate_typed(Parrot_FileHandle_attributes);

        PMC_data(SELF)             = data_struct;
        data_struct->flags         = 0;
        data_struct->filename      = NULL;
        data_struct->mode          = NULL;
        data_struct->encoding      = NULL;

        /* Create the handle pmc */
        data_struct->os_handle     = Parrot_io_make_os_handle_pmc(INTERP);

        PObj_custom_mark_SET(SELF);
        PObj_active_destroy_SET(SELF);
    }

/*

=item C<PMC *clone()>

Create a copy of the filehandle.

=cut

*/

    VTABLE PMC *clone() {
        Parrot_FileHandle_attributes * const old_struct  = PARROT_FILEHANDLE(SELF);
        PMC * const copy = Parrot_io_new_pmc(interp, old_struct->flags);
        Parrot_FileHandle_attributes * const data_struct = PARROT_FILEHANDLE(copy);

        data_struct->os_handle = VTABLE_clone(INTERP, old_struct->os_handle);

        return copy;
    }

/*

=item C<void mark()>

Mark active filehandle data as live.

=cut

*/

    VTABLE void mark() {
        Parrot_FileHandle_attributes * const data_struct = PARROT_FILEHANDLE(SELF);
        if (data_struct->mode)
            Parrot_gc_mark_PObj_alive(interp, (PObj *)data_struct->mode);
        if (data_struct->filename)
            Parrot_gc_mark_PObj_alive(interp, (PObj *)data_struct->filename);
        if (data_struct->encoding)
            Parrot_gc_mark_PObj_alive(interp, (PObj *)data_struct->encoding);
        if (data_struct->os_handle)
            Parrot_gc_mark_PObj_alive(interp, (PObj *)data_struct->os_handle);
    }

/*

=item C<void destroy()>

Free structures.

=cut

*/
    VTABLE void destroy() {
        if (PARROT_FILEHANDLE(SELF)) {
            Parrot_FileHandle_attributes *data_struct = PARROT_FILEHANDLE(SELF);

            mem_sys_free(PARROT_FILEHANDLE(SELF));
            PMC_data(SELF) = NULL;
        }
    }

/*

=item C<INTVAL get_bool()>

Returns whether the FileHandle has reached the end of the file.

=cut

*/

    VTABLE INTVAL get_bool() {
        return !Parrot_io_eof(INTERP, SELF);
    }


/*

=back

=head2 Methods

=over 4

=item C<METHOD open(STRING *filename :optional, STRING *mode :optional)>

Opens the file at the given filename (including path) with the given mode. The
invocant is modified and becomes an open filehandle. A copy of the invocant is
also returned by the method (some subclasses may create this as the primary
filehandle, rather than modifying the invocant).

=cut

*/

    METHOD open(STRING *filename :optional, INTVAL got_filename :opt_flag,
        STRING *mode :optional, INTVAL got_mode :opt_flag) {
        PMC *filehandle;
        STRING *open_filename, *open_mode;

        if (!Parrot_io_is_closed_filehandle(INTERP, SELF))
            Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_PIO_ERROR,
                                "Cannot reopen already open filehandle");

        if (got_mode && !STRING_IS_NULL(mode))
            SET_ATTR_mode(INTERP, SELF, Parrot_str_copy(INTERP, mode));

        if (got_filename && !STRING_IS_NULL(filename))
            SET_ATTR_filename(INTERP, SELF, Parrot_str_copy(INTERP, filename));

        /* Open the file. When no options are passed, reopen the same file as
         * before */
        GET_ATTR_filename(INTERP, SELF, open_filename);
        GET_ATTR_mode(INTERP, SELF, open_mode);


        if (STRING_IS_NULL(open_filename))
            Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_PIO_ERROR,
                            "Cannot open filehandle, no filename");

        if (STRING_IS_NULL(open_mode)) {
            open_mode = CONST_STRING(INTERP, "r");
            SET_ATTR_mode(INTERP, SELF, open_mode);
        }

        filehandle = Parrot_io_open(INTERP, SELF, open_filename, open_mode);

        RETURN(PMC *filehandle);
    }

/*

=item C<METHOD isatty()>

=cut

*/
    METHOD isatty() {
        INTVAL isatty = (PARROT_FILEHANDLE(SELF)->flags & PIO_F_CONSOLE) == PIO_F_CONSOLE;
        RETURN(INTVAL isatty);
    }

/*

=item C<METHOD close()>

Close the filehandle.

=cut

*/

    METHOD close() {
        INTVAL status;
        status = Parrot_io_close(INTERP, SELF);
        RETURN(INTVAL status);
    }

/*

=item C<METHOD is_closed()>

Test if the filehandle is closed.

=cut

*/

    METHOD is_closed() {
        INTVAL status;
        status = Parrot_io_is_closed(interp, SELF);
        RETURN(INTVAL status);
    }

/*

=item C<METHOD read(INTVAL bytes)>

Read the given number of bytes from the filehandle and return them in a string.

=cut

*/

    METHOD read(INTVAL length) {
        STRING *string_result = NULL;
        string_result = Parrot_io_reads(INTERP, SELF, length);

        RETURN(STRING *string_result);
    }

/*

=item C<METHOD readline()>

Read a line from the filehandle and return it in a string.

=cut

*/

    METHOD readline() {
        STRING *string_result;
        string_result = Parrot_io_readline(INTERP, SELF);
        RETURN(STRING *string_result);
    }

/*

=item C<METHOD readline_interactive(STRING *prompt)>

Read a line from the filehandle and return it in a string.

=cut

*/

    METHOD readline_interactive(STRING *prompt :optional, INTVAL got_prompt :opt_flag) {
        STRING *string_result = NULL;
#ifdef PARROT_HAS_READLINE
    /* 4-column indent to get c_indent.t to DTRT */
        char * const r = readline(got_prompt ? prompt->strstart : NULL);

        if (r) {
            if (*r)
                add_history(r);

            string_result = Parrot_str_new(INTERP, r, 0);
            mem_sys_free(r);
        }
#else
        if (got_prompt)
            fprintf(stderr, "%s", prompt->strstart);

        if (!(PARROT_FILEHANDLE(SELF)->flags & PIO_F_LINEBUF))
            Parrot_io_setlinebuf(INTERP, SELF);

        string_result = Parrot_io_reads(INTERP, SELF, 0);
        if (string_result) {
            UINTVAL len = Parrot_str_byte_length(INTERP, string_result);
            if (len < 1)
                string_result = NULL;
            else {
                while (len > 0 &&
                        (((char*)string_result->strstart)[len - 1] == '\n' ||
                         ((char*)string_result->strstart)[len - 1] == '\r')) {
                    --len;
                    --string_result->strlen;
                    --string_result->bufused;
                }
            }
        }
#endif
        if (string_result)
            RETURN(STRING *string_result);
        else
            RETURN(PMC *PMCNULL);
    }

/*

=item METHOD readall(STRING *name);

Read the entire contents of a file named I<name> into a Parrot string. On a
filehandle object that isn't opened yet, the path to a file can be passed to
C<readall> and it will open a filehandle on that file, read in the contents,
and close the filehandle.

  .local pmc pio
  pio = new 'FileHandle'
  $S0 = pio.'readall'('the_file')

If the filehandle is already open, then no file path should be passed. The
C<readall> method will read the contents of the file, and will not close the
filehandle when finished.

  pio = open 'the_file', 'r'
  $S0 = pio.'readall'()

=cut

*/

    METHOD readall(STRING *name :optional, INTVAL got_name :opt_flag) {
        STRING *result;

        if (got_name) {
            /* called as class method - open, slurp, close file */
            PMC *filehandle;
            STRING *encoding;
            size_t size;
            GET_ATTR_encoding(INTERP, SELF, encoding);
            if (!Parrot_io_is_closed_filehandle(INTERP, SELF)) {
                Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_PIO_ERROR,
                                "Cannot readall on a new file from an already open filehandle");
            }
            filehandle  = Parrot_io_open(INTERP, PMCNULL, name, NULL);
            PARROT_ASSERT(filehandle->vtable->base_type == enum_class_FileHandle);
            SET_ATTR_encoding(INTERP, filehandle, encoding);
            size = (size_t)(Parrot_stat_info_intval(INTERP, name, STAT_FILESIZE));

            result = Parrot_io_reads(INTERP, filehandle, size);
            Parrot_io_close(INTERP, filehandle);
            RETURN(STRING *result);
        }
        else {
            /* slurp open file */
            if (Parrot_io_is_closed_filehandle(INTERP, SELF)) {
                Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_PIO_ERROR,
                                "Cannot readall without a file name or open filehandle");
            }
            result = Parrot_str_new_noinit(INTERP, enum_stringrep_one, 0);

            /* Do line buffering on the filehandle */
            if (!(PARROT_FILEHANDLE(SELF)->flags & PIO_F_LINEBUF))
                Parrot_io_setlinebuf(INTERP, SELF);

            do {
                STRING * const part = Parrot_io_reads(INTERP, SELF, 0);

                result = Parrot_str_append(INTERP, result, part);
                if (Parrot_io_eof(INTERP, SELF))
                    break;
            } while (1);
        }

        RETURN(STRING *result);
    }

/*

=item C<METHOD flush()>

Flushes the filehandle.

=cut

*/

    METHOD flush() {
        Parrot_io_flush(INTERP, SELF);
    }

/*

=item C<METHOD print([INTVAL|FLOATVAL|STRING *|PMC*] value)>

Print the passed in integer, number, string, or PMC to the filehandle.
(Integers, numbers, and strings are auto-boxed as PMCs.)

=cut

*/

    METHOD print(PMC *to_print) {
        STRING * const string_to_print = VTABLE_get_string(INTERP, to_print);

        Parrot_io_putps(interp, SELF, string_to_print);
    }

/*

=item C<METHOD puts(STRING *value)>

Print the string to the filehandle.

=cut

*/

    METHOD puts(STRING *to_print) {
        INTVAL status;
        status = Parrot_io_putps(INTERP, SELF, to_print);
        RETURN(INTVAL status);
    }

/*

=item C<METHOD buffer_type(STRING *new_type :optional)>

Set or retrieve the buffering behavior for the filehandle. The argument and
return value are one of the following:

=over

=item C<unbuffered>

Buffering disabled, bytes are sent as soon as possible.

=item C<line-buffered>

Line buffering, bytes are sent when a record separator is encountered.

=item C<full-buffered>

Full buffering, bytes are sent when the buffer is full.

=cut

*/

    METHOD buffer_type(STRING *new_type :optional, INTVAL got_type :opt_flag) {
        INTVAL flags;
        STRING * const nobuffer_string   = CONST_STRING(INTERP, "unbuffered");
        STRING * const linebuffer_string = CONST_STRING(INTERP, "line-buffered");
        STRING * const fullbuffer_string = CONST_STRING(INTERP, "full-buffered");

        if (got_type) {
            if (Parrot_str_equal(INTERP, new_type, nobuffer_string))
                Parrot_io_setbuf(INTERP, SELF, PIOCTL_NONBUF);
            else if (Parrot_str_equal(INTERP, new_type, linebuffer_string))
                Parrot_io_setlinebuf(INTERP, SELF);
            else if (Parrot_str_equal(INTERP, new_type, fullbuffer_string))
                Parrot_io_setbuf(INTERP, SELF, PIO_UNBOUND);
        }

        GET_ATTR_flags(INTERP, SELF, flags);

        if (flags & PIO_F_LINEBUF)
            RETURN(STRING *linebuffer_string);
        else if (flags & PIO_F_BLKBUF)
            RETURN(STRING *fullbuffer_string);

        RETURN(STRING *nobuffer_string);

    }

/*

=item C<METHOD buffer_size(INTVAL new_size :optional)>

Set or retrieve the buffer size for the filehandle.

=cut

*/

    METHOD buffer_size(INTVAL new_size :optional, INTVAL got_size :opt_flag) {
        INTVAL buffer_size;

        if (got_size) {
            Parrot_io_setbuf(INTERP, SELF, (size_t) new_size);
        }

        buffer_size = (INTVAL) Parrot_io_get_buffer_size(INTERP, SELF);

        RETURN(INTVAL buffer_size);

    }

/*

=item C<METHOD mode()>

Retrieve the read mode string for the filehandle.

=cut

*/

    METHOD mode() {
        STRING *mode, *mode_copy;

        GET_ATTR_mode(INTERP, SELF, mode);
        mode_copy = Parrot_str_copy(INTERP, mode);

        RETURN(STRING *mode_copy);

    }

/*

=item C<METHOD encoding(STRING *new_encoding)>

Set or retrieve the encoding attribute (a string name of the selected encoding
scheme) for the filehandle.

=cut

*/

    METHOD encoding(STRING *new_encoding :optional, INTVAL got_encoding :opt_flag) {
        STRING *encoding;
        STRING *encoding_copy = NULL;

        if (got_encoding) {
            if (!STRING_IS_NULL(new_encoding))
                encoding_copy = Parrot_str_copy(INTERP, new_encoding);
            SET_ATTR_encoding(INTERP, SELF, encoding_copy);
            RETURN(STRING *new_encoding);
        }

        GET_ATTR_encoding(INTERP, SELF, encoding);
        if (!STRING_IS_NULL(encoding))
            encoding_copy = Parrot_str_copy(INTERP, encoding);

        RETURN(STRING *encoding_copy);

    }

/*

=item C<METHOD eof()>

Returns true if the filehandle is at end-of-file, returns false otherwise.

=cut

*/

    METHOD eof() {
        INTVAL flags;
        flags = Parrot_io_eof(INTERP, SELF);
        RETURN(INTVAL flags);
    }


/*

=item C<METHOD get_fd()>

Retrieve the integer file descriptor for the FileHandle (only available on
platforms that use integer file descriptors).

=cut

*/

    METHOD get_fd() {
#ifndef PIO_OS_STDIO
        INTVAL os_handle;
        os_handle = Parrot_io_get_os_handle(INTERP, SELF);
        RETURN(INTVAL os_handle);
#endif /*PIO_OS_STDIO*/

        RETURN(INTVAL -1);

    }


/*

=back

=cut

*/

} /* end pmclass */

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
