/*
Copyright (C) 2001-2003, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/parrotclass.pmc - Parrot Class

=head1 DESCRIPTION

The structure of a parrot class is reasonably straightforward. The PMC's
cached integer value is the number of attribute slots that an object of
this type requires. The data pointer holds a pointer to an array of
PMCs. That array has:

=over 4

=item PCD_PARENTS

An array of immediate parents.

=item PCD_CLASS_NAME

The class name PMC.

=item PCD_ATTRIBUTES

A hash, the keys are the classname/attrib name pair (separated by a
C<NULL>), while the value is the offset to the attribute.

=item PCD_CLASS_ATTRIBUTES

Array of attribute of this class.

=item PCD_OBJECT_VTABLE

Vtable PMC that holds the vtable for objects of this class.

=back

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

static PMC*
get_init_meth(PARROT_INTERP, PMC *_class, STRING *prop_str, STRING **meth_str /*NN*/)
    /* WARN_UNUSED */
{
    STRING     *meth;
    HashBucket *b;
    PMC        *props, *ns, *method;

    *meth_str = NULL;
    props = PMC_metadata(_class);
    if (!props)
        return PMCNULL;
    b = parrot_hash_get_bucket(interp,
                (Hash*) PMC_struct_val(props), prop_str);
    if (!b)
        return PMCNULL;
    meth = PMC_str_val((PMC*) b->value);

    *meth_str = meth;
    ns        = VTABLE_pmc_namespace(interp, _class);
    method    = VTABLE_get_pmc_keyed_str(interp, ns, meth);

    return method;
}

static void
do_initcall(PARROT_INTERP, PMC* _class, PMC *object, PMC *init)
{
    PMC * const classsearch_array = _class->vtable->mro;
    INTVAL      i, nparents;

    /*
     * 1) if class has a CONSTRUCT property run it on the object
     *    no redispatch
     *
     * XXX isn't CONSTRUCT for creating new objects?
     */
    STRING *meth_str;
    PMC    *meth = get_init_meth(interp, _class,
            string_from_cstring(interp, "CONSTRUCT", 9), &meth_str);
    int     default_meth;

    if (!PMC_IS_NULL(meth)) {
        if (!PMC_IS_NULL(init))
            Parrot_run_meth_fromc_args(interp, meth,
                    object, meth_str, "vP", init);
        else
            Parrot_run_meth_fromc_args(interp, meth,
                    object, meth_str, "v");
    }
    /*
     * 2. if class has a BUILD property call it for all classes
     *    in reverse search order - this class last.
     *
     *    Note: mro contains this class as first element
     */
    nparents = VTABLE_elements(interp, classsearch_array);

    for (i = nparents - 1; i >= 0; --i) {
        PMC * const parent_class =
            VTABLE_get_pmc_keyed_int(interp, classsearch_array, i);
        /* if it's a PMC, we put one PMC of that type into
         * the attribute slot #0 and call init() on that PMC
         */
        if (!PObj_is_class_TEST(parent_class)) {
            PMC *attr, *next_parent;
            SLOTTYPE *obj_data;

            /*
             * but only if init isn't inherited
             * or rather just on the last non-class parent
             */
            assert(i >= 1);
            next_parent = VTABLE_get_pmc_keyed_int(interp,
                    classsearch_array, i - 1);
            if (!PObj_is_class_TEST(next_parent))
                continue;

            attr     = pmc_new_noinit(interp, parent_class->vtable->base_type);
            obj_data = PMC_data_typed(object, SLOTTYPE *);
            set_attrib_num(object, obj_data, 0, attr);
            VTABLE_init(interp, attr);
            continue;
        }
        meth = get_init_meth(interp, parent_class,
                string_from_cstring(interp, "BUILD", 5), &meth_str);
/*                CONST_STRING(interp, "BUILD"), &meth_str); */
        /* no method found and no BUILD property set? */
        if (PMC_IS_NULL(meth) && meth_str == NULL) {
            PMC   *ns;
            INTVAL vtable_index;

            /* use __init or __init_pmc (depending on if an argument was passed)
             * as fallback constructor method, if it exists */
            if (init)
                meth_str = string_from_cstring(interp, "init_pmc", 8);
/*                meth_str = CONST_STRING(interp, "init_pmc"); */
            else
                meth_str = string_from_cstring(interp, "init", 4);
/*                meth_str = CONST_STRING(interp, "init"); */

            ns   = VTABLE_pmc_namespace(interp, parent_class);

            /* can't use find_method, it walks mro */
            vtable_index = Parrot_get_vtable_index(interp, meth_str);
            meth         = VTABLE_get_pmc_keyed_int(interp, ns, vtable_index);
            default_meth = 1;
        }
        else
            default_meth = 0;

        if (!PMC_IS_NULL(meth)) {
            if (init)
                Parrot_run_meth_fromc_args(interp, meth,
                        object, meth_str, "vP", init);
            else
                Parrot_run_meth_fromc_args(interp, meth,
                        object, meth_str, "v");
        }
        else if (meth_str != NULL &&
                string_length(interp, meth_str) != 0 && !default_meth) {
            real_exception(interp, NULL, METH_NOT_FOUND,
                    "Class BUILD method ('%Ss') not found", meth_str);
        }
    }
}

pmclass ParrotClass extends delegate need_ext {

/*

=item C<void init()>

Initializes the class flags.

=item C<void init_pmc(PMC *init)>

The actual class creation code, called from C<newclass> opcode. The C<init>
argument is not a PMC* but the C<classname> STRING.

=cut

*/

    void init() {
        /* No attributes to start with */
        PMC_int_val(SELF) = CLASS_ATTRIB_COUNT(SELF) = 0;
        /* But we are a class, really */
        PObj_is_class_SET(SELF);
        /* turn on marking of the class_data array */
        PObj_data_is_PMC_array_SET(SELF);
        /* turn on custom destruction since our PMC* array is
           dynamically allocated */
        PObj_active_destroy_SET(SELF);
    }

    void init_pmc(PMC* name) {
        SELF.init();
        Parrot_new_class(INTERP, SELF, name);
    }

/*

=item C<void destroy()>

Free the class's attribute array, if any. Also used by ParrotObjects.

=cut

*/
    void destroy() {
        if (PMC_int_val(SELF)) {
            mem_sys_free(PMC_data(SELF));
        }
    }

/*

=item C<PMC* instantiate(PMC* init)>

Creates a new PMC object of the type of the class and calls init().

=cut

*/

    PMC* instantiate(PMC* init) {
        SLOTTYPE    *new_object_array;
        INTVAL       attrib_count, i;
        const INTVAL type   = SELF->vtable->base_type;
        PMC         *object = pmc_new_noinit(interp, type);
        PMC * const _class  = object->vtable->pmc_class;
        /*
         * put in the real vtable
         */
        PMC * const vtable_pmc = get_attrib_num((SLOTTYPE *)PMC_data(_class),
                                                PCD_OBJECT_VTABLE);
        object->vtable         = (VTABLE *)PMC_struct_val(vtable_pmc);

        /* Grab the attribute count from the class */
        attrib_count = CLASS_ATTRIB_COUNT(_class);

        /* Build the array that hangs off the new object */
        /* First presize it */
        set_attrib_array_size(object, attrib_count);
        new_object_array = PMC_data_typed(object, SLOTTYPE *);

        /* fill with PMCNULL, so that access doesn't segfault */
        for (i = 0; i < attrib_count; ++i)
            set_attrib_num(object, new_object_array, i, PMCNULL);

        /* turn marking on */
        set_attrib_flags(object);

        /* We are an object now */
        PObj_is_object_SET(object);

        /* We really ought to call the class init routines here...
         * this assumes that an object isa delegate
         */
        do_initcall(interp, _class, object, init);

        return object;
    }

/*

=item C<INTVAL isa(STRING *classname)>

Returns whether the class is or inherits from C<*classname>.

=cut

*/

    INTVAL isa(STRING* classname) {
        PMC *_class;
        if (SUPER(classname))
            return 1;
        _class = Parrot_class_lookup(INTERP, classname);
        return Parrot_object_isa(INTERP, SELF, _class);
    }


/*

=item C<PMC *get_class()>

Return SELF.

=item C<STRING* name()>

Return the classname.

=cut

*/

    PMC* get_class() {
        return SELF;
    }

    STRING* name() {
        PMC **class_data, *name;
        class_data = (PMC **)PMC_data(SELF);

        if (class_data) {
            name = class_data[PCD_CLASS_NAME];
            return readable_name(interp, name);
        }
        return SELF->vtable->whoami;
    }



/*

=item C<void visit(visit_info *info)>

This is used by freeze/thaw to visit the contents of the class.

C<*info> is the visit info, (see F<include/parrot/pmc_freeze.h>).

=item C<void freeze(visit_info *info)>

Used to archive the class.

=item C<void thaw(visit_info *info)>

Used to unarchive the class.

=item C<void thawfinish(visit_info *info)>

Create the class from the thawed parents and attributes array.

=cut

*/

    void visit(visit_info *info) {
        PMC **class_data, **pos;

        class_data = (PMC **)PMC_data(SELF);

        /* 2) direct parents array */
        if (info->what == VISIT_THAW_NORMAL ||
                info->what == VISIT_THAW_CONSTANTS)
            pos = class_data + PCD_MAX;
        else
            pos = class_data + PCD_PARENTS;
        info->thaw_ptr = pos;
        (info->visit_pmc_now)(INTERP, *pos, info);

        /* 3) attributes array */
        if (info->what == VISIT_THAW_NORMAL ||
                info->what == VISIT_THAW_CONSTANTS)
            pos = class_data + PCD_MAX + 1;
        else
            pos = class_data + PCD_CLASS_ATTRIBUTES;
        info->thaw_ptr = pos;
        (info->visit_pmc_now)(INTERP, *pos, info);

        SUPER(info);
    }

    void freeze(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        PMC **class_data, **pos;

        SUPER(info);
        class_data = (PMC **)PMC_data(SELF);

        /* 1) freeze class name */
        pos = class_data + PCD_CLASS_NAME;
        io->vtable->push_string(INTERP, io,
                VTABLE_get_string(INTERP, *pos));

    }

    void thaw(visit_info *info) {
        IMAGE_IO *io = info->image_io;

        /*
         * Thawing a class is tricky - it might or might not exist
         * in the interpreter, where it get thawed.
         * Additionally, it could happen that a class exists
         * but the thawed one differs.
         *
         * So here's the plan:
         * During thaw, we first extend the class_data by two,
         * thaw parents and attribs into that new area, and
         * then we see what to do.
         */
        if (info->extra_flags == EXTRA_IS_PROP_HASH) {
            SUPER(info);
        }
        else if (info->extra_flags == EXTRA_IS_NULL) {
            STRING *class_name;
            INTVAL new_type;
            PMC *real_class;

            /* thaw class name */
            class_name = io->vtable->shift_string(INTERP, io);
            /* if class exists in this interpreter, check if the
             * thawed class is the same, if not bail out, if yes
             * ignore the class, consume the byte string
             */
            new_type = pmc_type(INTERP, class_name);
            if (new_type > enum_type_undef) {
                real_class = Parrot_class_lookup(INTERP, class_name);
                info->extra = real_class;
                info->extra_flags = EXTRA_CLASS_EXISTS;
            }
            else {
                PMC *name = pmc_new(interp, enum_class_String);
                real_class = SELF;
                VTABLE_set_string_native(interp, name, class_name);
                SELF.init_pmc(name);
            }
            /* make room for thawed arrays */
            if (PMC_int_val(real_class) == PCD_MAX) {
                PMC **class_data;
                resize_attrib_array(real_class, PCD_MAX + 2);
                class_data = (PMC **)PMC_data(real_class);
                class_data[PCD_MAX] = NULL;
                class_data[PCD_MAX + 1] = NULL;
            }

        }
    }

    void thawfinish(visit_info *info) {
        INTVAL i, n, nold;
        PMC *_class;
        PMC *parents, *attribs, *old;
        PMC **class_data;
        int parent_not_class = 0;

        _class = SELF;
        class_data = (PMC**)(PMC_data(_class));

        old = class_data[PCD_PARENTS];
        nold = VTABLE_elements(INTERP, old);
        parents = class_data[PCD_MAX];
        if (!parents)
            n = 0;
        else
            n = VTABLE_elements(INTERP, parents);
        if (nold && n != nold)
            real_exception(INTERP, NULL, E_AssertionError,
                    "thawed class differs");
        /* TODO compare elements */
        if (!nold) {
            for (i = 0; i < n; ++i) {
                PMC *parent_class;
                parent_class = VTABLE_get_pmc_keyed_int(INTERP, parents, i);
                if (!PObj_is_class_TEST(parent_class)) {
                    assert(!parent_not_class);
                    parent_not_class++;
                    parent_class = parent_class->vtable->pmc_class;
                }
                Parrot_add_parent(INTERP, _class, parent_class);
            }
        }
        /*
         * preserve the thawed attrib array
         */
        old = class_data[PCD_CLASS_ATTRIBUTES];
        nold = VTABLE_elements(INTERP, old);
        attribs = class_data[PCD_MAX + 1];
        if (!attribs)
            n = 0;
        else
            n = VTABLE_elements(INTERP, attribs);
        if (nold != parent_not_class && n != nold)
            real_exception(INTERP, NULL, E_AssertionError,
                    "thawed class differs");
        /* TODO compare attribs */

        if (nold == parent_not_class) {
            /* non-class parents already have an extra attribute for
             * delegating, which will have already been created by
             * Parrot_add_parent() and must be first
             */
            for (i = parent_not_class ? 1 : 0; i < n; ++i) {
                Parrot_add_attribute(INTERP, _class,
                        VTABLE_get_string_keyed_int(INTERP, attribs, i));
            }
        }
        class_data[PCD_MAX] = NULL;
        class_data[PCD_MAX + 1] = NULL;
    }

/*

=item C<METHOD PMC* get_parents()>

Returns the array of parents for this class.

=cut

*/

    METHOD PMC* get_parents() {
        PMC *_class;
        PMC **class_data;

        _class     = SELF;
        class_data = (PMC**)(PMC_data(_class));
        return class_data[PCD_PARENTS];
    }

}

/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
