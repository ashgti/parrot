/*
Copyright: 2001-2007 The Perl Foundation.
$Id$

=head1 NAME

src/pmc/stmvar.pmc -- A transactional variable

=head1 DESCRIPTION

XXX

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "parrot/stm/backend.h"

/* we set need_ext here because we really want to have PMC sync structure;
 * we set no_ro because we are logically read-only; one can't change which
 * transactional object this references (though one can change that
 * object)
 */
pmclass STMVar is_shared need_ext no_ro {
/*

=item C<void init()>

...

=cut

*/
    void init() {
        PMC_struct_val(SELF) = NULL;
        PMC_struct_val(SELF) = Parrot_STM_alloc(INTERP, PMCNULL);
        PObj_custom_mark_SET(SELF);
    }

    void init_pmc(PMC *value) {
        PMC_struct_val(SELF) = NULL;
        if (value->vtable->base_type == enum_class_STMRef
            || value->vtable->base_type == enum_class_STMVar) {
            PMC_struct_val(SELF) = PMC_struct_val(value);
        }
        else {
            PMC_struct_val(SELF) = Parrot_STM_alloc(INTERP, value);
        }
        PObj_custom_mark_SET(SELF);
    }
/*

=item C<PMC *clone()>

Return the STMVar PMC.

=cut

*/

    PMC *clone() {
        return SELF;
    }

/*

=item C<void mark()>

Mark data associated with this transactional variable.

=cut

*/

    void mark() {
        PARROT_ASSERT(PObj_is_PMC_shared_TEST(SELF));
        PARROT_ASSERT(PMC_sync(SELF)->owner == INTERP);
        Parrot_STM_mark_pmc_handle(INTERP,
            (Parrot_STM_PMC_handle)PMC_struct_val(SELF));
    }

    METHOD PMC *get_read() {
        return Parrot_STM_read(INTERP,
            (Parrot_STM_PMC_handle)PMC_struct_val(SELF));
    }

    METHOD PMC *get_update() {
        return Parrot_STM_begin_update(INTERP,
            (Parrot_STM_PMC_handle)PMC_struct_val(SELF));
    }

    METHOD void set(PMC *new_value) {
        Parrot_STM_write(INTERP, (Parrot_STM_PMC_handle)PMC_struct_val(SELF),
                         new_value);
    }

    void freeze(visit_info *info) {
        IMAGE_IO * const io = info->image_io;

        SUPER(info);

        Parrot_freeze_STM_PMC_handle(INTERP, io,
            (Parrot_STM_PMC_handle)PMC_struct_val(SELF));
    }

    void thaw(visit_info *info) {
        IMAGE_IO * const io = info->image_io;

        SUPER(info);

        PMC_struct_val(SELF) =
            Parrot_thaw_STM_PMC_handle(INTERP, io);

        PARROT_ASSERT(PObj_is_PMC_shared_TEST(SELF));
        PARROT_ASSERT(PMC_sync(SELF));
    }

    /* we can do this because we don't modify ourself in dangerous
       ways -- we are always a reference to the same transactional
       variable.
     */
    PMC *share_ro() {
        PMC *ret = pt_shared_fixup(INTERP, SELF);
        return ret;
    }
}

/*

=back

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
