/*
Copyright (C) 2001-2007, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/role.pmc - Role - defines a role

=head1 DESCRIPTION

This class implements the basic Parrot role PMC, for defining a role.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"
#define PARROT_ROLE(o) ((Parrot_Role *) PMC_data(o))


/* This is the underlying structure of this PMC. */
typedef struct Parrot_Role {
    STRING *name;         /* The name of the role. */
    PMC *namespace;       /* The namespace it's linked to, if any. */
    PMC *roles;           /* Any roles that this role is composed from. */
    PMC *methods;         /* Hash of method names to methods in this role. */
    PMC *attrib_metadata; /* Hash of attributes in this role to hashes of metadata. */
} Parrot_Role;


pmclass Role need_ext {
/*

=item C<void init()>

Initializes the role.

=item C<void init_pmc(PMC *name)>

The actual role creation code, called from C<newrole> opcode. The C<init>
argument should stringify to the name of the role. The role will be attatched
to the current namespace.

=cut

*/

    void init() {
        Parrot_Role *role = NULL;

        /* Custom DOD mark and destroy. */
        PObj_custom_mark_SET(SELF);
        PObj_active_destroy_SET(SELF);

        /* Init the role object. */
        role = mem_sys_allocate_zeroed(sizeof(Parrot_Role));
        role->name = CONST_STRING(interp, "");
        role->namespace = PMCNULL;
        role->roles = pmc_new(interp, enum_class_ResizablePMCArray);
        role->methods = pmc_new(interp, enum_class_Hash);
        role->attrib_metadata = pmc_new(interp, enum_class_Hash);

        PMC_data(SELF) = role;
    }

    void init_pmc(PMC* name) {
        Parrot_Role *role = NULL;

        /* Set up the role. */
        SELF.init();

        /* Set name and namespace. */
        role = PARROT_ROLE(SELF);
        role->name = VTABLE_get_string(interp, name);
        role->namespace = CONTEXT(interp->ctx)->current_namespace;
    }

/*

=item C<void destroy()>

Free the memory associated with the underlying struct.

=cut

*/
    void destroy() {
            mem_sys_free(PMC_data(SELF));
    }

/*

=item C<void mark()>

Mark any referenced strings and PMCs.

=cut

*/
    void mark() {
        Parrot_Role *role = PARROT_ROLE(SELF);
        if (role->name)
            pobject_lives(interp, (PObj*)role->name);
        if (role->namespace)
            pobject_lives(interp, (PObj*)role->namespace);
        if (role->roles)
            pobject_lives(interp, (PObj*)role->roles);
        if (role->methods)
            pobject_lives(interp, (PObj*)role->methods);
        if (role->attrib_metadata)
            pobject_lives(interp, (PObj*)role->attrib_metadata);
    }

/*

=item C<void add_attribute(STRING *name, PMC *type)>

Adds the given attribute with an optional type.

=cut

*/
    void add_attribute(STRING *name, PMC *type)
    {
        Parrot_Role *role = PARROT_ROLE(SELF);
        PMC *new_attribute = pmc_new(interp, enum_class_Hash);

        /* Set name and type. */
        VTABLE_set_string_keyed_str(interp, new_attribute,
            CONST_STRING(interp, "name"), name);
        if (!PMC_IS_NULL(type)) {
            VTABLE_set_pmc_keyed_str(interp, new_attribute,
                CONST_STRING(interp, "type"), type);
        }

        /* Enter the attribute in the attributes array. */
        VTABLE_set_pmc_keyed_str(interp, role->attrib_metadata, name, new_attribute);
    }

/*

=item C<void add_method(STRING *name, PMC *sub)>

Adds the given sub PMC as a method with the given name.

=cut

*/
    void add_method(STRING *name, PMC *sub)
    {
        Parrot_Role *role = PARROT_ROLE(SELF);

        /* If we have already added a method with this name... */
        if (VTABLE_exists_keyed_str(interp, role->methods, name)) {
            /* XXX Need to handle multi methods here. */
            real_exception(interp, NULL, E_NotImplementedError,
                "Currently, adding multiple methods of the same name is not supported.");
        }
        else {
            /* Enter it into the table. */
            VTABLE_set_pmc_keyed_str(interp, role->methods, name, sub);
        }
    }

/*

=item C<void add_role(PMC *role)>

Composes the supplied Role PMC into this role, provided there are no
conflicts.

=cut

*/
    void add_role(PMC *role)
    {
        Parrot_Role *this_role = PARROT_ROLE(SELF);

        /* Do the composition. */
        Parrot_ComposeRole(interp, role, PMCNULL, 0, PMCNULL, 0,
                           this_role->methods, this_role->roles);
    }

/*

=item C<PMC* inspect_str(STRING *what)>

Provides introspection of a specific piece of information about the role. The
available information is:

=over 4

=item name - String PMC containing the name of the role

=item namespce - NameSpace PMC of the the namespace attached to the role

=item attributes - Hash keyed on attribute name, value is hash describing it

=item methods - Hash keyed on method name, value is an invokable PMC. Includes
methods composed in from roles.

=item roles - Array of Role PMCs. Includes roles done by the roles that were
composed into this role.

=back

=cut

*/
    PMC* inspect_str(STRING *what)
    {
        Parrot_Role *role = PARROT_ROLE(SELF);

        /* What should we return? */
        PMC *found;
        if (string_equal(interp, what, CONST_STRING(interp, "name")) == 0) {
            found = pmc_new(interp, enum_class_String);
            VTABLE_set_string_native(interp, found, role->name);
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "namespace")) == 0) {
            found = role->namespace;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "attributes")) == 0) {
            found = role->attrib_metadata;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "methods")) == 0) {
            found = role->methods;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "roles")) == 0) {
            found = role->roles;
        }
        else {
            real_exception(interp, NULL, INVALID_OPERATION,
                "Unknown introspection value '%S'", what);
        }

        /* Clone and return. */
        return VTABLE_clone(interp, found);
    }

/*

=item C<PMC* inspect()>

Returns a Hash describing the role, with key/value pairs as described in
inspect_str.

*/
    PMC* inspect()
    {
        /* Create a hash, then use inspect_str to get all of the data to
         * fill it up with. */
        PMC *metadata = pmc_new(interp, enum_class_Hash);
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "name"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "name")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "namespace"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "namespace")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "attributes"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "attributes")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "methods"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "methods")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "roles"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "roles")));
        return metadata;
    }

    /* **********************************************************************
    /* Below here are non-vtable methods that eventually will go in a role
     * that is composed into here to optionally give a nice interface from
     * PIR (ParrotRole isa Role does RoleMethods or something like this).
     * **********************************************************************/

/*

=item C<void name()>

Sets the name of the role.

=cut

*/
    PCCMETHOD void name(STRING *name :optional, int got_name :opt_flag) {
        Parrot_Role *role = PARROT_ROLE(SELF);
        STRING *ret_name = NULL;

        if (got_name) {
            /* Set role name. */
            role->name = name;
        }

        ret_name = role->name;
        PCCRETURN(STRING *ret_name);
    }

/*

=item C<void namespace()>

With a parameter, sets the namespace for the role. Expects a fully
qualified namespace to be specified as a key. If you already have linked another
namespace with this role, this link will be broken and the new namespace
specified will be linked to this role.

=cut

*/
    PCCMETHOD void namespace(PMC *namespace :optional, int got_name :opt_flag) {
        Parrot_Role *role = PARROT_ROLE(SELF);
        PMC *ret_namespace = NULL;

        if (got_name) {
            /* If namespace is a key or a string, need to look it up. */
            switch (namespace->vtable->base_type) {
                case enum_class_NameSpace:
                    /* It's fine, don't need to do anything. */
                    break;
                case enum_class_Key:
                    /* Look it up relative to HLL base. */
                    namespace = Parrot_get_namespace_keyed(interp,
                        interp->HLL_namespace, namespace);
                    if (PMC_IS_NULL(namespace))
                        real_exception(interp, NULL, E_NameError, "Namespace cannot be found");
                    break;
                case enum_class_String:
                    /* Look it up relative to current namespace. */
                    namespace = Parrot_get_namespace_keyed_str(interp,
                        CONTEXT(interp->ctx)->current_namespace,
                        VTABLE_get_string(interp, namespace));
                    if (PMC_IS_NULL(namespace))
                        real_exception(interp, NULL, E_NameError, "Namespace cannot be found");
                    break;
                default:
                    /* Don't know what to do with it. */
                    real_exception(interp, NULL, E_NameError, "Namespace must be a key");
            }

            /* Check namespace is a key. */
            if (namespace->vtable->base_type != enum_class_Key)
            {
                real_exception(interp, NULL, E_NameError, "Namespace must be a key");
                return;
            }

            /* If we already have a namespace, it shouldn't refer to the
               role any more. */
            if (role->namespace)
            {
                PMC *role_ns = role->namespace;
                PCCINVOKE(interp, role_ns, "set_class", PMC* PMCNULL);
            }

            /* Set namespace. */
            role->namespace = Parrot_get_namespace_keyed(interp,
                interp->HLL_namespace, namespace);

            /* Link namespace to this role. */
            PCCINVOKE(interp, namespace, "set_class", PMC* SELF);

            /* XXX Get methods from the namespace we were linked to. */
        }

        ret_namespace = role->namespace;
        PCCRETURN(PMC *ret_namespace);
    }

/*

=item C<void attributes()>

Return a hash where the keys are attribute names and the values are hashes
providing a set of key/value pairs describing the attribute.

=cut

*/
    PCCMETHOD void attributes() {
        PMC *ret_attrib_metadata = VTABLE_inspect_str(interp, SELF,
            CONST_STRING(interp, "attributes"));
        PCCRETURN(PMC *ret_attrib_metadata);
    }


/*

=item C<void add_attribute()>

Add an attribute to the role. Requires a name and, optionally, a type.

=cut

*/
    PCCMETHOD void add_attribute(STRING *attribute_name,
            PMC* attribute_type :optional, int got_type :opt_flag) {
        VTABLE_add_attribute(interp, SELF, attribute_name,
            got_type ? attribute_type : PMCNULL);
    }

/*

=item C<void methods()>

Return a hash where the keys are method names and the values are methods.

=cut

*/
    PCCMETHOD void methods() {
        PMC *ret_methods = VTABLE_inspect_str(interp, SELF,
            CONST_STRING(interp, "methods"));
        PCCRETURN(PMC *ret_methods);
    }

/*

=item C<void add_method(STRING *name, PMC *sub)>

Adds the given sub PMC as a method with the given name.

=cut

*/
    PCCMETHOD void add_method(STRING *name, PMC *sub)
    {
        VTABLE_add_method(interp, SELF, name, sub);
    }

/*

=item C<void roles()>

Return the roles array PMC.

=cut

*/
    PCCMETHOD void roles() {
        PMC *ret_roles = VTABLE_inspect_str(interp, SELF,
            CONST_STRING(interp, "roles"));
        PCCRETURN(PMC *ret_roles);
    }

/*

=item C<void add_role(PMC* role, PMC* exclude :optional :named["exclude"],
PMC* alias :optional :named["alias"])>

Compose the given role into this one, using the given exclusions and aliases.

=cut

*/
    PCCMETHOD void add_role(PMC* role,
            PMC* exclude_method :optional :named["exclude_method"],
            int got_exclude_method :opt_flag,
            PMC* alias_method :optional :named["alias_method"],
            int got_alias_method :opt_flag) {
        Parrot_Role *role_info = PARROT_ROLE(SELF);
        Parrot_ComposeRole(interp, role, exclude_method, got_exclude_method,
                           alias_method, got_alias_method,
                           role_info->methods, role_info->roles);
    }

} /* END pmclass */

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd15_objects.pod>.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
