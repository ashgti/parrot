/*
Copyright (C) 2001-2007, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/role.pmc - Role - defines a role

=head1 DESCRIPTION

This class implements the Role PMC, a unit of class composition as outlined in
F<docs/pdds/pdd15_objects.pod>.

Role is not derived from any other PMC.

=head2 Structure

The Role PMC structure (C<Parrot_Role>) consists of five items:

=over 4

=item C<name>

The name of the role -- a STRING.
An empty STRING is allocated during initialization.

=item C<namespace>

The namespace the role is associated with, if any.
A Null PMC is allocated during initialization.

=item C<roles>

The list of roles from which this role is composed, if any.
An empty ResizablePMCArray is allocated during initialization.

=item C<methods>

The directory of method names and methods this role implements.
An empty Hash PMC is allocated during initialization.

=item C<attrib_metadata>

The directory of attribute names and attribute metadata this role contains.
An empty Hash PMC is allocated during initialization.

=cut

*/

#include "parrot/parrot.h"
#define PARROT_ROLE(o) ((Parrot_Role *) PMC_data(o))

/* This is the underlying structure of this PMC. */
typedef struct Parrot_Role {
    STRING *name;         /* The name of the role. */
    PMC *namespace;       /* The namespace it's linked to, if any. */
    PMC *roles;           /* Any roles that this role is composed from. */
    PMC *methods;         /* Hash of method names to methods in this role. */
    PMC *attrib_metadata; /* Hash of attributes in this role to hashes of metadata. */
} Parrot_Role;


/*

=back

=head2 Functions

=over 4

=cut

*/

pmclass Role
    need_ext {


/*

=item C<void init()>

Initializes a Role PMC.

=item C<void init_pmc(PMC *name)>

The actual role creation code, called from C<newrole> opcode.
The C<init> argument must stringify to the name of the role.
The role is attatched to the current namespace.

=cut

*/

    void init() {
        Parrot_Role *role = NULL;

        /* Set flags for custom DOD mark and destroy. */
        PObj_custom_mark_SET(SELF);
        PObj_active_destroy_SET(SELF);

        /* Set up the object. */
        role                  = mem_sys_allocate_zeroed(sizeof (Parrot_Role));
        role->name            = CONST_STRING(interp, "");
        role->namespace       = PMCNULL;
        role->roles           = pmc_new(interp, enum_class_ResizablePMCArray);
        role->methods         = pmc_new(interp, enum_class_Hash);
        role->attrib_metadata = pmc_new(interp, enum_class_Hash);
        PMC_data(SELF)        = role;
    }

    void init_pmc(PMC* name) {
        Parrot_Role *role = NULL;
        STRING *s_name;

        /* Set up the role. */
        SELF.init();


        /* Set name and namespace. */
        role            = PARROT_ROLE(SELF);
        if (!PMC_IS_NULL(name))
            role->name  = VTABLE_get_string(interp, name);
        role->namespace = CONTEXT(interp->ctx)->current_namespace;
    }


/*

=item C<void destroy()>

Free the memory associated with the object's underlying struct.

=cut

*/

    void destroy() {
            mem_sys_free(PMC_data(SELF));
    }


/*

=item C<void mark()>

Mark referenced strings and PMCs in the structure as live.

=cut

*/

    void mark() {
        Parrot_Role *role = PARROT_ROLE(SELF);
        if (role->name)
            pobject_lives(interp, (PObj*)role->name);
        if (role->namespace)
            pobject_lives(interp, (PObj*)role->namespace);
        if (role->roles)
            pobject_lives(interp, (PObj*)role->roles);
        if (role->methods)
            pobject_lives(interp, (PObj*)role->methods);
        if (role->attrib_metadata)
            pobject_lives(interp, (PObj*)role->attrib_metadata);
    }


/*

=item C<void add_attribute(STRING *name, PMC *type)>

Adds the given attribute with an optional type.
Enters the attribute in the C<attributes> array.

=cut

*/

    void add_attribute(STRING *name, PMC *type) {
        Parrot_Role *role = PARROT_ROLE(SELF);
        PMC *new_attribute = pmc_new(interp, enum_class_Hash);

        /* Set name and type. */
        VTABLE_set_string_keyed_str(interp, new_attribute,
            CONST_STRING(interp, "name"), name);
        if (!PMC_IS_NULL(type)) {
            VTABLE_set_pmc_keyed_str(interp, new_attribute,
                CONST_STRING(interp, "type"), type);
        }

        /* Enter the attribute in the attributes array. */
        VTABLE_set_pmc_keyed_str(interp, role->attrib_metadata, name, new_attribute);
    }


/*

=item C<void add_method(STRING *name, PMC *sub)>

Adds the given sub PMC as a method with the given name.

=cut

*/

    void add_method(STRING *name, PMC *sub) {
        Parrot_Role *role = PARROT_ROLE(SELF);

        /* If we have already added a method with this name... */
        if (VTABLE_exists_keyed_str(interp, role->methods, name)) {
            /* XXX Need to handle multi methods here. */
            real_exception(interp, NULL, E_NotImplementedError,
                "Currently, adding multiple methods of the same name is not supported.");
        }
        else {
            /* Enter it into the table. */
            VTABLE_set_pmc_keyed_str(interp, role->methods, name, sub);
        }
    }


/*

=item C<void add_role(PMC *role)>

Composes the supplied Role PMC into this role, provided there are no
conflicts.

=cut

*/

    void add_role(PMC *role) {
        Parrot_Role *this_role = PARROT_ROLE(SELF);

        /* Do the composition. */
        Parrot_ComposeRole(interp, role, PMCNULL, 0, PMCNULL, 0,
               this_role->methods, this_role->roles);
    }


/*

=item C<PMC *inspect_str(STRING *what)>

Provides introspection of a specific piece of information about the role. The
available information is:

=over 4

=item name - String PMC containing the name of the role

=item namespce - NameSpace PMC of the the namespace attached to the role

=item attributes - Hash keyed on attribute name, value is hash describing it

=item methods - Hash keyed on method name, value is an invokable PMC. Includes
methods composed in from roles.

=item roles - Array of Role PMCs. Includes roles done by the roles that were
composed into this role.

=back

=cut

*/

    PMC* inspect_str(STRING *what) {
        Parrot_Role *role = PARROT_ROLE(SELF);

        /* What should we return? */
        PMC *found;
        if (string_equal(interp, what, CONST_STRING(interp, "name")) == 0) {
            found = pmc_new(interp, enum_class_String);
            VTABLE_set_string_native(interp, found, role->name);
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "namespace")) == 0) {
            found = role->namespace;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "attributes")) == 0) {
            found = role->attrib_metadata;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "methods")) == 0) {
            found = role->methods;
        }
        else if (string_equal(interp, what, CONST_STRING(interp, "roles")) == 0) {
            found = role->roles;
        }
        else {
            real_exception(interp, NULL, INVALID_OPERATION,
                "Unknown introspection value '%S'", what);
        }

        /* Clone and return. */
        return VTABLE_clone(interp, found);
    }


/*

=item C<PMC *inspect()>

Returns a Hash describing the role, with key/value pairs as described in
inspect_str.

=cut

*/

    PMC* inspect() {
        /* Create a hash, then use inspect_str to get all of the data to
         * fill it up with. */
        PMC *metadata = pmc_new(interp, enum_class_Hash);
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "name"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "name")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "namespace"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "namespace")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "attributes"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "attributes")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "methods"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "methods")));
        VTABLE_set_pmc_keyed_str(interp, metadata, CONST_STRING(interp, "roles"),
            VTABLE_inspect_str(interp, SELF, CONST_STRING(interp, "roles")));
        return metadata;
    }

    /*
     * Below here are non-vtable methods that eventually will go in a role
     * that is composed into here to optionally give a nice interface from
     * PIR (ParrotRole isa Role does RoleMethods or something like this).
     */


/*

=back

=head2 Methods

=over 4

=item C<PCCMETHOD void
    name(STRING *name :optional, int got_name :opt_flag)>

Sets the name of the role.

=cut

*/

    PCCMETHOD void name(STRING *name :optional, int got_name :opt_flag) {
        Parrot_Role *role = PARROT_ROLE(SELF);
        STRING *ret_name = NULL;

        if (got_name) {
            /* Set role name. */
            role->name = name;
        }

        ret_name = role->name;
        PCCRETURN(STRING *ret_name);
    }


/*

=item C<PCCMETHOD void
    namespace(PMC *namespace :optional, int got_name :opt_flag)>

With a parameter, sets the namespace for the role. Expects a fully
qualified namespace to be specified as a key. If you already have linked another
namespace with this role, this link will be broken and the new namespace
specified will be linked to this role.

=cut

*/

    PCCMETHOD void namespace(PMC *namespace :optional, int got_name :opt_flag) {
        Parrot_Role *role = PARROT_ROLE(SELF);
        PMC *ret_namespace = NULL;

        if (got_name) {
            /* If namespace is a key or a string, need to look it up. */
            switch (namespace->vtable->base_type) {
                case enum_class_NameSpace:
                    /* It's fine, don't need to do anything. */
                    break;
                case enum_class_Key:
                    /* Look it up relative to HLL base. */
                    namespace = Parrot_get_namespace_keyed(interp,
                        interp->HLL_namespace, namespace);
                    if (PMC_IS_NULL(namespace))
                        real_exception(interp, NULL, E_NameError, "Namespace cannot be found");
                    break;
                case enum_class_String:
                    /* Look it up relative to current namespace. */
                    namespace = Parrot_get_namespace_keyed_str(interp,
                        CONTEXT(interp->ctx)->current_namespace,
                        VTABLE_get_string(interp, namespace));
                    if (PMC_IS_NULL(namespace))
                        real_exception(interp, NULL, E_NameError, "Namespace cannot be found");
                    break;
                default:
                    /* Don't know what to do with it. */
                    real_exception(interp, NULL, E_NameError, "Namespace must be a key");
            }

            /* Check namespace is a key. */
            if (namespace->vtable->base_type != enum_class_Key) {
                real_exception(interp, NULL, E_NameError, "Namespace must be a key");
                return;
            }

            /* If we already have a namespace, it shouldn't refer to the
               role any more. */
            if (role->namespace) {
                PMC *role_ns = role->namespace;
                PCCINVOKE(interp, role_ns, "set_class", PMC* PMCNULL);
            }

            /* Set namespace. */
            role->namespace = Parrot_get_namespace_keyed(interp,
                interp->HLL_namespace, namespace);

            /* Link namespace to this role. */
            PCCINVOKE(interp, namespace, "set_class", PMC* SELF);

            /* XXX Get methods from the namespace we were linked to. */
        }

        ret_namespace = role->namespace;
        PCCRETURN(PMC *ret_namespace);
    }


/*

=item C<PCCMETHOD void
    attributes()>

Return a hash where the keys are attribute names and the values are hashes
providing a set of key/value pairs describing the attribute.

=cut

*/
    PCCMETHOD void attributes() {
        PMC *ret_attrib_metadata = VTABLE_inspect_str(interp, SELF,
            CONST_STRING(interp, "attributes"));
        PCCRETURN(PMC *ret_attrib_metadata);
    }


/*

=item C<PCCMETHOD void
    add_attribute(STRING *attribute_name,
            PMC* attribute_type :optional, int got_type :opt_flag)>

Add an attribute to the role. Requires a name and, optionally, a type.

=cut

*/
    PCCMETHOD void add_attribute(STRING *attribute_name,
            PMC* attribute_type :optional, int got_type :opt_flag) {
        VTABLE_add_attribute(interp, SELF, attribute_name,
            got_type ? attribute_type : PMCNULL);
    }


/*

=item C<PCCMETHOD void
    methods()>

Return a hash where the keys are method names and the values are methods.

=cut

*/
    PCCMETHOD void methods() {
        PMC *ret_methods = VTABLE_inspect_str(interp, SELF,
                CONST_STRING(interp, "methods"));
        PCCRETURN(PMC *ret_methods);
    }


/*

=item C<PCCMETHOD void
    add_method(STRING *name, PMC *sub)>

Adds the given sub PMC as a method with the given name.

=cut

*/
    PCCMETHOD void add_method(STRING *name, PMC *sub) {
        VTABLE_add_method(interp, SELF, name, sub);
    }


/*

=item C<PCCMETHOD void
    roles()>

Return the roles array PMC.

=cut

*/
    PCCMETHOD void roles() {
        PMC *ret_roles = VTABLE_inspect_str(interp, SELF,
            CONST_STRING(interp, "roles"));
        PCCRETURN(PMC *ret_roles);
    }


/*

=item C<PCCMETHOD void
    add_role(PMC* role,
            PMC* exclude_method :optional :named["exclude_method"],
            int got_exclude_method :opt_flag,
            PMC* alias_method :optional :named["alias_method"],
            int got_alias_method :opt_flag)>

Compose the given role into this one, using the given exclusions and aliases.

=cut

*/
    PCCMETHOD void add_role(PMC* role,
            PMC* exclude_method :optional :named["exclude_method"],
            int got_exclude_method :opt_flag,
            PMC* alias_method :optional :named["alias_method"],
            int got_alias_method :opt_flag) {
        Parrot_Role *role_info = PARROT_ROLE(SELF);
        Parrot_ComposeRole(interp, role, exclude_method, got_exclude_method,
                           alias_method, got_alias_method,
                           role_info->methods, role_info->roles);
    }

/*

=item C<void inspect(STRING *what :optional)>

Gets all introspection data for the role or, if the optional string
parameter is supplied, a particular item of introspection data.

=cut

*/
    PCCMETHOD void inspect(STRING *what :optional, int got_what :opt_flag) {
        PMC *found;

        /* Just delegate to the appropriate vtable method. */
        if (got_what)
            found = VTABLE_inspect_str(interp, SELF, what);
        else
            found = VTABLE_inspect(interp, SELF);

        PCCRETURN(PMC *found);
    }

} /* end pmclass Role */


/*

=back

=head1 STABILITY

Unstable. This PMC is under active development; major portions of the
interface have not yet been completed.

=head1 SEE ALSO

F<docs/pdds/pdd15_objects.pod>.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
