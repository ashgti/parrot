/*
Copyright (C) 2001-2006, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/file.pmc - File PMC

=head1 DESCRIPTION

C<File> is a singleton class which provides access to File functions.

=head2 Methods

=over 4

=cut

*/

#ifdef WIN32
#include <direct.h>
#endif

#include "parrot/parrot.h"

/* XXX Check if we need to deallocate strerror strings */
/* XXX apparently, strerror_r is thread-safe and should be used instead.*/

static PMC * File_PMC;
pmclass File singleton {

/*

=item C<void* get_pointer()>

=item C<void set_pointer(void *ptr)>

These two functions are part of the singleton creation interface. For more
information see F<src/pmc.c>.

=cut

*/

    void* get_pointer() {
        return File_PMC;
    }

    void set_pointer(void* ptr) {
        File_PMC = (PMC*) ptr;
    }

/*

=item C<INTVAL is_dir(STRING* path)>

Returns a true value (1) if the supplied path is a directory.

=cut

*/

    METHOD INTVAL is_dir(STRING *path) {
        struct stat info;
        char *cpath = string_to_cstring(interpreter, path);
#ifdef WIN32
        int error = stat(cpath, &info);
#else
        int error = lstat(cpath, &info);
#endif
        string_cstring_free(cpath);
        if (error) {
            char *errmsg = strerror(errno);
            real_exception(interpreter, NULL, E_SystemError, errmsg);
        }

        if (S_ISDIR(info.st_mode)) {
            return 1;
        } else {
            return 0;
        }
    }

/*

=item C<INTVAL is_file(STRING* path)>

Returns a true value (1) if the supplied path is a plain file.

=cut

*/

    METHOD INTVAL is_file(STRING *path) {
        struct stat info;
        char *cpath = string_to_cstring(interpreter, path);
#ifdef WIN32
        int error = stat(cpath, &info);
#else
        int error = lstat(cpath, &info);
#endif
        string_cstring_free(cpath);
        if (error) {
            char *errmsg = strerror(errno);
            real_exception(interpreter, NULL, E_SystemError, errmsg);
        }

        if (S_ISREG(info.st_mode)) {
            return 1;
        } else {
            return 0;
        }
    }

/*

=item C<INTVAL is_link(STRING* path)>

Returns a true value (1) if the supplied path is a link.

=cut

*/

    METHOD INTVAL is_link(STRING *path) {
#ifdef WIN32
        /* I love win32 implementations */
        return 0;
#else
        struct stat info;
        char *cpath = string_to_cstring(interpreter, path);
        int error = lstat(cpath, &info);
        string_cstring_free(cpath);
        if (error) {
            char *errmsg = strerror(errno);
            real_exception(interpreter, NULL, E_SystemError, errmsg);
        }

        if (S_ISLNK(info.st_mode)) {
            return 1;
        } else {
            return 0;
        }
#endif
    }

/*

=item C<void copy(STRING* from, STRING *to)>

Copy the contents from file represented by path C<from> to the path
C<to>.

Uses the "work everywhere method". It is good enough to start with.

NOTE: I'm sure that there should be more efficient ways to do this. Be
free to change or give me hints on how to change it. -- ambs

=cut

*/

    METHOD void copy(STRING *from, STRING *to) {
#define CHUNK_SIZE 1024
        FILE *source = NULL;
        FILE *target = NULL;

        char *cfrom = string_to_cstring(interpreter, from);
        char *cto = string_to_cstring(interpreter, to);
        source = fopen(cfrom, "rb");
        if (source) {
            target = fopen(cto, "w+b");
            if (target) {
                char buf[CHUNK_SIZE];
                int bytes_read, bytes_written;
                while(!feof(source)) {
                    bytes_read = fread(buf, 1, CHUNK_SIZE, source);
                    if (bytes_read) {
                        bytes_written = fwrite(buf, 1, bytes_read, target);
                        if (bytes_read != bytes_written) {
                            real_exception(interpreter, NULL, E_SystemError, 
                                           "Error writting file");
                            break;
                        }
                    }
                }
                fclose(target);
            } else {
                char *errmsg = strerror(errno);
                real_exception(interpreter, NULL, E_SystemError, errmsg);
            }
            fclose(source);
        } else {
            char *errmsg = strerror(errno);
            real_exception(interpreter, NULL, E_SystemError, errmsg);
        }
        string_cstring_free(cfrom);
        string_cstring_free(cto);
#undef CHUNK_SIZE
    }

/*

=item C<void rename(STRING* from, STRING *to)>

Rename a file C<from> to the path C<to>.

=cut

*/

    METHOD void rename(STRING *from, STRING *to) {
        char *cfrom = string_to_cstring(interpreter, from);
        char *cto = string_to_cstring(interpreter, to);
        int error = rename(cfrom, cto);
        string_cstring_free(cfrom);
        string_cstring_free(cto);
        if (error) {
            char *errmsg = strerror(errno);
            real_exception(interpreter, NULL, E_SystemError, errmsg);
        }
    }
}

/*

=back

=head1 SEE ALS0

   stat(2), rename(2)

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
