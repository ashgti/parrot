/*
Copyright (C) 2001-2003, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/fixedstringarray.pmc - fixed size array for strings only

=head1 DESCRIPTION

This class, FixedStringArray, implements an array of fixed size, which
stores Parrot strings.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass FixedStringArray need_ext does array {

/*

=back

=head2 Methods

=over 4

=item C<void init()>

Initializes the array.

=cut

*/

    void init() {
        PMC_int_val(SELF) = 0;
        PMC_data(SELF) = NULL;
    }

/*

=item C<void morph(INTVAL type)>

Const PMCs must have a C<morph()>.

=cut

*/

    void morph(INTVAL type) {
        SUPER(type);
    }


/*

=item C<void destroy()>

Destroys the array.

=cut

*/

    void destroy() {
        if (PMC_data(SELF))
            mem_sys_free(PMC_data(SELF));
        PMC_data(SELF) = NULL;
        PMC_int_val(SELF) = 0;
    }

/*

=item C<PMC *clone()>

Creates and returns a copy of the array.

=cut

*/

    PMC* clone() {
        INTVAL size;
        PMC * dest = pmc_new(INTERP, SELF->vtable->base_type);

        if (!PMC_data(SELF))
            return dest;
        size = PMC_int_val(SELF);
        PMC_int_val(dest) = size;

        PMC_data(dest) = mem_sys_allocate(size * sizeof (STRING*));
        mem_sys_memcopy(PMC_data(dest), PMC_data(SELF), size*sizeof (STRING*));
        PObj_custom_mark_destroy_SETALL(dest);
        return dest;
    }

/*

=item C<void mark()>

Marks the array as live.

=cut

*/

    void mark() {
        int i, end;
        STRING **data;
        if (!PMC_data(SELF))
            return;
        data = (STRING **) PMC_data(SELF);
        end = PMC_int_val(SELF);
        for (i = 0; i < end; i++) {
            if (data[i]) {
                pobject_lives(INTERP, (PObj *) data[i]);
            }
        }
    }

/*

=item C<INTVAL get_bool()>

Returns 1 if the array has any elements; otherwise, returns 0.
Since this is a fixed size array, C<get_bool> will always
return true once the array has been initialized and had its
size set by C<set_integer_native>.

=cut

*/
    INTVAL get_bool() {
        INTVAL size = SELF.elements();
        return (INTVAL)(size != 0);
    }

/*

=item C<INTVAL elements()>

Returns the number of elements in the array.

=cut

*/

    INTVAL elements() {
        return PMC_int_val(SELF);
    }

/*

=item C<INTVAL get_integer()>

Returns the number of elements in the array.

=cut

*/

    INTVAL get_integer() {
        return SELF.elements();
    }


/*

=item C<INTVAL get_integer_keyed_int(INTVAL key)>

Returns the integer value of the element at index C<key>.

=cut

*/

    INTVAL get_integer_keyed_int(INTVAL key) {
        PMC *tempPMC = DYNSELF.get_pmc_keyed_int(key);
        return VTABLE_get_integer(INTERP, tempPMC);
    }

/*

=item C<INTVAL get_integer_keyed(PMC *key)>

Returns the integer value of the element at index C<*key>.

=cut

*/

    INTVAL get_integer_keyed(PMC* key) {
        /* simple int keys only */
        INTVAL k = key_integer(INTERP, key);
        return DYNSELF.get_integer_keyed_int(k);
    }


/*

=item C<FLOATVAL get_number_keyed_int(INTVAL key)>

Returns the floating-point value of the element at index C<key>.

=cut

*/

    FLOATVAL get_number_keyed_int(INTVAL key) {
        PMC *tempPMC = DYNSELF.get_pmc_keyed_int(key);
        return VTABLE_get_number(INTERP, tempPMC);
    }

/*

=item C<FLOATVAL get_number_keyed(PMC* key)>

Returns the floating-point value of the element at index C<*key>.

=cut

*/

    FLOATVAL get_number_keyed(PMC* key) {
        INTVAL k = key_integer(INTERP, key);
        return DYNSELF.get_number_keyed_int(k);
    }

/*

=item C<STRING *get_string_keyed_int(INTVAL key)>

Returns the Parrot string value of the element at index C<key>.

=cut

*/

    STRING* get_string_keyed_int(INTVAL key) {
        STRING **data;
        if (key < 0 || key >= PMC_int_val(SELF))
            real_exception(INTERP, NULL, E_IndexError,
                "FixedStringArray: index out of bounds!");

        data = (STRING **)PMC_data(SELF);
        return data[key];
    }

/*

=item C<STRING *get_string_keyed(PMC *key)>

Returns the Parrot string value of the element at index C<*key>.

=cut

*/

    STRING* get_string_keyed(PMC* key) {
        INTVAL k = key_integer(INTERP, key);
        return DYNSELF.get_string_keyed_int(k);
    }


/*

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Returns the PMC value of the element at index C<key>.

=cut

*/

    PMC* get_pmc_keyed_int(INTVAL key) {
        PMC *ret;
        STRING *val;

        ret = pmc_new(INTERP, enum_class_String);
        val = DYNSELF.get_string_keyed_int(key);
        VTABLE_set_string_native(INTERP, ret, val);
        return ret;
    }

/*

=item C<PMC *get_pmc_keyed(PMC *key)>

Returns the PMC value of the element at index C<*key>.

=cut

*/

    PMC* get_pmc_keyed(PMC* key) {
        INTVAL k = key_integer(INTERP, key);
        return DYNSELF.get_pmc_keyed_int(k);
    }

/*

=item C<void set_integer_native(INTVAL size)>

Sets the size of the array to C<size> elements. Once the array
has been given an initial size, attempts to resize it will
cause an exception to be thrown.

=cut

*/

    void set_integer_native(INTVAL size) {
        if (PMC_int_val(SELF) || size < 1)
            real_exception(INTERP, NULL, E_IndexError,
                    "FixedStringArray: Can't resize!");
        PMC_int_val(SELF) = size;
        PMC_data(SELF) = mem_sys_allocate_zeroed(size * sizeof (STRING*));
        PObj_custom_mark_destroy_SETALL(SELF);
    }

/*

=item C<void set_integer_keyed_int(INTVAL key, INTVAL value)>

Sets the integer value of the element at index C<key> to C<value>.

=cut

*/

    void set_integer_keyed_int(INTVAL key, INTVAL value) {
        PMC *ret;
        STRING *val;

        ret = pmc_new(INTERP, enum_class_String);
        VTABLE_set_integer_native(INTERP, ret, value);
        val = VTABLE_get_string(INTERP, ret);
        DYNSELF.set_string_keyed_int(key, val);
    }

/*

=item C<void set_integer_keyed(PMC *key, INTVAL value)>

Sets the integer value of the element at index C<key> to C<value>.

=cut

*/

    void set_integer_keyed(PMC *key, INTVAL value) {
        INTVAL k;
        k = key_integer(INTERP, key);
        DYNSELF.set_integer_keyed_int(k, value);
    }

/*

=item C<void set_number_keyed_int(INTVAL key, FLOATVAL value)>

Sets the floating-point value of the element at index C<key> to
C<value>.

=cut

*/

    void set_number_keyed_int(INTVAL key, FLOATVAL value) {
        PMC *ret;
        STRING *val;

        ret = pmc_new(INTERP, enum_class_String);
        VTABLE_set_number_native(INTERP, ret, value);
        val = VTABLE_get_string(INTERP, ret);
        DYNSELF.set_string_keyed_int(key, val);
    }

/*

=item C<void set_number_keyed(PMC *key, FLOATVAL value)>

Sets the floating-point value of the element at index C<key> to
C<value>.

=cut

*/

    void set_number_keyed(PMC *key, FLOATVAL value) {
        INTVAL k;
        k = key_integer(INTERP, key);
        DYNSELF.set_number_keyed_int(k, value);
    }

/*

=item C<void set_string_keyed_int(INTVAL key, STRING *value)>

Sets the Parrot string value of the element at index C<key> to C<value>.

=cut

*/

    void set_string_keyed_int(INTVAL key, STRING* value) {
        STRING **data;
        if (key < 0 || key >= PMC_int_val(SELF))
            real_exception(INTERP, NULL, E_IndexError,
                "FixedStringArray: index out of bounds!");

        data = (STRING**)PMC_data(SELF);
        DOD_WRITE_BARRIER(INTERP, SELF, data[key], value);
        data[key] = value;
    }

/*

=item C<void set_string_keyed(PMC *key, STRING* value)>

Sets the string value of the element at index C<key> to
C<value>.

=cut

*/

    void set_string_keyed(PMC *key, STRING* value) {
        INTVAL k;
        k = key_integer(INTERP, key);
        DYNSELF.set_string_keyed_int(k, value);
    }

/*

=item C<void set_pmc_keyed_int(INTVAL key, PMC *src)>

Sets the PMC value of the element at index C<key> to C<*src>.

=cut

*/

    void set_pmc_keyed_int(INTVAL key, PMC* src) {
        STRING *temp;

        temp = VTABLE_get_string(INTERP, src);
        DYNSELF.set_string_keyed_int(key, temp);
    }

/*

=item C<void set_pmc_keyed(PMC *key, PMC* value)>

Sets the string value of the element at index C<key> to
C<value>.

=cut

*/

    void set_pmc_keyed(PMC *key, PMC* value) {
        INTVAL k;
        k = key_integer(INTERP, key);
        DYNSELF.set_pmc_keyed_int(k, value);
    }

/*

=back

=head2 Freeze/thaw Interface

=over 4

=item C<void freeze(visit_info *info)>

Used to archive the string.

=cut

*/
    void freeze(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        INTVAL i, n;
        STRING **data;

        data = (STRING**)PMC_data(SELF);
        n = PMC_int_val(SELF);
        io->vtable->push_integer(INTERP, io, n);
        for (i = 0; i < n; ++i) {
            io->vtable->push_string(INTERP, io, data[i]);
        }
    }

/*

=item C<void thaw(visit_info *info)>

Used to unarchive the string.

=cut

*/
    void thaw(visit_info *info) {
        IMAGE_IO *io = info->image_io;
        INTVAL i, n;
        STRING **data;
        SUPER(info);

        if (info->extra_flags == EXTRA_IS_NULL) {
            DYNSELF.init();

            n    = io->vtable->shift_integer(INTERP, io);
            DYNSELF.set_integer_native(n);
            data = PMC_data_typed(SELF, STRING **);

            for (i = 0; i < n; ++i)
                data[i] = io->vtable->shift_string(INTERP, io);
        }
    }
}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd17_basic_types.pod>.

=head1 HISTORY

Initial version 2004.06.11 by Matt Fowles

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
