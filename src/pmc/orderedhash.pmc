/*
Copyright (C) 2001-2009, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/orderedhash.pmc - Ordered Hash

=head1 DESCRIPTION

C<OrderedHash> provide the interfaces of C<array> and
C<hash>.

Some limitations:

=over 4

=item *

Keys are always STRING*.

=item *

Values are always PMC*.

=back

To archive ordering for each item we store:

=over 4

=item * C<key>

Original key

=item * C<value>

Original value

=item * C<next>

Pointer to next C<item>

=item * C<prev>

Pointer to previous C<item>

=back

OrderedHash stores next things:

=over 4

=item * C<hash>

Lookup hash for values.

=item * C<first>

Pointer to first inserted value.

=item * C<last>

Pointer to last inserter value.

=back

See F<t/pmc/orderedhash.t> for test cases.

Overall design heavily inspired by C<Tie::StoredOrderHash>.

=head2 Methods

=over 4

=cut

*/

/* Create new stored item. FixedPMCArray of (key, value, prev, next). */
static PMC*
create_item(PARROT_INTERP, ARGIN(PMC *key), ARGIN(PMC *value)) {
    PMC *ret = pmc_new(interp, enum_class_FixedPMCArray);
    VTABLE_set_integer_native(interp, ret, ORDERED_HASH_ITEM_MAX);

    VTABLE_set_pmc_keyed_int(interp, ret, ORDERED_HASH_ITEM_KEY, key);
    VTABLE_set_pmc_keyed_int(interp, ret, ORDERED_HASH_ITEM_VALUE, value);
    return ret;
};

/* Find first/last in cloned/thawed OrderedHash */
/* Parameter C<pmc_hash> is Hash, not OrderedHash */
static void
find_bounds(PARROT_INTERP, PMC *pmc_hash, PMC **first, PMC **last) {
    PMC *iter = VTABLE_get_iter(interp, pmc_hash);
    while (VTABLE_get_bool(interp, iter)) {
        PMC *item  = VTABLE_shift_pmc(interp, iter);
        PMC *entry = VTABLE_get_pmc_keyed(interp, pmc_hash, item);
        /* First entry doesn't have prev */
        PMC *tmp   = VTABLE_get_pmc_keyed_int(interp, entry, ORDERED_HASH_ITEM_PREV);
        if (PMC_IS_NULL(tmp))
            *first = entry;
        /* Last entry doesn't have next */
        tmp   = VTABLE_get_pmc_keyed_int(interp, entry, ORDERED_HASH_ITEM_NEXT);
        if (PMC_IS_NULL(tmp))
            *last = entry;
    }
}

/* Helpers for boxing values */
static PMC*
box_string(PARROT_INTERP, STRING *str) {
    PMC * const ret = pmc_new(interp, Parrot_get_ctx_HLL_type(interp,
                enum_class_String));
    VTABLE_set_string_native(interp, ret, str);
    return ret;
}

static PMC*
box_integer(PARROT_INTERP, INTVAL val) {
    PMC * const ret = pmc_new(interp, Parrot_get_ctx_HLL_type(interp,
                enum_class_Integer));
    VTABLE_set_integer_native(interp, ret, val);
    return ret;
}

static PMC*
box_number(PARROT_INTERP, FLOATVAL val) {
    PMC * const ret = pmc_new(interp, Parrot_get_ctx_HLL_type(interp,
                enum_class_Float));
    VTABLE_set_number_native(interp, ret, val);
    return ret;
}


pmclass OrderedHash need_ext provides array {
    ATTR PMC    *hash;   /* key to item tuple */
    ATTR PMC    *first;  /* Pointer to first inserted value  */
    ATTR PMC    *last;   /* Pointer to last inserted value   */

/*

=item C<void init()>

Create new instance of OrderedHash.

=cut

*/

    VTABLE void init() {
        Parrot_OrderedHash_attributes * const attrs =
                mem_allocate_zeroed_typed(Parrot_OrderedHash_attributes);

        PMC_data(SELF)  = attrs;
        attrs->hash     = pmc_new(INTERP, enum_class_Hash);
        attrs->first    = PMCNULL;
        attrs->last     = PMCNULL;

        PObj_custom_mark_destroy_SETALL(SELF);
    }

/*

=item C<void mark()>

Marks the OrderedHash as live.

=cut

*/

    VTABLE void mark() {
        Parrot_OrderedHash_attributes * const attrs =
                PARROT_ORDEREDHASH(SELF);

        if (attrs->hash)
            Parrot_gc_mark_PObj_alive(INTERP, (PObj *)attrs->hash);

        /* Don't mark C<first> and C<last>. They are in lookup hash anyway */
    }


    VTABLE void destroy() {
        mem_sys_free(PMC_data(SELF));
    }

/*

=item C<PMC *get_iter()>

Return a new iterator

=cut

*/

    VTABLE PMC *get_iter() {
        return pmc_new_init(INTERP, enum_class_OrderedHashIterator, SELF);
    }

/*

=item C<INTVAL elements()>

=item C<INTVAL get_integer()>

=item C<FLOATVAL get_number()>

Returns the size of the hash.

=cut

*/

    VTABLE INTVAL get_integer() {
        return STATICSELF.elements();
    }

    VTABLE FLOATVAL get_number() {
        return SELF.get_integer();
    }

    VTABLE INTVAL elements() {
        return VTABLE_elements(INTERP, PARROT_ORDEREDHASH(SELF)->hash);
    }

/*

=item C<set_pmc_keyed(PMC *key, PMC *value)>

Main set function.

=cut

*/
    VTABLE void set_pmc_keyed(PMC *key, PMC *value) {
        Parrot_OrderedHash_attributes *attrs =
                PARROT_ORDEREDHASH(SELF);
        /* Check for old entry */
        PMC *list_entry = VTABLE_get_pmc_keyed(INTERP, attrs->hash, key);
        if (!PMC_IS_NULL(list_entry)) {
            /* We have old entry. Just update value */
            VTABLE_set_pmc_keyed_int(INTERP, list_entry, ORDERED_HASH_ITEM_VALUE, value);
            return;
        }

        /* Create new entry */
        list_entry = pmc_new(INTERP, enum_class_FixedPMCArray);
        VTABLE_set_integer_native(INTERP, list_entry, ORDERED_HASH_ITEM_MAX);
        VTABLE_set_pmc_keyed_int(INTERP, list_entry, ORDERED_HASH_ITEM_VALUE, value);
        VTABLE_set_pmc_keyed_int(INTERP, list_entry, ORDERED_HASH_ITEM_KEY, key);

        /* .. and link it */
        if (!PMC_IS_NULL(attrs->last)) {
            VTABLE_set_pmc_keyed_int(INTERP, list_entry, ORDERED_HASH_ITEM_PREV, attrs->last);
            VTABLE_set_pmc_keyed_int(INTERP, attrs->last, ORDERED_HASH_ITEM_NEXT, list_entry);
        }
        attrs->last = list_entry;
        if (PMC_IS_NULL(attrs->first))
            attrs->first = list_entry;

        /* .. and store it */
        VTABLE_set_pmc_keyed(INTERP, attrs->hash, key, list_entry);
    }
/*

=item C<void set_integer_keyed(INTVAL key, INTVAL value)>

=item C<void set_number_keyed(INTVAL key, FLOATVAL value)>

=item C<void set_string_keyed(INTVAL key, STRING *value)>

Sets the PMC value of the element at index C<key> to C<val>.

=cut

*/

    VTABLE void set_integer_keyed(PMC *key, INTVAL value) {
        PMC * const v = box_integer(INTERP, value);
        SELF.set_pmc_keyed(key, v);
    }

    VTABLE void set_number_keyed(PMC *key, FLOATVAL value) {
        PMC * const v = box_number(INTERP, value);
        SELF.set_pmc_keyed(key, v);
    }

    VTABLE void set_string_keyed(PMC *key, STRING *value) {
        PMC * const v = box_string(INTERP, value);
        SELF.set_pmc_keyed(key, v);
    }

/*

=item C<void set_pmc_keyed_str(STRING *key, PMC *val)>

=item C<void set_integer_keyed_str(STRING *key, INTVAL value)>

=item C<void set_number_keyed_str(STRING *key, FLOATVAL value)>

=item C<void set_string_keyed_str(STRING *key, STRING *value)>

Sets the PMC value of the element at index C<key> to C<val>.

=cut

*/

    VTABLE void set_pmc_keyed_str(STRING *key, PMC *value) {
        PMC *pkey = box_string(INTERP, key);
        VTABLE_set_pmc_keyed(INTERP, SELF, pkey, value);
    }

    VTABLE void set_string_keyed_str(STRING *key, STRING *value) {
        PMC * const v = box_string(INTERP, value);
        STATICSELF.set_pmc_keyed_str(key, v);
    }

    VTABLE void set_integer_keyed_str(STRING *key, INTVAL value) {
        PMC * const v = box_integer(INTERP, value);
        STATICSELF.set_pmc_keyed_str(key, v);
    }

    VTABLE void set_number_keyed_str(STRING *key, FLOATVAL value) {
        PMC * const v = box_number(INTERP, value);
        STATICSELF.set_pmc_keyed_str(key, v);
    }

/*

=item C<PMC *get_pmc_keyed(PMC *key)>

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

=item C<PMC *get_pmc_keyed_str(STRING *key)>

=cut

*/

    VTABLE PMC *get_pmc_keyed_int(INTVAL idx) {
        Parrot_OrderedHash_attributes *attrs = PARROT_ORDEREDHASH(SELF);
        INTVAL                         n = STATICSELF.elements();
        INTVAL                         pos;
        PMC                           *list_entry = attrs->first;

        if (idx < -n)
            idx = -idx - n - 1;
        else if (idx < 0)
            idx += n;

        /* Iterate over linked list to get value */
        for (pos = 0; pos < idx; ++pos) {
            list_entry = VTABLE_get_pmc_keyed_int(INTERP, list_entry, ORDERED_HASH_ITEM_NEXT);
        }

        PARROT_ASSERT(!PMC_IS_NULL(list_entry));
        return VTABLE_get_pmc_keyed_int(INTERP, list_entry, ORDERED_HASH_ITEM_VALUE);
    }

    VTABLE PMC *get_pmc_keyed(PMC *key) {
        PMC * item;
        if ((PObj_get_FLAGS(key) & KEY_type_FLAGS) == KEY_integer_FLAG) {
            PMC * const item = SELF.get_pmc_keyed_int(VTABLE_get_integer(INTERP, key));
            PMC * const next = VTABLE_shift_pmc(INTERP, key);

            if (!next)
                return item;

            return VTABLE_get_pmc_keyed(INTERP, item, next);
        }

        item = VTABLE_get_pmc_keyed(INTERP, PARROT_ORDEREDHASH(SELF)->hash, key);
        if (PMC_IS_NULL(item))
            return PMCNULL;
        return VTABLE_get_pmc_keyed_int(INTERP, item, ORDERED_HASH_ITEM_VALUE);
    }

    VTABLE PMC *get_pmc_keyed_str(STRING *key) {
        PMC *pkey = pmc_new(interp, Parrot_get_ctx_HLL_type(interp, enum_class_String));
        VTABLE_set_string_native(INTERP, pkey, key);
        return STATICSELF.get_pmc_keyed(pkey);
    }
/*

=item C<STRING *get_string_keyed(PMC *key)>

=item C<STRING *get_string_keyed_int(INTVAL key)>

=item C<STRING *get_string_keyed_str(STRING *key)>

=cut

*/

    VTABLE STRING *get_string_keyed_int(INTVAL idx) {
        PMC * const item = VTABLE_get_pmc_keyed_int(INTERP, SELF, idx);
        return VTABLE_get_string(INTERP, item);
    }

    VTABLE STRING *get_string_keyed(PMC *key) {
        PMC * const item = VTABLE_get_pmc_keyed(INTERP, SELF, key);
        return VTABLE_get_string(INTERP, item);
    }
/*

=item C<INTVAL get_integer_keyed(PMC *key)>

=item C<INTVAL get_integer_keyed_str(STRING *key)>

=item C<INTVAL get_integer_keyed_int(INTVAL key)>

Returns the integer value associated with C<key>.

=cut

*/

    VTABLE INTVAL get_integer_keyed_int(INTVAL idx) {
        PMC * const item = VTABLE_get_pmc_keyed_int(INTERP, SELF, idx);
        return VTABLE_get_integer(INTERP, item);
    }

    VTABLE INTVAL get_integer_keyed(PMC *key) {
        PMC * const item = VTABLE_get_pmc_keyed(INTERP, SELF, key);
        return VTABLE_get_integer(INTERP, item);
    }

/*

=item C<FLOATVAL get_number_keyed(PMC *key)>

=item C<FLOATVAL get_number_keyed_int(INTVAL key)>

=item C<FLOATVAL get_number_keyed_str(STRING *key)>

Returns the floating-point value for the element at C<key>.

=cut

*/

    VTABLE FLOATVAL get_number_keyed_int(INTVAL idx) {
        PMC * const item = VTABLE_get_pmc_keyed_int(INTERP, SELF, idx);
        return VTABLE_get_number(INTERP, item);
    }

    VTABLE FLOATVAL get_number_keyed(PMC *key) {
        PMC * const item = VTABLE_get_pmc_keyed(INTERP, SELF, key);
        return VTABLE_get_number(INTERP, item);
    }

/*

=item C<void set_pmc_keyed_int(INTVAL idx, PMC *val)>

=item C<void set_integer_keyed_int(INTVAL key, INTVAL value)>

=item C<void set_number_keyed_int(INTVAL key, FLOATVAL value)>

=item C<void set_string_keyed_int(INTVAL key, STRING *value)>

Sets the PMC value of the element at index C<key> to C<val>.
The created key = "\1idx".

=cut

*/

    VTABLE void set_pmc_keyed_int(INTVAL idx, PMC *val) {
        const INTVAL     n = STATICSELF.elements();
        STRING * const fmt = CONST_STRING(INTERP, "\1%d");
        PMC * list_entry;
        INTVAL pos;

        if (idx < -n)
            idx = -idx - n - 1;
        else if (idx < 0)
            idx += n;

        if (idx >= n) {
            /* TODO warn or fill if there are holes */
            STRING * const key = Parrot_sprintf_s(INTERP, fmt, idx);
            SELF.set_pmc_keyed_str(key, val);
        }
        else {
            /* Iterate over linked list to get value */
            for (pos = 0; pos < idx; ++pos) {
                list_entry = VTABLE_get_pmc_keyed_int(INTERP, list_entry, ORDERED_HASH_ITEM_NEXT);
            }
            PARROT_ASSERT(!PMC_IS_NULL(list_entry));
            VTABLE_set_pmc_keyed_int(INTERP, list_entry, ORDERED_HASH_ITEM_VALUE, val);
        }
    }

    VTABLE void set_integer_keyed_int(INTVAL idx, INTVAL value) {
        PMC * const v = pmc_new(INTERP, Parrot_get_ctx_HLL_type(INTERP,
                    enum_class_Integer));
        VTABLE_set_integer_native(INTERP, v, value);
        SELF.set_pmc_keyed_int(idx, v);
    }

    VTABLE void set_number_keyed_int(INTVAL idx, FLOATVAL value) {
        PMC * const v = pmc_new(INTERP, Parrot_get_ctx_HLL_type(INTERP,
                    enum_class_Float));
        VTABLE_set_number_native(INTERP, v, value);
        SELF.set_pmc_keyed_int(idx, v);
    }

    VTABLE void set_string_keyed_int(INTVAL idx, STRING *value) {
        PMC * const v = pmc_new(INTERP, Parrot_get_ctx_HLL_type(INTERP,
                    enum_class_String));
        VTABLE_set_string_native(INTERP, v, value);
        SELF.set_pmc_keyed_int(idx, v);
    }
/*

=item C<void push_float(FLOATVAL value)>

=item C<void push_integer(INTVAL value)>

=item C<void push_pmc(PMC *value)>

=item C<void push_string(STRING *value)>

=cut

*/

    VTABLE void push_pmc(PMC *value) {
        const INTVAL n = SELF.elements();
        SELF.set_pmc_keyed_int(n, value);
    }

    VTABLE void push_float(FLOATVAL value) {
        const INTVAL n = SELF.elements();
        SELF.set_number_keyed_int(n, value);
    }

    VTABLE void push_integer(INTVAL value) {
        const INTVAL n = SELF.elements();
        SELF.set_integer_keyed_int(n, value);
    }

    VTABLE void push_string(STRING *value) {
        const INTVAL n = SELF.elements();
        SELF.set_string_keyed_int(n, value);
    }

/*

=item C<INTVAL exists_keyed(PMC *key)>

=item C<INTVAL exists_keyed_str(STRING *key)>

=item C<INTVAL exists_keyed_int(INTVAL key)>

=cut

*/

    VTABLE INTVAL exists_keyed_int(INTVAL idx) {
        return (idx >= 0) && (idx < STATICSELF.elements());
    }

    VTABLE INTVAL exists_keyed(PMC *key) {
        /* TODO Handle Key PMC */
        return VTABLE_exists_keyed_str(INTERP, SELF, VTABLE_get_string(INTERP, key));
    }

    VTABLE INTVAL exists_keyed_str(STRING *key) {
        return VTABLE_exists_keyed_str(INTERP, PARROT_ORDEREDHASH(SELF)->hash, key);
    }

/*

=item C<INTVAL defined_keyed(PMC *key)>

=item C<INTVAL defined_keyed_str(STRING *key)>

=item C<INTVAL defined_keyed_int(INTVAL key)>

=cut

*/

    VTABLE INTVAL defined_keyed(PMC *key) {
        return VTABLE_defined_keyed(INTERP, PARROT_ORDEREDHASH(SELF)->hash, key);
    }

    VTABLE INTVAL defined_keyed_str(STRING *key) {
        return VTABLE_defined_keyed_str(INTERP, PARROT_ORDEREDHASH(SELF)->hash, key);
    }

    VTABLE INTVAL defined_keyed_int(INTVAL idx) {
        PARROT_ASSERT(!"Bah");
    }

/*

=item C<void delete_keyed(PMC *key)>

=item C<void delete_keyed_str(STRING *key)>

=item C<void delete_keyed_int(INTVAL key)>

Deletes the key C<*key> from the hash.

=cut

*/

    VTABLE void delete_keyed(PMC *key) {
        return VTABLE_delete_keyed(INTERP, PARROT_ORDEREDHASH(SELF)->hash, key);
    }

    VTABLE void delete_keyed_str(STRING *key) {
        return VTABLE_delete_keyed_str(INTERP, PARROT_ORDEREDHASH(SELF)->hash, key);
    }

    VTABLE void delete_keyed_int(INTVAL idx) {
        PARROT_ASSERT(!"Bah");
    }

/*

=item C<PMC *clone()>

Create a clone of the OrderedHash. Non-existent keys are compacted.  Accessing
the clone via integers has different indices, if items were deleted.

=cut

*/

    VTABLE PMC *clone() {
        PMC  * const dest   = pmc_new(INTERP, SELF->vtable->base_type);
        Parrot_OrderedHash_attributes *clone_attrs =
                PARROT_ORDEREDHASH(dest);

        clone_attrs->hash   = VTABLE_clone(INTERP, PARROT_ORDEREDHASH(SELF)->hash);
        find_bounds(INTERP, clone_attrs->hash, &clone_attrs->first, &clone_attrs->last);

        return dest;
    }
/*

=item C<void visit(visit_info *info)>

Used during archiving to visit the elements in the hash.

=item C<void freeze(visit_info *info)>

Used to archive the hash.

=item C<void thaw(visit_info *info)>

Used to unarchive the hash.

=cut

*/

    VTABLE void visit(visit_info *info) {
        PMC **hash = &(PARROT_ORDEREDHASH(SELF)->hash);
        info->thaw_ptr = hash;
        (info->visit_pmc_now)(INTERP, *hash, info);
        SUPER(info);
    }

    VTABLE void thawfinish(visit_info *info) {
        Parrot_OrderedHash_attributes *attrs =
                PARROT_ORDEREDHASH(SELF);
        find_bounds(INTERP, attrs->hash, &attrs->first, &attrs->last);
    }
}

/*

=back

=head1 SEE ALSO

F<docs/pdds/pdd08_keys.pod>.

=head1 HISTORY

Initial rev by leo 2003-08-21.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
