/*
Copyright (C) 2001-2006, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/exception.pmc - Exception PMC

=head1 DESCRIPTION

This is the exception base class.

As we are still lacking objects, this class is based on C<ResziablePMCArray>.
This will probably change.

Please note (#39744):

Keyed access to exception objects should be very forgiving of mistakes,
returning the equivalent of 'null' for invalid keys.

This issue *may* be revisited when exception objects get their new pdd23
interface.

An exception object has these attributes:

=over 4

=item 0 C<_message>

Textual representation of the exception.

=item 1 C<_type>

The exception type, (see F<include/parrot/exceptions.h>, F<except_type.pasm>).

=item 2 C<_severity>

The severity of the exception, (see F<src/exceptions.h>,
F<except_severity.pasm>).

=item 3 C<unused>

=item 4 C<unused>

=back

Optional:

=over 4

=item 5 C<_C_file>

The C code file in which the exception was raised.

=item 6 C<_C_line>

The line of C code on which the exception was raised.

=item 7 C<_P_file>

The PASM/PIR/Perl file in which the exception was raised.

=item 8 C<_P_line>

The line of PASM/PIR/Perl code on which the exception was raised.

=item 9, 10 C<unused>

Any information attached by the HL. This shouldn't start with an
underscore (that is reserved for Parrot's internal usage. These are
stored as properties.

Note: currently, HLL information must be indexed by number. Slots 9 and 10
are available for the HLL - This is subject to change.

=back

When an exception handler is called, the exception object is passed as
as the first argument, the message as the second argument of the call.
These arguments can be retrieved with the C<get_results> opcode.

This is experimental code. The C<enum_class> of the C<Exception> isn't
fixed. The interface isn't fixed.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

pmclass Exception extends ResizablePMCArray need_ext {

/*

=item C<void init()>

Initializes the exception with default values.

=cut

*/

    void init() {
        SUPER();
        /* pre-fill 11 slots with PMCNULL */
        DYNSELF.set_integer_native(11);
    }

/*

=item C<STRING* get_string_keyed(PMC* key)>

Returns the Parrot string value for C<*key>. The only current recognized
C<key> is "_message".

=item C<STRING* get_string()>

Return the exception message.

=cut

*/

    STRING* get_string_keyed(PMC* key) {
        STRING* s = key_string(INTERP, key);
        if (!string_compare(INTERP, s,
            string_from_cstring(INTERP, "_message", 0)))
            return DYNSELF.get_string_keyed_int(0);
        return 0;
    }

    STRING* get_string() {
        return DYNSELF.get_string_keyed_int(0);
    }

/*

=item C<INTVAL get_integer_keyed(PMC *key)>

Returns the integer value for C<*key>.

=cut

*/

    INTVAL get_integer_keyed(PMC* key) {
        STRING* s = key_string(INTERP, key);
        if (!string_compare(INTERP, s,
            string_from_cstring(INTERP, "_type", 0)))
            return DYNSELF.get_integer_keyed_int(1);
        if (!string_compare(INTERP, s,
            string_from_cstring(INTERP, "_severity", 0)))
            return DYNSELF.get_integer_keyed_int(2);
        return 0;
    }

/*

=item C<PMC* get_pmc_keyed(PMC* key)>

Returns the PMC value for C<*key>.

=cut

*/

    PMC* get_pmc_keyed(PMC* key) {
        STRING* s = key_string(INTERP, key);
        return DYNSELF.getprop(s);
    }

/*

=item C<PMC *get_pmc_keyed_int(INTVAL key)>

Returns the PMC value of the element at index C<key>, but ignores too
big negative keys.

=cut

*/

    PMC* get_pmc_keyed_int (INTVAL key) {
        if (key <= -PMC_int_val(SELF))
            return PMCNULL;
        return SUPER(key);
    }

/*

=item C<void set_string_keyed(PMC *key, STRING *value)>

Sets the Parrot string value for C<*key>.

=cut

*/

    void set_string_keyed(PMC* key, STRING* value) {
        STRING* s = key_string(INTERP, key);
        if (!string_compare(INTERP, s,
            string_from_cstring(INTERP, "_message", 0)))
            DYNSELF.set_string_keyed_int(0, value);
    }

/*

=item C<void set_integer_keyed(PMC* key, INTVAL value) >

Sets the integer value for C<*key>.

=cut

*/

    void set_integer_keyed(PMC* key, INTVAL value) {
        STRING* s = key_string(INTERP, key);
        if (!string_compare(INTERP, s,
            string_from_cstring(INTERP, "_type", 0)))
            DYNSELF.set_integer_keyed_int(1, value);
        if (!string_compare(INTERP, s,
            string_from_cstring(INTERP, "_severity", 0)))
            DYNSELF.set_integer_keyed_int(2, value);
    }

/*

=item C<void set_pmc_keyed(PMC *key, PMC *value)>

Sets the PMC value for C<*key>.

=cut

*/

    void set_pmc_keyed(PMC *key, PMC *value) {
        STRING* s = key_string(INTERP, key);
        DYNSELF.setprop(s, value);
    }
/*

=item C<INTVAL is_equal(PMC *value)>

Compare the passed in Exception with SELF. Returns True if C<SELF> isa C<value>

=cut

*/
    INTVAL is_equal(PMC *value) {
        if (value->vtable->base_type == enum_class_Exception ||
                VTABLE_isa(INTERP, value,
                    const_string(INTERP, "Exception"))) {
            /* TODO check parents */
            return 1;
        }
        return 0;
    }

/*

=item C<shift_*>, C<unshift_*>, C<pop_*>, C<push_*>

These methods are silently ignored.

=cut

*/
    PMC* shift_pmc () {
        /* fprintf(stderr, "don't do that then\n"); XXX */
        return NULL;
    }
    FLOATVAL shift_float () {
        (void) SELF.shift_pmc();
        return 0.0;
    }
    INTVAL shift_integer () {
        (void) SELF.shift_pmc();
        return 0;
    }
    STRING* shift_string () {
        (void) SELF.shift_pmc();
        return NULL;
    }
        
    void unshift_pmc(PMC* value) {
        /* fprintf(stderr, "don't do that then\n"); XXX */
    }
    void unshift_float(FLOATVAL value) {
        SELF.unshift_pmc(NULL);
    }
    void unshift_integer(INTVAL value) {
        SELF.unshift_pmc(NULL);
    }
    void unshift_string(STRING* value) {
        SELF.unshift_pmc(NULL);
    }

    void push_pmc(PMC* value) {
        /* fprintf(stderr, "don't do that then\n"); XXX */
    }
    void push_float(FLOATVAL value) {
        SELF.push_pmc(NULL);
    }
    void push_integer(INTVAL value) {
        SELF.push_pmc(NULL);
    }
    void push_string(STRING* value) {
        SELF.push_pmc(NULL);
    }

    PMC* pop_pmc() {
        /* fprintf(stderr, "don't do that then\n"); XXX */
        return NULL;
    }
    FLOATVAL pop_float() {
        (void) SELF.pop_pmc();
        return 0.0;
    }
    INTVAL pop_integer() {
        (void) SELF.pop_pmc();
        return 0;
    }
    STRING* pop_string() {
        (void) SELF.pop_pmc();
        return NULL;
    }
}

/*

=back

=head1 HISTORY

Initial revision by leo 2003.07.10.

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
