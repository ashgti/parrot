/*
Copyright (C) 2005-2008, The Perl Foundation.
$Id$

=head1 NAME

src/pmc/addrregistry.pmc - A DOD Registry PMC

=head1 DESCRIPTION

The AddrRegistry class provides the equivalence of reference counts
mainly for extenders and embedders of Parrot. The hash keys are the
addresses of the key PMC, values are reference counts, i.e. the
difference of (set_pmc_keyed - delete_pmc_keyed). If the reference
goes to zero, the entry is deleted physically.

Please note that you have to anchor an instance of AddrRegistry yourself with
C<Parrot_register_pmc> if it isn't visible to Parrot.

=head2 Functions

=over 4

=cut

*/

#include "parrot/parrot.h"
#include "pmc_hash.h"

pmclass AddrRegistry need_ext provides hash {
/*

=item C<void init()>

Initializes the instance.

=item C<void destroy()>

Free hash structure.

=cut

*/

    VTABLE void init() {
        PMC_struct_val(SELF) = NULL;
        PObj_custom_mark_destroy_SETALL(SELF);
        parrot_new_pmc_hash_x(SELF, enum_type_int, Hash_key_type_PMC,
                int_compare, key_hash_int);
    }

    VTABLE void destroy() {
        if (PMC_struct_val(SELF)) {
            parrot_hash_destroy(INTERP, (Hash *)PMC_struct_val(SELF));
            PMC_struct_val(SELF) = NULL;
        }
    }

/*

=item C<void mark()>

Marks the hash as live.

=cut

*/

    VTABLE void mark() {
        if (PMC_struct_val(SELF))
            parrot_mark_hash(INTERP, (Hash *)PMC_struct_val(SELF));
    }

/*

=item C<INTVAL get_integer_keyed(PMC *key)>

Returns the reference count for C<key> or 0 if the key doesn't exist.

=item C<INTVAL elements()>

Returns the number of elements in the hash.

=item C<INTVAL get_bool()>

Returns true if the hash size is not zero.

=cut

*/

    VTABLE INTVAL get_integer_keyed(PMC *key) {
        Hash       *hash = (Hash *)PMC_struct_val(SELF);
        HashBucket *b    = parrot_hash_get_bucket(INTERP, hash, key);

        if (b)
            return (INTVAL)b->value;

        return 0;
    }

    VTABLE INTVAL elements() {
        return parrot_hash_size(INTERP, (Hash *)PMC_struct_val(SELF));
    }

    VTABLE INTVAL get_bool() {
        return parrot_hash_size(INTERP, (Hash *)PMC_struct_val(SELF)) != 0;
    }
/*

=item C<void set_pmc_keyed(PMC *key, PMC *value)>

Increment the reference count of C<key>. If the entry doesn't exist
create it. The C<value> is always ignored.

=item C<void set_integer_keyed(PMC *key, INTVAL value)>

Set the given value.

=item C<void delete_keyed(PMC *key)>

Decrement the reference count of C<key>. If the reference count
reaches 0, delete the entry.


=cut

*/

    VTABLE void set_pmc_keyed(PMC *key, PMC *value) {
        Hash       * const hash = (Hash *)PMC_struct_val(SELF);
        HashBucket * const b    = parrot_hash_get_bucket(INTERP, hash, key);

        if (b)
            LVALUE_CAST(char *, b->value)++;
        else
            parrot_hash_put(INTERP, hash, key, (void *)1);
    }

    VTABLE void set_integer_keyed(PMC *key, INTVAL value) {
        Hash *hash = (Hash *)PMC_struct_val(SELF);
        parrot_hash_put(INTERP, hash, key, (void *)value);
    }

    VTABLE void delete_keyed(PMC *key) {
        Hash       * const hash = (Hash *)PMC_struct_val(SELF);
        HashBucket * const b    = parrot_hash_get_bucket(INTERP, hash, key);

        if (b) {
            if ((long)b->value == 1L)
                parrot_hash_delete(INTERP, hash, key);
            else
                LVALUE_CAST(long, b->value)--;
        }
    }

/*

=item C<PMC *get_iter ()>

Return a new iterator for the PMC.

=item C<PMC *get_pmc_keyed(PMC *key)>

If called from iteration, return the key PMC, else PMCNULL is returned.

=cut

*/

    VTABLE PMC *get_iter() {
        return Parrot_Hash_get_iter(INTERP, SELF);
    }

    VTABLE PMC *get_pmc_keyed(PMC *key) {
        Hash * const hash = (Hash *)PMC_struct_val(SELF);

        if (KEY_IS_HASH_ITERATOR(key))
            return (PMC *)parrot_hash_get_idx(INTERP, hash, key);

        return PMCNULL;
    }
}

/*

=back

=head1 SEE ALSO

F<src/pmc.c:dod_register_pmc()>

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
