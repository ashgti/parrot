/*
Copyright (C) 2001-2008, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/continuation.pmc - Continuation PMC

=head1 DESCRIPTION

A C<Continuation> has a copy of the interpreter's context at the location where
the Continuation was constructed.  See the L<Glossary|docs/glossary.pod> for
more information.

=head2 Functions

=over 4

=cut

*/


#include "parrot/oplib/ops.h"
#include "pmc/pmc_sub.h"

/*

=back

=head2 Methods

=over 4

=cut

*/


/*
 * A Continuation (and RetContinuation, ExceptionHandler) has in its
 * context a pointer to the register frame, which contains active objects.
 * Additionally ct->current_cont has the continuation of the caller.
 */

pmclass Continuation auto_attrs {
    /* continuation destination */
    ATTR PackFile_ByteCode *seg;             /* bytecode segment */
    ATTR opcode_t          *address;         /* start of bytecode, addr to continue */
    ATTR PMC               *to_ctx;          /* pointer to dest context */
    ATTR PMC               *to_call_object;  /* pointer to CallSignature */
    /* a Continuation keeps the from_ctx alive */
    ATTR PMC               *from_ctx;        /* sub, this cont is returning from */
    ATTR int                runloop_id;      /* id of the creating runloop. */
    ATTR int                invoked;         /* flag when a handler has been invoked. */
/*

=item C<void init()>

Initializes the continuation.

=cut

*/

    VTABLE void init() {
        Parrot_Continuation_attributes * const attrs = PARROT_CONTINUATION(SELF);

        attrs->to_ctx           = CURRENT_CONTEXT(interp);
        attrs->to_call_object   = Parrot_pcc_get_signature(INTERP, attrs->to_ctx);
        attrs->from_ctx         = CURRENT_CONTEXT(interp);
        attrs->runloop_id       = 0;
        attrs->seg              = interp->code;
        attrs->address          = NULL;

        PObj_custom_mark_SET(SELF);

        /* PANIC("don't do that"); */
        /*
         * Whenever we create a continuation, all return continuations
         * up the call chain may be reused due to invoking the
         * continuation. To avoid that all return continuations are
         * converted to true continuations.
         */
        invalidate_retc_context(INTERP, SELF);
    }

    /*if they pass in a PMC to initialize with*/
    VTABLE void init_pmc(PMC *values) {
        Parrot_Continuation_attributes * const attrs  = PARROT_CONTINUATION(SELF);
        Parrot_Continuation_attributes * const theirs = PARROT_CONTINUATION(values);

        attrs->to_ctx           = theirs->to_ctx;
        attrs->to_call_object   = Parrot_pcc_get_signature(INTERP, attrs->to_ctx);
        attrs->from_ctx         = CURRENT_CONTEXT(interp);
        attrs->runloop_id       = 0;
        attrs->seg              = theirs->seg;
        attrs->address          = theirs->address;

        PObj_custom_mark_SET(SELF);

        /* PANIC("don't do that"); */
        /*
         * Whenever we create a continuation, all return continuations
         * up the call chain may be reused due to invoking the
         * continuation. To avoid that all return continuations are
         * converted to true continuations.
         */
        invalidate_retc_context(INTERP, SELF);
    }



/*

=item C<void mark()>

Marks the continuation as live.

=cut

*/

    VTABLE void mark() {
        Parrot_Continuation_attributes * const cc = PARROT_CONTINUATION(SELF);

        /* If Continuation wasn't fully constructed yet */
        if (!cc)
            return;

        Parrot_gc_mark_PMC_alive(INTERP, cc->to_ctx);
        Parrot_gc_mark_PMC_alive(INTERP, cc->to_call_object);
        Parrot_gc_mark_PMC_alive(INTERP, cc->from_ctx);
    }

/*

=item C<PMC *clone()>

Creates and returns a clone of the continuation.

=cut

*/

    VTABLE PMC *clone() {
        /* Start to prepare for subclassable continuations */
        INTVAL type = SELF->vtable->base_type;
        PMC * ret = pmc_new_init(interp, type, SELF);
        return ret;
    }

/*

=item C<PMC *set_pmc()>

Assign context.

=cut

*/
    VTABLE void set_pmc(PMC *src) {
        Parrot_Continuation_attributes * const cc_self = PARROT_CONTINUATION(SELF);
        Parrot_Continuation_attributes * const cc_src  = PARROT_CONTINUATION(src);

        STRUCT_COPY(cc_self, cc_src);
    }
/*

=item C<void set_pointer(void *value)>

Sets the pointer to the return instruction.  Also captures the descriptor
address for any returned values.

=cut

*/

    VTABLE void set_pointer(void *value) {
        opcode_t                       * const pos = (opcode_t *)value;
        Parrot_Continuation_attributes * const cc  = PARROT_CONTINUATION(SELF);

        cc->address    = pos;
        cc->runloop_id = INTERP->current_runloop_id;
    }

/*

=item C<void *get_pointer()>

Returns the pointer to the return instruction.

=cut

*/

    VTABLE void *get_pointer() {
        return PARROT_CONTINUATION(SELF)->address;
    }

/*

=item C<INTVAL defined()>

=item C<INTVAL get_bool()>

Returns whether the subroutine is defined.

=cut

*/

    VTABLE INTVAL defined() {
        return PARROT_CONTINUATION(SELF)->address != NULL;
    }

    VTABLE INTVAL get_bool() {
        return PARROT_CONTINUATION(SELF)->address != NULL;
    }

/*

=item C<opcode_t *invoke(void *next)>

Restores the context of the interpreter and returns the branch
destination to continue execution.

=cut

*/

    VTABLE opcode_t *invoke(void *next) {
        Parrot_Continuation_attributes * const cc = PARROT_CONTINUATION(SELF);
        PMC      *from_ctx = CURRENT_CONTEXT(interp);
        PMC      *to_ctx   = cc->to_ctx;
        opcode_t *pc       = cc->address;
        PMC      *call_obj = cc->to_call_object;
        PMC      *from_obj = Parrot_pcc_get_signature(interp, from_ctx);
        UNUSED(next)

        Parrot_continuation_check(interp, SELF);
        Parrot_continuation_rewind_environment(interp, SELF);

        if (!PMC_IS_NULL(from_obj)) {
            STRING *string_sig = VTABLE_get_string(INTERP, from_obj);
            /* If there is no string - there is no args */
            if (string_sig) {
                PMC *raw_sig, *invalid_sig;
                Parrot_pcc_parse_signature_string(INTERP, string_sig, &raw_sig, &invalid_sig);

                /* Build results signature for continuation */
                if (*pc == PARROT_OP_get_results_pc)
                    call_obj = Parrot_pcc_build_sig_object_returns_from_op(INTERP, call_obj,
                        Parrot_pcc_get_pmc_constant(INTERP, to_ctx, pc[1]), pc);

                Parrot_pcc_fill_returns_from_continuation(interp, call_obj, raw_sig, from_obj);
            }
        }

        /* switch segment */
        if (INTERP->code != cc->seg)
            Parrot_switch_to_cs(INTERP, cc->seg, 1);

        return pc;
    }

/*

=item C<STRING *get_string()>

Experimental: return caller info as a STRING.

=cut

*/

    VTABLE STRING *get_string() {
        return Parrot_Context_infostr(INTERP, PARROT_CONTINUATION(SELF)->to_ctx);
    }

/*

=item C<PMC *caller()>

Experimental: return caller PMC or PMCNULL if none.

=cut

*/

    METHOD caller() {
        Parrot_Continuation_attributes * const cc = PARROT_CONTINUATION(SELF);
        PMC *caller = Parrot_pcc_get_sub(interp, cc->to_ctx);

        if (!caller)
            caller = PMCNULL;
        else {
            Parrot_Sub_attributes *sub;
            PMC_get_sub(INTERP, caller, sub);
            if (!sub->seg)
                caller = PMCNULL;
        }

        RETURN(PMC *caller);

    }
/*

=item C<PMC *continuation()>

Experimental: return continuation PMC of this Continuation or PMCNULL if none.

=cut

*/

    METHOD continuation() {
        Parrot_Continuation_attributes * const cc = PARROT_CONTINUATION(SELF);
        PMC * const cont = Parrot_pcc_get_continuation(interp, cc->to_ctx);

        if (cont)
            RETURN(PMC *cont);

        RETURN(PMC *PMCNULL);
    }
}

/*

=back

=head1 HISTORY

Initial revision by sean 2002/08/04.

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
