/*
Copyright (C) 2008, Parrot Foundation.
$Id$

=head1 NAME

src/pmc/pipe.pmc - Pipe PMC

=head1 DESCRIPTION

The Pipe PMC creates two connected IO handles for IPC purposes.  Each instance
is a container for a matched pair of PipeHandle objects, one read-only and one
write-only.  Data written to the writer is readable from the reader.

=head2 Vtable Functions

=over 4

=cut

*/

#include "pmc_pipehandle.h"

pmclass Pipe {
    ATTR PMC *r; /* Readable IO handle */
    ATTR PMC *w; /* Writable IO handle */

/*

=item C<void init()>

Create a new pipe.

=cut

*/

    VTABLE void init() {
        PIOHANDLE reader, writer;
        Parrot_Pipe_attributes *attrs =
                mem_allocate_zeroed_typed(Parrot_Pipe_attributes);

        PMC_data(SELF)      = attrs;
        if(PIO_PIPE(interp, &reader, &writer) < 0) {
            Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_PIO_ERROR,
                            "Cannot open pipe");
        }
        attrs->r = pmc_new(interp, enum_class_PipeHandle);
        attrs->w = pmc_new(interp, enum_class_PipeHandle);
        if(!attrs->r || !attrs->w) {
            Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_PIO_ERROR,
                            "Cannot create PipeHandle PMCs");
        }
        PARROT_PIPEHANDLE(attrs->r)->os_handle = reader;
        PARROT_PIPEHANDLE(attrs->w)->os_handle = writer;
        PARROT_PIPEHANDLE(attrs->r)->reader = 1;
        PARROT_PIPEHANDLE(attrs->w)->writer = 1;

        PObj_custom_mark_SET(SELF);
    }


/*

=item C<PMC *clone()>

Create a copy of the pipe container object.  The PipeHandle objects it contains
are *not* cloned.

=cut

*/

    VTABLE PMC *clone() {
        PMC * copy = SUPER();
        Parrot_Pipe_attributes * const old_struct  = PARROT_PIPE(SELF);
        Parrot_Pipe_attributes * const data_struct = PARROT_PIPE(copy);

        data_struct->r = old_struct->r;
        data_struct->w = old_struct->w;

        return SELF;
    }


/*

=item C<void mark()>

Mark active filehandle data as live.

=cut

*/

    VTABLE void mark() {
        Parrot_Pipe_attributes * const attrs = PARROT_PIPE(SELF);

        if (attrs) {
            if (attrs->r)
                Parrot_gc_mark_PObj_alive(interp, (PObj *)attrs->r);

            if (attrs->w)
                Parrot_gc_mark_PObj_alive(interp, (PObj *)attrs->w);
        }
    }


/*

=back

=head2 Methods

=over 4

=item C<reader>

Return the read-only PipeHandle object.

=cut

*/


    METHOD reader() {
        PMC *rv;
        Parrot_Pipe_attributes * const attrs = PARROT_PIPE(SELF);
        rv = attrs->r;
        RETURN(PMC *rv);
    }

/*

=item C<writer>

Return the write-only PipeHandle object.

=cut

*/


    METHOD writer() {
        PMC *rv;
        Parrot_Pipe_attributes * const attrs = PARROT_PIPE(SELF);
        rv = attrs->w;
        RETURN(PMC *rv);
    }

/*

=back

=cut

*/

} /* end pmclass */

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
