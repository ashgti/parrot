/*
Copyright (C) 2008, The Perl Foundation.
$Id$

=pod

=head1 NAME

src/dynpmc/rational.pmc - Rational numbers PMC

=head1 DESCRIPTION

Rational is currently going to get implemented. It uses the GNU Multiple Precision (GMP) library,
like BigInt, because implementation with integers would be too unstable and inaccurate.

'LispRational' will subclass this.

You may use Rational with any of parrot's basic data types as well as with String-, Integer- and
Float-PMCs.

=head1 Functions

Currently C<rational.pmc> only has some C<static> functions for code sharing.

=over 4

=cut

*/

#include "parrot/has_header.h"

#ifdef PARROT_HAS_GMP
#  include <gmp.h>
   typedef struct RATIONAL {
      mpq_t q;
   } RATIONAL;
#  define RT(x)         ((RATIONAL*) PMC_struct_val(x))->q
#else
#  define RT(x)
#endif

#define RAISE_EXCEPTION   real_exception(interp, NULL, E_LibraryNotLoadedError, \
                                   "GNU Multiple Precision library not found.");

/*

=item * static STRING *rat_get_string_to_base(PARROT_INTERP, PMC *self, int base)

Returns a string representation of a Rational-PMC to a certain base.

=cut

*/
static STRING *rat_get_string_to_base(PARROT_INTERP, PMC *self, int base) {
  #ifdef PARROT_HAS_GMP
    STRING *pstr;
    char *cstr = mpq_get_str(NULL, (int) base, RT(self));
    pstr = string_from_cstring(interp, cstr, 0);
    string_cstring_free(cstr);
    return pstr;
  #else
    RAISE_EXCEPTION
  #endif
}

/*

=item * static void rat_add_integer(PARROT_INTERP, PMC *self, int value, PMC *dest)

Adds an integer "value" to a Rational-PMC and stores the result in (another) Rational-PMC.

=cut

*/
static void rat_add_integer(PARROT_INTERP, PMC *self, int value, PMC *dest) {
  #ifdef PARROT_HAS_GMP
    mpq_t t;

    if (dest) {
        if (self != dest)
            VTABLE_morph(interp, dest, self->vtable->base_type);
    }
    else {
        dest = pmc_new(interp, self->vtable->base_type);
    }

    mpq_init(t);
    mpq_set_si(t, (int) value, 1);
    mpq_add(RT(dest), RT(self), t);
    mpq_clear(t);
  #else
    RAISE_EXCEPTION
  #endif
}

/*

=item * static void rat_add_float(PARROT_INTERP, PMC *self, double value, PMC *dest)

Adds a float "value" to a Rational-PMC and stores the result in (another) Rational-PMC. "value" is
first conveted to a rational using GMPs mpq_set_d-function. This is meant to be exact.

=cut

*/
static void rat_add_float(PARROT_INTERP, PMC *self, double value, PMC *dest) {
  #ifdef PARROT_HAS_GMP
    mpq_t t;

    if (dest)
        VTABLE_morph(interp, dest, self->vtable->base_type);
    else
        dest = pmc_new(interp, self->vtable->base_type);

    mpq_init(t);
    mpq_set_d(t, (double) value);
    mpq_add(RT(dest), RT(self), t);
    mpq_clear(t);
  #else
    RAISE_EXCEPTION
  #endif
}

/*

=item * static void rat_multiply_integer(PARROT_INTERP, PMC *self, int value, PMC *dest)

Multiplys a Rational-PMC with an integer "value" and stores the result in (another) Rational-PMC.

=cut

*/
static void rat_multiply_integer(PARROT_INTERP, PMC *self, int value, PMC *dest) {
  #ifdef PARROT_HAS_GMP
    if (dest)
        VTABLE_morph(interp, dest, self->vtable->base_type);
    else
        dest = pmc_new(interp, self->vtable->base_type);

    mpz_mul_ui(mpq_numref(RT(dest)), mpq_numref(RT(self)), (unsigned int) value);
    mpq_set_den(RT(dest), mpq_denref(RT(self)));
  #else
    RAISE_EXCEPTION
  #endif
}

/*

=item * static void rat_multiply_float(PARROT_INTERP, PMC *self, double value, PMC *dest)

Multiplies a Rational-PMC with a float "value" and stores the result in (another) Rational-PMC.

=cut

*/
static void rat_multiply_float(PARROT_INTERP, PMC *self, double value, PMC *dest) {
  #ifdef PARROT_HAS_GMP
    mpq_t t;

    if (dest)
        VTABLE_morph(interp, dest, self->vtable->base_type);
    else
        dest = pmc_new(interp, self->vtable->base_type);

    mpq_init(t);
    mpq_set_d(t, (double) value);
    mpq_mul(RT(dest), RT(self), t);
    mpq_clear(t);
  #else
    RAISE_EXCEPTION
  #endif
}

/*

=item * static void rat_divide_integer(PARROT_INTERP, PMC *self, int value, PMC *dest)

Divides a Rational-PMC through an integer "value" and stores the result in (another) Rational-PMC.

=cut

*/
static void rat_divide_integer(PARROT_INTERP, PMC *self, int value, PMC *dest) {
  #ifdef PARROT_HAS_GMP
    mpq_t t;

    if (dest)
        VTABLE_morph(interp, dest, self->vtable->base_type);
    else
        dest = pmc_new(interp, self->vtable->base_type);

    mpq_init(t);
    mpq_set_si(t, (int) value, 1);
    mpq_div(RT(dest), RT(self), t);
    mpq_clear(t);
  #else
    RAISE_EXCEPTION
  #endif
}

/*

=item * static void rat_divide_float(PARROT_INTERP, PMC *self, double value, PMC *dest)

Divides a Rational-PMC through a float "value" and stores the result in (another) Rational-PMC.

=cut

*/
static void rat_divide_float(PARROT_INTERP, PMC *self, double value, PMC *dest) {
  #ifdef PARROT_HAS_GMP
    mpq_t t;

    if (dest)
        VTABLE_morph(interp, dest, self->vtable->base_type);
    else
        dest = pmc_new(interp, self->vtable->base_type);

    mpq_init(t);
    mpq_set_d(t, (double) value);
    mpq_div(RT(dest), RT(self), t);
    mpq_clear(t);
  #else
    RAISE_EXCEPTION
  #endif
}

/*

=item * static void rat_power_int(PARROT_INTERP, PMC *self, int value, PMC *dest)

Calculates the power of a Rational-PMC to an exponent value and stores the result in (another)
Rational-PMC.

=cut

*/
static void rat_power_int(PARROT_INTERP, PMC *self, int value, PMC *dest) {
  #ifdef PARROT_HAS_GMP
    mpz_t t;

    if (dest)
        VTABLE_morph(interp, dest, self->vtable->base_type);
    else
        dest = pmc_new(interp, self->vtable->base_type);

    mpq_get_num(t, RT(self));
    mpz_pow_ui(t, t, (unsigned int) value);
    mpq_set_num(RT(dest), t);
    mpz_clear(t);

    mpq_get_den(t, RT(self));
    mpz_pow_ui(t, t, (unsigned int) value);
    mpq_set_den(RT(dest), t);
    mpz_clear(t);
  #else
    RAISE_EXCEPTION
  #endif
}

/*

=back

=cut

*/

pmclass Rational dynpmc provides scalar {
/*

=head2 Methods

The DynPMC Rational has the following methods. Note, that all methods depend on GMP. If GMP is not
available, an exception is thrown in almost all cases. The only exception is the version-method.

=over 4

=item C<METHOD version()>

Returns the version of GNU Multiple Precision library. Returns 0.0.0, if GMP is not available.

=cut

*/
    METHOD version() {
        STRING *version;
      #ifdef PARROT_HAS_GMP
        version = string_from_cstring(INTERP, gmp_version, 0);
      #else
        version = string_from_cstring(INTERP, "0.0.0", 0);
      #endif
        RETURN(STRING *version);
    }

/*

=item C<void init()>

=cut

*/
    VTABLE void init() {
      #ifdef PARROT_HAS_GMP
        PMC_struct_val(SELF) = malloc(sizeof (RATIONAL));
        mpq_init(RT(SELF));
        PObj_active_destroy_SET(SELF);
      #else
        PMC_struct_val(SELF) = NULL;
      #endif
    }

/*

=item C<void clone()>

=cut

*/
    VTABLE PMC *clone() {
      #ifdef PARROT_HAS_GMP
        mpz_t num, den;
        PMC *ret = pmc_new(INTERP, SELF->vtable->base_type);
        mpq_get_num(num, RT(SELF));
        mpq_get_den(den, RT(SELF));
        mpq_set_num(RT(ret), num);
        mpq_set_den(RT(ret), den);
        mpz_clear(num);
        mpz_clear(den);
        return ret;
      #else
        RAISE_EXCEPTION
      #endif
    }

/*

=item C<void destroy()>

=cut

*/
    VTABLE void destroy() {
      #ifdef PARROT_HAS_GMP
        mpq_clear(RT(SELF));
        mem_sys_free(PMC_struct_val(SELF));
      #else
        RAISE_EXCEPTION
      #endif
    }

/*

=item C<void set_integer_native(INTVAL)>

=cut

*/
    VTABLE void set_integer_native(INTVAL value) {
      #ifdef PARROT_HAS_GMP
        mpq_set_si(RT(SELF), (signed int) value, 1);
        mpq_canonicalize(RT(SELF));
      #else
        RAISE_EXCEPTION
      #endif
    }

/*

=item C<void set_number_native(FLOATVAL)>

=cut

*/
    VTABLE void set_number_native(FLOATVAL value) {
      #ifdef PARROT_HAS_GMP
        mpq_set_d(RT(SELF), (double) value);
        mpq_canonicalize(RT(SELF));
      #else
        RAISE_EXCEPTION
      #endif
    }

/*

=item C<void set_string_native(STRING*)>

=cut

*/
    VTABLE void set_string_native(STRING *value) {
      #ifdef PARROT_HAS_GMP
        char *cstr = string_to_cstring(INTERP, value);
        mpq_set_str(RT(SELF), cstr, 0);
        mpq_canonicalize(RT(SELF));
        string_cstring_free(cstr);
      #else
        RAISE_EXCEPTION
      #endif
    }

/*

=item C<void set_string_keyed_int(INTVAL base, STRING *value)>

=cut

*/
    VTABLE void set_string_keyed_int(INTVAL base, STRING *value) {
      #ifdef PARROT_HAS_GMP
        char *cstr = string_to_cstring(INTERP, value);
        mpq_set_str(RT(SELF), cstr, (int) base);
        mpq_canonicalize(RT(SELF));
        string_cstring_free(cstr);
      #else
        RAISE_EXCEPTION
      #endif
    }


/*

=item C<INTVAL get_integer()>

=cut

*/
    VTABLE INTVAL get_integer() {
      #ifdef PARROT_HAS_GMP
        mpz_t q;
        mpz_init(q);
        mpz_tdiv_q(q, mpq_numref(RT(SELF)), mpq_denref(RT(SELF)));
        if (mpz_fits_slong_p(q)) {
            INTVAL ret = (INTVAL) mpz_get_si(q);
            mpz_clear(q);
            return ret;
        }
        else {
            mpz_clear(q);
            real_exception(INTERP, NULL, 1,
                "Rational, get_integer(): Number is too big.");
        }
      #else
        RAISE_EXCEPTION
      #endif
    }

/*

=item C<get_number()>

=cut

*/
    VTABLE FLOATVAL get_number() {
      #ifdef PARROT_HAS_GMP
        double d;
        d = mpq_get_d(RT(SELF));
        return (FLOATVAL) d;
      #else
        RAISE_EXCEPTION
      #endif
    }

/*

=item C<get_bool()>

=cut

*/
    VTABLE INTVAL get_bool() {
      #ifdef PARROT_HAS_GMP
        if (mpq_cmp_si(RT(SELF), 0, 0))
            return 0;
        else
            return 1;
      #else
        RAISE_EXCEPTION
      #endif
    }
/*

=item C<STRING *get_string()>

=cut

*/
    VTABLE STRING *get_string() {
      #ifdef PARROT_HAS_GMP
        return rat_get_string_to_base(INTERP, SELF, 10);
      #else
        RAISE_EXCEPTION
      #endif
    }

/*

=item C<STRING *get_string_keyed_int(INTVAL base)>

=cut

*/
    VTABLE STRING *get_string_keyed_int(INTVAL base) {
      #ifdef PARROT_HAS_GMP
        return rat_get_string_to_base(INTERP, SELF, (int) base);
      #else
        RAISE_EXCEPTION
      #endif
    }

/*

=item C<void increment()>

=cut

*/
    VTABLE void increment() {
      #ifdef PARROT_HAS_GMP
        mpz_add(mpq_numref(RT(SELF)), mpq_numref(RT(SELF)), mpq_denref(RT(SELF)));
        mpq_canonicalize(RT(SELF));
      #else
        RAISE_EXCEPTION
      #endif
    }

/*

=item C<void decrement()>

=cut

*/
    VTABLE void decrement() {
      #ifdef PARROT_HAS_GMP
        mpz_sub(mpq_numref(RT(SELF)), mpq_numref(RT(SELF)), mpq_denref(RT(SELF)));
        mpq_canonicalize(RT(SELF));
      #else
        RAISE_EXCEPTION
      #endif
    }

/*

=item C<PMC *add(PMC* value, PMC* dest)>

Adds Integer-, Float- or Rational-PMCs to SELF and stores them in dest.

=cut

*/
    VTABLE PMC *add(PMC* value, PMC* dest) {
MMD_Integer: {
        rat_add_integer(INTERP, SELF, PMC_int_val(value), dest);
        return dest;
        }
MMD_Float: {
        rat_add_float(INTERP, SELF, PMC_num_val(value), dest);
        return dest;
        }
MMD_Rational: {
      #ifdef PARROT_HAS_GMP
        if (dest)
            VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        else
            dest = pmc_new(INTERP, SELF->vtable->base_type);

        mpq_add(RT(dest), RT(SELF), RT(value));
        return dest;
      #else
        RAISE_EXCEPTION
      #endif
        }
MMD_DEFAULT: {
    real_exception(INTERP, NULL, E_NotImplementedError,
        "Rational, add: Not implemented (yet).");
        }
    }

/*

=item C<void i_add(PMC *value)>

=cut

*/
    VTABLE void i_add(PMC *value) {
MMD_Integer: {
        rat_add_integer(INTERP, SELF, (int) PMC_int_val(value), SELF);
        }
MMD_Float: {
        rat_add_float(INTERP, SELF, (double) PMC_num_val(value), SELF);
        }
MMD_Rational: {
      #ifdef PARROT_HAS_GMP
        mpq_add(RT(SELF), RT(SELF), RT(value));
      #else
        RAISE_EXCEPTION
      #endif
        }
MMD_DEFAULT: {
    real_exception(INTERP, NULL, E_NotImplementedError,
        "Rational, i_add: Not implemented (yet).");
        }
    }

/*

=item C<PMC *add_int(INTVAL value, PMC* dest)>

=cut

*/
    VTABLE PMC *add_int(INTVAL value, PMC* dest) {
        rat_add_integer(INTERP, SELF, (int) value, dest);
        return dest;
    }

/*

=item C<void i_add_int(INTVAL value)>

=cut

*/
    VTABLE void i_add_int(INTVAL value) {
        rat_add_integer(INTERP, SELF, (int) value, SELF);
    }

/*

=item C<PMC *add_float(FLOATVAL value, PMC* dest)>

=cut

*/
    VTABLE PMC *add_float(FLOATVAL value, PMC* dest) {
        rat_add_float(INTERP, SELF, (double) value, dest);
        return dest;
    }

/*

=item C<void i_add_float(FLOATVAL value)>

=cut

*/
    VTABLE void i_add_float(FLOATVAL value) {
        rat_add_float(INTERP, SELF, (double) value, SELF);
    }

/*

=item C<PMC *subtract(PMC* value, PMC* dest)>

=cut

*/
    VTABLE PMC *subtract(PMC* value, PMC* dest) {
MMD_Integer: {
        rat_add_integer(INTERP, SELF, -((int) PMC_int_val(value)), dest);
        return dest;
        }
MMD_Float: {
        rat_add_float(INTERP, SELF, - ((double) PMC_num_val(value)), dest);
        return dest;
        }
MMD_Rational: {
      #ifdef PARROT_HAS_GMP
        if (dest)
            VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        else
            dest = pmc_new(INTERP, SELF->vtable->base_type);

        mpq_sub(RT(dest), RT(SELF), RT(value));
        return dest;
      #else
        RAISE_EXCEPTION
      #endif
        }
MMD_DEFAULT: {
    real_exception(INTERP, NULL, E_NotImplementedError,
        "Rational, subtract: Not implemented (yet).");
        }
    }

/*

=item C<void i_subtract(PMC *value)>

=cut

*/
    VTABLE void i_subtract(PMC *value) {
MMD_Integer: {
        rat_add_integer(INTERP, SELF, -((int) PMC_int_val(value)), SELF);
        }
MMD_Float: {
        rat_add_float(INTERP, SELF, - ((double) PMC_num_val(value)), SELF);
        }
MMD_Rational: {
      #ifdef PARROT_HAS_GMP
        mpq_sub(RT(SELF), RT(SELF), RT(value));
      #else
        RAISE_EXCEPTION
      #endif
        }
MMD_DEFAULT: {
    real_exception(INTERP, NULL, E_NotImplementedError,
        "Rational, i_subtract: Not implemented (yet).");
        }
    }

/*

=item C<PMC *subtract_int(INTVAL value, PMC* dest)>

=cut

*/
    VTABLE PMC *subtract_int(INTVAL value, PMC* dest) {
        rat_add_integer(INTERP, SELF, -((int) value), dest);
        return dest;
    }

/*

=item C<void i_subtract_int(INTVAL value)>

=cut

*/
    VTABLE void i_subtract_int(INTVAL value) {
        rat_add_integer(INTERP, SELF, -((int) value), SELF);
    }

/*

=item C<PMC *subtract_float(FLOATVAL value, PMC* dest)>

=cut

*/
    VTABLE PMC *subtract_float(FLOATVAL value, PMC* dest) {
        rat_add_float(INTERP, SELF, -((double) value), dest);
        return dest;
    }

/*

=item C<void i_subtract_float(FLOATVAL value)>

=cut

*/
    VTABLE void i_subtract_float(FLOATVAL value) {
        rat_add_float(INTERP, SELF, -((double) value), SELF);
    }

/*

=item C<PMC *multiply(PMC* value, PMC* dest)>

=cut

*/
    VTABLE PMC *multiply(PMC* value, PMC* dest) {
MMD_Integer: {
        rat_multiply_integer(INTERP, SELF, (int) PMC_int_val(value), dest);
        return dest;
        }
MMD_Float: {
        rat_multiply_float(INTERP, SELF, (double) PMC_num_val(value), dest);
        return dest;
        }
MMD_Rational: {
      #ifdef PARROT_HAS_GMP
        if (dest)
            VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        else
            dest = pmc_new(INTERP, SELF->vtable->base_type);

        mpq_mul(RT(dest), RT(SELF), RT(value));
        return dest;
      #else
        RAISE_EXCEPTION
      #endif
        }
MMD_DEFAULT: {
        real_exception(INTERP, NULL, E_NotImplementedError,
            "Rational, multiply: Not implemented (yet).");
        }
    }

/*

=item C<void i_multiply(PMC *value)>

=cut

*/
    VTABLE void i_multiply(PMC *value) {
MMD_Integer: {
        rat_multiply_integer(INTERP, SELF, (int) PMC_int_val(value), SELF);
        }
MMD_Float: {
        rat_multiply_float(INTERP, SELF, (double) PMC_num_val(value), SELF);
        }
MMD_Rational: {
      #ifdef PARROT_HAS_GMP
        mpq_mul(RT(SELF), RT(SELF), RT(value));
      #else
        RAISE_EXCEPTION
      #endif
        }
MMD_DEFAULT: {
        real_exception(INTERP, NULL, E_NotImplementedError,
            "Rational, i_multiply: Not implemented (yet).");
        }
    }

/*

=item C<PMC *multiply_int(INTVAL value, PMC* dest)>

=cut

*/
    VTABLE PMC *multiply_int(INTVAL value, PMC* dest) {
        rat_multiply_integer(INTERP, SELF, (int) value, dest);
        return dest;
    }

/*

=item C<void i_multiply_int(INTVAL value)>

=cut

*/
    VTABLE void i_multiply_int(INTVAL value) {
        rat_multiply_integer(INTERP, SELF, (int) value, SELF);
    }

/*

=item C<PMC *multiply_float(FLOATVAL value, PMC* dest)>

=cut

*/
    VTABLE PMC *multiply_float(FLOATVAL value, PMC* dest) {
        rat_multiply_float(INTERP, SELF, (double) value, dest);
        return dest;
    }

/*

=item C<void i_multiply_float(FLOATVAL value)>

=cut

*/
    VTABLE void i_multiply_float(FLOATVAL value) {
        rat_multiply_float(INTERP, SELF, (double) value, SELF);
    }

/*

=item C<PMC *divide(PMC* value, PMC* dest)>

=cut

*/
    VTABLE PMC *divide(PMC* value, PMC* dest) {
MMD_Integer: {
        rat_divide_integer(INTERP, SELF, (int) PMC_int_val(value), dest);
        return dest;
        }
MMD_Float: {
        rat_divide_float(INTERP, SELF, (double) PMC_num_val(value), dest);
        return dest;
        }
MMD_Rational: {
      #ifdef PARROT_HAS_GMP
        if (dest)
            VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        else
            dest = pmc_new(INTERP, SELF->vtable->base_type);

        mpq_div(RT(dest), RT(SELF), RT(value));
        return dest;
      #else
        RAISE_EXCEPTION
      #endif
        }
MMD_DEFAULT: {
        real_exception(INTERP, NULL, E_NotImplementedError,
            "Rational, divide: Not implemented (yet).");
        }
    }

/*

=item C<void i_divide(PMC *value)>

=cut

*/
    VTABLE void i_divide(PMC *value) {
MMD_Integer: {
        rat_divide_integer(INTERP, SELF, (int) PMC_int_val(value), SELF);
        }
MMD_Float: {
        rat_divide_float(INTERP, SELF, (double) PMC_num_val(value), SELF);
        }
MMD_Rational: {
      #ifdef PARROT_HAS_GMP
        mpq_div(RT(SELF), RT(SELF), RT(value));
      #else
        RAISE_EXCEPTION
      #endif
        }
MMD_DEFAULT: {
        real_exception(INTERP, NULL, E_NotImplementedError,
            "Rational, i_divide: Not implemented (yet).");
        }
    }

/*

=item C<PMC *divide_int(INTVAL value, PMC* dest)>

=cut

*/
    VTABLE PMC *divide_int(INTVAL value, PMC* dest) {
        rat_divide_integer(INTERP, SELF, (int) value, dest);
        return dest;
    }

/*

=item C<void i_divide_int(INTVAL value)>

=cut

*/
    VTABLE void i_divide_int(INTVAL value) {
        rat_divide_integer(INTERP, SELF, (int) value, SELF);
    }

/*

=item C<PMC *divide_float(FLOATVAL value, PMC* dest)>

=cut

*/
    VTABLE PMC *divide_float(FLOATVAL value, PMC* dest) {
        rat_divide_float(INTERP, SELF, (double) value, dest);
        return dest;
    }

/*

=item C<void i_divide_float(FLOATVAL value)>

=cut

*/
    VTABLE void i_divide_float(FLOATVAL value) {
        rat_divide_float(INTERP, SELF, (double) value, SELF);
    }

/*

=item C<PMC *negate(PMC* dest)>

=cut

*/
    VTABLE PMC *neg(PMC* dest) {
      #ifdef PARROT_HAS_GMP
        if (dest)
            VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        else
            dest = pmc_new(INTERP, SELF->vtable->base_type);

        mpq_neg(RT(dest), RT(SELF));
        return dest;
      #else
        RAISE_EXCEPTION
      #endif
    }

/*

=item C<void i_negate()>

=cut

*/
    VTABLE void i_neg() {
      #ifdef PARROT_HAS_GMP
        mpq_neg(RT(SELF), RT(SELF));
      #else
        RAISE_EXCEPTION
      #endif
    }

/*

=item C<PMC *absolute(PMC* dest)>

=cut

*/
    VTABLE PMC *absolute(PMC* dest) {
      #ifdef PARROT_HAS_GMP
        if (dest)
            VTABLE_morph(INTERP, dest, SELF->vtable->base_type);
        else
            dest = pmc_new(INTERP, SELF->vtable->base_type);

        mpq_abs(RT(dest), RT(SELF));
        return dest;
      #else
        RAISE_EXCEPTION
      #endif
    }

/*

=item C<void i_absolute()>

=cut

*/
    VTABLE void i_absolute() {
      #ifdef PARROT_HAS_GMP
        mpq_abs(RT(SELF), RT(SELF));
      #else
        RAISE_EXCEPTION
      #endif
    }

/*

=item C<INTVAL cmp(PMC *value)>

=cut

*/
    VTABLE INTVAL cmp(PMC *value) {
MMD_Integer: {
      #ifdef PARROT_HAS_GMP
        return (INTVAL) mpq_cmp_si(RT(SELF), PMC_int_val(value), 1);
      #else
        RAISE_EXCEPTION
      #endif
      }
MMD_Float: {
      #ifdef PARROT_HAS_GMP
        real_exception(INTERP, NULL, E_NotImplementedError,
            "This is going to get implemented soon.");
      #else
        RAISE_EXCEPTION
      #endif
      }
MMD_Rational: {
      #ifdef PARROT_HAS_GMP
        return (INTVAL) mpq_cmp(RT(SELF), RT(value));
      #else
        RAISE_EXCEPTION
      #endif
      }
MMD_DEFAULT: {
        real_exception(INTERP, NULL, E_NotImplementedError,
            "cmp not implemented (yet).");
      }
    }

/*

=item C<INTVAL is_equal(PMC *value)>

=cut

*/
    VTABLE INTVAL is_equal(PMC *value) {
MMD_Integer: {
      #ifdef PARROT_HAS_GMP
        INTVAL eq = 0;
        mpq_t t;
        mpq_init(t);
        mpq_set_ui(t, PMC_int_val(value), 1);

        eq = (INTVAL) mpq_equal(RT(SELF), RT(value));
        mpq_clear(t);

        return eq;
      #else
        RAISE_EXCEPTION
      #endif
      }
MMD_Float: {
        real_exception(INTERP, NULL, E_NotImplementedError,
            "Equality to floats can not be checked because of limited machine accuracy.\n"
             "Approximate the rational and check whether the difference to a value is lower\n"
             "than an epsilon.");
      }
MMD_Rational: {
      #ifdef PARROT_HAS_GMP
        return (INTVAL) mpq_equal(RT(SELF), RT(value));
      #else
        RAISE_EXCEPTION
      #endif
      }
MMD_DEFAULT: {
        real_exception(INTERP, NULL, E_NotImplementedError, "is_equal not implemented (yet).");
      }
    }
}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
