/*
Copyright: 2001-2006 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

src/classes/file.pmc - File PMC

=head1 DESCRIPTION

C<File> is a singleton class which provides access to File functions.

=head2 Methods

=over 4

=cut

*/

#ifdef WIN32
#include <direct.h>
#endif

#include "parrot/parrot.h"

/* XXX Check if we need to deallocate strerror strings */
/* XXX apparently, strerror_r is thread-safe and should be used instead.*/

static PMC * File_PMC;
pmclass File singleton {

/*

=item C<void* get_pointer()>

=item C<void set_pointer(void *ptr)>

These two functions are part of the singleton creation interface. For more
information see F<src/pmc.c>.

=cut

*/

    void* get_pointer() {
        return File_PMC;
    }

    void set_pointer(void* ptr) {
        File_PMC = (PMC*) ptr;
    }

/*

=item C<INTVAL is_dir(STRING* path)>

Returns a true value (1) if the supplied path is a directory.

=cut

*/

    METHOD INTVAL is_dir(STRING *path) {
        struct stat info;
        char *cpath = string_to_cstring(interpreter, path);
        int error = lstat(cpath, &info);
        if (error) {
            char *errmsg = strerror(errno);
            real_exception(interpreter, NULL, E_SystemError, errmsg);
        }

        if (S_ISDIR(info.st_mode)) {
            return 1;
        } else {
            return 0;
        }
    }

/*

=item C<INTVAL is_dir(STRING* path)>

Returns a true value (1) if the supplied path is a directory.

=cut

*/

    METHOD INTVAL is_file(STRING *path) {
        struct stat info;
        char *cpath = string_to_cstring(interpreter, path);
        int error = lstat(cpath, &info);
        if (error) {
            char *errmsg = strerror(errno);
            real_exception(interpreter, NULL, E_SystemError, errmsg);
        }

        if (S_ISREG(info.st_mode)) {
            return 1;
        } else {
            return 0;
        }
    }

/*

=item C<INTVAL is_link(STRING* path)>

Returns a true value (1) if the supplied path is a link.

=cut

*/

    METHOD INTVAL is_link(STRING *path) {
#ifdef WIN32
        return 0;
#else
        struct stat info;
        char *cpath = string_to_cstring(interpreter, path);
        int error = lstat(cpath, &info);
        if (error) {
            char *errmsg = strerror(errno);
            real_exception(interpreter, NULL, E_SystemError, errmsg);
        }

        if (S_ISLNK(info.st_mode)) {
            return 1;
        } else {
            return 0;
        }
#endif
    }

}

/*

=back

=head1 SEE ALS0

   stat(2)

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
