/*
Copyright: 2001-2005 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

src/classes/os.pmc - Files and Directories PMC

=head1 DESCRIPTION

C<os> is a singleton class which provides access to the system
files and directories.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

static PMC * OS_PMC;
pmclass OS singleton {

/*

=item C<void* get_pointer()>

=item C<void set_pointer(void *ptr)>

These two functions are part of the singleton creation interface. For more
information see F<src/pmc.c>.

=cut

*/

    void* get_pointer() {
        return OS_PMC;
    }

    void set_pointer(void* ptr) {
        OS_PMC = (PMC*) ptr;
    }


/*

=item C<char* cwd()>

=cut

*/

    METHOD STRING* cwd() {
        STRING *scwd;
        char * cwd = getcwd(NULL, 0);
        if (cwd) {
            scwd = string_from_cstring(interpreter, cwd, strlen(cwd));
            mem_sys_free(cwd);
            return scwd;
        } else {
            switch(errno) {
            case EACCES:
                real_exception(interpreter, NULL, E_SystemError,
                               "Read or search permission was denied for a "
                               "component of the pathname.");
                break;
            case EINVAL:
                real_exception(interpreter, NULL, E_SystemError,
                               "The size argument is zero.");
                break;
            case ENOENT:
                real_exception(interpreter, NULL, E_SystemError,
                               "A component of the pathname no longer exists.");
                break;
            case ENOMEM:
                real_exception(interpreter, NULL, E_SystemError,
                               "Insufficient memory is available.");
                break;
            case ERANGE:
                real_exception(interpreter, NULL, E_SystemError,
                               "The size argument is greater than zero but "
                               "smaller than the length of the pathname "
                               "plus 1.");
            }
            return NULL;
        }
    }


/*

=item C<void cd(char *path)>

=cut

*/

    METHOD void cd(STRING *path) {
        int error;
        char *cpath = string_to_cstring(interpreter, path);
        error = chdir(cpath);
        string_cstring_free(cpath);
        if (error) {
            switch(errno) {
            case ENOTDIR:
                real_exception(interpreter, NULL, E_SystemError,
                               "A component of the path prefix is not a "
                               "directory.");
                break;
            case ENAMETOOLONG:
                real_exception(interpreter, NULL, E_SystemError,
                               "A component of a pathname exceeded %d "
                               "characters, or an entire path name exceeded %d "
                               "characters.", NAME_MAX, PATH_MAX);
                break;
            case ENOENT:
                real_exception(interpreter, NULL, E_SystemError,
                               "The named directory does not exist.");
                break;
            case ELOOP:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Too many symbolic links were encountered in "
                               "translating the pathname.");
                break;
            case EACCES:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Search permission is denied for any component "
                               "of the path name.");
                break;
            case EFAULT:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Path points outside the process's allocated "
                               "address space.");
                break;
            case EIO:
                real_exception(interpreter, NULL, E_SystemError, 
                               "An I/O error occurred while reading from or "
                               "writing to the file system.");
                break;
            }
        }
    }


/*

=item C<void rm(char *path)>

Removes C<files>

=cut

*/

    METHOD void rm(STRING *path) {
        int error;
        char *cpath = string_to_cstring(interpreter, path);
        error = unlink(cpath);
        string_cstring_free(cpath);
        if (error) {
            switch(errno) {
            case ENOTDIR:
                real_exception(interpreter, NULL, E_SystemError, 
                               "A component of the path prefix is not a "
                               "directory.");
                break;

            case ENAMETOOLONG:
                real_exception(interpreter, NULL, E_SystemError, 
                               "A component of a pathname exceeded %d "
                               "characters, or an entire path name exceeded %d "
                               "characters.", NAME_MAX, PATH_MAX);
                break;

            case ENOENT:
                real_exception(interpreter, NULL, E_SystemError, 
                               "The named file does not exist.");
                break;

            case EACCES:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Search permission is denied for a component of "
                               "the path prefix or write permission is denied "
                               "on the directory containing the link to be "
                               "removed.");
                break;

            case ELOOP:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Too many symbolic links were encountered in "
                               "translating the pathname.");
                break;

            case EPERM:
                real_exception(interpreter, NULL, E_SystemError, 
                               "The named file is a directory and the effective"
                               " user ID of the process is not the super-user.");
                break;

            case EBUSY:
                real_exception(interpreter, NULL, E_SystemError, 
                               "The entry to be unlinked is the mount point "
                               "for a mounted file system.");
                break;

            case EIO:
                real_exception(interpreter, NULL, E_SystemError, 
                               "An I/O error occurred while deleting the "
                               "directory entry or deallocating the inode.");
                break;

            case EROFS:
                real_exception(interpreter, NULL, E_SystemError, 
                               "The named file resides on a read-only file "
                               "system.");
                break;

            case EFAULT:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Path points outside the process's allocated "
                               "address space.");
            }
        }
    }
}
/*

=back

=head1 SEE ALS0

   man chdir(2), getcwd(3), unlink(2)

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
