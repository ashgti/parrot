/*
Copyright: 2001-2005 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

src/classes/os.pmc - Files and Directories PMC

=head1 DESCRIPTION

C<os> is a singleton class which provides access to the system
files and directories.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

static PMC * OS_PMC;
pmclass OS singleton {

/*

=item C<void* get_pointer()>

=item C<void set_pointer(void *ptr)>

These two functions are part of the singleton creation interface. For more
information see F<src/pmc.c>.

=cut

*/

    void* get_pointer() {
        return OS_PMC;
    }

    void set_pointer(void* ptr) {
        OS_PMC = (PMC*) ptr;
    }


/*

=item C<STRING* cwd()>

Returns the current working directory.

=cut

*/

    METHOD STRING* cwd() {
#ifndef _MSC_VER
        STRING *scwd;
        char * cwd = getcwd(NULL, 0);
        if (cwd) {
            scwd = string_from_cstring(interpreter, cwd, strlen(cwd));
            mem_sys_free(cwd);
            return scwd;
        } else {
            switch(errno) {
            case EACCES:
                real_exception(interpreter, NULL, E_SystemError,
                               "Read or search permission was denied for a "
                               "component of the pathname.");
                break;
            case EINVAL:
                real_exception(interpreter, NULL, E_SystemError,
                               "The size argument is zero.");
                break;
            case ENOENT:
                real_exception(interpreter, NULL, E_SystemError,
                               "A component of the pathname no longer exists.");
                break;
            case ENOMEM:
                real_exception(interpreter, NULL, E_SystemError,
                               "Insufficient memory is available.");
                break;
            case ERANGE:
                real_exception(interpreter, NULL, E_SystemError,
                               "The size argument is greater than zero but "
                               "smaller than the length of the pathname "
                               "plus 1.");
            }
            return NULL;
        }
#else
        internal_exception(UNIMPLEMENTED, "Win32 is not POSIX. Need win32 developer!");
#endif
    }

/*

=item C<void cd(STRING *path)>

Changes the current working directory to the one specified by C<path>.

=cut

*/

    METHOD void cd(STRING *path) {
#ifndef _MSC_VER
        int error;
        char *cpath = string_to_cstring(interpreter, path);
        error = chdir(cpath);
        string_cstring_free(cpath);
        if (error) {
            switch(errno) {
            case ENOTDIR:
                real_exception(interpreter, NULL, E_SystemError,
                               "A component of the path prefix is not a "
                               "directory.");
                break;
            case ENAMETOOLONG:
                real_exception(interpreter, NULL, E_SystemError,
                               "A component of a pathname exceeded %d "
                               "characters, or an entire path name exceeded %d "
                               "characters.", NAME_MAX, PATH_MAX);
                break;
            case ENOENT:
                real_exception(interpreter, NULL, E_SystemError,
                               "The named directory does not exist.");
                break;
#ifdef ELOOP
            case ELOOP:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Too many symbolic links were encountered in "
                               "translating the pathname.");
                break;
#endif
            case EACCES:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Search permission is denied for any component "
                               "of the path name.");
                break;
            case EFAULT:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Path points outside the process's allocated "
                               "address space.");
                break;
#ifdef EIO
            case EIO:
                real_exception(interpreter, NULL, E_SystemError, 
                               "An I/O error occurred while reading from or "
                               "writing to the file system.");
#endif
            }
        }
#else
        internal_exception(UNIMPLEMENTED, "Win32 is not POSIX. Need win32 developer!");
#endif
    }


/*

=item C<void rm(STRING* path)>

Calls C<remove> to remove the file or empty directory specified by
C<path>.

=cut

*/


    METHOD void rm(STRING *path) {
        int error;
        char *cpath = string_to_cstring(interpreter, path);
        error = remove(cpath);
        string_cstring_free(cpath);
        if (error) {
            switch(errno) {
            case ENOTDIR:
                real_exception(interpreter, NULL, E_SystemError, 
                               "A component of the path prefix is not a "
                               "directory.");
                break;

            case ENAMETOOLONG:
#if defined NAME_MAX && defined PATH_MAX
                real_exception(interpreter, NULL, E_SystemError, 
                               "A component of a pathname exceeded %d "
                               "characters, or an entire path name exceeded %d "
                               "characters.", NAME_MAX, PATH_MAX);
#else
                real_exception(interpreter, NULL, E_SystemError, 
                               "A component of a pathname exceeded the limit "
                               "of alowed characters.");
#endif
                break;


            case ENOTEMPTY:
                real_exception(interpreter, NULL, E_SystemError,
                               "The named directory contains files other "
                               "than `.' and `..' in it.");
                break;

            case ENOENT:
                real_exception(interpreter, NULL, E_SystemError, 
                               "The named file does not exist.");
                break;

            case EACCES:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Search permission is denied for a component of "
                               "the path prefix or write permission is denied "
                               "on the directory containing the link to be "
                               "removed.");
                break;

#ifdef ELOOP
            case ELOOP:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Too many symbolic links were encountered in "
                               "translating the pathname.");
                break;
#endif
            case EPERM:
                real_exception(interpreter, NULL, E_SystemError, 
                               "The named file is a directory and the effective"
                               " user ID of the process is not the super-user.");
                break;

            case EBUSY:
                real_exception(interpreter, NULL, E_SystemError, 
                               "The entry to be unlinked is the mount point "
                               "for a mounted file system.");
                break;

#ifdef EIO
            case EIO:
                real_exception(interpreter, NULL, E_SystemError, 
                               "An I/O error occurred while deleting the "
                               "directory entry or deallocating the inode.");
                break;
#endif
            case EROFS:
                real_exception(interpreter, NULL, E_SystemError, 
                               "The named file resides on a read-only file "
                               "system.");
                break;

            case EFAULT:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Path points outside the process's allocated "
                               "address space.");
            }
        }
    }


/*

=item C<void mkdir(STRING* path, STRING* mode)>

Creates a directory specified by C<path> with mode C<mode>.

=cut

*/

    METHOD void mkdir(STRING *path, INTVAL mode) {
#ifndef _MSC_VER
        int error;
        char *cpath = string_to_cstring(interpreter, path);
        /* should we validate mode? */
        error = mkdir(cpath, mode);
        string_cstring_free(cpath);
        if (error) {
            switch(errno) {
            case ENOTDIR:
                real_exception(interpreter, NULL, E_SystemError, 
                               "A component of the path prefix is not a "
                               "directory.");
                break;

            case ENAMETOOLONG:
                real_exception(interpreter, NULL, E_SystemError, 
                               "A component of a pathname exceeded %d "
                               "characters, or an entire path name "
                               "exceeded %d characters.",
                               NAME_MAX, PATH_MAX);
                break;
                      
            case ENOENT:           
                real_exception(interpreter, NULL, E_SystemError, 
                               "A component of the path prefix does not "
                               "exist.");
                break;

            case EACCES:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Search permission is denied for a component "
                               "of the path prefix.");
                break;

#ifdef ELOOP
            case ELOOP:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Too many symbolic links were encountered in "
                               "translating the pathname.");
                break;
#endif
                
            case EROFS:
                real_exception(interpreter, NULL, E_SystemError, 
                               "The named file resides on a read-only file "
                               "system.");
                break;

            case EEXIST:
                real_exception(interpreter, NULL, E_SystemError, 
                               "The named file exists.");
                break;

            case ENOSPC:
                real_exception(interpreter, NULL, E_SystemError, 
                               "The new directory cannot be created because "
                               "there is no space left on the file system "
                               "that will contain the directory or there are "
                               "no free inodes on the file system on which "
                               "the directory is being created.");
                break;

            case EDQUOT:
                real_exception(interpreter, NULL, E_SystemError, 
                               "The new directory cannot be created because "
                               "the user's quota of disk blocks on the file "
                               "system that will contain the directory has "
                               "been exhausted, or the user's quota of inodes "
                               "on the file system on which the directory is "
                               "being created has been exhausted.");
                break;
                
#ifdef EIO
            case EIO:
                real_exception(interpreter, NULL, E_SystemError, 
                               "An I/O error occurred while making the "
                               "directory entry or allocating the inode or "
                               "an I/O error occurred while reading from or "
                               "writing to the file system.");
                break;
#endif
                
            case EFAULT:          
                real_exception(interpreter, NULL, E_SystemError, 
                               "Path points outside the process's allocated "
                               "address space.");
                
            }
        }
#else
        internal_exception(UNIMPLEMENTED, "Win32 is not POSIX. Need win32 developer!");
#endif
    }


/*

=item C<void stat(STRING* path)>

Stats a file, and returns a 13 position array as in Perl:

     0 dev      device number of filesystem
     1 ino      inode number
     2 mode     file mode  (type and permissions)
     3 nlink    number of (hard) links to the file
     4 uid      numeric user ID of file's owner
     5 gid      numeric group ID of file's owner
     6 rdev     the device identifier (special files only)
     7 size     total size of file, in bytes
     8 atime    last access time in seconds since the epoch
     9 mtime    last modify time in seconds since the epoch
    10 ctime    inode change time in seconds since the epoch (*)
    11 blksize  preferred block size for file system I/O
    12 blocks   actual number of blocks allocated

=cut

*/

    METHOD PMC* stat(STRING *path) {
#ifndef _MSC_VER
        struct stat info;
        PMC *array;

        char *cpath = string_to_cstring(interpreter, path);
        int error = stat(cpath, &info);
        string_cstring_free(cpath);

        array = pmc_new(interpreter, enum_class_FixedPMCArray);
        VTABLE_set_integer_native(interpreter, array, 13);
/*        VTABLE_init(interpreter, array); */
        VTABLE_set_integer_keyed_int(interpreter, array, 0,
                                     info.st_dev);
        VTABLE_set_integer_keyed_int(interpreter, array, 1,
                                     info.st_ino);
        VTABLE_set_integer_keyed_int(interpreter, array, 2,
                                     info.st_mode);
        VTABLE_set_integer_keyed_int(interpreter, array, 3,
                                     info.st_nlink);
        VTABLE_set_integer_keyed_int(interpreter, array, 4,
                                     info.st_uid);
        VTABLE_set_integer_keyed_int(interpreter, array, 5,
                                     info.st_gid);
        VTABLE_set_integer_keyed_int(interpreter, array, 6,
                                     info.st_rdev);
        VTABLE_set_integer_keyed_int(interpreter, array, 7,
                                     info.st_size);
        VTABLE_set_integer_keyed_int(interpreter, array, 8,
                                     info.st_atime);
        VTABLE_set_integer_keyed_int(interpreter, array, 9,
                                     info.st_mtime);
        VTABLE_set_integer_keyed_int(interpreter, array,10,
                                     info.st_ctime);
        VTABLE_set_integer_keyed_int(interpreter, array,11,
                                     info.st_blksize);
        VTABLE_set_integer_keyed_int(interpreter, array,12,
                                     info.st_blocks);

        if (error) {
            switch(errno) {
            case ENOTDIR:
                real_exception(interpreter, NULL, E_SystemError, 
                               "A component of the path prefix is not a "
                               "directory.");
                break;
                
            case ENAMETOOLONG:
                real_exception(interpreter, NULL, E_SystemError, 
                               "A component of a pathname exceeded %d "
                               "characters, or an entire path name "
                               "exceeded %d characters.",
                               NAME_MAX, PATH_MAX);
                break;

            case ENOENT:
                real_exception(interpreter, NULL, E_SystemError, 
                               "The named file does not exist.");
                break;

            case EACCES:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Search permission is denied for a component "
                               "of the path prefix.");
                break;

#ifdef ELOOP
            case ELOOP:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Too many symbolic links were encountered in "
                               "translating the pathname.");
                break;
#endif

            case EFAULT:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Sb or name points to an invalid address.");
                break;

#ifdef EIO
            case EIO:
                real_exception(interpreter, NULL, E_SystemError, 
                               "An I/O error occurred while reading from or "
                               "writing to the file system.");
                break;
#endif
            }
            return NULL;
        } else {
            return array;
        }
#else
        internal_exception(UNIMPLEMENTED, "Win32 is not POSIX. Need win32 developer!");
#endif
    }

}
/*

=back

=head1 SEE ALS0

   man chdir(2), getcwd(3), unlink(2), mkdir(2)

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
