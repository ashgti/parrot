/*
Copyright: 2001-2005 The Perl Foundation.  All Rights Reserved.
$Id$

=head1 NAME

src/classes/os.pmc - Files and Directories PMC

=head1 DESCRIPTION

C<os> is a singleton class which provides access to the system
files and directories.

=head2 Methods

=over 4

=cut

*/

#include "parrot/parrot.h"

static PMC * OS_PMC;
pmclass OS singleton {

/*

=item C<void* get_pointer()>

=item C<void set_pointer(void *ptr)>

These two functions are part of the singleton creation interface. For more
information see F<src/pmc.c>.

=cut

*/

    void* get_pointer() {
        return OS_PMC;
    }

    void set_pointer(void* ptr) {
        OS_PMC = (PMC*) ptr;
    }


/*

=item C<char* cwd()>

=cut

*/

    METHOD STRING* cwd() {
        STRING *scwd;
        char * cwd = getcwd(NULL, 0);
        if (cwd) {
            scwd = string_from_cstring(interpreter, cwd, strlen(cwd));
            mem_sys_free(cwd);
            return scwd;
        } else {
            switch(errno) {
            case EACCES:
                real_exception(interpreter, NULL, E_SystemError,
                               "Read or search permission was denied for a component of the pathname.");
                break;
            case EINVAL:
                real_exception(interpreter, NULL, E_SystemError,
                               "The size argument is zero.");
                break;
            case ENOENT:
                real_exception(interpreter, NULL, E_SystemError,
                               "A component of the pathname no longer exists.");
                break;
            case ENOMEM:
                real_exception(interpreter, NULL, E_SystemError,
                               "Insufficient memory is available.");
                break;
            case ERANGE:
                real_exception(interpreter, NULL, E_SystemError,
                               "The size argument is greater than zero but smaller than the length of the pathname plus 1.");
            }
            return NULL;
        }
    }


/*

=item C<void cd(char *path)>

=cut

*/

    METHOD void cd(STRING *path) {
        int error;
        char *cpath = string_to_cstring(interpreter, path);
        error = chdir(cpath);
        string_cstring_free(cpath);
        if (error) {
            switch(errno) {
            case ENOTDIR:
                real_exception(interpreter, NULL, E_SystemError,
                               "A component of the path prefix is not a directory.");
                break;
            case ENAMETOOLONG:
                real_exception(interpreter, NULL, E_SystemError,
                               "A component of a pathname exceeded %d characters, or an entire path name exceeded %d characters.", NAME_MAX, PATH_MAX);
                break;
            case ENOENT:
                real_exception(interpreter, NULL, E_SystemError,
                               "The named directory does not exist.");
                break;
            case ELOOP:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Too many symbolic links were encountered in translating the pathname.");
                break;
            case EACCES:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Search permission is denied for any component of the path name.");
                break;
            case EFAULT:
                real_exception(interpreter, NULL, E_SystemError, 
                               "Path points outside the process's allocated address space.");
                break;
            case EIO:
                real_exception(interpreter, NULL, E_SystemError, 
                               "An I/O error occurred while reading from or writing to the file system.");
                break;
            }
        }
    }
}
/*

=back

=head1 SEE ALS0

   man chdir(2), getcwd(3)

=cut

*/

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
 * vim: expandtab shiftwidth=4:
*/
