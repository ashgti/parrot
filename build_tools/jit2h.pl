#! /usr/bin/perl -w 
#
# jit2h.pl
#
# $Id$
#

use strict;
use lib 'lib';
use Parrot::OpLib::core;
use Parrot::Op;
use Parrot::OpTrans::C;

my %type_to_arg = (
    INT_CONST => 'ic',
    NUM_CONST => 'nc',
    STRING_CONST => 'sc',
    INT_REG => 'i',
    NUM_REG => 'n',
    PMC_REG => 'p',
    STRING_REG => 's',
);

my $core_numops = scalar(@$Parrot::OpLib::core::ops);
my @core_opfunc = map { $_->func_name } @$Parrot::OpLib::core::ops;

my $cpuarch = shift @ARGV;

my ($i,$j,$k,$n);

my ($function, $body, $line, $extern);

my ($asm, $precompiled);

my %core_ops;

sub readjit($) {
    my $file = shift;

    my %ops;

    open (IN,$file) or die "Can't open file $file: $!";
    while ($line = <IN>) {
        next if (($line =~ m/^[#;]/) || ($line =~ m/^\s*$/));
        if (!defined($function)) {
            $line =~ m/(extern\s*)?([^\s]*)\s*{/;
            $extern = (defined($1))? 1 : 0;
            $function = $2;
            $asm = "";
            next;
        }
        if ($line =~ m/^}/) {
            $asm =~ s/([\&\*])([a-zA-Z_]+)\[(\d+)\]/make_subs($1,$2,$3)/ge;
            $asm =~ s/NEW_FIXUP/Parrot_jit_newfixup(jit_info)/g;
            $asm =~ s/CUR_FIXUP/jit_info->fixups/g;
            $asm =~ s/NATIVECODE/jit_info->native_ptr/g;
            $asm =~ s/CUR_OPCODE/jit_info->cur_op/g;
            $asm =~ s/cur_opcode/jit_info->cur_op/g;
            $ops{$function} = [ $asm , $extern ];
            $function = undef;
        }
        $asm .= $line;
    }
    return %ops;
}

open JITCPU, ">$ARGV[0]" or die;

print JITCPU<<END_C;
/*
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *
 * This file is generated automatically from 'jit/$cpuarch/core.jit'
 * by $0.
 *
 * Any changes made here will be lost!  
 *
 */

#include<parrot/parrot.h>
#include"parrot/jit.h"
#include"parrot/jit_emit.h"

END_C

%core_ops = readjit("jit/$cpuarch/core.jit");

my @jit_funcs;
push @jit_funcs, "jit_fn_info_t op_jit[$core_numops]= {\n";

my $jit_fn_retn = "void";
my $jit_fn_params = "(Parrot_jit_info *jit_info, struct Parrot_Interp * interpreter)";

for ($i = 0; $i < $core_numops; $i++) {
    $body = $core_ops{$core_opfunc[$i]}[0];
    $extern = $core_ops{$core_opfunc[$i]}[1];

    my $jit_func;
    my $op = $Parrot::OpLib::core::ops->[$i];

    $precompiled = 0;
    if (!defined $body) {
        $precompiled = 1;
        $extern = 1;
        if ($op->jump) {
            $jit_func = "Parrot_jit_cpcf_op";
        } else {
            $jit_func = "Parrot_jit_normal_op";
        }
    }
    else
    {
        $jit_func = "$core_opfunc[$i]_jit";
    }

    unless($precompiled){
    print JITCPU "\nstatic $jit_fn_retn " . $core_opfunc[$i] . "_jit" . $jit_fn_params . "{\n$body}\n";
    }
    my $op_args = $op->size;
    push @jit_funcs, "/* op $i: $core_opfunc[$i] */\n";
    push @jit_funcs, "{ $jit_func, $op_args, $extern }, \n";
}

print JITCPU @jit_funcs, "};\n";

sub make_subs {
    my ($ptr, $type, $index) = @_; 
    return(($ptr eq '&' ? '&' : '') . sprintf($Parrot::OpTrans::C::arg_maps{$type_to_arg{$type}}, $index));
}
