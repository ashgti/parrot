# Copyright (C) 2009, Parrot Foundation.
# $Id$

=head1 NAME

tools/build/h2pasm.pl

=head1 DESCRIPTION

Generate C<.pasm> files with constants based on C<.h> files.

=cut

use strict;
use warnings;

my $usage = "Usage: $0 <input_file> > <output file>\n";

my $in_file  = shift or die $usage;
die $usage if @ARGV;

open my $fh, '<', $in_file or die "Can't open $in_file: $!\n";
my @directives = parse_file($in_file, $fh);
close $fh;
for my $d (@directives) {
    my @defs = perform_directive($d);
    for my $target ( @{ $d->{files} } ) {
        my $gen = join "\n", &const_to_parrot(@defs);
        print <<"EOF";
# DO NOT EDIT THIS FILE.
#
# This file is generated automatically from
# $in_file by $0
#
# Any changes made here will be lost.
#
$gen
EOF
    }
}

sub const_to_parrot {
    my $keylen = 0;
    foreach my $element (@_) {
        my $size = length($element->[0]);
        if ($size > $keylen) {
            $keylen = $size;
        }
    }
    my $vallen = 0;
    foreach my $element (@_) {
        my $size = length($element->[1]);
        if ($size > $vallen) {
            $vallen = $size;
        }
    }

    return map {sprintf ".macro_const %-${keylen}s %${vallen}s", $_->[0], $_->[1]} @_;
}

sub transform_name {
    my $action = shift;

    return map { [ $action->( $_->[0] ), $_->[1] ] } @_;
}

sub prepend_prefix {
    my $prefix = shift;

    transform_name( sub { $prefix . $_[0] }, @_ );
}

sub perform_directive {
    my ($d) = @_;

    my @defs = prepend_prefix $d->{prefix}, @{ $d->{defs} };
    if ( my $subst = $d->{subst} ) {
        @defs = transform_name( sub { local $_ = shift; eval $subst; $_ }, @defs );
    }
    @defs;
}

sub parse_file {
    my ( $file, $fh ) = @_;

    my ( @d, %values, $last_val, $cur, $or_continues );
    while ( my $line = <$fh> ) {
        if (
            $line =~ m!
            &gen_from_(enum|def) \( ( [^)]* ) \)
            (?: \s+ prefix \( (\w+) \) )?
            (?: \s+ subst \( (s/.*?/.*?/[eig]?) \) )?
            !x
            )
        {
            $cur and die "Missing '&end_gen' in $file\n";
            $cur = {
                type   => $1,
                files  => [ split ' ', $2 ],
                prefix => defined $3 ? $3 : '',
                defined $4 ? ( subst => $4 ) : (),
            };
            $last_val = -1;
        }
        elsif ( $line =~ /&end_gen\b/ ) {
            $cur or die "Missing &gen_from_(enum|def) in $file\n";
            push @d, $cur;
            $cur = undef;
        }

        $cur or next;

        if ( $cur->{type} eq 'def' && $line =~ /^\s*#define\s+(\w+)\s+(-?\w+|"[^"]*")/ ) {
            push @{ $cur->{defs} }, [ $1, $2 ];
        }
        elsif ( $cur->{type} eq 'enum' ) {
            # Special case: enum value is or'd combination of other values
            if ( $or_continues ) {
                $or_continues = 0;
                my $last_def = $cur->{defs}->[-1];
                my ($k, $v) = @{$last_def};
                my @or_values = grep {defined $_} $line =~ /^\s*(-?\w+)(?:\s*\|\s*(-?\w+))*/;
                for my $or (@or_values) {
                    if ( defined $values{$or} ) {
                        $v |= $values{$or};
                    }
                    elsif ( $or =~ /^0/ ) {
                        $v |= oct $or;
                    }
                }
                if ($line =~ /\|\s*$/) {
                    $or_continues = 1;
                }
                $values{$k} = $last_val = $v;
                $cur->{defs}->[-1]->[1] = $v;
            }
            elsif ( $line =~ /^\s*(\w+)\s*=\s*(-?\w+)\s*\|/ ) {
                my ( $k, $v ) = ( $1, $2 );
                my @or_values = ($v, $line =~ /\|\s*(-?\w+)/g);
                $v = 0;
                for my $or (@or_values) {
                    if ( defined $values{$or} ) {
                        $v |= $values{$or};
                    }
                    elsif ( $or =~ /^0/ ) {
                        $v |= oct $or;
                    }
                }
                if ($line =~ /\|\s*$/) {
                    $or_continues = 1;
                }
                $values{$k} = $last_val = $v;
                push @{ $cur->{defs} }, [ $k, $v ];
            }
            elsif ( $line =~ /^\s*(\w+)\s*=\s*(-?\w+)/ ) {
                my ( $k, $v ) = ( $1, $2 );
                if ( defined $values{$v} ) {
                    $v = $values{$v};
                }
                elsif ( $v =~ /^0/ ) {
                    $v = oct $v;
                }
                $values{$k} = $last_val = $v;
                push @{ $cur->{defs} }, [ $k, $v ];
            }
            elsif ( $line =~ m!^\s*(\w+)\s*(?:,\s*)?(?:/\*|$)! ) {
                my $k = $1;
                my $v = $values{$k} = ++$last_val;
                push @{ $cur->{defs} }, [ $k, $v ];
            }
        }
    }
    $cur and die "Missing '&end_gen' in $file\n";

    return @d;
}

1;

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
