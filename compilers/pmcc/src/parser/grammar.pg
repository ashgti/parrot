# Copyright (C) 2009, Parrot Foundation.
# $Id$


=begin overview

This is PMC grammar.

(ATM) PMC consists of
1. Some pure C header.
2. PMC class definition.
3. Optional ATTRibutes.
4. Mix of VTABLE and METHODS.

=end overview

grammar PMC::Grammar is PCT::Grammar;

token TOP {
    #<c_header>
    <pmc>
    [ $ || <panic: 'Syntax error'> ]
    {*}
}

rule c_header {
#  .* way too gready...
#    [.*] [<!before 'pmclass'> ]
    {*}
}

# pmc action will store "header" and "footer"
rule pmc {
    pmclass <identifier>
    {*}                                     #= begin
    <traits>* '{'
        <attribute>*
        <body>
    '}'
    {*}                                     #= end
}

rule traits {
    [
    | 'extends'     <identifier>            {*} #= extends
    | 'provides'    <identifier>            {*} #= provides
    | 'group'       <identifier>            {*} #= group
    | 'lib'         <identifier>            {*} #= lib
    | 'need_ext'                            {*} #= need_ext
    | 'abstract'                            {*} #= abstract
    | 'no_init'                             {*} #= no_init
    | 'singleton'                           {*} #= singleton
    | 'dynpmc'                              {*} #= dynpmc
    | 'no_ro'                               {*} #= no_ro
    ]
}

rule attribute {
    'ATTR' <attribute_type> <c_comment>?
}

rule attribute_type {
    [ <simple_attr>   {*}  #= simple_attr
    | <pointer_attr>  {*}  #= pointer_attr
    ]
}

rule simple_attr {
    <simple_attr_type> <identifier> ';'
}

rule simple_attr_type {
    [ 'U'? 'INTVAL'
    | 'FLOATVAL'
    | 'STRING'
    | 'struct'?  <identifier>
    | 'unsigned'? 'char'
    ]
}

rule pointer_attr {
    <pointer_attr_type> <identifier> ';'
}

rule pointer_attr_type {
    <simple_attr_type>  '*'+
}

# Body of PMC class.
rule body {
    <body_part>*
}

rule body_part {
    | <class_init>  {*} #= class_init
    | <vtable>      {*} #= vtable
    | <method>      {*} #= method
    | <multi>       {*} #= multi
}

# PMC can have class_init function.
rule class_init {
    'void' 'class_init' '(' ')' <c_body>
    {*}
}

rule method {
    'METHOD' :: [
        [ <identifier> '(' <parrot_c_arguments> ')' <c_body> ]
        | <.panic: "Unexpected METHOD content">
    ]
    {*}
}

rule vtable {
    'VTABLE' :: <c_signature> <c_body>
    {*}
}

rule multi {
    'MULTI' :: <c_signature> <c_body>
    {*}
}

# Nested list of something
rule c_body {
    '{' [ <-[{}]> | <c_body> ]* '}'
    {*}
}

# It's really bad signature
rule c_signature {
    <c_type> <identifier> '(' <c_arguments> ')'
}

# Very-very simplified C type. E.g. "void", "PMC *", etc
rule c_type {
    [
        | 'struct'   <identifier>
        | 'unsigned' <identifier>
        | <identifier>
    ]
    '*'*
    {*}
}

# Very-very simplified named? function param.
rule c_argument {
    <c_type> <identifier>?
    {*}
}

rule c_arguments {
    [ <c_argument> [ ',' <c_argument> ]* ]*
    {*}
}

# c_arguments with parrot's adverbs
rule parrot_c_argument {
    <c_argument> <adverb>?
}

rule parrot_c_arguments {
    [ <parrot_c_argument> [ ',' <parrot_c_argument> ]* ]*
}

rule c_comment {
    '/*' .*? '*/'
}

rule adverb {
    [
    | ':optional' <named>?
    | ':opt_flag'
    | ':slurpy' <named>?
    | <named>
    ]
}

rule named {
    ':named' [ '("' <identifier> '")' ]?
}

token identifier {
    <.ident>
}

## ws token handles whitespaces and C /* */ comments
token ws {
  [
  | '//' \N* \n
  | '/*' .*? '*/'
  | \s+
  ]*
}


