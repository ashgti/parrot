grammar POST::Grammar is TGE::Grammar;

transform root (PAST::Block) :language('PIR') {
    .local pmc blockpast
    blockpast = get_hll_global ['POST'], '@?BLOCK'
    unless null blockpast goto have_blockpast
    blockpast = new 'ResizablePMCArray'
    set_hll_global ['POST'], '@?BLOCK', blockpast
  have_blockpast:
    .local pmc post
    post = tree.'get'('post', node)
    $I0 = isa post, 'POST::Sub'
    if $I0 goto end
    $S0 = post.'unique'('__anon_')
    $P0 = getclass 'POST::Sub'
    post = $P0.'new'(post, 'name'=>$S0)
  end:
    .return (post)
}


transform post (PAST::Block) :language('PIR') {
    ##  add current PAST::Block to @?BLOCK
    .local pmc blockpast
    blockpast = get_hll_global ['POST'], '@?BLOCK'
    unshift blockpast, node

    .local string name, pragma, blocktype
    name = node.'name'()
    if name != '' goto with_name
    name = node.unique('_block')
  with_name:
    pragma = node.'pragma'()
    blocktype = node.'blocktype'()
    .local pmc outerpost
    outerpost = get_hll_global ['POST'], '$?SUB'
    .local pmc post
    post = new 'POST::Sub'
    post.'init'('node'=>node, 'name'=>name, 'outer'=>outerpost, 'pragma'=>pragma, 'blocktype'=>blocktype)
    set_hll_global ['POST'], '$?SUB', post
    .local string compiler
    compiler = node.'compiler'()
    if compiler goto hll_block
  past_block:
    .local pmc iter
    iter = node.'iterator'()
    unless iter goto iter_end
  iter_loop:
    .local pmc cpast, cpost
    cpast = shift iter
    cpost = tree.'get'('post', cpast)
    post.'push'(cpost)
    if iter goto iter_loop
    post.'result'(cpost)
  iter_end:
    goto end

  hll_block:
    post.'compiler'(compiler)
    iter = node.'iterator'()
  hll_loop:
    unless iter goto end
    $P0 = shift iter
    post.'push'($P0)
    goto hll_loop

  end:
    set_hll_global ['POST'], '$?SUB', outerpost
    if blocktype != 'immediate' goto blocktype_end
    $P0 = getclass 'POST::Op'
    post = $P0.'new'(post, 'node'=>node, 'pirop'=>'call', 'arglist'=>post)

  blocktype_end:
    ##  pop current block from @?BLOCK
    $P99 = shift blockpast
    .return (post)
}


transform post (PAST::Stmts) :language('PIR') {
    .local pmc ops
    ops =  new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc iter
    iter = node.'iterator'()
    unless iter goto end
  iter_loop:
    .local pmc cpast, cpost
    cpast = shift iter
    cpost = tree.'get'('post', cpast)
    ops.'push'(cpost)
    if iter goto iter_loop
  iter_end:
    ops.'result'(cpost)
  end:
    .return (ops)
}


transform post (PAST::Op) :language('PIR') {
    .local string pasttype
    pasttype = node.'pasttype'()
    if pasttype goto post_pasttype

  post_pirop:
    .local string pirop
    pirop = node.'pirop'()
    if pirop goto have_pirop
    node.'pirop'('call')
  have_pirop:
    .return tree.'get'('pirop', node)

  post_pasttype:
    .return tree.'get'(pasttype, node)
}


transform pirop (PAST::Op) :language('PIR') {
    .local string pirop
    .local pmc post
    pirop = node.'pirop'()
    post = new 'POST::Op'
    post.'init'('node'=>node, 'pirop'=>pirop)

    if pirop == 'inline' goto pirop_inline
    if pirop == 'call' goto pirop_call
    if pirop == 'callmethod' goto pirop_call
    goto post_children

  pirop_call:
    .local string name
    name = node.'name'()
    unless name goto post_children
    post.'push_new'('POST::Val', 'value'=>name)
    goto post_children

  pirop_inline:
    .local pmc inline
    inline = node.'inline'()
    post.'inline'(inline)

  post_children:
    .local pmc iter
    iter = node.'iterator'()
  iter_loop:
    unless iter goto iter_end
    .local pmc cpast, cpost
    cpast = shift iter
    cpost = tree.'get'('post', cpast)
    post.'push'(cpost)
    $P0 = cpast.'named'()
    unless $P0 goto iter_loop
    $P0 = tree.'get'('post', $P0)
    cpost.'named'($P0)
    goto iter_loop
  iter_end:
    $P0 = post.'get_array'()
    post.'arglist'($P0 :flat)
    .return (post)
}


transform call (PAST::Op) :language('PIR') {
    node.'pirop'('call')
    $P0 = tree.'get'('pirop', node)
    .return ($P0)
}


transform callmethod (PAST::Op) :language('PIR') {
    node.'pirop'('callmethod')
    $P0 = tree.'get'('pirop', node)
    .return ($P0)
}


transform inline (PAST::Op) :language('PIR') {
    node.'pirop'('inline')
    .return tree.'get'('pirop', node)
}


transform if (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)

    .local pmc exprpast, thenpast, elsepast
    .local pmc exprpost, thenpost, elsepost
    exprpast = node[0]
    thenpast = node[1]
    elsepast = node[2]

    .local pmc thenlabel, endlabel
    .local string pasttype, n
    pasttype = node.'pasttype'()
    n = node.'unique'('_')
    $S0 = concat pasttype, n
    $P0 = getclass 'POST::Label'
    thenlabel = $P0.'new'('result'=>$S0)
    $S0 = concat $S0, '_end'
    endlabel = $P0.'new'('result'=>$S0)

    exprpost = tree.'get'('post', exprpast)
    ops.'push'(exprpost)
    ops.'push_pirop'(pasttype, exprpost, thenlabel)
    elsepost = exprpost
    $I0 = defined elsepast
    if $I0 == 0 goto else_done
    elsepost = tree.'get'('post', elsepast)
    ops.'push'(elsepost)
  else_done:
    ops.'push_pirop'('set', ops, elsepost)
    ops.'push_pirop'('goto', endlabel)
    ops.'push'(thenlabel)
    thenpost = exprpost
    $I0 = defined thenpast
    if $I0 == 0 goto then_done
    thenpost = tree.'get'('post', thenpast)
    ops.'push'(thenpost)
  then_done:
    ops.'push_pirop'('set', ops, thenpost)
    ops.'push'(endlabel)
    .return (ops)
}


transform unless (PAST::Op) :language('PIR') {
    .return tree.'get'('if', node)
}


transform while (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)

    .local pmc exprpast, blockpast
    .local pmc exprpost, blockpost
    exprpast = node[0]
    blockpast = node[1]

    .local pmc looplabel, endlabel
    .local string pasttype, n
    pasttype = node.'pasttype'()
    n = node.'unique'('_')
    $S0 = concat pasttype, n
    $P0 = getclass 'POST::Label'
    looplabel = $P0.'new'('result'=>$S0)
    $S0 = concat $S0, '_end'
    endlabel = $P0.'new'('result'=>$S0)

    ##   determine if we need an 'if' or an 'unless' on
    ##   the conditional (while => if, until => unless)
    .local string iftype
    iftype = 'if'
    if $S0 == 'until' goto done_iftype
    iftype = 'unless'
  done_iftype:

    ops.'push'(looplabel)
    exprpost = tree.'get'('post', exprpast)
    ops.'push'(exprpost)
    ops.'push_pirop'(iftype, exprpost, endlabel)
    blockpost = tree.'get'('post', blockpast)
    ops.'push'(blockpost)
    ops.'push_pirop'('goto', looplabel)
    ops.'push'(endlabel)
    ops.'result'(exprpost)
    .return (ops)
}

transform until (PAST::Op) :language('PIR') {
    .return tree.'get'('while', node)
}

transform for (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)

    .local pmc looplabel, endlabel
    .local string pasttype, n
    pasttype = node.'pasttype'()
    n = node.'unique'('_')
    $S0 = concat pasttype, n
    $P0 = getclass 'POST::Label'
    looplabel = $P0.'new'('result'=>$S0)
    $S0 = concat $S0, '_end'
    endlabel = $P0.'new'('result'=>$S0)

    .local pmc collpast, collpost
    collpast = node[0] 
    collpost = tree.'get'('post', collpast)

    # reference our collection ...
    ops.'push'(collpost)
    # Create a temporary iterator for our collection
    # $P<unique> = new .Iterator, obj from collection.
    .local pmc iter
    iter = ops.'unique'('$P')
    ops.'push_pirop'('new', iter, "'Iterator'", collpost)

    # loop
    ops.'push'(looplabel)
    ops.'push_pirop'('unless', iter, endlabel)
    # end unless iterator
    
    # assign nextval to loop variable
    .local pmc nextval
    nextval = ops.'unique'('$P')
    ops.'push_pirop'('shift', nextval, iter)

    # execute block
    .local pmc subpast, subpost
    subpast = node[1] 
    subpost = tree.'get'('post', subpast)
    $P0 = subpost[0] # get to the sub so we can add the param..
    ops.'push'(subpost)
    ops.'push_pirop'('call',subpost,nextval)

    # goto loop
    ops.'push_pirop'('goto', looplabel)
    ops.'push'(endlabel)
    .return (ops)
}

transform try (PAST::Op) :language('PIR') {
    .local pmc trypast, trypost, post, traplabel, endlabel
    trypast = node[0]
    trypost = tree.'get'('post', trypast)
    $P0 = getclass 'POST::Ops'
    post = $P0.'new'('node'=>node, 'result'=>trypost)
    $S0 = node.'unique'('trap_')
    $P0 = getclass 'POST::Label'
    traplabel = $P0.'new'('result'=>$S0)
    $S0 = concat $S0, '_end'
    endlabel = $P0.'new'('result'=>$S0)
    post.'push_pirop'('push_eh', traplabel)
    post.'push'(trypost)
    post.'push_pirop'('clear_eh')
    post.'push_pirop'('goto', endlabel)
    post.'push'(traplabel)
    .local pmc catchnode, catchpast
    catchnode = node[1]
    unless catchnode goto have_catch
    catchpast = tree.'get'('post', catchnode)
    post.'push'(catchpast)
  have_catch:
    post.'push'(endlabel)
    .return (post)
}


transform xor (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)

    .local pmc endlabel, falselabel
    $P0 = getclass 'POST::Label'
    falselabel = $P0.'new'('name'=>'xor_false')
    endlabel = $P0.'new'('name'=>'xor_end')

    .local pmc iter, apast, apost, i, t, u
    i = ops.unique('$I')
    t = ops.unique('$I')
    u = ops.unique('$I')
    iter = node.'iterator'()
    apast = shift iter
    apost = tree.'get'('post', apast)
    ops.'push'(apost)
    ops.'push_pirop'('set', ops, apost)
    ops.'push_pirop'('istrue', t, apost)
  middle_child:
    .local pmc bpast, bpost
    bpast = shift iter
    bpost = tree.'get'('post', bpast)
    ops.'push'(bpost)
    ops.'push_pirop'('istrue', u, bpost)
    ops.'push_pirop'('and', i, t, u)
    ops.'push_pirop'('if', i, falselabel)
    unless iter goto last_child
    .local pmc s
    $P0 = new 'POST::Label'
    s = $P0.'new'('name'=>'xor_skip')
    ops.'push_pirop'('if', t, s)
    ops.'push_pirop'('set', ops, bpost)
    ops.'push_pirop'('set', t, u)
    ops.'push'(s)
    goto middle_child
  last_child:
    ops.'push_pirop'('if', t, endlabel)
    ops.'push_pirop'('set', ops, bpost)
    ops.'push_pirop'('goto', endlabel)
    ops.'push'(falselabel)
    ops.'push_pirop'('new', ops, '.Undef')
    ops.'push'(endlabel)
    .return (ops)
}


transform bind (PAST::Op) :language('PIR') {
    .local pmc lpast, rpast, lpost, rpost, post
    rpast = node[1]
    rpost = tree.'get'('post', rpast)
    lpast = node[0]
    lpast.'bindvalue'(rpost)
    lpost = tree.'get'('bind', lpast)
    $P0 = getclass 'POST::Ops'
    post = $P0.'new'(rpost, lpost, 'node'=>node)
    .return (post)
}


transform assign (PAST::Op) :language('PIR') {
    .local pmc lpast, rpast, lpost, rpost, post, alabel
    rpast = node[1]
    rpost = tree.'get'('post', rpast)
    lpast = node[0]
    lpost = tree.'get'('post', lpast)
    $P0 = getclass 'POST::Ops'
    post = $P0.'new'(rpost, lpost, 'node'=>node, 'result'=>lpost)
    $P0 = getclass 'POST::Label'
    alabel = $P0.'new'('name'=>'assign_')
    post.'push_pirop'('eq_addr', lpost, rpost, alabel)
    post.'push_pirop'('morph', lpost, '.Undef')
    post.'push_pirop'('assign', lpost, rpost)
    post.'push'(alabel)
    .return (post)
}


transform chain (PAST::Op) :language('PIR') {
    .local pmc clist, cpast
    clist = new .ResizablePMCArray
    cpast = node
  chain_loop:
    $I0 = isa cpast, 'PAST::Op'
    if $I0 == 0 goto chain_end
    .local string pasttype
    pasttype = cpast.'pasttype'()
    if pasttype != 'chain' goto chain_end
    push clist, cpast
    cpast = cpast[0]
    goto chain_loop
  chain_end:

    .local pmc ops, endlabel, apast, apost
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)
    cpast = pop clist
    $P0 = getclass 'POST::Label'
    endlabel = $P0.'new'('name'=>'chain_end_')
    apast = cpast[0]
    apost = tree.'get'('post', apast)
    ops.'push'(apost)

  clist_loop:
    .local pmc bpast, bpost
    bpast = cpast[1]
    bpost = tree.'get'('post', bpast)
    .local string name
    name = cpast.'name'()
    name = cpast.'escape'(name)
    ops.'push'(bpost)
    $P0 = ops.'push_pirop'('call', name, apost, bpost)
    $P0.'result'(ops)
    unless clist goto clist_end
    ops.'push_pirop'('unless', ops, endlabel)
    cpast = pop clist
    apost = bpost
    goto clist_loop
  clist_end:
    ops.'push'(endlabel)
    .return (ops)
}


transform post (PAST::Val) :language('PIR') {
    .local pmc value
    value = node['value']
    $P0 = getclass 'POST::Val'
    .return $P0.'new'('node'=>node, 'value'=>value)
}


transform keypost (PAST::Var) :language('PIR') {
    .local pmc post
    post = new 'POST::Ops'
    post.'init'('node'=>node)
    .local pmc basepast, keypast
    .local pmc basepost, keypost
    basepast = node[0]
    keypast = node[1]
    keypost = tree.'get'('post', keypast)
    post.'push'(keypost)
    basepost = tree.'get'('post', basepast)
    post.'push'(basepost)
    .local string key
    key = basepost.'result'()
    key = concat key, '['
    $S0 = keypost.'result'()
    key .= $S0
    key .= ']'
    post.'result'(key)
    .return (post)
}

##  Find the scope for the variable given by this node.  If
##  defined directly in the node, return it, otherwise search
##  through outer blocks for symbol information and use that
##  if found.
transform scope (PAST::Var) :language('PIR') {
    .local pmc scope
    scope = node.'scope'()
    if scope goto end

    .local string name
    name = node.'name'()
    .local pmc iter, bpast
    $P0 = get_hll_global ['POST'], '@?BLOCK'
    iter = new 'Iterator', $P0
  iter_loop:
    unless iter goto end
    .local pmc bpast, symbol
    bpast = shift iter
    symbol = bpast.'symbol'(name)
    unless symbol goto iter_loop
    scope = symbol['scope']
    unless scope goto iter_loop
  end:
    .return (scope)
}


transform bind (PAST::Var) :language('PIR') {
    .local pmc bindvalue
    .local string scope
    bindvalue = node.'bindvalue'()
    scope = tree.'get'('scope', node)
    if scope == 'keyed' goto keyed

    .local string name
    name = node.'name'()
    name = node.'escape'(name)
    .local pmc post
    post = new 'POST::Op'
    post.'init'('node'=>node, 'result'=>bindvalue, 'pirop'=>'set_global')
    post.'arglist'(name, bindvalue)
    if scope == 'lexical' goto lexical
    .return (post)

  lexical:
    .local int isdecl
    isdecl = node.'isdecl'()
    if isdecl goto lexical_decl
    post.'pirop'('store_lex')
    .return (post)

  lexical_decl:
    post.'pirop'('.lex')
    .return (post)

  keyed:
    .local pmc post, keypost
    keypost = tree.'get'('keypost', node)
    $P0 = getclass 'POST::Op'
    post = $P0.'new'(keypost, 'node'=>node, 'pirop'=>'set', 'result'=>bindvalue)
    post.'arglist'(keypost, bindvalue)
    .return (post)
}


transform vivipost (PAST::Var) :language('PIR') {
    .local pmc viviself, vivipost
    viviself = node.'viviself'()
    $I0 = isa viviself, 'PAST::Node'
    if $I0 goto viviself_past
    if viviself goto viviself_string
    vivipost = new 'POST::Ops'
    .return (vivipost)

  viviself_past:
    .return tree.'get'('post', viviself)

  viviself_string:
    $S0 = viviself
    $S0 = concat "'", $S0
    concat $S0, "'"
    vivipost = new 'POST::Op'
    vivipost.'init'('node'=>node, 'pirop'=>'new')
    vivipost.'arglist'(vivipost, $S0)
    .return (vivipost)
}


transform post (PAST::Var) :language('PIR') {
    .local pmc vivipost, vivilabel, post
    vivipost = tree.'get'('vivipost', node)
    $P0 = getclass 'POST::Ops'
    post = $P0.'new'('node'=>node, 'result'=>vivipost)
    $P0 = getclass 'POST::Label'
    vivilabel = $P0.'new'('name'=>'vivify_')

    .local string scope, name, fetchop, storeop
    scope = tree.'get'('scope', node)
    if scope == 'keyed' goto scope_keyed
    name = node.'name'()
    name = node.'escape'(name)
    if scope == 'lexical' goto scope_lexical
    if scope == 'parameter' goto scope_parameter
  scope_package:
    fetchop = 'get_global'
    storeop = 'set_global'
    goto have_scope

  scope_keyed:
    .local pmc keypost, basepost
    keypost = tree.'get'('keypost', node)
    post.'push'(keypost)
    name = keypost.'result'()
    fetchop = 'set'
    storeop = 'set'
    goto have_scope

  scope_lexical:
    fetchop = 'find_lex'
    storeop = 'store_lex'
    $I0 = node.'isdecl'()
    if $I0 == 0 goto have_scope
    post.'push'(vivipost)
    post.'push_pirop'('.lex', name, vivipost)
    .return (post)

  scope_parameter:
    post = new 'POST::Op'
    post.'pirop'('.lex')
    .local string pname
    pname = post.'unique'('param_')
    post.'arglist'(name, pname)
    post.'result'(pname)
    .local pmc subpost
    subpost = get_hll_global ['POST'], '$?SUB'
    subpost.'push_param'('pmc', pname)
    .return (post)

  have_scope:
    post.'push_pirop'(fetchop, post, name)
    $P0 = node.'viviself'()
    unless $P0 goto done_vivipost
    post.'push_pirop'('unless_null', post, vivilabel)
    post.'push'(vivipost)
    .local int islvalue
    islvalue = node.'islvalue'()
    unless islvalue goto done_lvalue
    post.'push_pirop'(storeop, name, post, 'result'=>post)
  done_lvalue:
    post.'push'(vivilabel)
  done_vivipost:
    .return (post)
}


transform bind (PAST::VarList) :language('PIR') {
    .local pmc post, bindvalue, binditer
    post = new 'POST::Ops'
    post.'init'('node'=>node)

    bindvalue = node.'bindvalue'()
    binditer = post.'push_new'('POST::Op', 'pirop'=>'new')
    binditer.'arglist'(binditer, '.Iterator', bindvalue)

    .local pmc iter
    iter = node.'iterator'()
  iter_loop:
    unless iter goto iter_end
    .local pmc cpast, cpost
    cpast = shift iter
    post.'push_pirop'('shift', post, binditer)
    cpast.'bindvalue'(post)
    cpost = tree.'get'('bind', cpast)
    post.'push'(cpost)
    goto iter_loop
  iter_end:
    .return (post)
}
