%{

/* ex: set ro ft=c:
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 *
 * This file is generated automatically by the Parrot build process
 * from the file compilers/pirc/new/pir.l.
 *
 * Any changes made here will be lost!
 *
*/

/* HEADERIZER HFILE: none */
/* HEADERIZER STOP */


/*
 * $Id$
 * Copyright (C) 2007, The Perl Foundation.
 */


/*

=head1 NAME

pir.l


=head1 DESCRIPTION

This is a complete rewrite of the PIR lexical analyzer, as defined in IMCC.
Goal is to fix the issues with the current implementation of the PIR language.
Major issues are:

=over 4

=item Grammar is a bit messy, and has some problems, like disallowing line comments in .param declarations.

=item The lexer is messy and not re-entrant. The macro layer is a mess and unmaintainable.

=item No support for nested heredocs. This is now supported.

=item The comment:  "this is just a sign that we suck.  that's all." speaks for itself (imc.h)

=back

=cut

*/



#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
#include "pirparser.h"
#include "pircompiler.h"


/* Parrot can check out whether the specified text is the name of an op.
 * We define a dummy function for now; replace this later.
 */
static int is_parrot_op(char *spelling);




/* datastructure to store the heredocs */
typedef struct heredoc_info {
   char *contents;  /* contents of heredoc */
   char *delimiter; /* delimiter of heredoc */
   int char_count;  /* number of characters in this heredoc */

   struct heredoc_info *next; /* this is a linked list, ptr to next */

} heredoc_info;


/* data structure for managing included files */
typedef struct file_info {
   char const *filename;
   int line_nr;
   int line_pos;
   YY_BUFFER_STATE buffer;
   struct file_info *prev;

} file_info;


/* data structure to store .constant definitions */
typedef struct constant_info {
    int line_declared;  /* line where the constant was declared */
    int token_type;     /* token type of the value */
    char *name;         /* name of the constant */
    char *value;        /* the value of the constant */

    struct constant_info *next; /* for now, linked list impl. */

} constant_info;


typedef struct macro_info {
    int line_declared;
    char *name;
    char *body;

    struct macro_info *next;

} macro_info;



/* store the "globals" of the lexer in a structure which is passed around. */
typedef struct lexer_state {
    int                     parse_errors;
    struct file_info       *current_file;
    struct constant_info   *constant_defs;
    struct heredoc_info    *heredocs;
    struct macro_info      *macro_defs;
    char                   *after_heredoc;

    /* this is the exactly like the file_info structure
     * Maybe use a file_info object for the main file too?
     */
    char const     *filename;
    int             line_nr;
    int             line_pos;
    YY_BUFFER_STATE file_buffer;

} lexer_state;





/* macro to chop off the last character, typically a newline character */
#define chop_yytext()   (yytext[--yyleng] = '\0')



#define YY_DECL int yylex(YYSTYPE *yylval, struct lexer_state *lexer)

extern YY_DECL;


#define YYERROR_DECL int yyerror(struct lexer_state *lexer, char *message)

extern YYERROR_DECL;

#define YYPARSE_DECL int yyparse(struct lexer_state *lexer)

extern YYPARSE_DECL;

/*

*/
static void
update_location(lexer_state *lexer) {
    char *iter = yytext;

    /* TODO: is yytext NULL terminated? */
    while (*iter != '\0') {
        if (*iter == '\n')
            lexer->line_nr++;
        iter++;
    }


}

/* after each rule execute update_location() */
#define YY_USER_ACTION update_location(lexer);




/*

constructor for a lexer.

*/
lexer_state *
new_lexer(char const *filename) {
    lexer_state *lexer = (lexer_state *)malloc(sizeof (lexer_state));
    assert(lexer != NULL);
    assert(filename != NULL);

    /*
    fprintf(stderr, "Constructing new lexer\n");
    */
    lexer->filename = filename;
    lexer->line_nr  = 1;
    return lexer;
}

/*

Accessor function for errors.

*/
int
get_parse_errors(lexer_state *lexer) {
    return lexer->parse_errors;
}

/*

Accessor function to increment the errors field.

*/
void
parse_error(lexer_state *lexer) {
    lexer->parse_errors++;
}

int
get_line_nr(lexer_state *lexer) {
    return lexer->line_nr;
}

/*

Return the name of the current file being parsed.
This can be an included file.

*/
char const *
get_current_file(struct lexer_state *lexer) {
    return lexer->filename;
}

/*

=over 4

=item static void push_file_info(file_info *info)

Store a file_info structure on a stack.

=cut

*/
static void
push_file_info(lexer_state *lexer, file_info *info) {
    info->prev = lexer->current_file;
    lexer->current_file = info;
}



/*

=item static file_info *pop_file_info(void)

Pop a file_info structure from a stack.

=cut

*/
static file_info *
pop_file_info(lexer_state *lexer) {
    /* current_file points to an included file, in a Last-In, First-Out way,
     * like a stack. Only the "main" file does not have a file_info structure.
     */
    if (lexer->current_file == NULL) {
        return NULL;
    }
    else { /* the current file is an included one */
        file_info *returning = lexer->current_file;
        lexer->current_file  = returning->prev;
        return returning;
    }
}


static void
switch_to_file(lexer_state *lexer, file_info *info) {

    /* restore the buffer info */

    /* put back the line number */
    lexer->line_nr = info->line_nr;

    /* delete the current buffer which points to a buffer for
     * the included file.
     */
    yy_delete_buffer(YY_CURRENT_BUFFER);
    /* close current file, currently pointed by yyin. */
    fclose(yyin);

    /* switch back to previous file */
    yy_switch_to_buffer(info->buffer);


    /* and free all resources of the file_info buffer */

    /*free(info->filename);
    */

    free(info);
    info = NULL;
}

/*

=item C<unshift_heredoc>

Push a heredoc_info structure back on to the queue.

=cut

*/
static void
unshift_heredoc(lexer_state *lexer, heredoc_info *heredoc) {
    heredoc->next   = lexer->heredocs;
    lexer->heredocs = heredoc;
}

/*

=item C<shift_heredoc>

Get the first heredoc_info structure and remove it from the queue.

=cut

*/
static heredoc_info *
shift_heredoc(lexer_state *lexer) {
    heredoc_info *returning = lexer->heredocs;

    /* one should never shift from the queue if it's empty: */
    assert(returning != NULL);

    /* the 2nd item on the queue becomes the 1st item, the latter
     * is now removed.
     */
    lexer->heredocs = returning->next;

    return returning;
}


/*

=item C<peek_heredoc>

Get a pointer to the first heredoc_info structure on the queue,
but don't remove it.

=cut

*/
static heredoc_info *
peek_heredoc(lexer_state *lexer) {
    return lexer->heredocs;
}


/*

=item C<save_heredoc_line>

Save a line of text as part of the heredoc string.

=cut

*/
static void
save_heredoc_line(lexer_state *lexer, char *text) {
    /* get a pointer to the first heredoc_info structure */
    heredoc_info *heredoc = peek_heredoc(lexer);
    int text_length = strlen(text);
    char *newbuffer = NULL;

    /* make sure there's a heredoc active. if not, error! */
    assert(heredoc != NULL);

    /* create a new buffer, large enough to hold current contents
     * plus new contents
     */

    /* only first time there will be no contents */
    if (heredoc->contents != NULL) {
        newbuffer = (char *)calloc(heredoc->char_count + text_length, sizeof (char));
        assert(newbuffer != NULL);
        fprintf(stderr, "copying old contents...\n(%s)", heredoc->contents);
        strcpy(newbuffer, heredoc->contents);
    }
    else {
        /* allocate first buffer, do allocate 1 char extra for NULL character. */
        newbuffer = (char *)calloc(text_length + 1, sizeof (char));
        assert(newbuffer != NULL);
    }

    fprintf(stderr, "concatenating new contents..\n");
    /* copy new text into ne buffer, after old contents. */
    strcpy(newbuffer + heredoc->char_count, text);
    /* free old buffer */
    free(heredoc->contents);
    /* attach new buffer to heredoc node */
    heredoc->contents = newbuffer;
    /* update number of characters in this buffer */
    heredoc->char_count += text_length;

}


/*

=item static void new_heredoc(char *delimiter, int line)

=cut

*/
static void
new_heredoc(lexer_state *lexer, char *delimiter) {
    heredoc_info *heredoc = (heredoc_info *)malloc(sizeof (heredoc_info));
    assert(heredoc != NULL);
    heredoc->delimiter    = delimiter;
    heredoc->contents     = NULL;
    heredoc->char_count   = 0;
     /* and store the newly created node */
    unshift_heredoc(lexer, heredoc);
}


/*

=item static constant_info *find_constant(char *name)

=cut

*/
static constant_info *
find_constant(lexer_state *lexer, char *name) {

    constant_info *iter = lexer->constant_defs;

    while (iter != NULL) {
        if (strcmp(iter->name, name) == 0) {
            return iter;
        }
        iter = iter->next;
    }
    return NULL;
}

/*

=item static void define_constant(char *name, char *value, int token_type, int line)

=cut

*/
static void
define_constant(lexer_state *lexer, char *name, char *value, int token_type) {
    constant_info *info = (constant_info *)malloc(sizeof (constant_info));
    assert(info != NULL);
    /* create the constant definition */
    info->line_declared = lexer->line_nr; /* store the line where it is defined */
    info->name          = name;       /* store the name of this constant */
    info->value         = value;      /* store the characters of this constant value */
    info->token_type    = token_type; /* store token type of this constant */

    /* for now, just use linked list. Later we'll use a hash */
    info->next = lexer->constant_defs;
    lexer->constant_defs = info;
}

/*

=item static macro_info *find_macro(char *name)

=cut

*/
static macro_info *
find_macro(lexer_state *lexer, char *name) {
    /* for now, just a list; should be a hash */
    macro_info *iter = lexer->macro_defs;

    while (iter != NULL) {
        if (strcmp(iter->name, name) == 0) {
            return iter;
        }
        iter = iter->next;
    }

    return NULL;
}


/*

=item static void read_macro(void)

=cut

*/
static void
read_macro(YYSTYPE *yylval, lexer_state *lexer) {
    int next_token;
    macro_info *macro = NULL;

    /* get next token, this must be macro id */
    next_token = yylex(yylval, lexer);

    /* check that there's a macro identifier token */
    if (next_token == TK_IDENT) {
        fprintf(stderr, "Macro identifier: '%s'\n", yytext);
    }
    else { /* error! */
        yyerror(lexer, "macro identifier expected after '.macro'");
    }

    /* read macro parameters, if any */
    next_token = yylex(yylval, lexer);

    if (next_token == '(') { /* there are parameters! */
        int expect_parameter = 0;

        /* get next token after opening parenthesis */
        next_token = yylex(yylval, lexer);

        while (next_token != ')' || expect_parameter) {
            if (next_token == TK_IDENT) {
                /* handle parameter */
                char *parameter = strdup(yytext);
                fprintf(stderr, "macro parameter: '%s'\n", parameter);

                /* clear flag */
                expect_parameter = 0;
                /* TODO: try to recover error */
            }
            else {
                yyerror(lexer, "macro parameter identifier expected");
            }

            /* get next token after parameter */
            next_token = yylex(yylval, lexer);

            if (next_token == ',') { /* current token is a comma, get next parameter */
                next_token = yylex(yylval, lexer);
                /* after a comma we expect a parameter; set a flag */
                expect_parameter = 1;
            }
            else { /* no more parameters expected */
                break;
            }
        }

        /* check closing parenthesis of macro parameter list */
        if (next_token == ')') {
            next_token = yylex(yylval, lexer);
        }
        else { /* it was not a ')' */
            yyerror(lexer, "closing ')' expected to close parameter list of macro.");
        }

    }

    /* make sure there's a newline after the macro header TODO: must this be part of the macro text? */
    if (next_token != TK_NL) {
        yyerror(lexer, "newline expected after macro parameter list.");
    }

    /* TODO: read macro body */
    next_token = yylex(yylval, lexer);
    while (next_token == TK_NL) {
        next_token = yylex(yylval, lexer);
    }

    /* END TODO */

    /* macros should be closed with ".endm" */
    if (next_token != TK_ENDM) {
        yyerror(lexer, "'.endm' expected to close macro definition.");
    }

    /* after ".endm" a newline is expected */
    next_token = yylex(yylval, lexer);
    if (next_token != TK_NL) {
        yyerror(lexer, "newline expected after '.endm'");
    }

    /* fill macro structure */
    macro = (macro_info *)malloc(sizeof (macro_info));
    macro->name = strdup(yytext);
}


/*

=back

=cut

*/




/*

There are a number of states, described in the table below.

State          Reads from  Description
===========================================================================
INITIAL        file        start state for scanner.

HEREDOC1       file        used as intermediate state to save the
                           "rest of the line" after a <<"STRING" token.

HEREDOC2       file        used to read heredoc contents

HEREDOC3       buffer      as HEREDOC1, but now when reading from a buffer

SCANSTRING     buffer      used to scan the "rest of the line", which
                           was saved by HEREDOC1 and HEREDOC3.

MACRO          file        used to read a macro definition.

POD            file        used to skip POD comments.
===========================================================================


*/


%}

ALPHA          [a-zA-Z@_]
DIGIT          [0-9]
DIGITS         {DIGIT}+
ALNUM          {ALPHA}|{DIGIT}

IDENT          {ALPHA}{ALNUM}*

DOT            [.]
HEX            0[xX][0-9A-Fa-f]+
OCT            0[oO][0-7]+
BIN            0[bB][01]+
WS             [\t\f\r\x1a ]
EOL            \r?\n

SIGN           [-+]
BIGINT         {SIGN}?{DIGITS}"L"
FLOATNUM       {SIGN}?(({DIGITS}{DOT}{DIGIT}*|{DOT}{DIGITS})([eE]{SIGN}?{DIGITS})?|{DIGITS}[eE]{SIGN}?{DIGITS})

DQ_STRING       \"(\\.|[^"\\\n])*\"
SQ_STRING       \'[^'\n]*\'
Q_STRING       {SQ_STRING}|{DQ_STRING}

LINECOMMENT    [#].*\n


%x HEREDOC1
%x HEREDOC2
%x HEREDOC3
%x SCANSTRING

%x POD

/* start state for macro scanning */
%x MACRO




/* support pushing/popping of start states */
%option stack

/* make sure yytext is a pointer */
%pointer

/* slightly more efficient when this option is set; our parser is not interactive anyway. */
%option never-interactive




%%



{WS}                               { /* ignore */; }

{EOL}([\t\r\n ]|{LINECOMMENT})*    { /* a set of continuous newlines yields a single newline token. */
                                     return TK_NL;
                                   }

{LINECOMMENT}                      { /* skip line comments */ ; }



"<<"{Q_STRING} {    /* skip the "<<" and the quote, so skip 3 characteres */
                    char *heredoc_id = strdup(yytext + 3);

                    /* check the length of the quoted string. Note that the close quote
                     * was copied in the call to strdup(), so that's why heredoc_id is
                     * at least 1.
                     */
                    if (strlen(heredoc_id) == 1) {
                        yyerror(lexer, "heredoc delimiter cannot be an empty string");
                    }
                    else {
                        /* remove the closing quote */
                        heredoc_id[strlen(heredoc_id) - 1] = '\0';
                        /* store the heredoc delimiter in a FIFO data structure, such as a queue */
                        new_heredoc(lexer, heredoc_id);

                        /* yy_push_state(HEREDOC1); */
                        BEGIN(HEREDOC1);
                    }
               }

<SCANSTRING>"<<"{Q_STRING} {
                             /* skip the "<<" and the quote, so skip 3 characteres */
                             char *heredoc_id = strdup(yytext + 3);

                             /* check the length of the quoted string. Note that the close quote
                              * was copied in the call to strdup(), so that's why heredoc_id is
                              * at least 1.
                              */
                             if (strlen(heredoc_id) == 1) {
                                 yyerror(lexer, "heredoc delimiter cannot be an empty string");
                             }
                             else {
                                 /* remove the closing quote */
                                 heredoc_id[strlen(heredoc_id) - 1] = '\0';

                                 /* store the heredoc delimiter in a FIFO data structure, such as a queue */
                                 new_heredoc(lexer, heredoc_id);

                                 /* yy_push_state(HEREDOC3); */
                                 BEGIN(HEREDOC3);
                             }
                           }

<SCANSTRING>{EOL}   {
                    }

<SCANSTRING>{WS}+   {
                    }

<SCANSTRING><<EOF>> { unsigned char dummy_char;

                      /* End of the "rest" string, switch back to normal buffer and state. */
                      yy_switch_to_buffer(lexer->file_buffer);
                      BEGIN(INITIAL);

                      /* we reached the end of the saved string, and just switched back to
                       * the file. However, there may be more whitespace or newlines, so skip these now
                       */
                      dummy_char = input();

                      while (isspace(dummy_char) || dummy_char == '\n') {
                         dummy_char = input();
                      }
                      /* we just read one character too many; this is not a space/'\n', so put it back */
                      unput(dummy_char);

                      /* end of buffer also means end of line (because the buffer represents
                       * the "rest of the line" after reading a <<STRINGC heredoc delimiter argument.
                       * So, return a newline token.
                       */
                      return TK_NL;
                    }

<HEREDOC1>.*{EOL}  { /* This state saves the string after the <<STRINGC heredoc delimiter argument.
                      * After saving the rest of the line, effectively, taking it away from the file input
                      * state HEREDOC2 is activated, in which the heredoc string can be scanned.
                      * After the heredoc string is scanned (until the delimiter is encountered), the
                      * string that was saved here is scanned.
                      */
                     if (lexer->after_heredoc != NULL) {
                        /* before allocating new memory to after_heredoc, free the old buffer */
                        free(lexer->after_heredoc);
                     }
                     lexer->after_heredoc = strdup(yytext);
                     /* continue scanning the file */
                     BEGIN(HEREDOC2);
               }



<HEREDOC3>.*{EOL}   { /* currently, we're reading from a buffer */

                      /* after_heredoc is the buffer we're reading from, it /should/ never be null */
                      assert(lexer->after_heredoc != NULL);
                      if (lexer->after_heredoc != NULL) {
                         free(lexer->after_heredoc);
                      }
                      lexer->after_heredoc = strdup(yytext);

                      /* switch back to file */
                      yy_switch_to_buffer(lexer->file_buffer);
                      BEGIN(HEREDOC2);
                    }

<HEREDOC2>{EOL}  { /* add a newline character to the heredoc */
                   save_heredoc_line(lexer, "\n");
                 }

<HEREDOC2><<EOF>> { /* does this ever happen? */
                    fprintf(stderr, "<HEREDOC><<EOF>>. Does this ever happen?\n");
                    BEGIN(INITIAL);
                    return TK_NL;
                  }

<HEREDOC2>.*   {  /* get the heredoc delimiter */
                  heredoc_info *heredoc = shift_heredoc(lexer);
                  /* remove newline character from current token's characters */
                  chop_yytext();

                  /* if the current token's characters equals the heredoc
                   * delimiter, the heredoc is complete
                   */
                  if (strcmp(yytext, heredoc->delimiter) == 0) {
                      /* we found the delimiter, save the current buffer, because
                       * we will first continue scanning the "after_heredoc" buffer.
                       */
                      BEGIN(SCANSTRING);
                      /* save the current buffer */
                      lexer->file_buffer = YY_CURRENT_BUFFER;
                      /* and go scanning the "rest of the line" after the <<STRINGC heredoc IDs */
                      yy_scan_string(lexer->after_heredoc);

                      /* return the complete heredoc as a string constant */
                      /* yylval.sval = heredoc->contents;
                      */
                      return TK_STRINGC;
                  }
                  else {
                      /* the current line does not contain the heredoc delimiter,
                       * put the heredoc thingie back
                       */
                      unshift_heredoc(lexer, heredoc);

                      /* and save the current text as part of the heredoc */
                      save_heredoc_line(lexer, yytext);
                  }

                }


^"=".*{EOL}            { yy_push_state(POD); }

<POD>^"=cut".*{EOL}+   { yy_pop_state(); }

<POD>.*                { /* ignore pod comments */ }

<POD>{EOL}+            { /* ignore newlines in POD */  }

<POD><<EOF>>           { yyerror(lexer, "POD comment not closed!");
                         yyterminate();
                       }


">>>="      { return TK_ASSIGN_USHIFT; }
">>>"       { return TK_USHIFT; }
">>="       { return TK_ASSIGN_RSHIFT; }
">>"        { return TK_RSHIFT; }
"<<"        { return TK_LSHIFT; }

".."        { return TK_DOTDOT; }
"=>"        { return TK_ARROW; }
"=="        { return TK_EQ; }
"!="        { return TK_NE; }
"<="        { return TK_LE; }
">="        { return TK_GE; }
"<"         { return TK_LT; }
">"         { return TK_GT; }

"//"        { return TK_FDIV; }
"&&"        { return TK_AND; }
"||"        { return TK_OR; }
"~~"        { return TK_XOR; }

"+"         { return '+'; }
"%"         { return '%'; }
"*"         { return '*'; }
"/"         { return '/'; }
"!"         { return '!'; }
"~"         { return '~'; }
"-"         { return '-'; }

<INITIAL,MACRO>"("                { return '('; }
<INITIAL,MACRO,SCANSTRING>")"     { return ')'; }
<INITIAL,MACRO,SCANSTRING>","     { return ','; }

"["         { return '['; }
"]"         { return ']'; }

{WS}"."{WS} { /* if the dot is surrounded by whitespace, it's a concatenation operator */
              return TK_CONC;
            }
"."         { return '.'; }
"="         { return '='; }
";"         { return ';'; }

"+="        { return TK_ASSIGN_INC; }
"-="        { return TK_ASSIGN_DEC; }
"/="        { return TK_ASSIGN_DIV; }
"*="        { return TK_ASSIGN_MUL; }
"%="        { return TK_ASSIGN_MOD; }
"**="       { return TK_ASSIGN_POW; }
"|="        { return TK_ASSIGN_BOR; }
"&="        { return TK_ASSIGN_BAND; }
"//="       { return TK_ASSIGN_FDIV; }
"~="        { return TK_ASSIGN_BNOT; }
".="        { return TK_ASSIGN_CONC; }

"if"              { return TK_IF; }
"goto"            { return TK_GOTO; }
"new"             { return TK_NEW; }
"n_operators"     { return TK_N_OPERATORS; }
"null"            { return TK_NULL; }
"unless"          { return TK_UNLESS; }

"int"             { return TK_INT; }
"num"             { return TK_NUM; }
"pmc"             { return TK_PMC; }
"string"          { return TK_STRING; }

".arg"            { return TK_ARG; }
".const"          { return TK_CONST; }
".emit"           { return TK_EMIT; }
".endnamespace"   { return TK_ENDNAMESPACE; }
".end"            { return TK_END; }

".eom"            { return TK_EOM; }
".get_results"    { return TK_GET_RESULTS; }
".globalconst"    { return TK_GLOBALCONST; }
".HLL"            { return TK_HLL; }
".HLL_map"        { return TK_HLL_MAP; }
".invocant"       { return TK_INVOCANT; }
".lex"            { return TK_LEX; }
".loadlib"        { return TK_LOADLIB; }
".local"          { return TK_LOCAL; }

".meth_call"      { return TK_METH_CALL; }
".namespace"      { return TK_NAMESPACE; }
".nci_call"       { return TK_NCI_CALL; }
".param"          { return TK_PARAM; }
".pcc_begin"      { return TK_PCC_BEGIN; }
".pcc_begin_return" { return TK_PCC_BEGIN_RETURN; }
".pcc_begin_yield"  { return TK_PCC_BEGIN_YIELD; }
".pcc_call"       { return TK_PCC_CALL; }
".pcc_end"        { return TK_PCC_END; }
".pcc_end_return" { return TK_PCC_END_RETURN; }
".pcc_end_yield"  { return TK_PCC_END_YIELD; }
".pragma"         { return TK_PRAGMA; }
".result"         { return TK_RESULT; }
".return"         { return TK_RETURN; }
".sub"            { return TK_SUB; }
".yield"          { return TK_YIELD; }

":anon"      { return TK_FLAG_ANON; }
":init"      { return TK_FLAG_INIT; }
":load"      { return TK_FLAG_LOAD; }
":postcomp"  { return TK_FLAG_POSTCOMP; }
":immediate" { return TK_FLAG_IMMEDIATE; }
":main"      { return TK_FLAG_MAIN; }
":method"    { return TK_FLAG_METHOD; }
":lex"       { return TK_FLAG_LEX; }
":outer"     { return TK_FLAG_OUTER; }
":vtable"    { return TK_FLAG_VTABLE; }
":multi"     { return TK_FLAG_MULTI; }

":unique_reg" { return TK_FLAG_UNIQUE_REG; }
":optional"   { return TK_FLAG_OPTIONAL; }
":opt_flag"   { return TK_FLAG_OPT_FLAG; }
":slurpy"     { return TK_FLAG_SLURPY; }
":named"      { return TK_FLAG_NAMED; }
":flat"       { return TK_FLAG_FLAT; }


{Q_STRING}   { /* yylval.sval = strdup(yytext); */
               return TK_STRINGC;
             }

"P"{DIGIT}+  { return TK_PASM_PREG; }
"S"{DIGIT}+  { return TK_PASM_SREG; }
"N"{DIGIT}+  { return TK_PASM_NREG; }
"I"{DIGIT}+  { return TK_PASM_IREG; }

"$P"{DIGIT}+  { return TK_SYM_PREG; }
"$S"{DIGIT}+  { return TK_SYM_SREG; }
"$N"{DIGIT}+  { return TK_SYM_NREG; }
"$I"{DIGIT}+  { return TK_SYM_IREG; }

{ALPHA}{ALNUM}*":"    { return TK_LABEL; }
{ALPHA}{ALNUM}*       { return is_parrot_op(yytext) ? TK_PARROT_OP : TK_IDENT; }


{FLOATNUM}        { return TK_NUMC; }
{SIGN}?{DIGITS}   { return TK_INTC; }
{HEX}             { return TK_INTC; }
{BIN}             { return TK_INTC; }
{OCT}             { return TK_INTC; }

".include"   { int next_token; /* used to store next tokens from lexer */
               int file_name_length;
               unsigned char dummy; /* used to scan whitespace/'\n' of included file */
               FILE *incl_file_ptr   = NULL;
               char *incl_file_name  = NULL;
               file_info *file_state = NULL;
               YY_BUFFER_STATE incl_file_buffer;

               /* get next token containing name of file being included */
               next_token = yylex(yylval, lexer);

               /* check that it's a string, if not return to parser. */
               if (next_token != TK_STRINGC) {
                   return next_token;
               }

               /* retrieve name of file, remove 2 quote characters. */
               file_name_length = yyleng - 2;
               incl_file_name   = (char *)calloc(file_name_length + 1, sizeof (char));

               assert(incl_file_name);

               /* copy file name, skip first character */
               strncpy(incl_file_name, yytext + 1, file_name_length);

               /* open the file */

               /* fprintf(stderr, "Including file '%s'\n", incl_file_name); */

               incl_file_ptr = fopen(incl_file_name, "r");
               /* check file */
               if (incl_file_ptr == NULL) { /* opening file went wrong */
                   yyerror(lexer, "Error including file");
                   return 0;
               }

               /* after an include statement a newline is expected */
               next_token = yylex(yylval, lexer);
               if (next_token != 0) { /* if not end of file */
                   if (next_token != TK_NL) { /* then it must be a newline */
                       yyerror(lexer, "newline expected after \".include '<string>'\"\n");
                   }
               }

               /* save current file info */
               file_state = (file_info *)malloc(sizeof (file_info));
               assert(file_state != NULL);

               /* save current buffer, current file name, current line nr*/
               file_state->buffer   = YY_CURRENT_BUFFER;
               file_state->filename = lexer->filename;
               file_state->line_pos = 0; /* FIX */
               file_state->line_nr  = lexer->line_nr;
               file_state->prev     = NULL; /* initialize to NULL */

               /* store the current file's info structure on the stack,
                * we'll continue scanning it later.
                */
               push_file_info(lexer, file_state);

               /* a new file is being scanned, reset line number */
               lexer->line_nr  = 1;
               /* set the name of the included file */
               lexer->filename = incl_file_name;

               /* create a new buffer for the included file and switch to that file */
               incl_file_buffer = yy_create_buffer(incl_file_ptr, YY_BUF_SIZE);
               yy_switch_to_buffer(incl_file_buffer);

               /* the included file may contain whitespace and newlines; remove them */
               dummy = input();
               while (isspace(dummy) || dummy == '\n') {
                   dummy = input();
               }
               unput(dummy);

             }

".constant"  { int next_token;
               char *constant_id    = NULL;
               char *constant_value = NULL;

               next_token = yylex(yylval, lexer);
               if (next_token != TK_IDENT) {
                   yyerror(lexer, "identifier expected after '.constant'.");
               }
               /* store identifier */
               constant_id = strdup(yytext);

               /* ".endm" will only be recognized as a reserved word in MACRO state,
                * but nevertheless, writing ".endm" to expand a constant is not good practice.
                * Emit a warning. This is true for all directives, but only ".endm" is
                * not recognized in state INITIAL.
                */
               if (strcmp(constant_id, "endm") == 0) {
                   fprintf(stderr, "Warning: 'endm' should not be used as a constant name, "
                                   "using it would make you write '.endm', which is a keyword.");
               }

               /* read next token, which contains the value */
               next_token = yylex(yylval, lexer);

               /* only these token types are allowed for constant values: */
               switch (next_token) {
                   case TK_INTC:
                   case TK_NUMC:
                   case TK_STRINGC:
                   case TK_SYM_PREG:
                   case TK_SYM_NREG:
                   case TK_SYM_IREG:
                   case TK_SYM_SREG:
                   case TK_PASM_PREG:
                   case TK_PASM_NREG:
                   case TK_PASM_IREG:
                   case TK_PASM_SREG:
                       /* store value by this constant's name */
                       constant_value = strdup(yytext);
                       define_constant(lexer, constant_id, constant_value, next_token);
                       break;
                   default:
                       yyerror(lexer, "Constant value must be a number, string literal or register");
                       break;
               }

               /* after the .constant declaration, a newline must be read */
               next_token = yylex(yylval, lexer);
               if (next_token != TK_NL) {
                   yyerror(lexer, "newline expected after constant declaration");
               }

             }

".macro"            {  /* macro definition */
                       yy_push_state(MACRO);
                       read_macro(yylval, lexer);
                    }

<MACRO>{EOL}        { return TK_NL; }

<MACRO>{WS}         { /* should we ignore?? */ }

<MACRO>{IDENT}      { return TK_IDENT; }

<MACRO>".endm"      { /* end of macro definition */ ;
                      yy_pop_state();
                      return TK_ENDM;
                    }

<MACRO><<EOF>>      { yyerror(lexer, "macro definition not closed before end of file");
                      yyterminate();
                    }


{WS}[.]{ALNUM}    { /* Check whether this token is a constant or a macro.
                     * Note that there must be whitespace before the dot, otherwise
                     * in "x.y", ".y" is matched, which is wrong.
                     */

                    /* because of the whitespace in front of this matched token, we need to skip this,
                     * yytext contains 1 or more space characters, so find out how many these are.
                     */
                    constant_info *constant = NULL;
                    /* there is at least one space, so we don't have to check that one */
                    int num_spaces = 1;

                    /* as long as yytext + num_spaces points to a space character, increment num_spaces */
                    while (isspace((unsigned char) *(yytext + num_spaces))) {
                        ++num_spaces;
                    }

                    /* give the name of the constant, skipping the whitespace prefix,
                     * and skip the prefix dot.
                     */
                    constant = find_constant(lexer, yytext + num_spaces + 1);

                    if (constant != NULL) { /* found the constant */
                        fprintf(stderr, "Constant '%s' found, value = '%s', token = '%d'\n",
                                constant->name, constant->value, constant->token_type);

                        /* make the value of the constant available to the parser */
                        /* TODO: where to store this? Probably in the %union->sval */
                        yytext = constant->value;
                        /* return the type of token that the constant value represents */
                        return constant->token_type;
                    }
                    else { /* not found, try macro */
                        macro_info *macro = NULL;

                        macro = find_macro(lexer, yytext + num_spaces + 1);

                        if (macro != NULL) {

                            /* TODO: how do we know how big a buffer we need? IMCC defines fixed size of 4KB. */
                            char *expansion_buffer = (char *)calloc(1, sizeof (char));

                            /* read input for parameters */

                            /* expand the macro into a string buffer */

                            /* and scan that string buffer. */
                            YY_BUFFER_STATE state = yy_scan_string(expansion_buffer);
                            yy_delete_buffer(state);

                            /* free the buffer */
                            free(expansion_buffer);
                        }
                        else {
                            /* not found, this is an unknown constant or macro. */
                            yyerror(lexer, "Undefined constant or macro");
                        }
                    }

                  }


<<EOF>>     {  /* get the file info structure of the .include-ing file, if any */
               file_info *info = pop_file_info(lexer);

               if (info == NULL) {
                   /* this was the initial file given to Parrot, stop scanning. */
                   yyterminate();

               }
               else { /* this file was included, switch back */
                   switch_to_file(lexer, info);
                   return 0;
               }
            }

<*>.   { yyerror(lexer, "Unexpected character"); }



%%


/*
 * Have yywrap return 1, so that the scanner will not
 * continue after an end of file.
 */
int
yywrap() {
    return 1;
}

static int
is_parrot_op(char *spelling) {

    /* only "print" is recognized as a Parrot instruction */
    if (strcmp(spelling, "print") == 0)
        return 1;
    return 0;
}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
