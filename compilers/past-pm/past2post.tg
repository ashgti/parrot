transform root (PAST::Block) :language('PIR') {
    .return tree.'get'('post', node)
}


transform post (PAST::Block) :language('PIR') {
    .local pmc name
    name = node.'name'()
    if name != '' goto with_name
    name = node.unique('_block')
  with_name:
    .local pmc post
    post = new 'POST::Sub'
    post.'init'('node'=>node, 'name'=>name)
    .local pmc iter
    iter = node.'iterator'()
    unless iter goto iter_end
  iter_loop:
    .local pmc cpast, cpost
    cpast = shift iter
    cpost = tree.'get'('post', cpast)
    post.'push'(cpost)
    if iter goto iter_loop
    post.'result'(cpost)
  iter_end:

    $S0 = node.'blocktype'()
    if $S0 != 'immediate' goto end
    post = post.'new'('POST::Op', post, 'node'=>node, 'pirop'=>'call', 'arglist'=>post)
  end:
    .return (post)
}


transform post (PAST::Stmts) :language('PIR') {
    .local pmc ops
    ops =  new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc iter
    iter = node.'iterator'()
    unless iter goto end
  iter_loop:
    .local pmc cpast, cpost
    cpast = shift iter
    cpost = tree.'get'('post', cpast)
    ops.'push'(cpost)
    if iter goto iter_loop
  iter_end:
    ops.'result'(cpost)
  end:
    .return (ops)
}


transform post (PAST::Op) :language('PIR') {
    .local string pasttype
    pasttype = node.'pasttype'()
    if pasttype goto post_pasttype

  post_pirop:
    .local string pirop
    pirop = node.'pirop'()
    if pirop goto have_pirop
    node.'pirop'('call')
  have_pirop:
    .return tree.'get'('pirop', node)

  post_pasttype:
    .return tree.'get'(pasttype, node)
}


transform pirop (PAST::Op) :language('PIR') {
    .local string pirop
    .local pmc post
    pirop = node.'pirop'()
    post = new 'POST::Op'
    post.'init'('node'=>node, 'pirop'=>pirop)

    .local pmc pirtable
    .local string signature
    pirtable = get_hll_global ['POST'], '%pirtable'
    signature = pirtable[pirop]
    if signature > '' goto have_signature
    signature = '%uppppppppppppp'                          # FIXME:
  have_signature:
    .local pmc arglist, iter
    .local int aindex
    aindex = 2
    arglist = new .ResizablePMCArray
    iter = node.'iterator'()
  iter_loop:
    unless iter goto iter_end
    .local pmc cpast, cpost
    cpast = shift iter
    $S0 = substr signature, aindex, 1
    cpast.'atype'($S0)
    cpost = tree.'get'('post', cpast)
    post.'push'(cpost)
    push arglist, cpost
    inc aindex
    goto iter_loop
  iter_end:
    .local int argresult
    argresult = 1

    if pirop == 'call' goto pirop_call
    if pirop == 'callmethod' goto pirop_call
    if pirop == 'inline' goto pirop_inline
    goto pirop_result

  pirop_call:
    .local string name
    argresult = 0
    name = node.'name'()
    unless name goto pirop_result
    name = node.'escape'(name)
    unshift arglist, name
    goto pirop_result

  pirop_inline:
    .local string inline
    argresult = 0
    inline = node.'inline'()
    unless inline goto pirop_result
    unshift arglist, inline
    signature = inline
    goto pirop_result

  pirop_result:
    $I0 = index signature, '%v'
    if $I0 >= 0 goto pirop_void
    $I0 = index signature, '%r'
    if $I0 >= 0 goto pirop_reg
    .local string returns
    returns = '.Undef'
    $S0 = node.'returns'()
    unless $S0 goto pirop_returns
    returns = $S0
  pirop_returns:
    $P0 = post.'push_new'('POST::Op', 'pirop'=>'new')
    $P0.'arglist'($P0, returns)
    post.'result'($P0)
    goto pirop_reg
  pirop_void:
    $P0 = post[0]
    post.'result'($P0)
    argresult = 0
  pirop_reg:
    unless argresult goto have_result
    unshift arglist, post
  have_result:
    post.'arglist'(arglist :flat)
    .return (post)
}


transform call (PAST::Op) :language('PIR') {
    node.'pirop'('call')
    $P0 = tree.'get'('pirop', node)
    .return ($P0)
}


transform inline (PAST::Op) :language('PIR') {
    node.'pirop'('inline')
    .return tree.'get'('pirop', node)
}


transform if (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)

    .local pmc exprpast, thenpast, elsepast
    .local pmc exprpost, thenpost, elsepost
    exprpast = node[0]
    thenpast = node[1]
    elsepast = node[2]

    .local pmc thenlabel, endlabel
    .local string pasttype, n
    pasttype = node.'pasttype'()
    n = node.'unique'('_')
    $S0 = concat pasttype, n
    thenlabel = ops.'new'('POST::Label', 'result'=>$S0)
    $S0 = concat $S0, '_end'
    endlabel = ops.'new'('POST::Label', 'result'=>$S0)

    exprpost = tree.'get'('post', exprpast)
    ops.'push'(exprpost)
    ops.'push_pirop'(pasttype, exprpost, thenlabel)
    elsepost = exprpost
    $I0 = defined elsepast
    if $I0 == 0 goto else_done
    elsepost = tree.'get'('post', elsepast)
    ops.'push'(elsepost)
  else_done:
    ops.'push_pirop'('set', ops, elsepost)
    ops.'push_pirop'('goto', endlabel)
    ops.'push'(thenlabel)
    thenpost = exprpost
    $I0 = defined thenpast
    if $I0 == 0 goto then_done
    thenpost = tree.'get'('post', thenpast)
    ops.'push'(thenpost)
  then_done:
    ops.'push_pirop'('set', ops, thenpost)
    ops.'push'(endlabel)
    .return (ops)
}


transform unless (PAST::Op) :language('PIR') {
    .return tree.'get'('if', node)
}


transform while (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)

    .local pmc exprpast, blockpast
    .local pmc exprpost, blockpost
    exprpast = node[0]
    blockpast = node[1]

    .local pmc looplabel, endlabel
    .local string pasttype, n
    pasttype = node.'pasttype'()
    n = node.'unique'('_')
    $S0 = concat pasttype, n
    looplabel = ops.'new'('POST::Label', 'result'=>$S0)
    $S0 = concat $S0, '_end'
    endlabel = ops.'new'('POST::Label', 'result'=>$S0)

    ##   determine if we need an 'if' or an 'unless' on
    ##   the conditional (while => if, until => unless)
    .local string iftype
    iftype = 'if'
    if $S0 == 'until' goto done_iftype
    iftype = 'unless'
  done_iftype:

    ops.'push'(looplabel)
    exprpost = tree.'get'('post', exprpast)
    ops.'push'(exprpost)
    ops.'push_pirop'(iftype, exprpost, endlabel)
    blockpost = tree.'get'('post', blockpast)
    ops.'push'(blockpost)
    ops.'push_pirop'('goto', looplabel)
    ops.'push'(endlabel)
    ops.'result'(exprpost)
    .return (ops)
}


transform until (PAST::Op) :language('PIR') {
    .return tree.'get'('while', node)
}
    

transform xor (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)

    .local pmc endlabel, falselabel
    falselabel = ops.'new'('POST::Label', 'name'=>'xor_false')
    endlabel = ops.'new'('POST::Label', 'name'=>'xor_end')

    .local pmc iter, apast, apost, i, t, u
    i = ops.unique('$I')
    t = ops.unique('$I')
    u = ops.unique('$I')
    iter = node.'iterator'()
    apast = shift iter
    apost = tree.'get'('post', apast)
    ops.'push'(apost)
    ops.'push_pirop'('set', ops, apost)
    ops.'push_pirop'('istrue', t, apost)
  middle_child:
    .local pmc bpast, bpost
    bpast = shift iter
    bpost = tree.'get'('post', bpast)
    ops.'push'(bpost)
    ops.'push_pirop'('istrue', u, bpost)
    ops.'push_pirop'('and', i, t, u)
    ops.'push_pirop'('if', i, falselabel)
    unless iter goto last_child
    .local pmc s
    s = ops.'new'('POST::Label', 'name'=>'xor_skip')
    ops.'push_pirop'('if', t, s)
    ops.'push_pirop'('set', ops, bpost)
    ops.'push_pirop'('set', t, u)
    ops.'push'(s)
    goto middle_child
  last_child:
    ops.'push_pirop'('if', t, endlabel)
    ops.'push_pirop'('set', ops, bpost)
    ops.'push_pirop'('goto', endlabel)
    ops.'push'(falselabel)
    ops.'push_pirop'('new', ops, '.Undef')
    ops.'push'(endlabel)
    .return (ops)
}


transform assign (PAST::Op) :language('PIR') {
    .local pmc post, lpast, lpost, rpast, rpost, pasttype
    post = new 'POST::Ops'
    post.'init'('node'=>node)
    lpast = node[0]
    rpast = node[1]
    rpost = tree.'get'('post', rpast)
    post.'push'(rpost)
    pasttype = node.'pasttype'()
    if pasttype == 'bind' goto bind_variable
    rpost = post.'push_pirop'('clone', rpost, rpost, 'result'=>rpost)
  bind_variable:
    lpast.'bindvalue'(rpost)
    lpost = tree.'get'('post', lpast)
    post.'push'(lpost)
    post.'result'(lpost)
    .return (post)
}


transform post (PAST::Val) :language('PIR') {
    .local string vtype, ctype, name
    vtype = node.'vtype'()
    ctype = node.'ctype'()
    name = node.'name'()

    $I0 = index ctype, '~'
    if $I0 < 0 goto skip_escape
    name = node.'escape'(name)
  skip_escape:

    .local pmc post
    post = new 'POST::Ops'
    post.'init'('node'=>node)

    .local string atype
    atype = node.'atype'()
    if ctype == '' goto return_pmc
    if atype == '*' goto return_native
    $I0 = index ctype, atype
    if $I0 >= 0 goto return_native

  return_pmc:
    $P0 = post.'push_new'('POST::Op', 'pirop'=>'new')
    $P0.'arglist'($P0, vtype)
    $P1 = post.'push_pirop'('assign', $P0, name, 'result'=>$P0)
    post.'result'($P1)
    .return (post)

  return_native:
    post.'result'(name)
    .return (post)
}


transform post (PAST::Var) :language('PIR') {
    .local pmc post, vivibindop
    .local string scope
    scope = node.'scope'()
    if scope == 'keyed' goto keyed

  package:
    .local string name
    .local pmc bindvalue
    name = node.'name'()
    name = node.'escape'(name)
    bindvalue = node.'bindvalue'()
    if bindvalue goto package_bind

  package_rvalue:
    post = new 'POST::Ops'
    post.'init'('node'=>node)
    post.'push_pirop'('get_global', post, name)
    vivibindop = post.'new'('POST::Op', 'pirop'=>'set_global')
    vivibindop.'arglist'(name, post)
    goto check_vivify

  package_bind:
    post = new 'POST::Op'
    post.'init'('node'=>node, 'pirop'=>'set_global', 'result'=>bindvalue)
    post.'arglist'(name, bindvalue)
    .return (post)

  keyed:
    post = new 'POST::Ops'
    post.'init'('node'=>node)
    .local pmc basepast, keypast
    .local pmc basepost, keypost
    basepast = node[0]
    keypast = node[1]
    keypast.'atype'('*')
    keypost = tree.'get'('post', keypast)
    post.'push'(keypost)
    basepost = tree.'get'('post', basepast)
    post.'push'(basepost)
    .local string key
    key = basepost.'result'()
    key = concat key, '['
    $S0 = keypost.'result'()
    key .= $S0
    key .= ']'
    bindvalue = node.'bindvalue'()
    if bindvalue goto keyed_bind

  keyed_rvalue:
    .local pmc labelpost
    .local string ireg
    ireg = post.'unique'('$I')
    labelpost = post.'new'('POST::Label', 'name'=>'keyed_')
    post.'result'(basepost)
    post.'push_pirop'('defined', ireg, basepost)
    post.'push_pirop'('unless', ireg, labelpost)
    post.'push_pirop'('set', post, key)
    post.'push'(labelpost)
    vivibindop = post.'new'('POST::Op', 'pirop'=>'set')
    vivibindop.'arglist'(key, post)
    goto check_vivify

  keyed_bind:
    post.'push_pirop'('set', key, bindvalue)
    post.'push_pirop'('set', post, key)
    .return (post)

  check_vivify:
    .local pmc viviself
    viviself = node.'viviself'()
    unless viviself goto end
  do_vivify:
    .local pmc vivlabel
    .local string ireg
    vivlabel = post.'new'('POST::Label', 'name'=>'vivify_')
    ireg = post.'unique'('$I')
    post.'push_pirop'('defined', ireg, post)
    post.'push_pirop'('if', ireg, vivlabel)
    post.'push_pirop'('new', post, viviself)
    $I0 = node.'islvalue'()
    unless $I0 goto do_vivify_1
    post.'push'(vivibindop)
  do_vivify_1:
    post.'push'(vivlabel)
  end:
    .return (post)
}

