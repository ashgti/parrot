transform root (PAST::Block) :language('PIR') {
    .return tree.'get'('post', node)
}


transform post (PAST::Block) :language('PIR') {
    .local pmc name
    name = node.'name'()
    if name != '' goto with_name
    name = node.unique('_block')
  with_name:
    .local pmc post
    post = new 'POST::Sub'
    post.'init'('node'=>node, 'name'=>name)
    .local pmc iter
    iter = node.'iterator'()
    unless iter goto iter_end
  iter_loop:
    .local pmc cpast, cpost
    cpast = shift iter
    cpost = tree.'get'('post', cpast)
    post.'push'(cpost)
    if iter goto iter_loop
    post.'result'(cpost)
  iter_end:

    $S0 = node.'blocktype'()
    if $S0 != 'immediate' goto end
    post = post.'new'('POST::Op', post, 'node'=>node, 'pirop'=>'call', 'arglist'=>post)
  end:
    .return (post)
}


transform post (PAST::Stmts) :language('PIR') {
    .local pmc ops
    ops =  new 'POST::Ops'
    ops.'init'('node'=>node)
    .local pmc iter
    iter = node.'iterator'()
    unless iter goto end
  iter_loop:
    .local pmc cpast, cpost
    cpast = shift iter
    cpost = tree.'get'('post', cpast)
    ops.'push'(cpost)
    if iter goto iter_loop
  iter_end:
    ops.'result'(cpost)
  end:
    .return (ops)
}


transform post (PAST::Op) :language('PIR') {
    .local string pasttype
    pasttype = node.'pasttype'()
    if pasttype == '' goto post_pirop
    .return tree.'get'(pasttype, node)

  post_pirop:
    .local string pirop
    pirop = node.'pirop'()
    if pirop == '' goto post_call
    .return tree.'get'('pirop', node)

  post_call:
    .return tree.'get'('call', node)
}


transform call (PAST::Op) :language('PIR') {
    .local pmc post
    post = new 'POST::Op'
    post.'init'('node'=>node, 'pirop'=>'call')
    .local pmc iter, arglist
    arglist = new .ResizablePMCArray
    iter = node.'iterator'()
  iter_loop:
    unless iter goto iter_end
    .local pmc cpast, cpost
    cpast = shift iter
    cpast.'atype'('*')
    cpost = tree.'get'('post', cpast)
    post.'push'(cpost)
    push arglist, cpost
    goto iter_loop
  iter_end:
    .local pmc name, result
    name = node.'name'()
    unless name goto have_arglist
    name = node.'escape'(name)
    unshift arglist, name
  have_arglist:
    post.'arglist'(arglist :flat)
    .return (post)
}


transform pirop (PAST::Op) :language('PIR') {
    .local pmc pirop
    pirop = node.'pirop'()
    .local pmc post
    post = new 'POST::Op'
    post.'init'('node'=>node, 'pirop'=>pirop)
    .local pmc pirtable
    .local string atypes
    pirtable = get_hll_global ['POST'], '%pirtable'
    atypes =  pirtable[pirop]
    if atypes > '' goto atypes_done
    atypes = 'PPPPPP'
  atypes_done:
    .local pmc arglist, iter
    .local int aindex
    aindex = 1
    arglist = new .ResizablePMCArray
    iter = node.'iterator'()
  iter_loop:
    unless iter goto iter_end
    .local pmc cpast, cpost
    cpast = shift iter
    $S0 = substr atypes, aindex, 1
    cpast.'atype'($S0)
    cpost = tree.'get'('post', cpast)
    post.'push'(cpost)
    push arglist, cpost
    inc aindex
    goto iter_loop
  iter_end:
    $P0 = post[0]
    post.'result'($P0)
    $S0 = substr atypes, 0, 1
    if $S0 == 'v' goto pirop_void
    if $S0 == 'r' goto pirop_reg
    .local string returns
    returns = '.Undef'
    $S0 = node.'returns'()
    if $S0 == '' goto pirop_returns
    returns = $P0
  pirop_returns:
    $P0 = post.'push_new'('POST::Op', 'node'=>node, 'pirop'=>'new')
    $P0.'arglist'($P0, returns)
    post.'result'($P0)
  pirop_reg:
    unshift arglist, post
  pirop_void:
    post.'arglist'(arglist :flat)
    .return(post)
}


transform if (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)

    .local pmc exprpast, thenpast, elsepast
    .local pmc exprpost, thenpost, elsepost
    exprpast = node[0]
    thenpast = node[1]
    elsepast = node[2]

    .local pmc thenlabel, endlabel
    .local string pasttype, n
    pasttype = node.'pasttype'()
    n = node.'unique'('_')
    $S0 = concat pasttype, n
    thenlabel = ops.'new'('POST::Label', 'result'=>$S0)
    $S0 = concat $S0, '_end'
    endlabel = ops.'new'('POST::Label', 'result'=>$S0)

    exprpost = tree.'get'('post', exprpast)
    ops.'push'(exprpost)
    ops.'push_pirop'(pasttype, exprpost, thenlabel)
    elsepost = exprpost
    $I0 = defined elsepast
    if $I0 == 0 goto else_done
    elsepost = tree.'get'('post', elsepast)
    ops.'push'(elsepost)
  else_done:
    ops.'push_pirop'('set', ops, elsepost)
    ops.'push_pirop'('goto', endlabel)
    ops.'push'(thenlabel)
    thenpost = exprpost
    $I0 = defined thenpast
    if $I0 == 0 goto then_done
    thenpost = tree.'get'('post', thenpast)
    ops.'push'(thenpost)
  then_done:
    ops.'push_pirop'('set', ops, thenpost)
    ops.'push'(endlabel)
    .return (ops)
}


transform unless (PAST::Op) :language('PIR') {
    .return tree.'get'('if', node)
}


transform while (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)

    .local pmc exprpast, blockpast
    .local pmc exprpost, blockpost
    exprpast = node[0]
    blockpast = node[1]

    .local pmc looplabel, endlabel
    .local string pasttype, n
    pasttype = node.'pasttype'()
    n = node.'unique'('_')
    $S0 = concat pasttype, n
    looplabel = ops.'new'('POST::Label', 'result'=>$S0)
    $S0 = concat $S0, '_end'
    endlabel = ops.'new'('POST::Label', 'result'=>$S0)

    ##   determine if we need an 'if' or an 'unless' on
    ##   the conditional (while => if, until => unless)
    .local string iftype
    iftype = 'if'
    if $S0 == 'until' goto done_iftype
    iftype = 'unless'
  done_iftype:

    ops.'push'(looplabel)
    exprpost = tree.'get'('post', exprpast)
    ops.'push'(exprpost)
    ops.'push_pirop'(iftype, exprpost, endlabel)
    blockpost = tree.'get'('post', blockpast)
    ops.'push'(blockpost)
    ops.'push_pirop'('goto', looplabel)
    ops.'push'(endlabel)
    ops.'result'(exprpost)
    .return (ops)
}


transform until (PAST::Op) :language('PIR') {
    .return tree.'get'('while', node)
}
    

transform xor (PAST::Op) :language('PIR') {
    .local pmc ops
    ops = new 'POST::Ops'
    ops.'init'('node'=>node)

    .local pmc endlabel, falselabel
    falselabel = ops.'new'('POST::Label', 'name'=>'xor_false')
    endlabel = ops.'new'('POST::Label', 'name'=>'xor_end')

    .local pmc iter, apast, apost, i, t, u
    i = ops.unique('$I')
    t = ops.unique('$I')
    u = ops.unique('$I')
    iter = node.'iterator'()
    apast = shift iter
    apost = tree.'get'('post', apast)
    ops.'push'(apost)
    ops.'push_pirop'('set', ops, apost)
    ops.'push_pirop'('istrue', t, apost)
  middle_child:
    .local pmc bpast, bpost
    bpast = shift iter
    bpost = tree.'get'('post', bpast)
    ops.'push'(bpost)
    ops.'push_pirop'('istrue', u, bpost)
    ops.'push_pirop'('and', i, t, u)
    ops.'push_pirop'('if', i, falselabel)
    unless iter goto last_child
    .local pmc s
    s = ops.'new'('POST::Label', 'name'=>'xor_skip')
    ops.'push_pirop'('if', t, s)
    ops.'push_pirop'('set', ops, bpost)
    ops.'push_pirop'('set', t, u)
    ops.'push'(s)
    goto middle_child
  last_child:
    ops.'push_pirop'('if', t, endlabel)
    ops.'push_pirop'('set', ops, bpost)
    ops.'push_pirop'('goto', endlabel)
    ops.'push'(falselabel)
    ops.'push_pirop'('new', ops, '.Undef')
    ops.'push'(endlabel)
    .return (ops)
}


transform assign (PAST::Op) :language('PIR') {
    .local pmc post, lpast, lpost, rpast, rpost, pasttype
    post = new 'POST::Ops'
    post.'init'('node'=>node)
    lpast = node[0]
    rpast = node[1]
    rpost = tree.'get'('post', rpast)
    post.'push'(rpost)
    pasttype = node.'pasttype'()
    if pasttype == 'bind' goto bind_variable
    rpost = post.'push_pirop'('clone', rpost, rpost, 'result'=>rpost)
  bind_variable:
    lpast.'bindvalue'(rpost)
    lpost = tree.'get'('post', lpast)
    post.'push'(lpost)
    post.'result'(lpost)
    .return (post)
}


transform post (PAST::Val) :language('PIR') {
    .local string vtype, ctype, name
    vtype = node.'vtype'()
    ctype = node.'ctype'()
    name = node.'name'()

    if ctype != 's' goto skip_escape
    name = node.'escape'(name)
  skip_escape:

    .local pmc post
    post = new 'POST::Ops'
    post.'init'('node'=>node)

    .local string atype
    atype = node.'atype'()
    if atype == '*' goto return_native
    if atype == ctype goto return_native

  return_pmc:
    $P0 = post.'push_new'('POST::Op', 'pirop'=>'new')
    $P0.'arglist'($P0, vtype)
    $P1 = post.'push_pirop'('assign', $P0, name, 'result'=>$P0)
    post.'result'($P1)
    .return (post)

  return_native:
    post.'result'(name)
    .return (post)
}


transform post (PAST::Var) :language('PIR') {
    .local pmc post, vivibindop
    .local string scope
    scope = node.'scope'()
    if scope == 'keyed' goto keyed

  package:
    .local string name
    .local pmc bindvalue
    name = node.'name'()
    name = node.'escape'(name)
    bindvalue = node.'bindvalue'()
    if bindvalue goto package_bind

  package_rvalue:
    post = new 'POST::Ops'
    post.'init'('node'=>node)
    post.'push_pirop'('get_global', post, name)
    vivibindop = post.'new'('POST::Op', 'pirop'=>'set_global')
    vivibindop.'arglist'(name, post)
    goto check_vivify

  package_bind:
    post = new 'POST::Op'
    post.'init'('node'=>node, 'pirop'=>'set_global', 'result'=>bindvalue)
    post.'arglist'(name, bindvalue)
    .return (post)

  keyed:
    post = new 'POST::Ops'
    post.'init'('node'=>node)
    .local pmc basepast, keypast
    .local pmc basepost, keypost
    basepast = node[0]
    keypast = node[1]
    keypast.'atype'('*')
    keypost = tree.'get'('post', keypast)
    post.'push'(keypost)
    basepost = tree.'get'('post', basepast)
    post.'push'(basepost)
    .local string key
    key = basepost.'result'()
    key = concat key, '['
    $S0 = keypost.'result'()
    key .= $S0
    key .= ']'
    bindvalue = node.'bindvalue'()
    if bindvalue goto keyed_bind

  keyed_rvalue:
    .local pmc labelpost
    .local string ireg
    ireg = post.'unique'('$I')
    labelpost = post.'new'('POST::Label', 'name'=>'keyed_')
    post.'result'(basepost)
    post.'push_pirop'('defined', ireg, basepost)
    post.'push_pirop'('unless', ireg, labelpost)
    post.'push_pirop'('set', post, key)
    post.'push'(labelpost)
    vivibindop = post.'new'('POST::Op', 'pirop'=>'set')
    vivibindop.'arglist'(key, post)
    goto check_vivify

  keyed_bind:
    post.'push_pirop'('set', key, bindvalue)
    post.'push_pirop'('set', post, key)
    .return (post)

  check_vivify:
    .local pmc viviself
    viviself = node.'viviself'()
    unless viviself goto end
  do_vivify:
    .local pmc vivlabel
    .local string ireg
    vivlabel = post.'new'('POST::Label', 'name'=>'vivify_')
    ireg = post.'unique'('$I')
    post.'push_pirop'('defined', ireg, post)
    post.'push_pirop'('if', ireg, vivlabel)
    post.'push_pirop'('new', post, viviself)
    $I0 = node.'islvalue'()
    unless $I0 goto do_vivify_1
    post.'push'(vivibindop)
  do_vivify_1:
    post.'push'(vivlabel)
  end:
    .return (post)
}

