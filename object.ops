/*
** object.ops
*/

#include "parrot/method_util.h"

VERSION = PARROT_VERSION;

=head1 NAME

object.ops

=cut

=head1 DESCRIPTION

Parrot's library of object ops

=cut

=item B<callmeth>()

Call a method on an object as per Parrot's calling conventions. We assume
that all the registers are properly set up.

=cut

=item B<callmethcc>

Take the continuation for the next instruction, put it in P1, then call the
method as per the calling conventions.

=cut

=item B<tailcallmeth>

Restore the continuation in P1 then call the method as per the calling
conventions.

=cut


=item B<can>(out INT, in PMC, in STR)

Sets $1 to true or false, depending on whether $2 ->can the method in
$3

=cut

inline op can(out INT, in PMC, in STR) {
  $1 = $2->vtable->can(interpreter, $2, $3);
  goto NEXT();
}

=item B<does>(out INT, in PMC, in STR)

Sets $1 to true or false, depending on whether $2 ->does the interface in
$3

=cut

inline op does(out INT, in PMC, in STR) {
  $1 = $2->vtable->does(interpreter, $2, $3);
  goto NEXT();
}

###############################################################################

=item B<newclass>(out PMC, in STR)

Creates a new Parrot-style class, named $2, and puts the new PMC for it
into $1. (This
is a real out--the contents of $1 is ignored, and the pointer for the new
PMC is put in there) 

=cut

inline op newclass(out PMC, in STR) {
  goto NEXT();
}

=item B<subclass>(out PMC, in PMC)
=item B<subclass>(out PMC, in PMC, in STR)
=item B<subclass>(out PMC, in STR)
=item B<subclass>(out PMC, in STR, in STR)

Create a new class, put in $1, that is a subclass of $2. $3, if available,
is the name of the new class--if not, the subclass is an anonymous subclass.

$1 is replaced--a new PMC for the subclass is generated and put in it.

=cut

inline op subclass(out PMC, in PMC, in STR) {
  goto NEXT();
}

inline op subclass(out PMC, in PMC) {
  goto NEXT();
}

inline op subclass(out PMC, in STR, in STR) {
  goto NEXT();
}

inline op subclass(out PMC, in STR) {
  goto NEXT();
}


=item B<singleton>(in PMC) 

Take the object in $1 and put it into its own singleton class, which is
an anonymous subclass of the object's current class.

=cut

inline op singleton(in PMC) {
  goto NEXT();
}

=item B<class>(out PMC, in PMC) 

Get the class PMC for the object in $2 and put it in $1.

=cut

inline op class(out PMC, in PMC) {
  goto NEXT();
}

=item B<classname>(out STR, in PMC)

Get the class name for the class in $2 and put it in $1

=cut

inline op classname(out STR, in PMC) {
  goto NEXT();
}

###############################################################################

=head1 COPYRIGHT

Copyright (C) 2003 Yet Another Society. All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.

=cut
